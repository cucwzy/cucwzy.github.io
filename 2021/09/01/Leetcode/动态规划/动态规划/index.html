<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>动态规划 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="一、什么是动态规划 动态规划问题的一般形式就是求最值。  ​        既然是要求最值，求解动态规划的核心问题便是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。​        而动态规划的穷举不是一般的暴力穷举，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程。而且动态规划问题一定会具备「最优子结">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://example.com/2021/09/01/Leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="一、什么是动态规划 动态规划问题的一般形式就是求最值。  ​        既然是要求最值，求解动态规划的核心问题便是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。​        而动态规划的穷举不是一般的暴力穷举，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程。而且动态规划问题一定会具备「最优子结">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328093527192.png">
<meta property="article:published_time" content="2021-09-01T01:36:05.000Z">
<meta property="article:modified_time" content="2022-03-28T03:30:23.745Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328093527192.png">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1648713239102">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1648713239102">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1648713239102">
    <link rel="stylesheet" href="/css/style.css?v=1648713239102">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>34</div>
        <div><span>Tags</span>11</div>
        <div><span>Categories</span>16</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">20</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">9</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">17</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/剑指offer/">剑指offer</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/贪心算法/">贪心算法</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Leetcode/" style="font-size: 17.5px;">Leetcode</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 12.5px;">搜索</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="/img/搜索算法.jpg" data-sizes="auto" alt="动态规划" class="lazyload">
              <h1>动态规划</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月01日</a>
</div>

      

      <h2 id="一、什么是动态规划"><a href="#一、什么是动态规划" class="headerlink" title="一、什么是动态规划"></a>一、什么是动态规划</h2><blockquote>
<p>动态规划问题的一般形式就是求最值。</p>
</blockquote>
<p>​        既然是要求最值，<strong>求解动态规划的核心问题便是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。<br>​        而动态规划的穷举不是一般的暴力穷举，因为这类问题存在<strong>「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程。而且动态规划问题一定会具备<strong>「最优子结构」</strong>，可以通过子问题的最值得到原问题的最值。然而，只有列出正确的「状态转移方程」，才能正确地穷举。</p>
<h2 id="二、如何使用动态规划解决问题"><a href="#二、如何使用动态规划解决问题" class="headerlink" title="二、如何使用动态规划解决问题"></a>二、如何使用动态规划解决问题</h2><p>​        明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义<br>（即确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的就是优化递归树，消除重叠子问题）</p>
<p>解题套路框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"># 初始化 base <span class="hljs-keyword">case</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = base<br># 进行状态转移<br><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br><br></code></pre></td></tr></table></figure>

<h2 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h2><h3 id="LeetCode斐波那契数列"><a href="#LeetCode斐波那契数列" class="headerlink" title="LeetCode斐波那契数列"></a>LeetCode斐波那契数列</h3><p>（体现重叠子问题）</p>
<p>给定 n ，返回斐波那契数列的第 n 项 F(n)</p>
<p><em>①暴力递归：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度： 子问题个数 x 解决一个子问题需要的时间</p>
</blockquote>
<p>​        首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>​        然后计算解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p>
<p>​        所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p>
<p>​        <strong>这就是动态规划问题的第一个性质：重叠子问题</strong></p>
<p><em>②带备忘录的递归解法：</em><br>        增加一个变量「备忘录」，每次算出某个子问题的答案后先记到「备忘录」里，再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不必再耗时去计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 备忘录全初始化为 0</span><br>    <span class="hljs-keyword">int</span>[] memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 进行带备忘录的递归</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(memo, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] memo, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-comment">// 已经计算过，不用再计算了</span><br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[n];<br>    memo[n] = <span class="hljs-built_in">helper</span>(memo, n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">helper</span>(memo, n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<blockquote>
<p>时间复杂度：O(n) x O(1)</p>
</blockquote>
<p>​        这种解法是「自顶向下」进行「递归」求解，我们更常见的动态规划代码是「自底向上」进行「递推」求解。</p>
<p><em>③dp 数组的迭代（递推）解法：</em><br>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，通常叫做 DP table，在这张表上完成「自底向上」的推算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​        DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>​        动态规划问题的最后一步优化：如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度。</p>
<p>​        根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">// 分别代表 dp[i - 1] 和 dp[i - 2]</span><br>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">1</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// dp[i] = dp[i - 1] + dp[i - 2];</span><br>        <span class="hljs-keyword">int</span> dp_i = dp_i_1 + dp_i_2;<br>        <span class="hljs-comment">// 滚动更新</span><br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Leetcode凑零钱问题"><a href="#Leetcode凑零钱问题" class="headerlink" title="Leetcode凑零钱问题"></a>Leetcode凑零钱问题</h3><p>(最优子结构）</p>
<p>​        给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>​        计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<blockquote>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p>
</blockquote>
<p>①暴力递归：<br>        根据之前提出的框架，列出正确的状态转移方程的步骤：</p>
<ul>
<li><p>确定 base case，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
</li>
<li><p>确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p>
</li>
<li><p>确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p>
</li>
<li><p>明确 dp 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</p>
</li>
</ul>
<p>所以我们可以这样定义 dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-comment">// 题目要求的最终结果是 dp(amount)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(coins, amount)<br>&#125;<br><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">dp</span>(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount) &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>        <span class="hljs-comment">// 计算子问题的结果</span><br>        <span class="hljs-keyword">int</span> subProblem = <span class="hljs-built_in">dp</span>(coins, amount - coin);<br>        <span class="hljs-comment">// 子问题无解则跳过</span><br>        <span class="hljs-keyword">if</span> (subProblem == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 在子问题中选择最优解，然后加一</span><br>        res = Math.<span class="hljs-built_in">min</span>(res, subProblem + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">-1</span> : res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328093527192.png" alt="image-20220328093527192" class="lazyload"></p>
<p>时间复杂度：O(n^k) x O(k) 指数级</p>
<p>②带备忘录的递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>[] memo;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// dp 数组全都初始化为特殊值</span><br>    Arrays.<span class="hljs-built_in">fill</span>(memo, <span class="hljs-number">-666</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(coins, amount);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 查备忘录，防止重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[amount] != <span class="hljs-number">-666</span>)<br>        <span class="hljs-keyword">return</span> memo[amount];<br><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>        <span class="hljs-comment">// 计算子问题的结果</span><br>        <span class="hljs-keyword">int</span> subProblem = <span class="hljs-built_in">dp</span>(coins, amount - coin);<br>        <span class="hljs-comment">// 子问题无解则跳过</span><br>        <span class="hljs-keyword">if</span> (subProblem == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 在子问题中选择最优解，然后加一</span><br>        res = Math.<span class="hljs-built_in">min</span>(res, subProblem + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 把计算结果存入备忘录</span><br>    memo[amount] = (res == Integer.MAX_VALUE) ? <span class="hljs-number">-1</span> : res;<br>    <span class="hljs-keyword">return</span> memo[amount];<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n) x O(k) = O(kn)</p>
</blockquote>
<p>③dp 数组的迭代解法：<br>        dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出。<br>        根据我们文章开头给出的动态规划代码框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span><br>    Arrays.<span class="hljs-built_in">fill</span>(dp, amount + <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">//凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。</span><br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 外层 for 循环在遍历所有状态的所有取值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>        <span class="hljs-comment">// 内层 for 循环在求所有选择的最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> (i - coin &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>; 不要直接<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>，那样会终止函数执行<br>            &#125;<br>            dp[i] = Math.<span class="hljs-built_in">min</span>(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (dp[amount] == amount + <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : dp[amount];<span class="hljs-comment">//解决了coins = [2], amount = 3时需返回 -1 的情况</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="四、关于最优子结构"><a href="#四、关于最优子结构" class="headerlink" title="四、关于最优子结构"></a>四、关于最优子结构</h2><p>​        要符合「最优子结构」，子问题间必须互相独立。</p>
<p>​        比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>​        得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p>
<p>​        但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p>
<p>​        回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2021/09/01/Leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;09&#x2F;01&#x2F;Leetcode&#x2F;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#x2F;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;09&#x2F;01&#x2F;Leetcode&#x2F;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#x2F;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/Leetcode/">Leetcode</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/Leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">一、什么是动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">二、如何使用动态规划解决问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BE%8B%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">三、例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">LeetCode斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">Leetcode凑零钱问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E4%BA%8E%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">四、关于最优子结构</span></a></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1648713239104"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
