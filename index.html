
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Stay Hungry, Stay Foolish</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Shuyan</h1>
                <h3>Stay Hungry, Stay Foolish</h3>
                <h5>ShuyanCoding......</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/配置文件/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--MAven版本和头文件--&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    
    &lt;!--这里就是我们刚才配置的GAV--&gt;
    &lt;groupId&gt;com.qf&lt;/groupId&gt;
    &lt;artifactId&gt;javaweb-03-maven&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    
    &lt;!--项目的打包方式
  jar:java应用
  war:javaweb应用--&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;name&gt;javaweb-03-maven Maven Webapp&lt;/name&gt;
    
    &lt;!-- FIXME change it to the project&#39;s website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;
    
    &lt;!--配置--&gt;
    &lt;properties&gt;
        &lt;!--项目的默认构建编码--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;!--编码版本--&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    
    &lt;!--项目依赖--&gt;
    &lt;dependencies&gt;
        &lt;!--具体依赖的jar包配置文件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;!--  项目构建用的东西--&gt;
    &lt;build&gt;
        &lt;finalName&gt;javaweb-03-maven&lt;/finalName&gt;
        &lt;pluginManagement&gt;
            
            &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.1.0&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.8.0&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.22.1&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.5.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.8.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;

&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;
                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;
            &lt;/excludes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
    http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
    version=&quot;4.0&quot;
    metadata-complete=&quot;true&quot;&gt;
&lt;/web-app&gt;
</code></pre>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- 旧版，注释掉
     &lt;dependency&gt;
         &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
         &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
         &lt;version&gt;2.1&lt;/version&gt;
         &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt; 
     --&gt;
&lt;/dependencies&gt;


JSP方面的依赖
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.3&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- JSTL表达式的依赖 --&gt;
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--standard标签库--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/配置文件/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/JVM/G1使用详解/">
        <h2>
            G1使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>​        Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8/9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意的优化点。笔者希望通过本文，让有一定JVM基础的读者能尽快掌握G1的知识点。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​        G1(Garbage First)垃圾收集器是当今<strong>垃圾回收技术</strong>最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是<strong>关注最小时延</strong>的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是<strong>引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源</strong>，解决了其他收集器甚至CMS的众多缺陷。</p>
<h2 id="二、JVM-GC收集器的回顾与比较"><a href="#二、JVM-GC收集器的回顾与比较" class="headerlink" title="二、JVM GC收集器的回顾与比较"></a>二、JVM GC收集器的回顾与比较</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png" alt="JVM GC收集器成员"></p>
<p>​        从JDK3(1.3)开始，HotSpot团队一直努力朝着**高效收集、减少停顿(STW: Stop The World)**的方向努力，也贡献了从串行到CMS乃至最新的G1在内的一系列优秀的垃圾收集器。上图展示了JDK的垃圾回收大家庭，以及相互之间的组合关系，下面就几种典型的组合应用进行简单的介绍。</p>
<h3 id="2-1、串行收集器"><a href="#2-1、串行收集器" class="headerlink" title="2.1、串行收集器"></a>2.1、串行收集器</h3><p><img src="https://c1.staticflickr.com/5/4603/28345836579_8dff90eb76_z.jpg" alt="img"></p>
<p>​        串行收集器组合 Serial + Serial Old</p>
<blockquote>
<p> 开启选项：-XX:+SerialGC</p>
</blockquote>
<p>​        串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。</p>
<p>​        串行收集器采用<strong>单线程stop-the-world</strong>的方式进行收集。<strong>当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。</strong>单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</p>
<h3 id="2-2、并行收集器"><a href="#2-2、并行收集器" class="headerlink" title="2.2、并行收集器"></a>2.2、并行收集器</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/46f9b4f25c7783fd48a9a7df404e4f5e.png" alt="并行收集器组合"></p>
<p>​        并行收集器组合 Parallel Scavenge + Parallel Old</p>
<blockquote>
<p> 开启选项：-XX:+UseParallelGC或-XX:+UseParallelOldGC(可互相激活)</p>
</blockquote>
<p>​        并行收集器是以<strong>关注吞吐量</strong>为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。</p>
<p>​        并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。</p>
<p>​        关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数**-XX:MaxGCPauseMills和-XX:GCTimeRatio**，调整新生代空间大小，来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<h3 id="2-3、并发标记清除收集器"><a href="#2-3、并发标记清除收集器" class="headerlink" title="2.3、并发标记清除收集器"></a>2.3、并发标记清除收集器</h3><p><img src="https://c1.staticflickr.com/5/4740/40093687062_7383cd1b49_z.jpg" alt="img"></p>
<p>​        并发标记清除收集器组合 ParNew + CMS + Serial Old</p>
<blockquote>
<p> 开启选项：-XX:+UseConcMarkSweepGC</p>
</blockquote>
<p>​        并发标记清除(CMS)是以<strong>关注延迟</strong>为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。</p>
<p>​        年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：<strong>初始标记、并发标记、重新标记、并发清除</strong>。其中，</p>
<ul>
<li>初始标记以STW的方式标记所有的根对象；</li>
<li>并发标记则同应用线程一起并行，标记出根对象的可达路径；</li>
<li>在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；</li>
<li>最后得到的不可达对象将在并发清除阶段进行回收。</li>
</ul>
<p>​        值得注意的是，初始标记和重新标记都已优化为多线程执行。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p>
<p>​        但是CMS并不完美，它有以下缺点：</p>
<p>​        由于并发进行，CMS在收集与应用线程会同时会<strong>增加对堆内存的占用</strong>，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。</p>
<p>​        CMS也提供了参数**-XX:CMSFullGCsBeForeCompaction**(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。</p>
<h3 id="2-4、Garbage-First"><a href="#2-4、Garbage-First" class="headerlink" title="2.4、Garbage First"></a>2.4、Garbage First</h3><p><img src="https://c1.staticflickr.com/5/4655/28345836209_7b70465317_b.jpg" alt="img"></p>
<p>​        Garbage First (G1)</p>
<blockquote>
<p>开启选项：-XX:+UseG1GC</p>
</blockquote>
<p>​        之前介绍的几组垃圾收集器组合，都有几个共同点：</p>
<ul>
<li><p>年轻代、老年代是独立且连续的内存块；</p>
</li>
<li><p>年轻代收集使用单eden、双survivor进行复制算法；</p>
</li>
<li><p>老年代收集必须扫描整个老年代区域；</p>
</li>
<li><p>都是以尽可能少而块地执行GC为设计原则。</p>
</li>
</ul>
<p>​        G1垃圾收集器也是<strong>以关注延迟为目标</strong>、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：</p>
<p>​        G1的设计原则是”<strong>首先收集尽可能多的垃圾(Garbage First)</strong>“。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；<br>​        G1采用<strong>内存分区(Region)<strong>的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；<br>​        G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1</strong>只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换；<br>​        <strong>G1的收集都是STW的</strong>，但年轻代和老年代的收集界限比较模糊，采用了<strong>混合(mixed)收集</strong>的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p>
<h2 id="三、G1的内存模型"><a href="#三、G1的内存模型" class="headerlink" title="三、G1的内存模型"></a>三、G1的内存模型</h2><h3 id="3-1、分区概念"><a href="#3-1、分区概念" class="headerlink" title="3.1、分区概念"></a>3.1、分区概念</h3><p><img src="https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg" alt="img"></p>
<h4 id="3-1-1、分区-Region"><a href="#3-1-1、分区-Region" class="headerlink" title="3.1.1、分区 Region"></a>3.1.1、分区 Region</h4><p>​        G1采用了分区(Region)的思路，将整个<strong>堆空间</strong>分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>
<h4 id="3-1-2、卡片-Card"><a href="#3-1-2、卡片-Card" class="headerlink" title="3.1.2、卡片 Card"></a>3.1.2、卡片 Card</h4><p>​        在每个分区内部又被分成了若干个<strong>大小为512 Byte卡片</strong>(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<h4 id="3-1-3、堆-Heap"><a href="#3-1-3、堆-Heap" class="headerlink" title="3.1.3、堆 Heap"></a>3.1.3、堆 Heap</h4><p>​        G1同样可以<strong>通过-Xms/-Xmx来指定堆空间大小</strong>。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数**-XX:GCTimeRatio<strong>即为GC与应用的</strong>耗费时间比<strong>，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的</strong>Full GC**。Full GC后，堆尺寸计算结果也会调整堆空间。</p>
<h3 id="3-2、分代模型"><a href="#3-2、分代模型" class="headerlink" title="3.2、分代模型"></a>3.2、分代模型</h3><p><img src="https://c1.staticflickr.com/5/4621/28345836009_65a54854be_z.jpg" alt="img"></p>
<h4 id="3-2-1、分代-Generation"><a href="#3-2-1、分代-Generation" class="headerlink" title="3.2.1、分代 Generation"></a>3.2.1、分代 Generation</h4><p>​        分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为<strong>年轻代和老年代</strong>，其中年轻代又划分为<strong>Eden空间和Survivor空间</strong>。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p>
<p>​        整个年轻代内存会在<strong>初始空间-XX:G1NewSizePercent</strong>(默认整堆5%)与<strong>最大空间-XX:G1MaxNewSizePercent</strong>(默认60%)之间动态变化，且<strong>由参数目标暂停时间-XX:MaxGCPauseMillis</strong>(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以**设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)**，但同时暂停目标将失去意义。</p>
<h4 id="3-2-2、本地分配缓冲-Lab"><a href="#3-2-2、本地分配缓冲-Lab" class="headerlink" title="3.2.2、本地分配缓冲  Lab"></a>3.2.2、本地分配缓冲  Lab</h4><p>​        值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Local allocation buffer)。</p>
<p>​        其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，<strong>因此TLAB的分区属于Eden空间</strong>；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为**晋升本地缓冲区(PLAB)**。</p>
<h3 id="3-3、分区模型"><a href="#3-3、分区模型" class="headerlink" title="3.3、分区模型"></a>3.3、分区模型</h3><p><img src="https://c1.staticflickr.com/5/4619/40093686872_ce639c1121_z.jpg" alt="img"></p>
<p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p>
<h4 id="3-3-1、巨型对象-Humongous-Region"><a href="#3-3-1、巨型对象-Humongous-Region" class="headerlink" title="3.3.1、巨型对象 Humongous Region"></a>3.3.1、巨型对象 Humongous Region</h4><p>​        <strong>一个大小达到甚至超过分区大小一半的对象称为巨型对象</strong>(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为<strong>巨型分区</strong>(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p>
<p>​        巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为<u>开始巨型</u>(StartsHumongous)，相邻连续分区被标记为<u>连续巨型</u>(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<h4 id="3-3-2、已记忆集合-RSet"><a href="#3-3-2、已记忆集合-RSet" class="headerlink" title="3.3.2、已记忆集合  RSet"></a>3.3.2、已记忆集合  RSet</h4><p>​        在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(Remember Set)，*内部类似一个<u>反向指针</u>*，<strong>记录引用分区内对象的卡片索引</strong>。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>​        事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。</p>
<h4 id="3-3-3、Per-Region-Table"><a href="#3-3-3、Per-Region-Table" class="headerlink" title="3.3.3、Per Region Table"></a>3.3.3、Per Region Table</h4><p>​        RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p>
<ul>
<li><strong>稀少：</strong>直接记录引用对象的卡片索引；</li>
<li><strong>细粒度：</strong>记录引用对象的分区索引；</li>
<li><strong>粗粒度：</strong>只记录引用情况，每个分区对应一个比特位。</li>
</ul>
<p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
<h3 id="3-4、收集集合-CSet"><a href="#3-4、收集集合-CSet" class="headerlink" title="3.4、收集集合 (CSet)"></a>3.4、收集集合 (CSet)</h3><p><img src="https://c1.staticflickr.com/5/4766/40126693251_d74183c2c6.jpg" alt="img"></p>
<h4 id="3-4-1、收集集合-CSet"><a href="#3-4-1、收集集合-CSet" class="headerlink" title="3.4.1、收集集合 CSet"></a>3.4.1、收集集合 CSet</h4><p>​        收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p>
<p>​        候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-<strong>XX:G1OldCSetRegionThresholdPercent</strong> (默认10%)<strong>设置数量上限</strong>。</p>
<p>​        由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h4 id="3-4-2、年轻代收集集合"><a href="#3-4-2、年轻代收集集合" class="headerlink" title="3.4.2、年轻代收集集合"></a>3.4.2、年轻代收集集合</h4><p>年轻代收集集合 CSet of Young Collection</p>
<p>​        应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>​        同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、S<strong>urvivor填充容量-XX:TargetSurvivorRatio</strong>(默认50%)、<strong>最大任期阈值-XX:MaxTenuringThreshold</strong>(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<h4 id="3-4-3、混合收集集合"><a href="#3-4-3、混合收集集合" class="headerlink" title="3.4.3、混合收集集合"></a>3.4.3、混合收集集合</h4><p>混合收集集合 CSet of Mixed Collection</p>
<p>​        年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过<strong>整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent</strong>(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>
<p>​        为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p>
<h1 id="四、G1的活动周期"><a href="#四、G1的活动周期" class="headerlink" title="四、G1的活动周期"></a>四、G1的活动周期</h1><h3 id="4-1、G1垃圾收集活动汇总"><a href="#4-1、G1垃圾收集活动汇总" class="headerlink" title="4.1、G1垃圾收集活动汇总"></a>4.1、G1垃圾收集活动汇总</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/5a60b80279c1f7a7664f6b54d26e967c.png" alt="G1垃圾收集活动周期图"></p>
<h3 id="4-2、RSet的维护"><a href="#4-2、RSet的维护" class="headerlink" title="4.2、RSet的维护"></a>4.2、RSet的维护</h3><p>​        由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。在G1中，RSet的维护主要来源两个方面：<strong>写栅栏</strong>(Write Barrier)和<strong>并发优化线程</strong>(Concurrence Refinement Threads)</p>
<h3 id="4-3、栅栏-Barrier"><a href="#4-3、栅栏-Barrier" class="headerlink" title="4.3、栅栏 Barrier"></a>4.3、栅栏 Barrier</h3><p><img src="https://c1.staticflickr.com/5/4658/40093686702_9d689b29e9_z.jpg" alt="img">)</p>
<p>​        首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p>
<h4 id="4-3-1、写前栅栏-Pre-Write-Barrrier"><a href="#4-3-1、写前栅栏-Pre-Write-Barrrier" class="headerlink" title="4.3.1、写前栅栏 Pre-Write Barrrier"></a>4.3.1、写前栅栏 Pre-Write Barrrier</h4><p>​        <strong>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么JVM就需要在赋值语句生效之前，记录丧失引用的对象</strong>。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见SATB)。</p>
<h4 id="4-3-2、写后栅栏-Post-Write-Barrrier"><a href="#4-3-2、写后栅栏-Post-Write-Barrrier" class="headerlink" title="4.3.2、写后栅栏 Post-Write Barrrier"></a>4.3.2、写后栅栏 Post-Write Barrrier</h4><p>​        <strong>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新</strong>。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</p>
<h4 id="4-3-4、起始快照算法-SATB"><a href="#4-3-4、起始快照算法-SATB" class="headerlink" title="4.3.4、起始快照算法 SATB"></a>4.3.4、起始快照算法 SATB</h4><p>​        Taiichi Tuasa贡献的增量式完全并发标记算法起始快照算法(Snapshot at the beginning)，主要针对标记-清除垃圾收集器的<strong>并发标记阶段</strong>，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p>
<p>​        SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet。此过程又称为并发标记/SATB写前栅栏。</p>
<h3 id="4-4、并发优化线程"><a href="#4-4、并发优化线程" class="headerlink" title="4.4、并发优化线程"></a>4.4、并发优化线程</h3><h4 id="4-4-1、并发优化线程-Concurrence-Refinement-Threads"><a href="#4-4-1、并发优化线程-Concurrence-Refinement-Threads" class="headerlink" title="4.4.1、并发优化线程 Concurrence Refinement Threads"></a>4.4.1、并发优化线程 Concurrence Refinement Threads</h4><p>​        G1中使用基于Urs Hölzle的快速写栅栏，将栅栏开销缩减到2个额外的指令。栅栏将会更新一个<strong>card table type</strong>的结构来<strong>跟踪代间引用</strong>。</p>
<p>​        当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p>
<p>​        并发优化线程(Concurrence Refinement Threads)，<strong>只专注扫描日志缓冲区记录的卡片来维护更新RSet</strong>，线程最大数目可通过-XX:G1ConcRefinementThreads(默认等于-XX:ParellelGCThreads)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。</p>
<p>​        如果记录增长很快或者来不及处理，那么通过阈值-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p>
<h4 id="4-4-2、并发标记周期-Concurrent-Marking-Cycle"><a href="#4-4-2、并发标记周期-Concurrent-Marking-Cycle" class="headerlink" title="4.4.2、并发标记周期 Concurrent Marking Cycle"></a>4.4.2、并发标记周期 Concurrent Marking Cycle</h4><p>​        并发标记周期是G1中非常重要的阶段，这个阶段将会<strong>为混合收集周期识别垃圾最多的老年代分区</strong>。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p>
<p>​        <strong>当达到IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，便会触发并发标记周期</strong>。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，<strong>初始标记(随年轻代收集一起活动)、重新标记、清除是STW的</strong>，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p>
<h4 id="4-4-3、并发标记线程-Concurrent-Marking-Threads"><a href="#4-4-3、并发标记线程-Concurrent-Marking-Threads" class="headerlink" title="4.4.3、并发标记线程 Concurrent Marking Threads"></a>4.4.3、并发标记线程 Concurrent Marking Threads</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/ac554fcaf159d7a7c62511c5e7db19fc.png" alt="并发标记位图过程"></p>
<p>​        要标记存活的对象，每个分区都需要<strong>创建位图(Bitmap)信息来存储标记数据</strong>，来确定标记周期内被分配的对象。G1采用了两个位图Previous Bitmap、Next Bitmap，来存储标记数据，Previous位图存储上次的标记数据，Next位图在标记周期内不断变化更新，同时Previous位图的标记数据也越来越过时，当标记周期结束后Next位图便替换Previous位图，成为上次标记的位图。同时，每个分区通过顶部开始标记(TAMS)，来记录已标记过的内存范围。同样的，G1使用了两个顶部开始标记Previous TAMS(PTAMS)、Next TAMS(NTAMS)，记录已标记的范围。</p>
<p>​        在并发标记阶段，G1会根据参数-XX:ConcGCThreads(默认GC线程数的1/4，即-XX:ParallelGCThreads/4)，分配并发标记线程(Concurrent Marking Threads)，进行标记活动。<u>每个并发线程一次只扫描一个分区</u>，并通过”手指”指针的方式优化获取分区。并发标记线程是爆发式的，在给定的时间段拼命干活，然后休息一段时间，再拼命干活。</p>
<p>​        每个并发标记周期，在初始标记STW的最后，G1会分配一个空的Next位图和一个指向分区顶部(Top)的NTAMS标记。Previous位图记录的上次标记数据，上次的标记位置，即PTAMS，在PTAMS与分区底部(Bottom)的范围内，所有的存活对象都已被标记。那么，在PTAMS与Top之间的对象都将是隐式存活(Implicitly Live)对象。在并发标记阶段，Next位图吸收了Previous位图的标记数据，同时每个分区都会有新的对象分配，则Top与NTAMS分离，前往更高的地址空间。在并发标记的一次标记中，并发标记线程将找出NTAMS与PTAMS之间的所有存活对象，将标记数据存储在Next位图中。同时，在NTAMS与Top之间的对象即成为已标记对象。如此不断地更新Next位图信息，并在清除阶段与Previous位图交换角色。</p>
<p><strong>初始标记 Initial Mark</strong></p>
<p>​        初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是<strong>需要一个STW的时间段</strong>。事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为<strong>借道</strong>(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p>
<p><strong>根分区扫描 Root Region Scanning</strong></p>
<p>​        在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为<strong>根分区</strong>(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p>
<p><strong>并发标记 Concurrent Marking</strong></p>
<p>​        和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数-XX:ConcGCThreads(默认GC线程数的1/4，即-XX:ParallelGCThreads/4) 控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。</p>
<p>​        参数-XX:+ClassUnloadingWithConcurrentMark会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p>
<p><strong>存活数据计算 Live Data Accounting</strong></p>
<p>​        存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p>
<p><strong>重新标记 Remark</strong></p>
<p>​        重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数-XX:ParallelGCThread可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p>
<p><strong>清除 Cleanup</strong></p>
<p>​        紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p>
<ul>
<li>RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节；</li>
<li>整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</li>
<li>识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</li>
</ul>
<h3 id="4-5、年轻代收集-混合收集周期"><a href="#4-5、年轻代收集-混合收集周期" class="headerlink" title="4.5、年轻代收集/混合收集周期"></a>4.5、年轻代收集/混合收集周期</h3><p>​        年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p>
<h4 id="4-5-1、GC工作线程数-XX-ParallelGCThreads"><a href="#4-5-1、GC工作线程数-XX-ParallelGCThreads" class="headerlink" title="4.5.1、GC工作线程数 -XX:ParallelGCThreads"></a>4.5.1、GC工作线程数 -XX:ParallelGCThreads</h4><p>​        JVM可以通过参数-XX:ParallelGCThreads进行指定GC工作的线程数量。参数-XX:ParallelGCThreads默认值并不是固定的，而是根据当前的CPU资源进行计算。如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；当然也可以人工指定与CPU核数相等。</p>
<h4 id="4-5-2、年轻代收集-Young-Collection"><a href="#4-5-2、年轻代收集-Young-Collection" class="headerlink" title="4.5.2、年轻代收集 Young Collection"></a>4.5.2、年轻代收集 Young Collection</h4><p>​        每次收集过程中，既有并行执行的活动，也有串行执行的活动，但都可以是多线程的。在并行执行的任务中，如果某个任务过重，会导致其他线程在等待某项任务的处理，需要对这些地方进行优化。</p>
<p><strong>并行活动</strong></p>
<p>​        <strong>外部根分区扫描 Ext Root Scanning：</strong>此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</p>
<p>​        <strong>更新已记忆集合 Update RS：</strong>并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比-XX:G1RSetUpdatingPauseTimePercent(默认10%，即-XX:MaxGCPauseMills/10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</p>
<p>​        <strong>RSet扫描 Scan RS：</strong>在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式-XX:UnlockDiagnosticVMOptions后，通过参数-XX:+G1SummarizeRSetStats可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数-XX：G1SummarizeRSetStatsPeriod=n可设置RSet的统计周期，即经历多少此GC后进行一次统计</p>
<p>​        <strong>代码根扫描 Code Root Scanning：</strong>对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</p>
<p>​        <strong>转移和回收 Object Copy：</strong>通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来负载均衡地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</p>
<p>​        <strong>终止 Termination：</strong>完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</p>
<p>​        <strong>GC外部的并行活动 GC Worker Other：</strong>该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</p>
<p><strong>串行活动</strong></p>
<p>​        <strong>代码根更新 Code Root Fixup：</strong>根据转移对象更新代码根。</p>
<p>​        <strong>代码根清理 Code Root Purge：</strong>清理代码根集合表。</p>
<p>​        <strong>清除全局卡片标记 Clear CT：</strong>在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</p>
<p>​        <strong>选择下次收集集合 Choose CSet：</strong>该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</p>
<p>​        <strong>引用处理 Ref Proc：</strong>主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数-XX:ParallelRefProcEnabled激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</p>
<p>​        <strong>引用排队 Ref Enq：</strong>此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</p>
<p>​        <strong>卡片重新脏化 Redirty Cards：</strong>重新脏化卡片。</p>
<p>​        <strong>回收空闲巨型分区 Humongous Reclaim：</strong>G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</p>
<p>​        <strong>释放分区 Free CSet：</strong>回收CSet分区的所有空间，并加入到空闲分区中。</p>
<p>​        <strong>其他活动 Other：</strong>GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等。</p>
<h4 id="4-5-3、并发标记周期后的年轻代收集"><a href="#4-5-3、并发标记周期后的年轻代收集" class="headerlink" title="4.5.3、并发标记周期后的年轻代收集"></a>4.5.3、并发标记周期后的年轻代收集</h4><p><strong>并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</strong></p>
<p>​        当G1发起并发标记周期之后，并不会马上开始混合收集。G1会先等待下一次年轻代收集，然后在该收集阶段中，确定下次混合收集的CSet(Choose CSet)。</p>
<p><strong>混合收集周期 Mixed Collection Cycle</strong></p>
<p>​        单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p>
<h3 id="4-6、转移失败的担保机制-Full-GC"><a href="#4-6、转移失败的担保机制-Full-GC" class="headerlink" title="4.6、转移失败的担保机制 Full GC"></a>4.6、转移失败的担保机制 Full GC</h3><p><strong>转移失败的担保机制 Full GC</strong></p>
<p>​        转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，<strong>执行一次STW式的、单线程的Full GC</strong>。Full GC会<strong>对整堆做标记清除和压缩，最后将只包含纯粹的存活对象</strong>。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p>
<p>​        G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p>
<ul>
<li>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区</li>
<li>从老年代分区转移存活对象时，无法找到可用的空闲分区</li>
<li>分配巨型对象时在老年代无法找到足够的连续分区</li>
</ul>
<p>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>​        G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过**首先收集尽可能多的垃圾(Garbage First)**的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JVM" style=color:#1bccbc>
                JVM
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/JVM/G1使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/JVM/JVM使用详解/">
        <h2>
            JVM使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><img src="https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="一、Java-内存区域与内存溢出异常"><a href="#一、Java-内存区域与内存溢出异常" class="headerlink" title="一、Java 内存区域与内存溢出异常"></a>一、Java 内存区域与内存溢出异常</h2><h3 id="1-1、运行时数据区域"><a href="#1-1、运行时数据区域" class="headerlink" title="1.1、运行时数据区域"></a>1.1、运行时数据区域</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="1-1-1、程序计数器"><a href="#1-1-1、程序计数器" class="headerlink" title="1.1.1、程序计数器"></a>1.1.1、程序计数器</h4><blockquote>
<p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p>
</blockquote>
<p>​        如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h4 id="1-1-2、Java-虚拟机栈"><a href="#1-1-2、Java-虚拟机栈" class="headerlink" title="1.1.2、Java 虚拟机栈"></a>1.1.2、Java 虚拟机栈</h4><blockquote>
<p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p>
</blockquote>
<ul>
<li><strong>局部变量表：</strong>存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</li>
<li><strong>StackOverflowError：</strong>线程请求的栈深度大于虚拟机所允许的深度。</li>
<li><strong>OutOfMemoryError：</strong>如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</li>
</ul>
<h4 id="1-1-3、本地方法栈"><a href="#1-1-3、本地方法栈" class="headerlink" title="1.1.3、本地方法栈"></a>1.1.3、本地方法栈</h4><blockquote>
<p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p>
</blockquote>
<h4 id="1-1-4、Java-堆"><a href="#1-1-4、Java-堆" class="headerlink" title="1.1.4、Java 堆"></a>1.1.4、Java 堆</h4><blockquote>
<p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p>
</blockquote>
<ul>
<li><strong>OutOfMemoryError：</strong>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</li>
</ul>
<h4 id="1-1-5、方法区"><a href="#1-1-5、方法区" class="headerlink" title="1.1.5、方法区"></a>1.1.5、方法区</h4><blockquote>
<p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<p>现在用一张图来介绍每个区域存储的内容。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="1-1-6、运行时常量池"><a href="#1-1-6、运行时常量池" class="headerlink" title="1.1.6、运行时常量池"></a>1.1.6、运行时常量池</h4><blockquote>
<p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p>
</blockquote>
<h4 id="1-1-7、直接内存"><a href="#1-1-7、直接内存" class="headerlink" title="1.1.7、直接内存"></a>1.1.7、直接内存</h4><blockquote>
<p>非虚拟机运行时数据区的部分</p>
</blockquote>
<p>​        在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。</p>
<ul>
<li><strong>OutOfMemoryError：</strong>会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</li>
</ul>
<h3 id="1-2、HotSpot-虚拟机对象探秘"><a href="#1-2、HotSpot-虚拟机对象探秘" class="headerlink" title="1.2、HotSpot 虚拟机对象探秘"></a>1.2、HotSpot 虚拟机对象探秘</h3><blockquote>
<p>主要介绍数据是如何创建、如何布局以及如何访问的。</p>
</blockquote>
<h4 id="1-2-1、对象的创建"><a href="#1-2-1、对象的创建" class="headerlink" title="1.2.1、对象的创建"></a>1.2.1、对象的创建</h4><blockquote>
<p>创建过程比较复杂，建议看书了解，这里提供个人的总结。</p>
</blockquote>
<p>​        遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p>
<p>​        类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p>
<p>​        前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p>
<p>​        内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p>
<p>​        执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p>
<h4 id="1-2-2、对象的内存布局"><a href="#1-2-2、对象的内存布局" class="headerlink" title="1.2.2、对象的内存布局"></a>1.2.2、对象的内存布局</h4><blockquote>
<p>在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p>
</blockquote>
<p>​        <strong>对象头(Header)：</strong>包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p>​        <strong>实例数据(Instance Data)：</strong>程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p>​        <strong>对齐填充(Padding)：</strong>不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<h4 id="1-2-3、对象的访问定位"><a href="#1-2-3、对象的访问定位" class="headerlink" title="1.2.3、对象的访问定位"></a>1.2.3、对象的访问定位</h4><blockquote>
<p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p>
</blockquote>
<ul>
<li><strong>通过句柄访问</strong></li>
</ul>
<blockquote>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<ul>
<li><strong>使用直接指针访问</strong></li>
</ul>
<blockquote>
<p>reference 中直接存储对象地址</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>​        比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h3 id="1-3、实战"><a href="#1-3、实战" class="headerlink" title="1.3、实战"></a>1.3、实战</h3><p>// 待填</p>
<h2 id="二、垃圾回收器与内存分配策略"><a href="#二、垃圾回收器与内存分配策略" class="headerlink" title="二、垃圾回收器与内存分配策略"></a>二、垃圾回收器与内存分配策略</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p>​        程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p>
<h3 id="2-2、对象已死吗？"><a href="#2-2、对象已死吗？" class="headerlink" title="2.2、对象已死吗？"></a>2.2、对象已死吗？</h3><p>​        在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p>
<h4 id="2-2-1、引用计数法"><a href="#2-2-1、引用计数法" class="headerlink" title="2.2.1、引用计数法"></a>2.2.1、引用计数法</h4><p>​        给对象添加一个引用计数器。但是难以解决循环引用问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>​        从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p>
<h4 id="2-2-2、可达性分析法"><a href="#2-2-2、可达性分析法" class="headerlink" title="2.2.2、可达性分析法"></a>2.2.2、可达性分析法</h4><p>​        通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>可作为 GC Roots 的对象：</p>
<p>虚拟机栈(栈帧中的本地变量表)中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</p>
<h4 id="2-2-3、再谈引用"><a href="#2-2-3、再谈引用" class="headerlink" title="2.2.3、再谈引用"></a>2.2.3、再谈引用</h4><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p>
<p>下面四种引用强度一次逐渐减弱</p>
<ul>
<li><p>强引用</p>
<ul>
<li>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</li>
</ul>
</li>
<li><p>软引用</p>
<ul>
<li>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li>
</ul>
</li>
<li><p>弱引用</p>
<ul>
<li>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li>
</ul>
</li>
<li><p>虚引用</p>
<ul>
<li>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
</li>
</ul>
<h4 id="2-2-4、生存还是死亡"><a href="#2-2-4、生存还是死亡" class="headerlink" title="2.2.4、生存还是死亡"></a>2.2.4、生存还是死亡</h4><p>​        即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>​        如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p>
<p>​        finalize() 方法只会被系统自动调用一次。</p>
<h4 id="2-2-5、回收方法区"><a href="#2-2-5、回收方法区" class="headerlink" title="2.2.5、回收方法区"></a>2.2.5、回收方法区</h4><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p>
<ul>
<li>判断废弃常量：一般是判断没有该常量的引用。</li>
<li>判断无用的类：要以下三个条件都满足</li>
</ul>
<p>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例<br>加载该类的 ClassLoader 已经被回收<br>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</p>
<h3 id="2-3、垃圾回收算法"><a href="#2-3、垃圾回收算法" class="headerlink" title="2.3、垃圾回收算法"></a>2.3、垃圾回收算法</h3><p>仅提供思路</p>
<h4 id="2-3-1、标记-——-清除算法"><a href="#2-3-1、标记-——-清除算法" class="headerlink" title="2.3.1、标记 —— 清除算法"></a>2.3.1、标记 —— 清除算法</h4><p>直接标记清除就可。</p>
<p>两个不足：</p>
<p>效率不高<br>空间会产生大量碎片</p>
<h4 id="2-3-2、复制算法"><a href="#2-3-2、复制算法" class="headerlink" title="2.3.2、复制算法"></a>2.3.2、复制算法</h4><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p>
<p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p>
<h4 id="2-3-3、标记-整理算法"><a href="#2-3-3、标记-整理算法" class="headerlink" title="2.3.3、标记-整理算法"></a>2.3.3、标记-整理算法</h4><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p>
<h4 id="2-3-4、分代回收"><a href="#2-3-4、分代回收" class="headerlink" title="2.3.4、分代回收"></a>2.3.4、分代回收</h4><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p>
<p>新生代</p>
<p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p>
<p>老年代</p>
<p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。</p>
<h3 id="2-4、HotSpot-的算法实现"><a href="#2-4、HotSpot-的算法实现" class="headerlink" title="2.4、HotSpot 的算法实现"></a>2.4、HotSpot 的算法实现</h3><p>// 待填</p>
<h3 id="2-5、垃圾回收器"><a href="#2-5、垃圾回收器" class="headerlink" title="2.5、垃圾回收器"></a>2.5、垃圾回收器</h3><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p>
<h4 id="2-5-1、Serial-收集器"><a href="#2-5-1、Serial-收集器" class="headerlink" title="2.5.1、Serial 收集器"></a>2.5.1、Serial 收集器</h4><blockquote>
<p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="2-5-2、ParNew-收集器"><a href="#2-5-2、ParNew-收集器" class="headerlink" title="2.5.2、ParNew 收集器"></a>2.5.2、ParNew 收集器</h4><blockquote>
<p>可以认为是 Serial 收集器的多线程版本。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>并行：Parallel</p>
<p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p>
<p>并发：Concurrent</p>
<p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p>
<h4 id="2-5-3、Parallel-Scavenge-收集器"><a href="#2-5-3、Parallel-Scavenge-收集器" class="headerlink" title="2.5.3、Parallel Scavenge 收集器"></a>2.5.3、Parallel Scavenge 收集器</h4><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p>
<p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p>
<p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p>
<h4 id="2-5-4、Serial-Old-收集器"><a href="#2-5-4、Serial-Old-收集器" class="headerlink" title="2.5.4、Serial Old 收集器"></a>2.5.4、Serial Old 收集器</h4><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="2-5-5、Parallel-Old-收集器"><a href="#2-5-5、Parallel-Old-收集器" class="headerlink" title="2.5.5、Parallel Old 收集器"></a>2.5.5、Parallel Old 收集器</h4><blockquote>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 <code>标记 —— 整理</code></p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="2-5-6、CMS-收集器"><a href="#2-5-6、CMS-收集器" class="headerlink" title="2.5.6、CMS 收集器"></a>2.5.6、CMS 收集器</h4><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p>
<p>运作步骤:</p>
<p>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象<br>并发标记(CMS concurrent mark)：进行 GC Roots Tracing<br>重新标记(CMS remark)：修正并发标记期间的变动部分<br>并发清除(CMS concurrent sweep)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p>
<h4 id="2-5-7、G1-收集器"><a href="#2-5-7、G1-收集器" class="headerlink" title="2.5.7、G1 收集器"></a>2.5.7、G1 收集器</h4><p>面向服务端的垃圾回收器。</p>
<p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p>
<p>运作步骤:</p>
<p>初始标记(Initial Marking)<br>并发标记(Concurrent Marking)<br>最终标记(Final Marking)<br>筛选回收(Live Data Counting and Evacuation)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h3 id="2-6、内存分配与回收策略"><a href="#2-6、内存分配与回收策略" class="headerlink" title="2.6、内存分配与回收策略"></a>2.6、内存分配与回收策略</h3><h4 id="2-6-1、对象优先在-Eden-分配"><a href="#2-6-1、对象优先在-Eden-分配" class="headerlink" title="2.6.1、对象优先在 Eden 分配"></a>2.6.1、对象优先在 Eden 分配</h4><blockquote>
<p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p>
</blockquote>
<p>一般来说 Java 堆的内存模型如下图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>新生代 GC (Minor GC)</p>
<p>发生在新生代的垃圾回收动作，频繁，速度快。</p>
<p>老年代 GC (Major GC / Full GC)</p>
<p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p>
<h4 id="2-6-2、大对象直接进入老年代"><a href="#2-6-2、大对象直接进入老年代" class="headerlink" title="2.6.2、大对象直接进入老年代"></a>2.6.2、大对象直接进入老年代</h4><h4 id="2-6-3、长期存活的对象将进入老年代"><a href="#2-6-3、长期存活的对象将进入老年代" class="headerlink" title="2.6.3、长期存活的对象将进入老年代"></a>2.6.3、长期存活的对象将进入老年代</h4><h4 id="2-6-4、动态对象年龄判定"><a href="#2-6-4、动态对象年龄判定" class="headerlink" title="2.6.4、动态对象年龄判定"></a>2.6.4、动态对象年龄判定</h4><h4 id="2-6-5、空间分配担保"><a href="#2-6-5、空间分配担保" class="headerlink" title="2.6.5、空间分配担保"></a>2.6.5、空间分配担保</h4><h2 id="三、Java-内存模型与线程"><a href="#三、Java-内存模型与线程" class="headerlink" title="三、Java 内存模型与线程"></a>三、Java 内存模型与线程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h3 id="3-1、Java-内存模型"><a href="#3-1、Java-内存模型" class="headerlink" title="3.1、Java 内存模型"></a>3.1、Java 内存模型</h3><blockquote>
<p>屏蔽掉各种硬件和操作系统的内存访问差异。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h4 id="3-1-1、主内存和工作内存之间的交互"><a href="#3-1-1、主内存和工作内存之间的交互" class="headerlink" title="3.1.1、主内存和工作内存之间的交互"></a>3.1.1、主内存和工作内存之间的交互</h4><p>操作    作用对象    解释<br>lock    主内存    把一个变量标识为一条线程独占的状态<br>unlock    主内存    把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定<br>read    主内存    把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用<br>load    工作内存    把 read 操作从主内存中得到的变量值放入工作内存中<br>use    工作内存    把工作内存中一个变量的值传递给执行引擎，<br>每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作<br>assign    工作内存    把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，<br>每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作<br>store    工作内存    把工作内存中的一个变量的值传送到主内存中，以便 write 操作<br>write    工作内存    把 store 操作从工作内存中得到的变量的值放入主内存的变量中</p>
<h4 id="3-1-2、对于-volatile-型变量的特殊规则"><a href="#3-1-2、对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2、对于 volatile 型变量的特殊规则"></a>3.1.2、对于 volatile 型变量的特殊规则</h4><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p>
<p>一个变量被定义为 volatile 的特性：</p>
<p>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。<br>如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p>
<p>禁止指令重排序优化。<br>通过插入内存屏障保证一致性。</p>
<h4 id="3-1-3、对于-long-和-double-型变量的特殊规则"><a href="#3-1-3、对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3、对于 long 和 double 型变量的特殊规则"></a>3.1.3、对于 long 和 double 型变量的特殊规则</h4><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p>
<h4 id="3-1-4、原子性、可见性与有序性"><a href="#3-1-4、原子性、可见性与有序性" class="headerlink" title="3.1.4、原子性、可见性与有序性"></a>3.1.4、原子性、可见性与有序性</h4><p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p>
<p>原子性(Atomicity)<br>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p>
<p>可见性(Visibility)<br>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p>
<p>有序性(Ordering)<br>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h4 id="3-1-5、先行发生原则"><a href="#3-1-5、先行发生原则" class="headerlink" title="3.1.5、先行发生原则"></a>3.1.5、先行发生原则</h4><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>
<p>天然的先行发生关系</p>
<p>规则    解释<br>程序次序规则    在一个线程内，代码按照书写的控制流顺序执行<br>管程锁定规则    一个 unlock 操作先行发生于后面对同一个锁的 lock 操作<br>volatile 变量规则    volatile 变量的写操作先行发生于后面对这个变量的读操作<br>线程启动规则    Thread 对象的 start() 方法先行发生于此线程的每一个动作<br>线程终止规则    线程中所有的操作都先行发生于对此线程的终止检测<br>(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)<br>线程中断规则    对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生<br>(通过 Thread.interrupted() 方法检测)<br>对象终结规则    一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始<br>传递性    如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</p>
<h3 id="3-2、Java-与线程"><a href="#3-2、Java-与线程" class="headerlink" title="3.2、Java 与线程"></a>3.2、Java 与线程</h3><h4 id="3-2-1、线程的实现"><a href="#3-2-1、线程的实现" class="headerlink" title="3.2.1、线程的实现"></a>3.2.1、线程的实现</h4><p>使用内核线程实现</p>
<p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>使用用户线程实现</p>
<blockquote>
<p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>使用用户线程夹加轻量级进程混合实现</p>
<blockquote>
<p>直接看图</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>Java 线程实现</p>
<p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p>
<h4 id="3-2-2、Java-线程调度"><a href="#3-2-2、Java-线程调度" class="headerlink" title="3.2.2、Java 线程调度"></a>3.2.2、Java 线程调度</h4><p>协同式线程调度</p>
<p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p>
<p>抢占式线程调度</p>
<p>每个线程由系统来分配执行时间。</p>
<h4 id="3-2-3、状态转换"><a href="#3-2-3、状态转换" class="headerlink" title="3.2.3、状态转换"></a>3.2.3、状态转换</h4><p>五种状态：</p>
<p>新建(new)<br>创建后尚未启动的线程。</p>
<p>运行(Runable)<br>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p>
<p>无限期等待(Waiting)<br>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p>
<p>以下方法会然线程进入无限期等待状态：<br>1.没有设置 Timeout 参数的 Object.wait() 方法。<br>2.没有设置 Timeout 参数的 Thread.join() 方法。<br>3.LookSupport.park() 方法。</p>
<p>限期等待(Timed Waiting)<br>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p>
<p>以下方法会让线程进入限期等待状态：<br>1.Thread.sleep() 方法。<br>2.设置了 Timeout 参数的 Object.wait() 方法。<br>3.设置了 Timeout 参数的 Thread.join() 方法。<br>4.LockSupport.parkNanos() 方法。<br>5.LockSupport.parkUntil() 方法。</p>
<p>阻塞(Blocked)<br>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
<p>结束(Terminated)<br>已终止线程的线程状态。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<h2 id="四、线程安全与锁优化"><a href="#四、线程安全与锁优化" class="headerlink" title="四、线程安全与锁优化"></a>四、线程安全与锁优化</h2><p>// 待填</p>
<h2 id="五、类文件结构"><a href="#五、类文件结构" class="headerlink" title="五、类文件结构"></a>五、类文件结构</h2><p>// 待填</p>
<p>有点懒了。。。先贴几个网址吧。</p>
<ol>
<li>Official：The class File Format<br>2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构</li>
</ol>
<h2 id="六、虚拟机类加载机制"><a href="#六、虚拟机类加载机制" class="headerlink" title="六、虚拟机类加载机制"></a>六、虚拟机类加载机制</h2><p>  虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
<p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
<h3 id="6-1、类加载时机"><a href="#6-1、类加载时机" class="headerlink" title="6.1、类加载时机"></a>6.1、类加载时机</h3><p>类的生命周期( 7 个阶段)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p>
<p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p>
<p>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。<br>使用 java.lang.reflect 包的方法对类进行反射调用的时候。<br>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。<br>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。<br>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。<br>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~</p>
<pre><code class="java">public class SuperClass &#123;
    static &#123;
        System.out.println(&quot;SuperClass init!&quot;);
    &#125;
    public static int value = 1127;
&#125;
 
public class SubClass extends SuperClass &#123;
    static &#123;
        System.out.println(&quot;SubClass init!&quot;);
    &#125;
&#125;
 
public class ConstClass &#123;
    static &#123;
        System.out.println(&quot;ConstClass init!&quot;);
    &#125;
    public static final String HELLOWORLD = &quot;hello world!&quot;
&#125;
 
public class NotInitialization &#123;
    public static void main(String[] args) &#123;
        System.out.println(SubClass.value);
        /**
         *  output : SuperClass init!
         * 
         * 通过子类引用父类的静态对象不会导致子类的初始化
         * 只有直接定义这个字段的类才会被初始化
         */
 
        SuperClass[] sca = new SuperClass[10];
        /**
         *  output : 
         * 
         * 通过数组定义来引用类不会触发此类的初始化
         * 虚拟机在运行时动态创建了一个数组类
         */
 
        System.out.println(ConstClass.HELLOWORLD);
        /**
         *  output : 
         * 
         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，
         * 因此不会触发定义常量的类的初始化。
         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。
         */
    &#125;
&#125;
</code></pre>
<h3 id="6-2、类的加载过程"><a href="#6-2、类的加载过程" class="headerlink" title="6.2、类的加载过程"></a>6.2、类的加载过程</h3><h4 id="6-2-1、加载"><a href="#6-2-1、加载" class="headerlink" title="6.2.1、加载"></a>6.2.1、加载</h4><p>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。<br>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p>
<p>如果数组的组件类型是引用类型，那就递归采用类加载加载。<br>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。<br>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。<br>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p>
<h4 id="6-2-2、验证"><a href="#6-2-2、验证" class="headerlink" title="6.2.2、验证"></a>6.2.2、验证</h4><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p>
<p>文件格式验证</p>
<p>是否以魔数 0xCAFEBABE 开头<br>主、次版本号是否在当前虚拟机处理范围之内<br>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）<br>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量<br>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据<br>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息<br>……<br>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p>
<p>元数据验证</p>
<p>这个类是否有父类（除 java.lang.Object 之外）<br>这个类的父类是否继承了不允许被继承的类（final 修饰的类）<br>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法<br>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）<br>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<p>字节码验证</p>
<p>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）<br>保证跳转指令不会跳转到方法体以外的字节码指令上<br>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）<br>……<br>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<p>符号引用验证</p>
<p>符号引用中通过字符创描述的全限定名是否能找到对应的类<br>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段<br>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问<br>……<br>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p>
<h4 id="6-2-3、准备"><a href="#6-2-3、准备" class="headerlink" title="6.2.3、准备"></a>6.2.3、准备</h4><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p>
<p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p>
<p>基本数据类型的零值</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">零值</th>
<th align="left">数据类型</th>
<th align="left">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">(short) 0</td>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
<td align="left">reference</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">(byte) 0</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p>
<h4 id="6-2-4、解析"><a href="#6-2-4、解析" class="headerlink" title="6.2.4、解析"></a>6.2.4、解析</h4><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。<br>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p>
<h4 id="6-2-5、初始化"><a href="#6-2-5、初始化" class="headerlink" title="6.2.5、初始化"></a>6.2.5、初始化</h4><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p>
<h3 id="6-3、类加载器"><a href="#6-3、类加载器" class="headerlink" title="6.3、类加载器"></a>6.3、类加载器</h3><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p>
<h4 id="6-3-1、双亲委派模型"><a href="#6-3-1、双亲委派模型" class="headerlink" title="6.3.1、双亲委派模型"></a>6.3.1、双亲委派模型</h4><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p>
<p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p>
<p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p>
<p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p>
<p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p>
<h4 id="6-3-2、破坏双亲委派模型"><a href="#6-3-2、破坏双亲委派模型" class="headerlink" title="6.3.2、破坏双亲委派模型"></a>6.3.2、破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>
<h2 id="七、JVM问题"><a href="#七、JVM问题" class="headerlink" title="七、JVM问题"></a>七、JVM问题</h2><h3 id="7-1、什么是JVM？"><a href="#7-1、什么是JVM？" class="headerlink" title="7.1、什么是JVM？"></a>7.1、什么是JVM？</h3><ul>
<li>JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机。</li>
<li>jvm是运行在操作系统之上的，与硬件没有任何关系。</li>
</ul>
<h3 id="7-2、JVM跨平台及原理"><a href="#7-2、JVM跨平台及原理" class="headerlink" title="7.2、JVM跨平台及原理"></a>7.2、JVM跨平台及原理</h3><p><img src="https://img-blog.csdnimg.cn/20201107194951119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行。</li>
<li>原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) </li>
</ul>
<h3 id="7-3、JVM的分类"><a href="#7-3、JVM的分类" class="headerlink" title="7.3、JVM的分类"></a>7.3、JVM的分类</h3><p><img src="https://img-blog.csdnimg.cn/20201107194241173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>类加载子系统。</li>
<li>运行时数据区 [ 我们核心关注这里 的栈、堆、方法区 ]。</li>
<li>执行引擎(一般都是JIT编译器和解释器共存)<ul>
<li>JIT编译器(主要影响性能)：编译执行； 一般热点数据会进行二次编译，将字节码指令变成机器指令。将机器指令放在方法区缓存。</li>
<li>解释器(负责响应时间，他的响应时间很快)：逐行解释字节码。</li>
</ul>
</li>
</ul>
<h3 id="7-4、JVM的位置"><a href="#7-4、JVM的位置" class="headerlink" title="7.4、JVM的位置"></a>7.4、JVM的位置</h3><p><img src="https://img-blog.csdnimg.cn/20201107194535119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>JVM位于操作系统上层，但是位于应用程序下层。</p>
<h3 id="7-5、JVM的体系结构"><a href="#7-5、JVM的体系结构" class="headerlink" title="7.5、JVM的体系结构"></a>7.5、JVM的体系结构</h3><p><img src="https://img-blog.csdnimg.cn/20201107194653461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>入口是编译好的字节码文件（编译器前端）–&gt;经过类加载子系统（将我们的字节码加载到内存当中，生成一个class对象，中间经过三步：加载—&gt;链接—&gt;初始化）</li>
<li>在内存中，多个对象共享内存的是方法区和堆区（多个线程共享区）。</li>
<li>Java虚拟机栈，本地方法栈，程序计数器每一个线程独有一份。</li>
<li>执行引擎：解释器（解释运行），jit及时编译器（编译器后端），垃圾回收器三部分。</li>
</ul>
<h3 id="7-6、Java代码的执行流程"><a href="#7-6、Java代码的执行流程" class="headerlink" title="7.6、Java代码的执行流程"></a>7.6、Java代码的执行流程</h3><p><img src="https://img-blog.csdnimg.cn/20201107195054275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>高级语言翻译为机器指令，主要是由执行引擎完成的。<ul>
<li>解释器（解释运行，把字节码翻译为机器指令，主要负责翻编译器性能）。</li>
<li>jit及时编译器（编译器后端，主要是把热点代码缓存起来，主要负责编译器性能）组成执行引擎。</li>
</ul>
</li>
</ul>
<h3 id="7-7、JVM的架构模型"><a href="#7-7、JVM的架构模型" class="headerlink" title="7.7、JVM的架构模型"></a>7.7、JVM的架构模型</h3><p>​        Java编译器输入的指令流基本上是基于栈的指令集架构，另一种指令集架构是基于寄存器的指令集架构，两种架构之间的区别如下：</p>
<p>基于栈实现的指令集特点如下：</p>
<ul>
<li>设计和实现更加简单，适用于资源受限的系统。</li>
<li>避开了寄存器额分配难题，使用零地址指令分配方式。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器更加容易实现。</li>
<li>不需要硬件支持，可移植性好，更好实现跨平台。</li>
<li>基于栈的指令集：跨平台性，指令集小，指令多执行性能比寄存器差。</li>
</ul>
<p>基于寄存器指令集的特点：</p>
<ul>
<li>典型的应用是x86二进制指令集，比如传统的pc以及android的davlik虚拟机。</li>
<li>指令集架构完全依赖于硬件，可移植性差。</li>
<li>性能优秀和执行更加高效。</li>
<li>花费更少的指令去完成一项任务。</li>
<li>在大部分情况下，<strong>基于寄存器的指令集往往都以一地址指令，二地址指令，三地址指令为主</strong>，而<strong>基于栈结构的指令集则以零地址为主</strong>。</li>
</ul>
<p>小结：</p>
<p>​        由于扩平台式的设计，Java的指令集都是根据栈来设计的，不同的平台cpu架构不同，所以不能设计为基于寄存器的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h3 id="7-8、JVM的生命周期"><a href="#7-8、JVM的生命周期" class="headerlink" title="7.8、JVM的生命周期"></a>7.8、JVM的生命周期</h3><ul>
<li>虚拟机的启动<ul>
<li>Java虚拟机的启动是通过引导类加载器bootstrap class loader创建一个初始类initail calss来完成的，这个类是由虚拟机的具体实现指定的。</li>
</ul>
</li>
<li>虚拟机的执行：<ul>
<li>一个运行着的java虚拟机有着清晰的任务，执行java程序。</li>
<li>程序开始执行虚拟机就运行，程序结束虚拟机就结束运行。</li>
<li>执行一个java程序的时候，真真正正的在执行的是一个java虚拟机进程。</li>
</ul>
</li>
<li>虚拟机的停止：以下几种情况会退出虚拟机：<ul>
<li>程序正常执行结束。</li>
<li>程序在运行过程中遇到错误或者异常而终止执行。</li>
<li>由于操作系统发故障而导致虚拟机进程终止运行。</li>
<li>某一个线程调用了Runtime类或者system类的exit方法，或者调用runtime类的halt方法，并且java安全管理器允许执行安全退出的方法。</li>
</ul>
</li>
</ul>
<h3 id="7-9、三大商业虚拟机"><a href="#7-9、三大商业虚拟机" class="headerlink" title="7.9、三大商业虚拟机"></a>7.9、三大商业虚拟机</h3><ul>
<li>Sun HotSpot<ul>
<li>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。</li>
<li>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码， 并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</li>
<li>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务， 使用HotSpot的JIT编译器与混合的运行时系统。</li>
<li>从服务器，桌面，到移动端，嵌入式都有应用。</li>
</ul>
</li>
<li>BEA JRocket<ul>
<li>专注于服务端应用(JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行)。</li>
<li>Jrockit JVM 是世界上最快的jvm3. 2008年被oracle收购。</li>
<li>专注于服务器端的应用。</li>
<li>它不太关注程序的启动速度，因此JRockit内部不包含解析器的实现，全部代码都靠及时编译器编译之后执行。</li>
</ul>
</li>
<li>iBM J9<ul>
<li>市场定位与hotspot接近，服务器端，桌面应用，嵌入式等。</li>
<li>目前，是影响力最大的三大商业虚拟机之一。</li>
<li>应用于IBM的各种Java产品。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JVM" style=color:#ff7d73>
                JVM
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/JVM/JVM使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/JSP简介/">
        <h2>
            JSP简介
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>浏览器向服务器发送请求，不管访问什么资源，都是在访问servelt</p>
<h2 id="1、JSP原理"><a href="#1、JSP原理" class="headerlink" title="1、JSP原理"></a>1、JSP原理</h2><p>浏览器向服务器发送请求，不管访问什么资源，都是在访问servelt</p>
<pre><code class="java">public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
//--------------------
//--------------------
//初始化
public void _jspInit() 
//销毁
public void _jspDestroy() 
//JSPService
public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
throws java.io.IOException, javax.servlet.ServletException
</code></pre>
<h3 id="1-1-判断请求"><a href="#1-1-判断请求" class="headerlink" title="1.1 判断请求"></a>1.1 判断请求</h3><h3 id="1-2-内置一些对象"><a href="#1-2-内置一些对象" class="headerlink" title="1.2 内置一些对象"></a>1.2 内置一些对象</h3><pre><code class="java"> final javax.servlet.jsp.PageContext pageContext;//页面上下文
 final javax.servlet.ServletContext application;//application
 final javax.servlet.ServletConfig config;//配置
 javax.servlet.jsp.JspWriter out = null;//页面输出流
 final java.lang.Object page = this;//页面本身
 final javax.servlet.http.HttpServletRequest request
 final javax.servlet.http.HttpServletResponse response
</code></pre>
<h3 id="1-3-输出页面前增加的代码"><a href="#1-3-输出页面前增加的代码" class="headerlink" title="1.3 输出页面前增加的代码"></a>1.3 输出页面前增加的代码</h3><pre><code class="java"> response.setContentType(&quot;text/html; charset=UTF-8&quot;);//设置响应页面类型
 pageContext = _jspxFactory.getPageContext(this, request, response,
 null, false, 8192, true);
 _jspx_page_context = pageContext;
 application = pageContext.getServletContext();
 config = pageContext.getServletConfig();
 out = pageContext.getOut();
 _jspx_out = out;
</code></pre>
<h3 id="1-4-以上对象可以在JSP页面中直接使用"><a href="#1-4-以上对象可以在JSP页面中直接使用" class="headerlink" title="1.4 以上对象可以在JSP页面中直接使用"></a>1.4 以上对象可以在JSP页面中直接使用</h3><h3 id="1-5-在JSP中："><a href="#1-5-在JSP中：" class="headerlink" title="1.5 在JSP中："></a>1.5 在JSP中：</h3><ul>
<li>只要是java代码，就会原封不动的输出</li>
<li>HTML代码会被out.write()方法写出</li>
</ul>
<h2 id="2、JSP基础语法"><a href="#2、JSP基础语法" class="headerlink" title="2、JSP基础语法"></a>2、JSP基础语法</h2><h3 id="2-1-jsp表达式"><a href="#2-1-jsp表达式" class="headerlink" title="2.1 jsp表达式"></a>2.1 jsp表达式</h3><pre><code class="jsp">&lt;%-- jsp表达式
    作用：用来将程雪输出，写到客户端
    &lt;%= 变量名/表达式%&gt;
--%&gt;
&lt;%= new java.util.Date()%&gt;
</code></pre>
<h3 id="2-2-jsp脚本片段"><a href="#2-2-jsp脚本片段" class="headerlink" title="2.2 jsp脚本片段"></a>2.2 jsp脚本片段</h3><pre><code class="jsp">&lt;%-- jsp脚本片段 --%&gt;
&lt;%
    int sum=0;
    for (int i = 0; i &lt; 10; i++) &#123;
        sum+=i;
    &#125;
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
%&gt;
</code></pre>
<pre><code class="jsp">&lt;%-- 嵌入正常的标签 --%&gt;
&lt;%
    int x=10;
    out.print(x);
%&gt;
&lt;p&gt;这是一个jsp文档&lt;/p&gt;
&lt;%
    int y=20;
    out.print(20);
%&gt;
</code></pre>
<pre><code class="jsp">&lt;%-- 在代码中嵌入html元素 --%&gt;
&lt;%
    for (int i = 0; i &lt; 5; i++) &#123;
%&gt;
&lt;h1&gt;HelloWorld,&lt;%= new java.util.Date()%&gt;&lt;/h1&gt;
&lt;%
    &#125;
%&gt;
</code></pre>
<h3 id="2-3-脚本片段的再实现"><a href="#2-3-脚本片段的再实现" class="headerlink" title="2.3 脚本片段的再实现"></a>2.3 脚本片段的再实现</h3><pre><code class="jsp">&lt;%-- 在代码中嵌入html元素 --%&gt;
&lt;%
    for (int i = 0; i &lt; 5; i++) &#123;
%&gt;
&lt;h1&gt;HelloWorld,&lt;%= new java.util.Date()%&gt;&lt;/h1&gt;
&lt;%
    &#125;
%&gt;
</code></pre>
<h3 id="2-4-jsp声明"><a href="#2-4-jsp声明" class="headerlink" title="2.4 jsp声明"></a>2.4 jsp声明</h3><pre><code class="jsp">&lt;%!
static &#123;
    System.out.println(&quot;Loading Servlet...&quot;);
&#125;
private int globalVar=0;
public void jspInit()&#123;
    System.out.println(&quot;进入了初始化方法&quot;);
&#125;
%&gt;
</code></pre>
<h2 id="3、JSP指令"><a href="#3、JSP指令" class="headerlink" title="3、JSP指令"></a>3、JSP指令</h2><h3 id="3-1-定制错误页面"><a href="#3-1-定制错误页面" class="headerlink" title="3.1 定制错误页面"></a>3.1 定制错误页面</h3><p>使用jsp指令：</p>
<pre><code class="xml">&lt;%--定制错误页面--%&gt;
&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;
</code></pre>
<p>另一种办法：在<strong>web.xml</strong>文件中配置：</p>
<pre><code class="xml">&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/error/404.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/error/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
<pre><code class="xml">&lt;!--
@include：会将两个页面合二为一
--&gt;
&lt;%@include file=&quot;common/header.jsp&quot;%&gt;
&lt;hr&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;
&lt;hr&gt;
&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;
</code></pre>
<pre><code class="xml">&lt;!--
jsp:include：拼接页面，本质还是三个页面
--&gt;
&lt;jsp:include page=&quot;/common/header.jsp&quot; /&gt;
&lt;hr&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;
&lt;hr&gt;
&lt;jsp:include page=&quot;/common/footer.jsp&quot; /&gt;
</code></pre>
<h3 id="3-2-9大内置对象"><a href="#3-2-9大内置对象" class="headerlink" title="3.2  9大内置对象"></a>3.2  9大内置对象</h3><ul>
<li>PageContext 存东西</li>
<li>Request 存东西</li>
<li>Response</li>
<li>Session 存东西</li>
<li>Application【ServletContext】 存东西</li>
<li>Config【ServletConfig】</li>
<li>Out</li>
<li>Page</li>
<li>Exception</li>
</ul>
<pre><code class="jsp">&lt;%
    pageContext.setAttribute(&quot;name1&quot;,&quot;oi1号&quot;);//保存的数据只在一个页面中有效
    request.setAttribute(&quot;name2&quot;,&quot;oi2号&quot;);//保存的数据只在一次请求中有效，请求转发会携带这个数据
    session.setAttribute(&quot;name3&quot;,&quot;oi3号&quot;);//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
    application.setAttribute(&quot;name4&quot;,&quot;oi4号&quot;);//保存的数据只在服务器中有效，从打开服务器到关闭服务器
%&gt;
</code></pre>
<p>​        <strong>request：</strong>客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</p>
<p>​        <strong>session：</strong>客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p>
<p>​        <strong>application：</strong>客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p>
<h3 id="3-3-JSP标签、JSTL标签、EL表达式"><a href="#3-3-JSP标签、JSTL标签、EL表达式" class="headerlink" title="3.3 JSP标签、JSTL标签、EL表达式"></a>3.3 JSP标签、JSTL标签、EL表达式</h3><pre><code class="xml">&lt;!-- JSTL表达式的依赖 --&gt;
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
  &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
  &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--standard标签库--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;taglibs&lt;/groupId&gt;
  &lt;artifactId&gt;standard&lt;/artifactId&gt;
  &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>1、EL表达式：${ }</strong></p>
<ul>
<li>获取数据</li>
<li>执行运算</li>
<li>获取web开发的常用对象</li>
<li><del>调用java方法</del></li>
</ul>
<p><strong>2、JSP标签</strong></p>
<pre><code class="jsp">&lt;%--jsp:include--%&gt;
&lt;jsp:forward page=&quot;jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;oi&quot;/&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;2+&quot;/&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>3、JSTL表达式</strong></p>
<p>​        JSTL标签库的使用是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和java代码一样！</p>
<p><strong><u>核心标签</u></strong></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/05/27/kuangstudy90787b3b-ffc8-42a8-aa02-71337b27e328.png" alt="img"></p>
<p><strong>4、JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的taglib</li>
<li>使用其中的方法</li>
</ul>
<p><strong>&lt;c: out&gt;</strong></p>
<pre><code class="xml">&lt;!-- 
    1、value 要输出的信息
    2、 default 默认情况下输出什么
    3、 escapeXml 是否以xml格式输出注：默认为true，即像”&lt;”，”&gt;”这样的符号会原样输出
--&gt;
&lt;c:out value=&quot;&lt;string&gt;&quot; default=&quot;&lt;string&gt;&quot; escapeXml=&quot;&lt;true|false&gt;&quot;/&gt;
</code></pre>
<p><strong>&lt;c：if&gt;</strong></p>
<pre><code class="xml">&lt;%--引入JSTL核心标签库--%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h4&gt;if测试&lt;/h4&gt;
&lt;hr&gt;
&lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
    EL表达式获取表单中的数据
    $&#123;param.参数名&#125;
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;
        
&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;
&lt;%--进行条件判断:
            test属性为逻辑表达式，
            var属性为逻辑表达式返回值的变量名，
            scope属性设置作用域,默认为page
--%%&gt;
&lt;c:if test=&quot;$&#123;param.username==&#39;admin&#39;&#125;&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎你！&quot;/&gt;
&lt;/c:if&gt;
&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>&lt;c：choose&gt;</strong></p>
<pre><code class="xml">&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;85&quot; /&gt;
&lt;c:choose&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=60&#125;&quot;&gt;
        你的成绩为及格
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&lt;60&#125;&quot;&gt;
        你的成绩为不及格
    &lt;/c:when&gt;
&lt;/c:choose&gt;
</code></pre>
<p><strong>&lt;c：forEach&gt;</strong></p>
<pre><code class="xml">&lt;%
    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();
    people.add(0, &quot;张三&quot;);
    people.add(1, &quot;李四&quot;);
    people.add(2, &quot;王五&quot;);
    people.add(3, &quot;赵六&quot;);
    people.add(4, &quot;丁一&quot;);
    people.add(5, &quot;胡二&quot;);
    request.setAttribute(&quot;list&quot;, people);
%&gt;
&lt;!--
    var,每一次遍历出来的变量
    items，要遍历的对象
    begin, 开始位置
    end,   结束位置
    step, 步长
--&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot;&gt;
    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt;
    &lt;br&gt;
&lt;/c:forEach&gt;
&lt;hr&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt;
    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt;
    &lt;br&gt;
&lt;/c:forEach&gt;
</code></pre>
<p>1、<strong>全部遍历</strong></p>
<pre><code class="xml">&lt;c:forEach var=&quot;存储当前遍历元素的变量&quot; items=&quot;待遍历集合&quot;&gt;
&lt;/c:forEach&gt;
&lt;% List&lt;String&gt; fruits = new ArrayList&lt;String&gt;();
        fruits.add(&quot;apple&quot;);
        fruits.add(&quot;orange&quot;);
        fruits.add(&quot;pear&quot;);
        fruits.add(&quot;watermelon&quot;);
        fruits.add(&quot;banana&quot;);
        request.setAttribute(&quot;fruits&quot;, fruits);
    %&gt;
    &lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot;&gt;
        &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
    &lt;/c:forEach&gt;
</code></pre>
<p>2、 <strong>部分遍历</strong></p>
<pre><code class="xml">&lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot; begin=&quot;2&quot; end=&quot;4&quot;&gt;
        &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
    &lt;/c:forEach&gt;
    &lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot; varStatus=&quot;fru&quot;&gt;
        &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
        &lt;c:out value=&quot;index属性值：$&#123;fru.index &#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
        &lt;c:out value=&quot;first属性值：$&#123;fru.first &#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
    &lt;/c:forEach&gt;
</code></pre>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/28/kuangstudy6fd0ebae-91bf-4577-9455-4de0c57e099d.png" alt="img"></p>
<p><strong>&lt;c: url&gt;</strong></p>
<pre><code class="xml">&lt;!--
    value属性用于构造构造的URL
    context属性用于指定导入同一个服务器的下其他web应用的名称
    var属性用于指定将构造的URL地址保存到域对象的属性名称
    scope属性用于指定将URL保存到的域对象
--&gt;
&lt;a href=&quot;
 &lt;c:url value=&quot;./testParamImported.jsp&quot;&gt;
 &lt;c:param name=&quot;username&quot; value=&quot;yangmu&quot;&gt;&lt;/c:param&gt;
 &lt;c:param name=&quot;password&quot; value=&quot;hello&quot;&gt;&lt;/c:param&gt;
 &lt;/c:url&gt;
  &quot;&gt;跳转页面&lt;/a&gt;
</code></pre>
<p><strong>&lt;c: param&gt;</strong></p>
<pre><code class="xml">&lt;!--用于在URL地址中附加参数，一般在&lt;c:url&gt;标签中嵌套使用。
name属性表示参数名，
value属性表示参数值
--&gt;

&lt;c:param name=&quot;name&quot; value=&quot;lwk&quot;&gt;

&lt;c:param name=&quot;name&quot;&gt;
    lwk
&lt;/c:param&gt;
</code></pre>
<p><strong>&lt;c: set&gt;</strong></p>
<pre><code class="xml">&lt;!--存值，存值到scope中--&gt;
&lt;c:set value=&quot;today&quot; var=&quot;day&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt;
&lt;c:set var=&quot;age&quot; scope=&quot;application&quot;&gt;12&lt;/c:set&gt;
</code></pre>
<p><strong>&lt;fn: contains()&gt;</strong></p>
<pre><code class="xml">&lt;!--fn:contains() 函数判断一个输入字符串是否包含一个指定的子串。--&gt;
&lt;c:if test=&quot;$&#123;fn:contains(theString, &#39;test&#39;)&#125;&quot;&gt;
</code></pre>
<p><strong>jsp与javaBean</strong></p>
<pre><code class="xml">&lt;jsp:useBean&gt;：创建JavaBean对象；
&lt;jsp:setProperty&gt;：设置JavaBean属性；
&lt;jsp:getProperty&gt;：获取JavaBean属性；
</code></pre>
<p>base64加密解密</p>
<pre><code class="java">   public static void base64(String str) &#123;
    byte[] bytes = str.getBytes();
   //Base64 加密
    String encoded = Base64.getEncoder().encodeToString(bytes);
    System.out.println(&quot;Base 64 加密后：&quot; + encoded);
    //Base64 解密
    byte[] decoded = Base64.getDecoder().decode(encoded);
    String decodeStr = new String(decoded);
    System.out.println(&quot;Base 64 解密后：&quot; + decodeStr);
    System.out.println();
</code></pre>
<h3 id="3-4-其他指令"><a href="#3-4-其他指令" class="headerlink" title="3.4 其他指令"></a>3.4 其他指令</h3><pre><code class="xml">&lt;!-- 配置错误页面 --&gt;
&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/error/404.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/error/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
<p><strong>page：</strong></p>
<p>language表明jsp页面中可以写java代码</p>
<p>contentType:其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</p>
<p>pageEncoding :jsp内容编码</p>
<pre><code class="xml">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;% session=&quot;true&quot; errorPage=&quot;error.jsp&quot;&gt;
    
在errorPage里的
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;% isErrorPage=&quot;true&quot;&gt;
</code></pre>
<pre><code class="xml">
&lt;!-- 导入jar包 --&gt;
&lt;%@ page import=&quot;java.util.Date&quot; %&gt;
&lt;!-- 指定错误页面 --&gt;
&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;
&lt;!-- 显示的声明这是一个错误页面 --&gt;
&lt;%@ page isErrorPage=&quot;true&quot; %&gt;
&lt;!-- 页面编码格式 --&gt;
&lt;%@ page pageEncoding=&quot;utf-8&quot; %&gt;
</code></pre>
<p><strong>include:</strong></p>
<p>​        作用包含另一个jsp的页面过来（把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来（包含<html></html>）。）</p>
<pre><code class="xml">&lt;%-- @include会将页面整合在一起 --%&gt;
&lt;!-- 定义的变量会相互影响 --&gt;
    &lt;%@ include file=&quot;common/header.jsp&quot;%&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;%@ include file=&quot;common/footer.jsp&quot;%&gt;
&lt;hr&gt;
&lt;%--  jsp标签jsp:include 是将页面拼接在一起，本质还是分开的页面  --%&gt;
&lt;!-- 定义的变量互不影响 --&gt;
    &lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;
</code></pre>
<p><strong>taglib:</strong></p>
<p>定义一个标签库以及其自定义标签的前缀.。</p>
<pre><code class="xml">&lt;%@ taglib prefix=&quot;&quot;  uri=&quot;&quot;%&gt;  
uri: 标签库路径
    prefix : 标签库的别名
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JavaWeb" style=color:#ff7d73>
                JavaWeb
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/JSP简介/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/JavaWeb/">
        <h2>
            JavaWeb
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="一、Tomcat"><a href="#一、Tomcat" class="headerlink" title="一、Tomcat"></a>一、Tomcat</h2><blockquote>
<p>tomcat官网：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
</blockquote>
<h3 id="1-1、tomcat启动"><a href="#1-1、tomcat启动" class="headerlink" title="1.1、tomcat启动"></a>1.1、tomcat启动</h3><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225113582.png" alt="image-20210317225113582"></p>
<p>启动、关闭tomcat</p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225203904.png" alt="image-20210317225203904"></p>
<p>可能遇到的问题：</p>
<p>​            1、Java环境变量没有配置</p>
<p>​            2、乱码问题：配置文件中设置</p>
<h3 id="1-2、tomcat配置"><a href="#1-2、tomcat配置" class="headerlink" title="1.2、tomcat配置"></a>1.2、tomcat配置</h3><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225435335.png" alt="image-20210317225435335"></p>
<p>可以配置启动的<strong>端口号</strong></p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<pre><code class="xml">&lt;Connectorport=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre>
<p>可以配置<strong>主机名称</strong></p>
<ul>
<li>默认主机名为: localhost —&gt;127.0.0.1<ul>
<li>默认网站:存放的位置为: webapps</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;Hostname=&quot;www.baidu.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<p><strong>网站是如何访问的？</strong></p>
<ul>
<li>输入一个域名: 回车</li>
<li></li>
</ul>
<p>这种需要在本机配置域名映射</p>
<p>C:\Windows\System32\drivers\etc下的hosts文件</p>
<p>127.0.0.1 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
<h3 id="1-3、搭建一个web网站"><a href="#1-3、搭建一个web网站" class="headerlink" title="1.3、搭建一个web网站"></a>1.3、搭建一个web网站</h3><p>将自己的war包项目放到tomcat中webapps目录下，然后启动tomcat即可</p>
<p>网站应该有的结构</p>
<pre><code class="xml">--webapps ：Tomcat服务器的web目录
-ROOT-myblog ：网站的目录名
- WEB-INF-classes : java程序
-lib：web应用所依赖的jar包
-web.xml ：网站配置文件
- index.html 默认的首页
-static-css-style.css-js-img-.....
</code></pre>
<h3 id="1-4、启动多个不同端口的Tomcat"><a href="#1-4、启动多个不同端口的Tomcat" class="headerlink" title="1.4、启动多个不同端口的Tomcat"></a>1.4、启动多个不同端口的Tomcat</h3><p>​        一个服务器可能需要启动多个项目，为了方便，不同项目访问只需要通过不同的端口号区分。</p>
<p>​        修改端口只需修改三处即可，以<strong>tomcat8</strong>为例</p>
<p>1、<strong>shutdown端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113724868.png" alt="image-20210318113724868"></p>
<p>2、<strong>HTTP端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113738086.png" alt="image-20210318113738086"></p>
<p>3、<strong>AJP端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113750347.png" alt="image-20210318113750347"></p>
<p>tomcat9版本不需要第三步了</p>
<p>注意：有时更新项目后不能得到及时刷新，这是可以清除缓存，进入tomcat目录下删除work文件夹里面的文件。</p>
<h2 id="二、HTTP"><a href="#二、HTTP" class="headerlink" title="二、HTTP"></a>二、HTTP</h2><h3 id="2-1、HTTP简介"><a href="#2-1、HTTP简介" class="headerlink" title="2.1、HTTP简介"></a>2.1、HTTP简介</h3><p>​        HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<h3 id="2-2、两个时代"><a href="#2-2、两个时代" class="headerlink" title="2.2、两个时代"></a>2.2、两个时代</h3><ul>
<li>http1.0<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接（<strong>短连接</strong>）。</li>
</ul>
</li>
<li>http2.0<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源（<strong>长连接</strong>）</li>
</ul>
</li>
</ul>
<h3 id="2-3、HTTP请求"><a href="#2-3、HTTP请求" class="headerlink" title="2.3、HTTP请求"></a>2.3、HTTP请求</h3><blockquote>
<p><strong>客户端—-&gt;发请求(request)—-&gt;服务端</strong></p>
</blockquote>
<p>​        访问百度：</p>
<pre><code class="xml">Request URL: https://www.baidu.com/  请求地址
Request Method: GET    //请求方式get/post
Status Code:200 OK    //状态码
Remote(远程) Address:14.215.177.38:443//远程ip地址
</code></pre>
<blockquote>
<p><strong>请求行</strong></p>
</blockquote>
<ul>
<li>请求行中的请求方式:GET</li>
<li>请求方式：GeT , POST , HEAD , Delete , PUT , Tract<ul>
<li>get 能够携带的参数比较少, 大小有限制 , 会在浏览器URL地址栏显示数据内容 ,不安全,但是高效</li>
<li>post 能够携带的参数无限制, 大小无限制 , 不会在浏览器URL地址栏显示数据内容 ,安全,但是不太高效</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>请求（消息）头</strong></p>
</blockquote>
<pre><code class="xml">Accept:text/html  //支持的数据类型
Accept-Encoding:gzip, deflate, br  //支持的编码格式
Accept-Language:zh-CN,zh;q=0.9//语言
Cache-Control:max-age=0//缓存控制
Connection:keep-alive  //是否长连接
</code></pre>
<h3 id="2-4、HTTP响应"><a href="#2-4、HTTP响应" class="headerlink" title="2.4、HTTP响应"></a>2.4、HTTP响应</h3><blockquote>
<p><strong>服务端—-&gt;响应—-&gt;客户端</strong></p>
</blockquote>
<pre><code class="properties">Cache-Control:private        缓存控制
Connection:Keep-Alive        连接
Content-Encoding:gzip        编码
Content-Type:text/html       类型
</code></pre>
<h4 id="2-4-1、响应体"><a href="#2-4-1、响应体" class="headerlink" title="2.4.1、响应体"></a>2.4.1、响应体</h4><pre><code class="xmsl">Accept：                告诉浏览器，它所支持的数据类型
Accept-Encoding：    支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：    告诉浏览器，它的语言环境Cache-Control：缓存控制
Connection：            告诉浏览器，请求完成是断开还是保持连接
HOST：                主机....
Refresh：            告诉客户端，多久刷新一次；Location：让网页重新定位；
Location:             让网页重新定位
</code></pre>
<h4 id="2-4-2、响应状态码"><a href="#2-4-2、响应状态码" class="headerlink" title="2.4.2、响应状态码"></a>2.4.2、响应状态码</h4><p><img src="https://img-blog.csdnimg.cn/20191102141905774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI0NTU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191102141918916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI0NTU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-5、Maven"><a href="#2-5、Maven" class="headerlink" title="2.5、Maven"></a>2.5、Maven</h3><h3 id="2-5-1-Maven项目架构管理工具"><a href="#2-5-1-Maven项目架构管理工具" class="headerlink" title="2.5.1 Maven项目架构管理工具"></a>2.5.1 Maven项目架构管理工具</h3><p>​        作用：导jar包</p>
<p>​        Maven 的核心思想：<strong>约定大于配置</strong></p>
<p>​                有约束不要去违反</p>
<p>​        Maven会规定好如何来写java代码，必须按照这个规定来。</p>
<h3 id="2-5-2下载安装Maven"><a href="#2-5-2下载安装Maven" class="headerlink" title="2.5.2下载安装Maven"></a>2.5.2下载安装Maven</h3><p>​        下载后解压就能用,和TOMCAT 一样</p>
<h3 id="2-5-3-配置环境变量"><a href="#2-5-3-配置环境变量" class="headerlink" title="2.5.3 配置环境变量"></a>2.5.3 配置环境变量</h3><p>​        在系统环境变量中</p>
<p>​        配置如下:</p>
<p>​                    M2_HOME maven下的bin目录</p>
<p>​                    MAVEN_HOME maven目录</p>
<p>​                    系统中path中配置 %MAVEN_HOME%\bin</p>
<h3 id="2-5-4-阿里云镜像"><a href="#2-5-4-阿里云镜像" class="headerlink" title="2.5.4 阿里云镜像"></a>2.5.4 阿里云镜像</h3><ul>
<li>镜像: mirrors<ul>
<li>作用: 加速下载</li>
<li>国内建议使用阿里镜像</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;
    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;
    &lt;name&gt;Nexus aliyun&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
&lt;/mirror&gt;
</code></pre>
<h3 id="2-5-5-本地仓库"><a href="#2-5-5-本地仓库" class="headerlink" title="2.5.5 本地仓库"></a>2.5.5 本地仓库</h3><p>​        在本地的仓库，远程仓库;</p>
<p>​        建立一个本地仓库：<strong>localRepository</strong></p>
<h3 id="2-5-6-在IDEA中使用MAVEN"><a href="#2-5-6-在IDEA中使用MAVEN" class="headerlink" title="2.5.6 在IDEA中使用MAVEN"></a>2.5.6 在IDEA中使用MAVEN</h3><ol>
<li><p>启动IDEA</p>
</li>
<li><p>创建一个Maven项目</p>
</li>
<li><p>sav</p>
</li>
<li><p>等待自动导包,出现build success表示成功!!!</p>
</li>
<li><p>IDEA 中Maven的设置</p>
<p><strong>注意：</strong>IDEA项目创建成功后看一眼Maven的配置</p>
</li>
<li><p>到这里Maven在IDEA中的使用就配置完成了</p>
</li>
</ol>
<h3 id="2-5-7创建一个普通的Maven项目"><a href="#2-5-7创建一个普通的Maven项目" class="headerlink" title="2.5.7创建一个普通的Maven项目"></a>2.5.7创建一个普通的Maven项目</h3><p>将文件标记为指定文件1类型</p>
<pre><code class="html">&lt;img src=&quot;C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210508222659273.png&quot; alt=&quot;image-20210508222659273&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;img src=&quot;C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210508223015644.png&quot; alt=&quot;image-20210508223015644&quot; style=&quot;zoom:67%;&quot; /&gt;
</code></pre>
<h3 id="2-5-8-IDEA配置TOMECAT"><a href="#2-5-8-IDEA配置TOMECAT" class="headerlink" title="2.5.8 IDEA配置TOMECAT"></a>2.5.8 IDEA配置TOMECAT</h3><h3 id="2-5-9-pom文件"><a href="#2-5-9-pom文件" class="headerlink" title="2.5.9 pom文件"></a>2.5.9 pom文件</h3><p>pom.xml是Maven的核心配置文件</p>
<pre><code class="xml">&lt;!--  在build中配置resources , 来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;
                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;
            &lt;/excludes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h2 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h2><h3 id="3-1、Servlet简介"><a href="#3-1、Servlet简介" class="headerlink" title="3.1、Servlet简介"></a>3.1、Servlet简介</h3><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="3-2、HelloServlet"><a href="#3-2、HelloServlet" class="headerlink" title="3.2、HelloServlet"></a>3.2、HelloServlet</h3><ol>
<li><p>构建一个普通的Maven项目, 删掉 src,以后我们的学习,就在项目中建立Moudle</p>
</li>
<li><p>关于Maven父子工程的理解</p>
</li>
</ol>
<p>  <strong>父项目中会有:</strong></p>
<pre><code class="xml">&lt;modules&gt;
    &lt;module&gt;servlet-01&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
<p>​        <strong>子项目中会有:</strong></p>
<pre><code class="xml">&lt;parent&gt;
    &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
    &lt;groupId&gt;com.zhu&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<p>​        父项目中的java子项目可以直接使用</p>
<pre><code class="xml">son extend father
</code></pre>
<p>​        <strong>Maven 环境优化</strong></p>
<pre><code class="xml"> 1. 修改web.xml为最新
 2. 将maven的结构搭建完整
</code></pre>
<h4 id="3-2-1、编写一个servlet-程序"><a href="#3-2-1、编写一个servlet-程序" class="headerlink" title="3.2.1、编写一个servlet 程序"></a>3.2.1、编写一个servlet 程序</h4><ol>
<li>实现Servlet 接口 直接继承 HttpServlet</li>
<li>编写Serviet 的映射<ol>
<li>为什么写映射: 我们写的是JAVA程序,但是要通过浏览器访问,浏览器需要连接web浏览器, 所以我们需要在web服务中注册我们写的Servlet 还需要给他一个浏览器能够访问的路径</li>
</ol>
</li>
</ol>
<ul>
<li>导入依赖</li>
</ul>
<pre><code class="xml">&lt;!--添加Servlet和JSP依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>编写servlet类继承HttpServlet</li>
</ul>
<pre><code class="java">public class HellowServlet extends HttpServlet &#123;
    //由于gat或者post只是请求实现的不同方法,可以互相调用,业务逻辑一样
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter();///响应流
        writer.println(&quot;HellowServlet&quot;);
    &#125;
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 直接调用doGet，逻辑相似
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-2-2、配置映射"><a href="#3-2-2、配置映射" class="headerlink" title="3.2.2、配置映射"></a>3.2.2、配置映射</h4><p>一、xml方式</p>
<pre><code class="xml">&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;hellow&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.javaweb.servlet.HellowServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!--  servlet请求路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hellow&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hellow&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>二、注解方式</p>
<pre><code class="java">@WebServlet(&quot;/hi&quot;)
public class HelloServletextendsHttpServlet&#123;
    ...
&#125;
</code></pre>
<ul>
<li><p>配置tomcat</p>
<p>注意配置项目发布的路径</p>
</li>
<li><p>启动项目，访问路径</p>
</li>
</ul>
<h3 id="3-3、Servlet原理"><a href="#3-3、Servlet原理" class="headerlink" title="3.3、Servlet原理"></a>3.3、Servlet原理</h3><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318220210550.png" alt="image-20210318220210550"></p>
<h3 id="3-4、Mapping问题"><a href="#3-4、Mapping问题" class="headerlink" title="3.4、Mapping问题"></a>3.4、Mapping问题</h3><p>1、一个Servlet可以指定一个映射路径</p>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>2、一个Servlet可以指定多个映射路径</p>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>3、一个Servlet可以指定<strong>通用</strong>映射路径</p>
<ul>
<li>/hello/* ——&gt; /hellow后边不管写啥都返回当前带哦用的servlet-name 的方法</li>
<li>/* 默认通配符</li>
</ul>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>4、默认请求路径</p>
<pre><code class="xml">&lt;!--默认请求路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>5、指定一些后缀或者前缀等等….</p>
<pre><code class="xml">&lt;!--
    可以自定义后缀实现请求映射    
    注意点：*前面不能加项目映射的路径hello/sajdlkajda.qinjiang，只要以 .qinjiang  就能访问
 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.qinjiang&lt;/url-pattern&gt;
&lt;/servlet-mapping
</code></pre>
<p>6、优先级问题<br>        指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求（404）；</p>
<pre><code class="xml">&lt;!--404--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h3 id="3-5、ServletContext"><a href="#3-5、ServletContext" class="headerlink" title="3.5、ServletContext"></a>3.5、ServletContext</h3><p>​        web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用</p>
<h4 id="3-5-1、共享数据"><a href="#3-5-1、共享数据" class="headerlink" title="3.5.1、共享数据"></a>3.5.1、共享数据</h4><pre><code class="java">public class Serlvet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //this.getServletConfig()  //servlrt 配置
        //this.getInitParameter()   //初始化参数
        //this.getServletContext();   //servlet上下文
        ServletContext contxt = this.getServletContext();
        String username = &quot;JOBB&quot;; //数据
        contxt.setAttribute(&quot;username&quot;,username);//将一个数据保存在了ServletContext中,  名字为: username 值: username
        System.out.println(&quot;欢迎&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ReadSerlvet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //数据
        ServletContext context = this.getServletContext();
        String username = (String)context.getAttribute(&quot;username&quot;);
        //响应
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.getWriter().println(&quot;姓名: &quot;+username);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;setnum&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.zhu.servlet.Serlvet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;setnum&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
    &lt;servlet-name&gt;get&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.zhu.servlet.ReadSerlvet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;get&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/get&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>必须先访问hello接口，然后访问get接口，才能获取name的值。</p>
<h4 id="3-5-2、获取初始化参数"><a href="#3-5-2、获取初始化参数" class="headerlink" title="3.5.2、获取初始化参数"></a>3.5.2、获取初始化参数</h4><p>web.xml中配置</p>
<pre><code class="xml">&lt;!--Web的初始化配置--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>java中</p>
<pre><code class="java">public class ServletContext extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        javax.servlet.ServletContext context = this.getServletContext();
        String url = context.getInitParameter(&quot;url&quot;);
        resp.getWriter().println(url);
    &#125;
    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-5-3、请求转发"><a href="#3-5-3、请求转发" class="headerlink" title="3.5.3、请求转发"></a>3.5.3、请求转发</h4><pre><code class="java">public class ServletrequestDispatcher extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;进入了ServletrequestDispatcher&quot;);
        ServletContext context = this.getServletContext();
        
        //RequestDispatcher url = context.getRequestDispatcher(&quot;url&quot;);//转发路径 格式: /url  /路径
        //url.forward(req,resp);//调用forward 转发
        context.getRequestDispatcher(&quot;/url&quot;).forward(req,resp);//合写
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-5-4、读取资源文件"><a href="#3-5-4、读取资源文件" class="headerlink" title="3.5.4、读取资源文件"></a>3.5.4、读取资源文件</h4><p>编写b.properties文件</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现: 都被打包到了同一路径下: classes,俗称为类路径</p>
<p>思路: 需要一个<strong>文件流</strong>；</p>
<pre><code class="properties">username = Mack
id = 00001
passworld = 123456789
</code></pre>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320004726070.png" alt="image-20210320004726070"></p>
<pre><code class="java">public class ServletReadPropise extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        InputStream is = context.getResourceAsStream(&quot;/WEB-INF/classes/db.propise&quot;);
        Properties prop = new Properties();
        prop.load(is);
        String username = prop.getProperty(&quot;username&quot;);
        String id = prop.getProperty(&quot;id&quot;);
        String passworld = prop.getProperty(&quot;passworld&quot;);
        resp.getWriter().println(username+&quot;, &quot;+passworld+&quot;, &quot;+id);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp); 
    &#125;
&#125;
</code></pre>
<h3 id="3-6、HttpServletResponse"><a href="#3-6、HttpServletResponse" class="headerlink" title="3.6、HttpServletResponse"></a>3.6、HttpServletResponse</h3><p>​        web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；</p>
<ul>
<li>如果要获取客户端请求过来的参数：<ul>
<li>HttpServlet<strong>Request</strong></li>
</ul>
</li>
<li>如果要给客户端响应一些信息：<ul>
<li>HttpServlet<strong>Response</strong></li>
</ul>
</li>
</ul>
<h4 id="3-6-1、简单分类"><a href="#3-6-1、简单分类" class="headerlink" title="3.6.1、简单分类"></a>3.6.1、简单分类</h4><p>​        负责向浏览器发送数据的方法</p>
<pre><code class="java">ServletOutputStream getOutputStream() throws IOException;//y
PrintWriter getWriter() throws IOException;//一般中文用
</code></pre>
<p><strong>负责向浏览器发送响应头的方法：</strong></p>
<pre><code class="java">void setCharacterEncoding(String var1);
void setContentLength(int var1);
void setContentLengthLong(long var1);
void setContentType(String var1);
void setDateHeader(String var1,long var2);
void addDateHeader(String var1,long var2);
void setHeader(String var1,String var2);
void addHeader(String var1,String var2);
void setIntHeader(String var1,int var2);
void addIntHeader(String var1,int var2);
</code></pre>
<p><strong>响应的状态码：</strong></p>
<pre><code class="java">/*200：请求响应成功 200
3xx：请求重定向
- 重定向：你重新到我给你新位置去；
4xx：找不到资源 404
- 资源不存在；
5xx：服务器代码错误 500 502:网关错误
*/
int SC_CONTINUE =100;
int SC_SWITCHING_PROTOCOLS =101;
int SC_OK =200;
int SC_CREATED =201;
int SC_ACCEPTED =202;
int SC_NON_AUTHORITATIVE_INFORMATION =203;
int SC_NO_CONTENT =204;
int SC_RESET_CONTENT =205;
int SC_PARTIAL_CONTENT =206;
int SC_MULTIPLE_CHOICES =300;
int SC_MOVED_PERMANENTLY =301;
int SC_MOVED_TEMPORARILY =302;
int SC_FOUND =302;
int SC_SEE_OTHER =303;
int SC_NOT_MODIFIED =304;
int SC_USE_PROXY =305;
int SC_TEMPORARY_REDIRECT =307;
int SC_BAD_REQUEST =400;
int SC_UNAUTHORIZED =401;
int SC_PAYMENT_REQUIRED =402;
int SC_FORBIDDEN =403;
int SC_NOT_FOUND =404;
int SC_METHOD_NOT_ALLOWED =405;
int SC_NOT_ACCEPTABLE =406;
int SC_PROXY_AUTHENTICATION_REQUIRED =407;
int SC_REQUEST_TIMEOUT =408;
int SC_CONFLICT =409;
int SC_GONE =410;
int SC_LENGTH_REQUIRED =411;
int SC_PRECONDITION_FAILED =412;
int SC_REQUEST_ENTITY_TOO_LARGE =413;
int SC_REQUEST_URI_TOO_LONG =414;
int SC_UNSUPPORTED_MEDIA_TYPE =415;
int SC_REQUESTED_RANGE_NOT_SATISFIABLE =416;
int SC_EXPECTATION_FAILED =417;
int SC_INTERNAL_SERVER_ERROR =500;
int SC_NOT_IMPLEMENTED =501;
int SC_BAD_GATEWAY =502;
int SC_SERVICE_UNAVAILABLE =503;
int SC_GATEWAY_TIMEOUT =504;
int SC_HTTP_VERSION_NOT_SUPPORTED =505;
</code></pre>
<h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><h4 id="3-6-2、下载文件"><a href="#3-6-2、下载文件" class="headerlink" title="3.6.2、下载文件"></a>3.6.2、下载文件</h4><ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class Servlet_04_FileDown extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 1. 要获取下载文件的路径
        String realPath = &quot;D:\\IDEA_project\\JavaWeb\\response\\target\\classes\\60599be88322e6675c2d7c68.jpg&quot;;
        System.out.println(&quot;下载的文件的路径: &quot;+realPath);
        // 2. 下载的文件名是啥？
        String filename = realPath.substring(realPath.indexOf(&quot;\\&quot;) + 1);
        // 3. 设置想办法让浏览器能够支持下载我们需要的东西
        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename= &quot;+ filename);
        // 4. 获取下载文件的输入流
        FileInputStream in = new FileInputStream(realPath);
        // 5. 创建缓冲区
        int length = 0;
         byte[]buffer = new byte[1024];
        // 6. 获取OutputStream对象
        ServletOutputStream out= resp.getOutputStream();
        // 7. 将FileOutputStream流写入到buffer缓冲区
        // 8. 使用OutputStream将缓冲区中的数据输出到客户端！
        while ((length=in.read(buffer))&gt;0)&#123;
            out.write(buffer,0,length);
        &#125;
        // 9.关闭流
        in.close();
        out.close();
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        super.doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-6-3、验证码功能"><a href="#3-6-3、验证码功能" class="headerlink" title="3.6.3、验证码功能"></a>3.6.3、验证码功能</h4><ul>
<li>前端实现</li>
<li>后端实现，需要用到Java的图片类，生产一个图片</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/img&quot;)
public class ImageServletextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        //如何让浏览器3秒自动刷新一次;        
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image =newBufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g =(Graphics2D) image.getGraphics();
        
        //笔
        //设置图片的背景颜色        
        g.setColor(Color.white);        
        g.fillRect(0,0,80,20);
        
        //给图片写数据        
        g.setColor(Color.BLUE);        
        g.setFont(newFont(null,Font.BOLD,20));        
        g.drawString(makeNum(),0,20);
        
        //告诉浏览器，这个请求用图片的方式打开        
        resp.setContentType(&quot;image/jpeg&quot;);
        
        //网站存在缓存，不让浏览器缓存        
        resp.setDateHeader(&quot;expires&quot;,-1);        
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
       
        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());
    &#125;
    
    //生成随机数
    private String makeNum()&#123;
        Random random =newRandom();
        String num = random.nextInt(9999999)+&quot;&quot;;
        StringBuffer sb =newStringBuffer();
        for(int i =0; i &lt; 7 - num.length(); i++)&#123;            
            sb.append(&quot;0&quot;);
        &#125;        
        num = sb.toString()+ num;return num;
    &#125;
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;        
        doGet(req, resp);
    &#125; 
&#125;
</code></pre>
<h4 id="3-6-4、实现重定向"><a href="#3-6-4、实现重定向" class="headerlink" title="3.6.4、实现重定向"></a>3.6.4、实现重定向</h4><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320172123691.png" alt="image-20210320172123691"></p>
<p>​        B一个web资源收到客户端A请求后，B会通知A去访问另外一个web资源C，这个过程叫<strong>重定向</strong>。</p>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="java">void sendRedirect(String varl)throw IOException;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    /*
         */
    resp.setHeader(&quot;Location&quot;,&quot;/r/image&quot;);
    resp.setStatus(302);
    resp.sendRedirect(&quot;/r/image&quot;);//重定向
&#125;
</code></pre>
<p><strong>重定向和转发的区别？</strong></p>
<p>相同点:</p>
<ul>
<li>页面都会跳转</li>
</ul>
<p>不同点:</p>
<ul>
<li>请求转发 url不会产生变化， 重定向会发生变化</li>
<li>请求转发 可以携带参数， 重定向不能携带参数</li>
<li>请求转发 只能发送一个请求， 重定向至少发送两次请求</li>
</ul>
<h4 id="3-6-5、简单实现登录重定向"><a href="#3-6-5、简单实现登录重定向" class="headerlink" title="3.6.5、简单实现登录重定向"></a>3.6.5、简单实现登录重定向</h4><pre><code class="java">public class Servlet_06_RequestTest extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;进入请求&quot;);
        //处理请求
        //从那个请求中获取参数
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        System.out.println(username+&quot; : &quot;+password);
        //重定向时一定要注意路径问题  否则44
        resp.sendRedirect(&quot;/r/success.jsp&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h3 id="3-7、HttpServletRequest"><a href="#3-7、HttpServletRequest" class="headerlink" title="3.7、HttpServletRequest"></a>3.7、HttpServletRequest</h3><p>​        HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</p>
<h4 id="3-7-1-获取前端传递的参数-并-请求转发"><a href="#3-7-1-获取前端传递的参数-并-请求转发" class="headerlink" title="3.7.1. 获取前端传递的参数 并 请求转发"></a>3.7.1. 获取前端传递的参数 并 请求转发</h4><pre><code class="java"> @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
        System.out.println(&quot;--------------------------------------&quot;);
        System.out.println(username);
        System.out.println(password);
        System.out.println(Arrays.toString(hobbies));
        System.out.println(&quot;--------------------------------------&quot;);
        //通过请求转发
        //这里的/代表当前Web应用
        req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
</code></pre>
<pre><code class="java">@WebServlet(&quot;/req&quot;)
public class ReqServletextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        System.out.println(&quot;url路径：&quot;+req.getRequestURL());
        System.out.println(&quot;uri路径：&quot;+req.getRequestURI());
        System.out.println(&quot;context路径：&quot;+req.getContextPath());
        req.getRequestDispatcher(&quot;/file&quot;).forward(req,resp);
    &#125; 
&#125;
</code></pre>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320180403649.png" alt="image-20210320180403649"></p>
<h2 id="四、Cookie、Session"><a href="#四、Cookie、Session" class="headerlink" title="四、Cookie、Session"></a>四、Cookie、Session</h2><h3 id="4-1、会话"><a href="#4-1、会话" class="headerlink" title="4.1、会话"></a>4.1、会话</h3><p>​        <strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p>​        <strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<h3 id="4-2、保存会话的两种技术"><a href="#4-2、保存会话的两种技术" class="headerlink" title="4.2、保存会话的两种技术"></a>4.2、保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术（响应、请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<h3 id="4-3、Cookie"><a href="#4-3、Cookie" class="headerlink" title="4.3、Cookie"></a>4.3、Cookie</h3><p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li><p>不设置有效期，关闭浏览器，自动失效；（默认）</p>
</li>
<li><p>设置有效期时间为 0 ；</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>cookie默认有效期是在浏览器关闭后失效，如果设置了有效期就在过期后失效</li>
</ul>
<pre><code class="java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    //服务器告诉你你来的时间,把时间封装成一个信件,下次来的时候带着
    //解决中文乱码
    resp.setCharacterEncoding(&quot;utf-8&quot;);
    req.setCharacterEncoding(&quot;utf-8&quot;);
    //响应
    PrintWriter out = resp.getWriter();
    //Cookie ,服务端从客户端获取
    Cookie[] cookies = req.getCookies();//返回数组,说明可能存在多个
    //判断Cookie是否存在
    if (cookies!=null)&#123;
        //如果存在怎么办
        out.write(&quot;When was your last visit: &quot;);
        for (int i = 0; i &lt;cookies.length ; i++) &#123;
            Cookie cookie =  cookies[i];
            //或缺Cookie的名字
            if(cookie.getName().equals(&quot;LastLoginTime&quot;))&#123;
                //获取cookie中的值
                long LastLoginTime = Long.parseLong(cookie.getValue());
                Date date = new Date(LastLoginTime);
                out.write(date.toLocaleString());
            &#125;
        &#125;
    &#125;else &#123;
        System.out.println(&quot;This is your first visit&quot;);
    &#125;
    //服务器给客户端响应一个Cookie
    Cookie cookie = new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);
    //给cookie设置有效期为一天
    cookie.setMaxAge(24*60*60);
    resp.addCookie(cookie);
</code></pre>
<pre><code class="java">Cookie[] cookie = req.getCookies();//获得cookie
cookie.getName();//获得cookie中的key
cookie.getValve();//获得cookie中的value
new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);//新建cookie
cookie.setMaxAge(24*60*60);        //给cookie设置有效期为一天
resp.addCookie(cookie);//添加一个cookie
</code></pre>
<p>编码与解码，防止乱码</p>
<pre><code class="java">@WebServlet(&quot;/c3&quot;)
public class CookieDemo2extendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
       PrintWriter out = resp.getWriter();
       for(Cookie cookie : req.getCookies())&#123;
           if(cookie.getName().equals(&quot;name&quot;))&#123;
               out.write(URLDecoder.decode(cookie.getValue(),&quot;utf-8&quot;));
           &#125; 
       &#125;
     Cookie cookie = new Cookie(&quot;name&quot;,URLEncoder.encode(&quot;筱语&quot;,&quot;utf-8&quot;));        
      resp.addCookie(cookie);
    &#125; 
&#125;
</code></pre>
<h3 id="4-3、Session（重点）"><a href="#4-3、Session（重点）" class="headerlink" title="4.3、Session（重点）"></a>4.3、Session（重点）</h3><p>什么是session</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个session对象</li>
<li>一个session独占一个浏览器，主要浏览器没有关闭，这个session就存在</li>
<li>用户登录后，整个网站它都可以访问——&gt;保存用户的信息，保存购物车的信息。</li>
</ul>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210323084508377.png" alt="image-20210323084508377"></p>
<ul>
<li>给session中存用户信息</li>
</ul>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class Servlet_09_Session extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 解决乱码问题
        req.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
        
        // 获得Session
        HttpSession session = req.getSession();
        
        // 给Session存东西
        // session.setAttribute(&quot;name&quot;,&quot;小狗&quot;);
        session.setAttribute(&quot;name&quot;,new Person(18,&quot;小红&quot;,123456789));
        // 获取Session的id
        String id = session.getId();
        System.out.println(id);
        // 判断Session是不是新创建的
        boolean aNew = session.isNew();
        if (aNew)&#123;
            resp.getWriter().println(&quot;session创建成功! session id 为: &quot;+id);
        &#125;else &#123;
            resp.getWriter().println(&quot;session已经创建了id 为: &quot;+id);
        &#125;
        // session在创建的时候做了啥
        // Cookie cookie = new Cookie(&quot;SESSIONID&quot;, id);
        // resp.addCookie(cookie);
    &#125;
    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<ul>
<li>获取session中存储的用户信息</li>
</ul>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class Servlet_09_SessionGet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 解决编码问题
        resp.setCharacterEncoding(&quot;utf8&quot;);
        req.setCharacterEncoding(&quot;utf8&quot;);
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
        
        // 得到session
        HttpSession session = req.getSession();
        Person person = (Person) session.getAttribute(&quot;name&quot;);
        System.out.println(person.toString());
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<p>每次新打开一个浏览器访问地址，都会新建一个session会话，也会向客户端存储一个值为sessionId的cookie。</p>
<h5 id="手动注销session"><a href="#手动注销session" class="headerlink" title="手动注销session"></a>手动注销session</h5><pre><code class="java">public class Servlet_10_SessionRemove extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        HttpSession session = req.getSession();
        session.removeAttribute(&quot;name&quot;);
        session.invalidate();//注销
    &#125;
</code></pre>
<h5 id="设置session的失效时间，在web-xml中"><a href="#设置session的失效时间，在web-xml中" class="headerlink" title="设置session的失效时间，在web.xml中"></a>设置session的失效时间，在web.xml中</h5><pre><code class="xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<h4 id="7天免登录案例实现"><a href="#7天免登录案例实现" class="headerlink" title="7天免登录案例实现"></a>7天免登录案例实现</h4><p>思路：session在一次会话后就会结束，所以可以通过servletContext来存储当前的session，以sessionId为key，session对象为值，然后将sessionId存在客户端的cookie中，每次获取用户信息先去cookie中查找是否有这个id，然后通过该id获取servletContext中的session对象实现。</p>
<ul>
<li>登录接口，将session存到ServletContext中</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/ss1&quot;)
public class SessionAnextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        HttpSession session = req.getSession();
        session.setAttribute(&quot;name&quot;,&quot;小腿&quot;);                                                                          String sessionId = session.getId();
       Cookie cookie =newCookie(&quot;session&quot;,sessionId);        
       cookie.setMaxAge(Integer.MAX_VALUE);        
       resp.addCookie(cookie);
       //存session对象
       this.getServletContext().setAttribute(sessionId,session);       
       resp.getWriter().write(&quot;登录成功！&quot;);
     &#125; 
&#125;
</code></pre>
<ul>
<li>获取用户信息接口</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/ss2&quot;)
public class SessionAn2extendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        String sId =&quot;&quot;;
        for(Cookie cookie : req.getCookies())&#123;
            if(cookie.getName().equals(&quot;session&quot;))&#123;                
                sId = cookie.getValue();
            &#125; 
        &#125;
        HttpSession session = (HttpSession) this.getServletContext().getAttribute(sId);
        String  name =(String)session.getAttribute(&quot;name&quot;);        
        resp.getWriter().write(&quot;欢迎你，&quot;+name);
    &#125; 
&#125;
</code></pre>
<p>​        先访问ss1接口，设置用户信息到session中，然后访问ss2接口就可以拿到用户信息了。将cookie过期时间设置为7天即可。当关闭浏览器后，下次直接访问ss2接口就能拿到用户信息，相当于不用再通过ss1接口登录了。</p>
<p><strong>注意：</strong>每次访问网站都会生成一个JsessionId在cookie中，而且会是不同的值。</p>
<h3 id="4-4、session与cookie异同"><a href="#4-4、session与cookie异同" class="headerlink" title="4.4、session与cookie异同"></a>4.4、session与cookie异同</h3><table>
<thead>
<tr>
<th align="left">COOKIE</th>
<th align="left">SESSION</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存在客户端中，不安全</td>
<td align="left">存在服务端中，比较安全</td>
</tr>
<tr>
<td align="left">只支持存字符串数据</td>
<td align="left">支持任意数据类型</td>
</tr>
<tr>
<td align="left">单个cookie存的数据大小不能超过4k</td>
<td align="left">可存储数据远高于Cookie</td>
</tr>
</tbody></table>
<h3 id="4-5使用场景"><a href="#4-5使用场景" class="headerlink" title="4.5使用场景:"></a>4.5使用场景:</h3><ul>
<li>保存一个登录用户的信息</li>
<li>购物车信息</li>
<li>在整个网站中经常会使用的数据,我们将他保存在Session中</li>
</ul>
<h2 id="五、JSP"><a href="#五、JSP" class="headerlink" title="五、JSP"></a>五、JSP</h2><h3 id="5-1什么是JSP"><a href="#5-1什么是JSP" class="headerlink" title="5.1什么是JSP"></a>5.1什么是JSP</h3><p>Java Server Pages: java 服务端界面 也和Servlet一样,用于动态Web技术!</p>
<p>最大的特点:</p>
<ol>
<li>写JSP就像像写HTML                   </li>
<li>区别:                                 <ul>
<li>HTML只提供静态界面                                 </li>
<li>JSP可以嵌入JAVA代码,为用户提供动态数据</li>
</ul>
</li>
</ol>
<h3 id="5-2-JSP原理"><a href="#5-2-JSP原理" class="headerlink" title="5.2 JSP原理-"></a>5.2 JSP原理-</h3><p><strong>JSP 本质上</strong>是也是一个Servlet</p>
<ol>
<li><p>判断请求</p>
</li>
<li><p>内置一些对象</p>
<ol>
<li>输出页面前增加的代码</li>
</ol>
</li>
</ol>
<h3 id="5-3JSP基本语法"><a href="#5-3JSP基本语法" class="headerlink" title="5.3JSP基本语法"></a>5.3JSP基本语法</h3><p>任何语言都有自己的语法,jsp作为java技术的一种应用,也有一些自己的扩充语法(了解,知道即可!!)java所有语法都支持!!</p>
<h4 id="JSP表达式"><a href="#JSP表达式" class="headerlink" title="JSP表达式"></a>JSP表达式</h4><pre><code class="xml">&lt;%--    jsp表达式
作用:用来将程序的输出,输出到客户端
&lt;%= bian&#39;laing %&gt;
--%&gt;
&lt;%= new java.util.Date()%&gt;
</code></pre>
<h4 id="JSP脚本片段"><a href="#JSP脚本片段" class="headerlink" title="JSP脚本片段"></a>JSP脚本片段</h4><pre><code class="xml">&lt;%--  JSP脚本片段--%&gt;
&lt;%
    int sum = 0;
    for (int i = 0; i &lt;100 ; i++) &#123;
        sum++;
    &#125;
    System.out.println(&quot;&lt;h1&gt;SUM=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
%&gt;
</code></pre>
<h4 id="JSP代码的在实现"><a href="#JSP代码的在实现" class="headerlink" title="JSP代码的在实现"></a>JSP代码的在实现</h4><pre><code class="xml">&lt;%
    for (int i = 0; i &lt; 5; i++) &#123;
%&gt;
&lt;h1&gt;HELLO,WOrLD&lt;/h1&gt;
&lt;%
    &#125;
%&gt;
输出5个Hello World
</code></pre>
<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a>JSP声明</h4><pre><code class="xml">&lt;%!
    static &#123;
        System.out.println(&quot;Loading Servlet...&quot;);
&#125;;
    private int globalVar = 0;
    public void kuang()&#123;
        System.out.println(&quot;进入了方法&quot;);
    &#125;
%&gt;
</code></pre>
<p>jsp声明会被编译到jsp生成的java的类中其他的会被生成到_jspServlet方法中!</p>
<p>在jsp,嵌入java代码即可!</p>
<pre><code class="xml">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;
&lt;%--注释--%&gt;
</code></pre>
<p>jsp的注释不会在客户端显示,但是HTML的就会!!</p>
<p>说明jsp会相较于html更安全</p>
<p><strong>EL表达式</strong></p>
<blockquote>
<p>在JSP页面的任何静态部分均可通过：${expression}来获取到指定表达式的值</p>
</blockquote>
<h4 id="jsp指令"><a href="#jsp指令" class="headerlink" title="jsp指令"></a>jsp指令</h4><pre><code class="xml">&lt;%@ page ...%&gt;
</code></pre>
<h3 id="5-4-九大内置对象"><a href="#5-4-九大内置对象" class="headerlink" title="5.4 九大内置对象"></a>5.4 九大内置对象</h3><ul>
<li><p>PageContext 存东西</p>
</li>
<li><p>Request 存东西</p>
</li>
<li><p>Response</p>
</li>
<li><p>Session 存东西</p>
</li>
<li><p>Application (Servlet Context) 存东西</p>
</li>
<li><p>config (servlet config)</p>
</li>
<li><p>out</p>
</li>
<li><p>page</p>
</li>
<li><p>exception</p>
<p>request: 客户端向服务器发送请求,产生的数据,用户看完就没用了, 比如: 新闻,用户看完没用的!</p>
<p>session: 客户端向服务器发送请求,产生的数据,用户用完之后还有用 , 比如: 购物车;</p>
<p>application: 客户端向服务器发送请求,产生的数据,一个用户用完了,其他用户还可以使用, 比如:聊天数据</p>
</li>
</ul>
<h3 id="5-5Jsp-标签-JSbTL表达式-EL表达式"><a href="#5-5Jsp-标签-JSbTL表达式-EL表达式" class="headerlink" title="5.5Jsp 标签 ,JSbTL表达式,EL表达式"></a>5.5Jsp 标签 ,JSbTL表达式,EL表达式</h3><p>EL表达式: ${}</p>
<ul>
<li>获取数据</li>
<li>执行运算</li>
<li>获取WEB开发的常用对象</li>
</ul>
<p>JSP 标签</p>
<pre><code class="xml">&lt;%--jsp:include--%&gt;
&lt;%--
http://localhost:8080?jsptag.jsp?name=kuangshen&amp;age=12
--%&gt;
&lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>JSTL表达式</strong></p>
<p><strong>JSTL标签库的使用</strong>就是为了弥补HTML的不足: 他自定义了许多标签,可以供我们使用,标签功能和Java代码一样!</p>
<p>格式化标签</p>
<p>SQL标签</p>
<p>XML标签</p>
<p>核心标签(<strong>掌握部分</strong>)</p>
<p>JSTL使用步骤:</p>
<pre><code class="xml">1. 引入对应taglib
2. 使用其中的方法
3. 在tomcat中也要引入JSTL的包,否则会报错:JSTL解析错误
</code></pre>
<pre><code class="html">&lt;body&gt;
&lt;h4&gt;if测试&lt;/h4&gt;
&lt;hr&gt;
&lt;form action=&quot;JSTL_CoreIf.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
        EL表达式获取表单中的数据
        $&#123;param.参数名&#125; &#125;
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;
&lt;%--判断如果是管理员则提交成功--%&gt;
&lt;c:if test=&quot;$&#123;param.username ==&#39;admin&#39;&#125;&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎你~~!&quot;/&gt;
&lt;/c:if&gt;
&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%--定义一个变量 值为85--%&gt;
    &lt;c:set var=&quot;score&quot; value=&quot;85&quot;/&gt;
&lt;c:choose&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt;
        你的分数挺高!~
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt;
        你的分数还行
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt;
        你的分数一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&lt;=60&#125;&quot;&gt;
        你的分数想死
    &lt;/c:when&gt;
&lt;/c:choose&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="六、JavaBean"><a href="#六、JavaBean" class="headerlink" title="六、JavaBean"></a>六、JavaBean</h2><p>实体类</p>
<p>JavaBean有特定的写法:</p>
<ul>
<li>必须有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法</li>
</ul>
<p>**_<strong>一般来和数据库字段做映射</strong>_**ORM</p>
<p>ORM对象关系映射</p>
<ul>
<li><p>表——&gt;类</p>
</li>
<li><p>字段—-&gt;属性</p>
</li>
<li><p>行记录——&gt;对象</p>
<p>People表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小猪</td>
<td>3</td>
<td>广州</td>
</tr>
<tr>
<td>2</td>
<td>小猪</td>
<td>15</td>
<td>上海</td>
</tr>
<tr>
<td>3</td>
<td>小猪</td>
<td>88</td>
<td>北京</td>
</tr>
</tbody></table>
<pre><code class="java">class People&#123;
    private int id;
    private String name;
    private int age; 
    private String address;
&#125;

class A&#123;
    new people(1,&quot;小猪&quot;,3,&quot;广州&quot;);
     new people(2,&quot;小猪&quot;,15,&quot;上海&quot;);
     new people(3,&quot;小猪&quot;,88,&quot;北京&quot;);
&#125;
</code></pre>
<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC复习,如何使用JDBC , JDBC crud , JDBC事物</li>
</ul>
<h2 id="七、三层架构MVC"><a href="#七、三层架构MVC" class="headerlink" title="七、三层架构MVC"></a>七、三层架构MVC</h2><p><strong>MVC是啥?</strong> model view controller 模型(实体类与数据库对应的字段) 视图(jsp页面) 控制器(Servlet) | 当前理解</p>
<p>Model</p>
<ul>
<li>业务处理: 业务逻辑 (service)</li>
<li>数据库持久层: CRUD (Dao)</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供连接发起servlet请求(a from img)</li>
</ul>
<p>Controller</p>
<ul>
<li>接受用户请求: request :请求参数,Session信息</li>
<li>交给业务层处理对应代码</li>
<li>控制视图的跳转</li>
</ul>
<pre><code class="xml">登录
----&gt;接受用户的登录请求
-----&gt;处理用户请求(获取用户登陆的参数 usename passworld)
----&gt;交给业务层处理登录业务(判断用户名 密码是否吻合 )
----&gt;Dao层查询用户名密码是否正确
---&gt;查数据库
</code></pre>
<h2 id="八、Filter过滤器"><a href="#八、Filter过滤器" class="headerlink" title="八、Filter过滤器"></a>八、Filter过滤器</h2><p><strong>Filter</strong>：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证…</li>
</ul>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210325121124401.png" alt="image-20210325121124401"></p>
<p>开发步骤:</p>
<ol>
<li>导包</li>
<li>编写过滤器</li>
<li>导包不要错(javax.servlet)</li>
<li>实现Filer接口,重写对应方法即可</li>
</ol>
<pre><code class="java">public class Filer implements Filter &#123;
    //初始化
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;初始化成功~~~~!&quot;);
    &#125;
    //初始化: web服务器启动时就初始化,随时等待过滤器对象的出现
    //Chain 链
    //1. 过滤器中的所有代码,在过滤特定请求时
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html; charset=UTF-8&quot;);
        System.out.println(&quot;执行前...&quot;);
        chain.doFilter(servletRequest, servletResponse);//让请求继续走,如果不写拦截停止
        System.out.println(&quot;执行后....&quot;);
    &#125;
    //销毁 web服务器关闭的时候才会被销毁
    public void destroy() &#123;
        System.out.println(&quot;已被销毁~~~~!&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li>在web.xml中配置Filter映射</li>
</ol>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;filer&lt;/filter-name&gt;
    &lt;filter-class&gt;com.zhu.Filer.Filer&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;!-- /*会过滤所有的请求--&gt;
    &lt;!--servlet/*会过滤所有servlet下的所有请求--&gt;
    &lt;filter-name&gt;filer&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<h2 id="九、监听器"><a href="#九、监听器" class="headerlink" title="九、监听器"></a>九、监听器</h2><p>监测网站在线人数（基于session）</p>
<p>1、编写一个监听器，实现HttpSessionListener</p>
<pre><code class="java">public class OnlineListenimplementsHttpSessionListener&#123;
    /**     
    * 监听session新创建时执行的方法     
    * @param se     
    */
    @Override
    public void sessionCreated(HttpSessionEvent se)&#123;
        ServletContext sc = se.getSession().getServletContext();
        System.out.println(&quot;sessionId:&quot;+ se.getSession().getId());
        Integer onlineCount =(Integer) sc.getAttribute(&quot;onlineCount&quot;);
        if(onlineCount ==null)&#123;            
            onlineCount =1;
        &#125;else&#123;           
            onlineCount++;
        &#125;        
        sc.setAttribute(&quot;onlineCount&quot;,onlineCount);&#125;
    
    /**     
    * 监听session销毁时执行方法     
    * @param se     
    */
    @Override
    public void sessionDestroyed(HttpSessionEvent se)&#123;
        ServletContext sc = se.getSession().getServletContext();
        Integer onlineCount =(Integer) sc.getAttribute(&quot;onlineCount&quot;);
        if(onlineCount ==null)&#123;            
            onlineCount =0;
        &#125;else&#123;            
            onlineCount--;
        &#125;
        System.out.println(&quot;销毁session了--监听到&quot;);        
        sc.setAttribute(&quot;onlineCount&quot;,onlineCount);
    &#125; 
&#125;
</code></pre>
<p>2、web.xml中注册监听器</p>
<pre><code class="xml">&lt;!--监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.bug.listener.OnlineListen&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>session销毁方法</p>
<ul>
<li>手动销毁 getSession().invalidate();</li>
<li>自动销毁 在web.xml中设置超时时间</li>
</ul>
<h2 id="十、-过滤器-监听器常见应用"><a href="#十、-过滤器-监听器常见应用" class="headerlink" title="十、 过滤器,监听器常见应用"></a>十、 过滤器,监听器常见应用</h2><p>监听器在javaGUI中常常被使用:</p>
<p>用户登录才能进入主页,注销后不能进去主页</p>
<h2 id="十一、SMBS-项目从头到尾"><a href="#十一、SMBS-项目从头到尾" class="headerlink" title="十一、SMBS 项目从头到尾"></a>十一、SMBS 项目从头到尾</h2><h3 id="11-1、-项目怎么搭建"><a href="#11-1、-项目怎么搭建" class="headerlink" title="11.1、 项目怎么搭建"></a>11.1、 项目怎么搭建</h3><h4 id="11-1-1、是否使用Maven"><a href="#11-1-1、是否使用Maven" class="headerlink" title="11.1.1、是否使用Maven"></a>11.1.1、是否使用Maven</h4><p>依赖 or jar包</p>
<h4 id="11-1-2、项目搭建的准备工作"><a href="#11-1-2、项目搭建的准备工作" class="headerlink" title="11.1.2、项目搭建的准备工作"></a>11.1.2、项目搭建的准备工作</h4><ol>
<li><p>搭建一个Maven Web 项目</p>
</li>
<li><p>配置Tomcat</p>
</li>
<li><p>测试项目是否能跑起来</p>
</li>
<li><p>导入项目的jar 包</p>
<p> JSP Servlet Mysql</p>
</li>
<li><p>创建项目包结构</p>
</li>
<li><p>编写实体类</p>
<p>ORM映射, 表-&gt;类映射</p>
</li>
<li><p>编写基础公共类</p>
</li>
</ol>
<h4 id="11-1-3、数据库配置文件"><a href="#11-1-3、数据库配置文件" class="headerlink" title="11.1.3、数据库配置文件"></a>11.1.3、数据库配置文件</h4><pre><code class="properties">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306?useUnicode=true &amp; characterEncoding=utf-8 
useername = root
password = 510562
</code></pre>
<p><strong>编写数据库的公共类</strong></p>
<pre><code class="java">package com.zhu.dao;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.*;
import java.util.Properties;
/**
 * 操作数据库的公共类
 */
public class BaseDao &#123;
    private static String driver;
    private static String url;
    private static String username;
    private static String password;
    
    //静态代码块,类加载的时候就会加载
    static &#123;
        Properties properties = new Properties();
        //通过类加载器读取资源
        InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);
        try &#123;
            properties.load(is);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        //获取 db.properties 中对应的数据
        driver = properties.getProperty(&quot;driver&quot;);
        url = properties.getProperty(&quot;url&quot;);
        username = properties.getProperty(&quot;username&quot;);
        password = properties.getProperty(&quot;password&quot;);
    &#125;
    
    //获取数据库的链接
    public static Connection getConnection() &#123;
        Connection connection = null;
        try &#123;
            Class.forName(driver);
            connection = DriverManager.getConnection(url, username, password);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return connection;
    &#125;
    
    //编写查询公共类
    public static ResultSet excute(Connection connection, String sql, Object[] params, ResultSet resultSet, PreparedStatement preparedStatement) throws SQLException &#123;
        //预编译的SQL在后边直接执行就行
        preparedStatement = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; params.length; i++) &#123;
            //setobject ,占位符从1开始,  数组从0开始
            preparedStatement.setObject(i + 1, params[i]);
        &#125;
        resultSet = preparedStatement.executeQuery();
        return resultSet;
    &#125;
    
    //编写增删改公共方法
    public static int excute(Connection connection, String sql, Object[] params, PreparedStatement preparedStatement) throws SQLException &#123;
        preparedStatement = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; params.length; i++) &#123;
            //setobject ,占位符从1开始,  数组从0开始
            preparedStatement.setObject(i + 1, params[i]);
        &#125;
        int updateRow = preparedStatement.executeUpdate();
        return updateRow;
    &#125;
    
    //关闭链接,释放资源
    public static boolean closeResource(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123;
        boolean flag = true;
        if (resultSet != null) &#123;
            try &#123;
                resultSet.close();
                //GC回收
                resultSet = null;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        if (connection != null) &#123;
            try &#123;
                connection.close();
                //GC回收
                connection = null;
                ;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        &#125;
        if (resultSet != null) &#123;
            try &#123;
                resultSet.close();
                //GC回收
                resultSet = null;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        &#125;
        return flag;
    &#125;
&#125;
</code></pre>
<h3 id="11-2、编写字符编码过滤器"><a href="#11-2、编写字符编码过滤器" class="headerlink" title="11.2、编写字符编码过滤器"></a>11.2、编写字符编码过滤器</h3><h4 id="11-2-1、导入静态资源"><a href="#11-2-1、导入静态资源" class="headerlink" title="11.2.1、导入静态资源"></a>11.2.1、导入静态资源</h4><h4 id="11-2-2、登录功能实现"><a href="#11-2-2、登录功能实现" class="headerlink" title="11.2.2、登录功能实现"></a>11.2.2、登录功能实现</h4><ol>
<li>编写前端</li>
<li>设置首页</li>
<li>编写dao层,得到用户登陆的接口</li>
<li>编写dao接口的实现类</li>
<li>业务层接口</li>
<li>业务层实现类</li>
<li>编写Servlet</li>
<li>注册Servlet</li>
</ol>
<pre><code class="xml">&lt;session-config&gt;&lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt;
</code></pre>
<pre><code class="xml">  以下是mavaen推荐的项目目录.
  ├── pom.xml
  └── src
      ├── main
      │   ├── java
      │   │   └── group
      │   │       ├── controller
      │   │       │   ├── HomeController.java
      │   │       │   └── PersonController.java
      │   │       ├── dao
      │   │       │   └── PersonDao.java
      │   │       └── model
      │   │           └── Person.java
      │   ├── resources
      │   │   ├── db.properties
      │   │   ├── log4j.xml
      │   │   └── META-INF
      │   │       └── persistence.xml
      │   └── webapp
      │       ├── index.html
      │       ├── META-INF
      │       │   ├── context.xml
      │       │   └── MANIFEST.MF
      │       ├── resources
      │       │   └── css
      │       │       └── screen.css
      │       └── WEB-INF
      │           ├── spring
      │           │   ├── app
      │           │   │   ├── controllers.xml
      │           │   │   └── servlet-context.xml
      │           │   ├── db.xml
      │           │   └── root-context.xml
      │           ├── views
      │           │   ├── edit.jsp
      │           │   ├── home.jsp
      │           │   └── list.jsp
      │           └── web.xml
      └── test
          ├── java
          │   └── group
          │       ├── controller
          │       │   ├── DataInitializer.java
          │       │   ├── HomeControllerTest.java
          │       │   └── PersonControllerTest.java
          │       └── dao
          │           └── PersonDaoTest.java
          └── resources
              ├── db.properties
              ├── log4j.xml
              ├── test-context.xml
              └── test-db.xml
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JavaWeb" style=color:#ffa2c4>
                JavaWeb
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/JavaWeb/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/helloservlet/">
        <h2>
            配置文件
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1. Servlet"></a>1. Servlet</h1><h2 id="1-1-servlet简介"><a href="#1-1-servlet简介" class="headerlink" title="1.1 servlet简介"></a>1.1 servlet简介</h2><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun公司在这些API提供一个借口叫做：servlert程序<ul>
<li>编写一个类，实现servlet借口</li>
<li>把开发好的类部署到web服务器</li>
</ul>
</li>
<li>把实现了servlet接口的程序叫做 servlet</li>
</ul>
<h2 id="1-2-关于maven父子工程的理解"><a href="#1-2-关于maven父子工程的理解" class="headerlink" title="1.2 关于maven父子工程的理解"></a>1.2 关于maven父子工程的理解</h2><ul>
<li><p>父项目中会有</p>
<pre><code class="xml">&lt;modules&gt;
  &lt;module&gt;servlet-01&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
</li>
<li><p>子项目中会有</p>
<pre><code class="xml">&lt;parent&gt;
  &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
  &lt;groupId&gt;org.example&lt;/groupId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
</li>
</ul>
<h2 id="1-3-编写一个servlet程序"><a href="#1-3-编写一个servlet程序" class="headerlink" title="1.3 编写一个servlet程序"></a>1.3 编写一个servlet程序</h2><h3 id="1-3-1-编写一个普通类"><a href="#1-3-1-编写一个普通类" class="headerlink" title="1.3.1 编写一个普通类"></a>1.3.1 编写一个普通类</h3><h3 id="1-3-2-通过继承httpservlet实现servlet接口"><a href="#1-3-2-通过继承httpservlet实现servlet接口" class="headerlink" title="1.3.2 通过继承httpservlet实现servlet接口"></a>1.3.2 通过继承httpservlet实现servlet接口</h3><ul>
<li><p>注：如果出现导入失败的情况，可能是镜像还没加入该文件，需要自己去仓库里面下载，放入到相应的文件夹</p>
<pre><code class="java">public class HelloServlet extends HttpServlet &#123;
 //由于get或者post只是请求实现的不同方式，可以相互调用
 @Override
 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
     PrintWriter writer=resp.getWriter();
     writer.print(&quot;Hello,Servlet&quot;);
 &#125;
    
 @Override
 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
     doGet(req,resp);
 &#125;
&#125;
</code></pre>
<h3 id="1-3-3-编写servlet的映射"><a href="#1-3-3-编写servlet的映射" class="headerlink" title="1.3.3 编写servlet的映射"></a>1.3.3 编写servlet的映射</h3><blockquote>
<p> 为什么需要映射</p>
</blockquote>
<p>​    我们写的是Java程序，但是需要通过浏览器进行访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的servlet，还需要给他一个浏览器能够访问的路径。</p>
<pre><code class="xml"> &lt;!--注册servlet--&gt;
 &lt;servlet&gt;
     &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
     &lt;servlet-class&gt;com.yu.servlet.HelloServlet&lt;/servlet-class&gt;
 &lt;/servlet&gt;

 &lt;!--servlet的请求路径--&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
<h3 id="1-3-4-启动错误原因总结"><a href="#1-3-4-启动错误原因总结" class="headerlink" title="1.3.4 启动错误原因总结"></a>1.3.4 启动错误原因总结</h3><ol>
<li><p>pom文件没有配置好，检查子项目的配置文件，把重复的属性值删除(文件仅供参考)</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; 
    &lt;parent&gt;     
        &lt;artifactId&gt;javaweb-02&lt;/artifactId&gt;     
        &lt;groupId&gt;com.yu&lt;/groupId&gt;     
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
    &lt;/parent&gt; 
    
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
    
    &lt;artifactId&gt;servlet-01&lt;/artifactId&gt; 
    
    &lt;packaging&gt;war&lt;/packaging&gt; 
    &lt;name&gt;servlet-01 Maven Webapp&lt;/name&gt; 
    &lt;!-- FIXME change it to the project&#39;s website --&gt; 
    &lt;url&gt;http://www.example.com&lt;/url&gt; 
    &lt;properties&gt;     
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;     
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; 
    &lt;/properties&gt; 
    &lt;dependencies&gt;     
        &lt;dependency&gt;     
            &lt;groupId&gt;junit&lt;/groupId&gt;     
            &lt;artifactId&gt;junit&lt;/artifactId&gt;     
            &lt;version&gt;4.11&lt;/version&gt;     
            &lt;scope&gt;test&lt;/scope&gt;     
        &lt;/dependency&gt; 
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
</li>
<li><p>检查导入依赖，如果在external libraries 没有相应依赖会导致启动失败</p>
<pre><code class="xml"> javax.servlet.jsp.api javax.sevlet.api maven:junit maven:hamcresrt-core
</code></pre>
</li>
<li><p>检查tomcat配置</p>
<pre><code class="xml"> 环境变量 deployment server
 注意核对一下几项：
 Application server        
 JRE        
 HTTP port
 JMX port
</code></pre>
</li>
</ol>
</li>
</ul>
<h1 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h1><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--MAven版本和头文件--&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    
    &lt;!--这里就是我们刚才配置的GAV--&gt;
    &lt;groupId&gt;com.qf&lt;/groupId&gt;
    &lt;artifactId&gt;javaweb-03-maven&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    
    &lt;!--项目的打包方式
  jar:java应用
  war:javaweb应用--&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;name&gt;javaweb-03-maven Maven Webapp&lt;/name&gt;
    
    &lt;!-- FIXME change it to the project&#39;s website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;
    
    &lt;!--配置--&gt;
    &lt;properties&gt;
        &lt;!--项目的默认构建编码--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;!--编码版本--&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    
    &lt;!--项目依赖--&gt;
    &lt;dependencies&gt;
        &lt;!--具体依赖的jar包配置文件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;!--  项目构建用的东西--&gt;
    &lt;build&gt;
        &lt;finalName&gt;javaweb-03-maven&lt;/finalName&gt;
        &lt;pluginManagement&gt;
            
            &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.1.0&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.8.0&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.22.1&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.5.2&lt;/version&gt;
                &lt;/plugin&gt;
                
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.8.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;

&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;
                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;
            &lt;/excludes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
    http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
    version=&quot;4.0&quot;
    metadata-complete=&quot;true&quot;&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- 旧版，注释掉
     &lt;dependency&gt;
         &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
         &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
         &lt;version&gt;2.1&lt;/version&gt;
         &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt; 
     --&gt;
&lt;/dependencies&gt;


JSP方面的依赖
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.3&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- JSTL表达式的依赖 --&gt;
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--standard标签库--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JavaWeb" style=color:#ff7d73>
                JavaWeb
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/JavaWeb/helloservlet/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/JDBC以及连接池/">
        <h2>
            JDBC以及连接池
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="JDBC以及连接池"><a href="#JDBC以及连接池" class="headerlink" title="JDBC以及连接池"></a>JDBC以及连接池</h1><h2 id="一、JDBC入门"><a href="#一、JDBC入门" class="headerlink" title="一、JDBC入门"></a>一、JDBC入门</h2><h3 id="1-1-JDBC的四个核心对象"><a href="#1-1-JDBC的四个核心对象" class="headerlink" title="1.1 JDBC的四个核心对象"></a>1.1 JDBC的四个核心对象</h3><ul>
<li><strong>DriverManager:</strong> <ul>
<li>用于注册驱动 PS：</li>
<li>需要注册驱动才能让JDBC跑起来，但是我老师说后面都不用再写，因为会自动注册</li>
</ul>
</li>
<li><strong>Connection:</strong> <ul>
<li>表示数据库的连接 PS：</li>
<li>类似于socket 开启管道使得Java程序连接数据库</li>
</ul>
</li>
<li><strong>Statement:</strong> <ul>
<li>执行SQL语句的对象 PS：</li>
<li>把要执行的sql语句运送到数据库</li>
</ul>
</li>
<li><strong>ResultSet:</strong> <ul>
<li>结果集或一张虚拟表 PS：</li>
<li>接受和保存数据库传回来的数据</li>
</ul>
</li>
</ul>
<h3 id="1-2-JDBC使用步骤"><a href="#1-2-JDBC使用步骤" class="headerlink" title="1.2 JDBC使用步骤"></a>1.2 JDBC使用步骤</h3><h4 id="1-2-1、注册驱动"><a href="#1-2-1、注册驱动" class="headerlink" title="1.2.1、注册驱动"></a>1.2.1、<strong>注册驱动</strong></h4><p>​        首先复制JDBC包到lib-解压；</p>
<pre><code class="java">// 注册驱动   
DriverManager.registerDriver(new com.mysql.jdbc.Driver());
</code></pre>
<p>​        或使用java.lang.Class 类中的 forName() 方法指定 JDBC 驱动的类型：</p>
<pre><code class="java"> Class.froName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre>
<h4 id="1-2-2、获取数据库连接"><a href="#1-2-2、获取数据库连接" class="headerlink" title="1.2.2、获取数据库连接"></a>1.2.2、<strong>获取数据库连接</strong></h4><p>​        表示Java程序与数据库之间的连接，只有拿到Connection才能操作数据库。</p>
<p>​        <strong>理解</strong>：就像之前接触过的网络编程，java程序就像是客户端，客户端要取得端口一样，然后打开socket</p>
<table>
<thead>
<tr>
<th>static Connection getConnection(String url, String user, String password)</th>
<th>连接到给定数据库 URL ，并返回连接。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​        <strong>String url：</strong>连接数据库的URL，用于说明连接数据库的位置</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/07/30/kuangstudyf27a7b35-ed7e-4352-a7d8-c1a4d532adfb.png" alt="img"></p>
<p>如果是本地服务器，端口号是默认的3306，则可以简写：jdbc:mysql:///test</p>
<p>​        <strong>String username：</strong>数据库的账号<br>​        <strong>String password：</strong>数据库的密码</p>
<pre><code class="java">//参数解释：createDatabaseIfNotExist:如果数据库不存在就创建
String url = &quot;jdbc:mysql://localhost:3306/activitiDB?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=utf8&quot;;
String username = &quot;root&quot;;
String password =  &quot;1234566&quot;;

Connection connection = DriverManager.getConnection(url,username,password);
</code></pre>
<h4 id="1-2-3、获取执行SQL语句对象"><a href="#1-2-3、获取执行SQL语句对象" class="headerlink" title="1.2.3、获取执行SQL语句对象"></a>1.2.3、<strong>获取执行SQL语句对象</strong></h4><pre><code class="java">Statement statement = connection.createStatement();
</code></pre>
<h4 id="1-2-4、执行SQL语句并返回结果"><a href="#1-2-4、执行SQL语句并返回结果" class="headerlink" title="1.2.4、执行SQL语句并返回结果"></a>1.2.4、<strong>执行SQL语句并返回结果</strong></h4><table>
<thead>
<tr>
<th align="center">Statement的API介绍</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ResultSet executeQuery(String sql)</td>
<td>用于执行查询语句; 返回查询到的结果集</td>
</tr>
<tr>
<td align="center">int executeUpdate(String sql)</td>
<td>用于执行除查询外的SQL; 返回影响的行数</td>
</tr>
</tbody></table>
<h4 id="1-2-5、处理结果"><a href="#1-2-5、处理结果" class="headerlink" title="1.2.5、处理结果"></a>1.2.5、处理结果</h4><p>​        <strong>ResultSet</strong>用于保存执行查询SQL语句的结果。我们不能一次性取出所有的数据，需要一行一行的取出。</p>
<p>​        ResultSet内部有一个<strong>指针</strong>，记录获取到哪行数据,获取到哪行数据，获取到哪行数据，获取到哪行数据，是<strong>一行一行获取</strong>！！！</p>
<p>​        每扫过一行，就会获得这一行的id，name，password 的信息。它有<strong>next()方法</strong>，没运行一次就会让游标向下移动一行 ，如果有数据返回true,没有数据返回false，</p>
<p>​        我们可以通过ResultSet得到一行数据 getXxx得到某列数据。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/07/30/kuangstudy02f90056-299f-4315-bcdd-5374d270d38a.png" alt="img"></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>boolean getBoolean(String columnLabel)</td>
<td>获取boolean值</td>
</tr>
<tr>
<td>byte getByte(String columnLabel)</td>
<td>获取byte值</td>
</tr>
<tr>
<td>double getDouble(String columnLabel)</td>
<td>获取double值</td>
</tr>
<tr>
<td>int getInt(String columnLabel)</td>
<td>获取int值</td>
</tr>
<tr>
<td>long getLong(String columnLabel)</td>
<td>获取long值</td>
</tr>
<tr>
<td>String getString(String columnLabel)</td>
<td>获取String值</td>
</tr>
</tbody></table>
<p><strong>案例</strong>：</p>
<pre><code class="java">while (rs.next()) &#123;
            // 取出数据
            // 通过字段名获取字段值
            int id = rs.getInt(&quot;id&quot;);
            String name = rs.getString(&quot;name&quot;);
            String password = rs.getString(&quot;password&quot;);
            System.out.println(id + &quot;: &quot; + name + &quot;: &quot; + password);
        &#125;
</code></pre>
<p><strong>注：</strong>SQL类型与JDBC对应方法：</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/07/30/kuangstudy89db4b00-7c13-4bcc-b75c-93e7caf4f5a1.png" alt="img"></p>
<h4 id="1-2-6、释放资源"><a href="#1-2-6、释放资源" class="headerlink" title="1.2.6、释放资源"></a>1.2.6、释放资源</h4><p>关流，把流出去和流进来的数据通道关掉！</p>
<h3 id="1-3、案例"><a href="#1-3、案例" class="headerlink" title="1.3、案例"></a>1.3、案例</h3><pre><code class="java">public class Demo &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.注册驱动(自动注册)
        
        // 2.获取连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///test&quot;, &quot;root&quot;, &quot;root&quot;);
        
        // 3.获取Statement对象
        Statement stmt = conn.createStatement();
        
        // 4.执行SQL语句
        String sql = &quot;SELECT * FROM user;&quot;;
        ResultSet rs = stmt.executeQuery(sql);
        
        // 5.处理结果
        while (rs.next()) &#123;
            // 取出数据
            // 通过字段名获取字段值
            int id = rs.getInt(&quot;id&quot;);
            String name = rs.getString(&quot;name&quot;);
            String password = rs.getString(&quot;password&quot;);
            System.out.println(id + &quot;: &quot; + name + &quot;: &quot; + password);
        &#125;
        
        // 6.关闭资源
        rs.close();
        stmt.close();
        conn.close();
    &#125;
&#125;
</code></pre>
<h2 id="二、JDBC工具类"><a href="#二、JDBC工具类" class="headerlink" title="二、JDBC工具类"></a>二、JDBC工具类</h2><p>​        定义一个**<code>JDBCUtils</code>类**。把注册驱动，获取连接，得到Statement，以及释放资源的代码放到这个类的方法中，以后直接调用方法即可。</p>
<h3 id="2-1、-编写JDBC工具类步骤"><a href="#2-1、-编写JDBC工具类步骤" class="headerlink" title="2.1、 编写JDBC工具类步骤"></a>2.1、 编写JDBC工具类步骤</h3><p>​        1、将固定字符串定义为常量<br>​        2、提供一个获取连接的方法<code>static Connection getConneciton();</code><br>​        3、定义关闭资源的方法<code>close(Connection conn, Statement stmt, ResultSet rs)</code><br>​        4、重载关闭方法<code>close(Connection conn, Statement stmt)</code></p>
<h3 id="2-2、-案例"><a href="#2-2、-案例" class="headerlink" title="2.2、 案例"></a>2.2、 案例</h3><pre><code class="java">import java.sql.*;
public class JDBCUtils &#123;
    // 编写JDBC工具类步骤
    // 1.将固定字符串定义为常量
    private static final String URL = &quot;jdbc:mysql:///test&quot;;
    private static final String USER = &quot;root&quot;;
    private static final String PASSWORD = &quot;root&quot;;
    
    // 2.提供一个获取连接的方法`static Connection getConneciton();`
    // 谁使用谁处理异常, 这个方法把连接返回给别人使用,有问题也抛给他处理
    public static Connection getConnection() throws SQLException &#123;
        Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
        return conn;
    &#125;
    
    // 3.定义关闭资源的方法`close(Connection conn, Statement stmt, ResultSet rs)`
    // 谁使用谁处理异常, 其他地方调用close会传入 conn, stmt, rs给我们使用.就处理异常
    public static void close(Connection conn, Statement stmt, ResultSet rs) &#123;
        if (rs != null) &#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (stmt != null) &#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (conn != null) &#123; // 防止空指针
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    
    // 4.重载关闭方法`close(Connection conn, Statement stmt)`
    public static void close(Connection conn, Statement stmt) &#123;
        close(conn, stmt, null);
    &#125;
&#125;
</code></pre>
<h2 id="三、JDBC事务"><a href="#三、JDBC事务" class="headerlink" title="三、JDBC事务"></a>三、JDBC事务</h2><h3 id="3-1、JDBC事务使用步骤"><a href="#3-1、JDBC事务使用步骤" class="headerlink" title="3.1、JDBC事务使用步骤"></a>3.1、JDBC事务使用步骤</h3><ul>
<li><p><strong>注册驱动</strong></p>
</li>
<li><p><strong>获取连接</strong></p>
</li>
<li><p><strong>开启事务</strong></p>
</li>
<li><p><strong>获取到Statement</strong></p>
</li>
<li><p><strong>Statement执行SQL</strong></p>
</li>
<li><p><strong>提交或回滚事务</strong></p>
</li>
<li><p><strong>关闭资源</strong></p>
</li>
</ul>
<p>执行的流程就和在sql里面相似，但是在java程序中执行的话会有一定的语法差异</p>
<table>
<thead>
<tr>
<th>Connection接口中与事务有关的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>void setAutoCommit(boolean autoCommit)</td>
<td>false：开启事务， ture：关闭事务</td>
</tr>
<tr>
<td>void commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback()</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<h3 id="3-2、-案例"><a href="#3-2、-案例" class="headerlink" title="3.2、 案例"></a>3.2、 案例</h3><pre><code class="java">import com.itheima.utils.JDBCUtils;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
public class Demo &#123;
    public static void main(String[] args) &#123;
        Connection conn = null;
        Statement stmt = null;
        try &#123;
            // 1.注册驱动(自动注册)
            // 2.获取连接
            conn = JDBCUtils.getConnection();
            
            // 3.开启事务
            conn.setAutoCommit(false); // false会关闭自动提交,变成开启事务,我们手动提交
            
            // 4.获取到Statement
            stmt = conn.createStatement();
            // 5.Statement执行SQL
            // 张三-500
            stmt.executeUpdate(&quot;UPDATE account SET balance=balance-500 WHERE id=1;&quot;);
            // 模拟异常
            int a = 10 / 0;
            // 李四+500
            stmt.executeUpdate(&quot;UPDATE account SET balance=balance+500 WHERE id=2;&quot;);
            
            // 6.成功提交事务
            conn.commit();
            System.out.println(&quot;成功提交事务&quot;);
        &#125; catch (Exception e) &#123;
            
            // 7.失败回滚事务
            try &#123;
                if (conn != null) &#123;
                    conn.rollback();
                    System.out.println(&quot;失败回滚事务&quot;);
                &#125;
            &#125; catch (SQLException e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125; finally &#123;
            JDBCUtils.close(conn, stmt);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-3、JDBC实现登录以及SQL注入攻击"><a href="#3-3、JDBC实现登录以及SQL注入攻击" class="headerlink" title="3.3、JDBC实现登录以及SQL注入攻击"></a>3.3、JDBC实现登录以及SQL注入攻击</h3><p><strong>案例分析</strong>：</p>
<p>​        使用数据库保存用户的账号和密码<br>​        让用户输入账号和密码<br>​        使用SQL根据用户的账号和密码去数据库查询数据<br>​        如果查询到数据，说明登录成功<br>​        如果查询不到数据，说明登录失败</p>
<p><strong>代码</strong>：</p>
<pre><code class="java">import com.itheima.utils.JDBCUtils;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;
public class Demo &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.使用数据库保存用户的账号和密码
        
        // 2.让用户输入账号和密码
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入账号:&quot;);
        String name = sc.next();
        System.out.println(&quot;请输入密码:&quot;);
        String password = sc.next();
        
        // 3.使用SQL根据用户的账号和密码去数据库查询数据
        Connection conn = JDBCUtils.getConnection();
        Statement stmt = conn.createStatement();
        
        String sql = &quot;SELECT * FROM user WHERE name=&#39;&quot; + name + &quot;&#39; AND password=&#39;&quot; + password + &quot;&#39;;&quot;;
        System.out.println(&quot;sql = &quot; + sql); 
        // SELECT * FROM user WHERE name=&#39;hehe&#39; AND password=&#39;a&#39;or&#39;1&#39;=&#39;1&#39;;
        ResultSet rs = stmt.executeQuery(sql);
        
        // 4.如果查询到数据，说明登录成功
        // 5.如果查询不到数据，说明登录失败
        if (rs.next()) &#123;
            System.out.println(&quot;欢迎您, &quot; + name + &quot;登录成功!&quot;);
        &#125; else &#123; 
            System.out.println(&quot;登录失败, 用户名或密码错误!&quot;);
        &#125;
        
        // 6.关闭资源
        JDBCUtils.close(conn, stmt, rs);
    &#125;
&#125;
</code></pre>
<h4 id="3-3-1、SQL注入攻击："><a href="#3-3-1、SQL注入攻击：" class="headerlink" title="3.3.1、SQL注入攻击："></a><strong>3.3.1、SQL注入攻击：</strong></h4><p>正常来说正常登录是可以实现的，但是如果SQL语句换成</p>
<pre><code class="sql">SELECT * FROM user WHERE name=&#39;hehe&#39; AND password=&#39;a&#39;or&#39;1&#39;=&#39;1&#39;;
</code></pre>
<p>任何人都可以直接登录，主要是<strong>a’or’1’=’1</strong>的原因 ，<strong>or</strong>导致了数据库对传输进来的sql语句判断为<strong>true</strong>（or语句只要有一边为ture就都是true），则会判断账户以及密码比对正确，就会成功登录。</p>
<p><strong>SQL注入攻击的原理：</strong></p>
<p>​        按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成。但是现在Statement对象在执行sql语句时，将密码的一部分内容当做查询条件来执行了。</p>
<p><strong>解决SQL注入问题：</strong></p>
<p>​        为了避免这种情况的发生，Statement就被我们淘汰了，我们使用<strong>子接口PreparedStatement</strong></p>
<p>PreparedStatement预编译执行者对象</p>
<pre><code>     预编译：SQL语句在执行前就已经编译好了，执行速度更快。
     安全性更高：没有字符串拼接的SQL语句，所以避免SQL注入的问题
     代码的可读性更好，因为没有字符串拼接
</code></pre>
<h4 id="3-3-2、PreparedStatement使用"><a href="#3-3-2、PreparedStatement使用" class="headerlink" title="3.3.2、PreparedStatement使用"></a>3.3.2、PreparedStatement使用</h4><p>​         SQL语句中的参数使用?作为占位符， 给?占位符赋值。</p>
<p><strong>设置参数</strong></p>
<p> setXxx(参数1,参数2); </p>
<p>​         Xxx代表：数据类型<br>​         参数1：第几个? (编号从1开始)<br>         参数2：?的实际参数</p>
<p><strong>执行SQL语句</strong></p>
<pre><code class="java">//执行insert、update、delete语句
int executeUpdate();

//执行select语句
ResultSet executeQuery(); 
</code></pre>
<p><strong>PreparedStatement实现增删改</strong></p>
<pre><code class="java">import com.itheima.utils.JDBCUtils;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
/*
目标:使用PreparedStatement实现增删改
讲解:
    添加数据: 向user表添加1条记录
    注意:只有字段值不确定才能给?
 */
public class Demo &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.获取连接
        Connection conn = JDBCUtils.getConnection();
        // 2.编写参数化SQL(带?的SQL语句)
        String sql = &quot;INSERT INTO user VALUES (NULL, ?, ?)&quot;;
        // 3.为sql语句获取PreparedStatement对象
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 4.给?赋值
        // pstmt.setXxx(第几个?, 具体值);
        pstmt.setString(1, &quot;刘德华&quot;);
        pstmt.setString(2, &quot;666&quot;);
        // 5.执行
        int row = pstmt.executeUpdate();
        System.out.println(&quot;影响的行数: &quot; + row);
        // 6.释放资源
        JDBCUtils.close(conn, pstmt);
    &#125;
&#125;
</code></pre>
<h4 id="3-3-3、JDBC实现登陆之改进"><a href="#3-3-3、JDBC实现登陆之改进" class="headerlink" title="3.3.3、JDBC实现登陆之改进"></a>3.3.3、JDBC实现登陆之改进</h4><pre><code class="java">import com.itheima.utils.JDBCUtils;
import java.sql.*;
import java.util.Scanner;
public class Demo &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.使用数据库保存用户的账号和密码
        // 2.让用户输入账号和密码
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入账号:&quot;);
        String name = sc.next();
        System.out.println(&quot;请输入密码:&quot;);
        String password = sc.next();
        
        // 3.使用SQL根据用户的账号和密码去数据库查询数据
        Connection conn = JDBCUtils.getConnection();
        String sql = &quot;SELECT * FROM user WHERE name=? AND password=?;&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, name);
        pstmt.setString(2, password);
        ResultSet rs = pstmt.executeQuery();
        
        // 4.如果查询到数据，说明登录成功
        // 5.如果查询不到数据，说明登录失败
        if (rs.next()) &#123;
            System.out.println(&quot;欢迎您, &quot; + name + &quot;登录成功!&quot;);
        &#125; else &#123;
            System.out.println(&quot;登录失败, 用户名或密码错误!&quot;);
        &#125;
        // 6.关闭资源
        JDBCUtils.close(conn, pstmt, rs);
    &#125;
&#125;
</code></pre>
<h3 id="3-4、PreparedSatement查询数据"><a href="#3-4、PreparedSatement查询数据" class="headerlink" title="3.4、PreparedSatement查询数据"></a>3.4、PreparedSatement查询数据</h3><p>​        使用PreparedSatement实现查询数据，将查询出的数据保存到对象中。</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>定义User类</li>
<li>执行SQL语句，得到ResultSet</li>
<li>创建一个集合用于保存所有的用户对象</li>
<li>每次循环将一条记录存的数据放到一个用户对象中</li>
<li>把用户对象放到集合中</li>
<li>关闭资源</li>
<li>遍历集合操作数据</li>
</ul>
<p><strong>定义User类：</strong></p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private String password;
&#125;
</code></pre>
<p><strong>测试类：</strong></p>
<pre><code class="java">import com.itheima.utils.JDBCUtils;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
public class Demo &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.定义User类
        Connection conn = JDBCUtils.getConnection();
        String sql = &quot;SELECT * FROM user WHERE id&lt;=?;&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 给?赋值
        pstmt.setInt(1, 4); // 第1个?赋值为4
        // 2.执行SQL语句，得到ResultSet
        ResultSet rs = pstmt.executeQuery();
        // 3.创建一个集合用于保存所有的用户对象
        ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;();
        // 4.每次循环将一条记录存的数据放到一个用户对象中
        while (rs.next()) &#123;
            // 取出这条数据
            int id = rs.getInt(&quot;id&quot;);
            String name = rs.getString(&quot;name&quot;);
            String password = rs.getString(&quot;password&quot;);
            User user = new User(id, name, password);
            // 5.把用户对象放到集合中
            list.add(user);
        &#125;
        // 6.关闭资源
        JDBCUtils.close(conn, pstmt, rs);
        // 7.遍历集合操作数据, 以后只要操作User对象就有数据.不需要每次都查询数据库
        for (User user : list) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="四、连接池"><a href="#四、连接池" class="headerlink" title="四、连接池"></a>四、连接池</h2><h3 id="4-1、-连接池简介"><a href="#4-1、-连接池简介" class="headerlink" title="4.1、 连接池简介"></a>4.1、 连接池简介</h3><p><strong>之前JDBC访问数据库的步骤：</strong><br>        创建数据库连接→运行SQL语句→关闭连接 每次数据库访问执行这样重复的动作。</p>
<p><strong>每次创建数据库连接遇到的问题</strong>：</p>
<p>​        获取数据库连接需要消耗比较多的资源，而每次操作都要重新获取新的连接对象，执行一次操作就把连接关闭，而数据库创建连接通常需要消耗相对较多的资源。这样数据库连接对象的使用率低。</p>
<p><strong>连接池的概念</strong>：</p>
<p>​        连接池就是一个容器，连接池中保存了一些数据库连接，这些连接是可以重复使用的。</p>
<p><strong>连接池原理</strong>：</p>
<p>​        1、启动连接池，连接池就会初始化一些连接<br>​        2、当用户需要使用数据库连接，直接从连接池中取出<br>​        3、当用户使用完连接，会将连接重新放回连接池中</p>
<p><strong>常见的连接池</strong>：</p>
<p>​        阿里巴巴-德鲁伊Druid连接池：Druid是阿里巴巴开源平台上的一个项目<br>​        C3P0是一个开源的连接池，目前使用它的开源项目有Hibernate，Spring等。<br>​        DBCP(DataBase Connection Pool)数据库连接池，是Tomcat使用的连接池组件。</p>
<p>​        <strong>javax.sql.DataSource表示数据库连接池</strong>，是JDK中提供的一个<strong>接口</strong>，没有具体的实现，它的实现由连接池的厂商去实现。我们只需要学习这个工具如何使用即可。</p>
<pre><code class="java">public interface DataSource extends CommonDataSource, Wrapper&#123;
    Connection getConnection();
    ...
&#125;
</code></pre>
<h3 id="4-2、-C3P0连接池"><a href="#4-2、-C3P0连接池" class="headerlink" title="4.2、 C3P0连接池"></a>4.2、 C3P0连接池</h3><h4 id="4-2-1-C3P0连接池简介"><a href="#4-2-1-C3P0连接池简介" class="headerlink" title="4.2.1 C3P0连接池简介"></a>4.2.1 C3P0连接池简介</h4><blockquote>
<p> C3P0地址：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/c3p0/?source=navbar">https://sourceforge.net/projects/c3p0/?source=navbar</a></p>
</blockquote>
<h4 id="4-2-2-配置文件参数解释"><a href="#4-2-2-配置文件参数解释" class="headerlink" title="4.2.2 配置文件参数解释"></a>4.2.2 配置文件参数解释</h4><table>
<thead>
<tr>
<th>initialPoolSize</th>
<th>连接池刚启动时，连接池内包含的连接数量</th>
</tr>
</thead>
<tbody><tr>
<td>maxPoolSize</td>
<td>连接池中最多可以放多少个连接</td>
</tr>
<tr>
<td>checkoutTimeout</td>
<td>连接池中没有连接时最长等待时间</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>连接池中的空闲连接多久没有使用就会回收。默认是0，0表示不回收</td>
</tr>
</tbody></table>
<h4 id="4-2-3-C3P0连接池API"><a href="#4-2-3-C3P0连接池API" class="headerlink" title="4.2.3 C3P0连接池API"></a>4.2.3 C3P0连接池API</h4><table>
<thead>
<tr>
<th>public ComboPooledDataSource()</th>
<th>无参构造使用默认配置（使用xml中default-config标签中对应的参数）</th>
</tr>
</thead>
<tbody><tr>
<td>public ComboPooledDataSource(String configName)</td>
<td>有参构造使用命名配置（configName：xml中配置的名称，使用xml中named-config标签中对应的参数）</td>
</tr>
<tr>
<td>public Connection getConnection() throws SQLException</td>
<td>从连接池中取出一个连接</td>
</tr>
</tbody></table>
<h4 id="4-2-4-使用步骤"><a href="#4-2-4-使用步骤" class="headerlink" title="4.2.4 使用步骤"></a>4.2.4 使用步骤</h4><p>​        导入jar包c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar<br>​        复制配置文件c3p0-config.xml放在src目录下，配置对应参数<br>​        创建连接池对象ComboPooledDataSource<br>​        从连接池中获取连接对象<br>​        使用连接对象操作数据库<br>​        关闭资源，将连接还回连接池中</p>
<p><strong>【注意事项】</strong></p>
<p>​        注意事项C3P0配置文件名称必须为c3p0-config.xml<br>​        C3P0命名配置可以有多个</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/07/30/kuangstudy29a1b745-650c-4d74-a7ff-423156fba3ba.png" alt="img"></p>
<pre><code class="java">import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
public class Demo11 &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.导入jar包c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar
        // 2.复制配置文件c3p0-config.xml放在src目录下，配置对应参数
        // 3.创建连接池对象ComboPooledDataSource
        ComboPooledDataSource ds = new ComboPooledDataSource(); // 使用&lt;default-config&gt;这套配置
        // ComboPooledDataSource ds = new ComboPooledDataSource(&quot;nba&quot;); // 使用&lt;named-config name=&quot;nba&quot;&gt;这套配置
        // 4.从连接池中获取连接对象
        Connection conn = ds.getConnection();
        // 5.使用连接对象操作数据库
        String sql = &quot;DELETE FROM user WHERE id=?;&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.setInt(1, 5);
        pstmt.executeUpdate();
        // 6.关闭资源，将连接还回连接池中
        pstmt.close();
        conn.close(); // 连接的close是把连接放回连接池
    &#125;
&#125;
</code></pre>
<h3 id="4-3、Druid连接池"><a href="#4-3、Druid连接池" class="headerlink" title="4.3、Druid连接池"></a>4.3、Druid连接池</h3><h4 id="4-3-1、Druid连接池简介"><a href="#4-3-1、Druid连接池简介" class="headerlink" title="4.3.1、Druid连接池简介"></a>4.3.1、Druid连接池简介</h4><p>​        Druid是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。</p>
<p>​        <strong>特点：</strong>①日志监控，可以很好的监控数据库连接池和SQL的执行情况；②需要自行加载propertise文件；</p>
<p>​        <strong>下载地址：</strong><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/07/30/kuangstudy3325d26a-3611-49ce-8246-3e2493ff2f28.png" alt="img"></p>
<h4 id="4-3-2、-配置参数解释"><a href="#4-3-2、-配置参数解释" class="headerlink" title="4.3.2、 配置参数解释"></a>4.3.2、 配置参数解释</h4><table>
<thead>
<tr>
<th>initialSize</th>
<th>刚启动连接池时,连接池中包含连接的数量</th>
</tr>
</thead>
<tbody><tr>
<td>maxActive</td>
<td>连接池中最多可以放多少个连接</td>
</tr>
<tr>
<td>maxWait</td>
<td>获取连接时最大等待时间，单位毫秒</td>
</tr>
</tbody></table>
<p><strong>druid.properties</strong></p>
<pre><code class="java">url=jdbc:mysql://localhost:3306/数据库名
username=mysql账户
password=密码
driverClassName=com.mysql.jdbc.Driver //固定
initialSize=5  //连接池默认连接量5
maxActive=10    //连接池最大连接量10
maxWait=2000    //单位（毫秒）  最大等待时间2000毫秒
</code></pre>
<h4 id="4-3-3、使用步骤"><a href="#4-3-3、使用步骤" class="headerlink" title="4.3.3、使用步骤"></a>4.3.3、使用步骤</h4><p>首先需要创建连接池的方法：</p>
<table>
<thead>
<tr>
<th>public static DataSource createDataSource(Properties properties)</th>
<th>创建一个连接池，连接池的参数使用properties中的数据</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>可以看到需要添加参数的参数类型是properties，这里就是添加druid.properties配置文件中数据的地方啦,需要根据配置来创建连接池！</strong></p>
<pre><code class="java">import com.alibaba.druid.pool.DruidDataSourceFactory;
import com.itheima.utils.JDBCUtils;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.Properties;
public class Demo &#123;
    public static void main(String[] args) throws Exception &#123;
        //创建properties对象
        //加载properties文件的内容到Properties对象中（如果有不懂的朋友，可以看一下IO流附近的知识哦，属性集可以读取保存数据）
        Properties pp = new Properties();
        //我这里用的是类加载，
        pp.load(Demo02.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
        //    4.创建Druid连接池，使用配置文件中的参数
        DataSource dataSource = DruidDataSourceFactory.createDataSource(pp);
        //    5.从Druid连接池中取出连接
        Connection coon = dataSource.getConnection();
        //    6.执行SQL语句
        String sql = &quot;UPDATE  user SET ps=998 WHERE id=4;&quot;;
        PreparedStatement pps = coon.prepareStatement(sql);
        pps.executeUpdate();
        //    7.关闭资源
        JDBCUtils.close(coon,pps);
    &#125;
&#125;
</code></pre>
<h3 id="4-4、连接池工具类"><a href="#4-4、连接池工具类" class="headerlink" title="4.4、连接池工具类"></a>4.4、连接池工具类</h3><h4 id="4-4-1、-工具类使用步骤"><a href="#4-4-1、-工具类使用步骤" class="headerlink" title="4.4.1、 工具类使用步骤"></a>4.4.1、 工具类使用步骤</h4><p>​        声明静态连接池成员变量<br>​        创建连接池对象<br>​        定义得到连接对象的方法<br>​        定义关闭资源的方法</p>
<h4 id="4-4-2、-案例"><a href="#4-4-2、-案例" class="headerlink" title="4.4.2、 案例"></a>4.4.2、 案例</h4><pre><code class="java">import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;
// 这是一个连接池工具类.对Druid连接池的代码进行封装,让德鲁伊连接池使用更简单
public class DataSourceUtils &#123;
    
    // 1.声明静态连接池成员变量
    private static DataSource ds;
    
    // 使用静态代码块给静态成员变量赋值
    static &#123;
        System.out.println(&quot;静态代码块执行啦!&quot;);
        // 2.创建连接池对象
        Properties pp = new Properties();
        // FileInputStream fis = new FileInputStream(&quot;study_day20\\src\\druid.properties&quot;);
        InputStream in = DataSourceUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        try &#123;
            pp.load(in);
            ds = DruidDataSourceFactory.createDataSource(pp);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
    // 3.定义得到连接对象的方法
    public static Connection getConnection() throws SQLException &#123;
        return ds.getConnection(); // 从连接池中取一个连接去使用
    &#125;
    
    // 4.定义关闭资源的方法
    public static void close(Connection conn, Statement stmt, ResultSet rs) &#123;
        if (rs != null) &#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (stmt != null) &#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (conn != null) &#123; // 防止空指针
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    
    // 5.重载关闭方法`close(Connection conn, Statement stmt)`
    public static void close(Connection conn, Statement stmt) &#123;
        close(conn, stmt, null);
    &#125;
&#125;
</code></pre>
<pre><code class="java">import com.itheima.utils.DataSourceUtils;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
public class Demo03 &#123;
    public static void main(String[] args) throws SQLException &#123;
        // 1.从连接池工具类中取出连接
        Connection conn = DataSourceUtils.getConnection();
        // 2.执行SQL语句
        String sql = &quot;DELETE FROM user WHERE id=4;&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.executeUpdate();
        // 3.关闭资源
        DataSourceUtils.close(conn, pstmt);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#1bccbc>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/JDBC以及连接池/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Lombok使用详解/">
        <h2>
            Lombok使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Lombok使用详解"><a href="#Lombok使用详解" class="headerlink" title="Lombok使用详解"></a>Lombok使用详解</h1><h2 id="一、Lombok简介"><a href="#一、Lombok简介" class="headerlink" title="一、Lombok简介"></a>一、Lombok简介</h2><h3 id="1-1、-Idea插件安装"><a href="#1-1、-Idea插件安装" class="headerlink" title="1.1、 Idea插件安装"></a>1.1、 Idea插件安装</h3><p>File–Settings…–搜索plugins–搜索lombok，点击INSTALL即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200313172227657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211X3dpbmQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-2、maven中pom文件的导入"><a href="#1-2、maven中pom文件的导入" class="headerlink" title="1.2、maven中pom文件的导入"></a>1.2、maven中pom文件的导入</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="1-3、Lombok实现原理"><a href="#1-3、Lombok实现原理" class="headerlink" title="1.3、Lombok实现原理"></a>1.3、Lombok实现原理</h3><p>​        Lombok实现了JSR 269 API规范，javac在Java6开始支持这一规范，只要程序实现了该API，就能在javac运行的时候得到调用，那么Lombok在编译时使用的就是<strong>javac</strong>，具体流程如下：</p>
<p><img src="https://img-blog.csdn.net/20180315114050871" alt="img"></p>
<p>​        首先是项目的源代码文件，在经过编译处理以后，lombok会使用自己的抽象语法树去进行注解的匹配，如果在项目中的某一个类中使用了lombok中的注解，那么注解编译器就会自动去匹配项目中的注解对应到在lombok语法树中的注解文件，并经过自动编译匹配来生成对应类中的getter或者setter方法，达到简化代码的目的。执行顺序就如上图的叠放顺序。</p>
<h2 id="二、Lombok使用"><a href="#二、Lombok使用" class="headerlink" title="二、Lombok使用"></a>二、Lombok使用</h2><h3 id="2-1、-Data"><a href="#2-1、-Data" class="headerlink" title="2.1、 @Data"></a>2.1、 @Data</h3><p>​        @Data最常用的注解之一。注解在类上，提供该类所有属性的getter、setter方法，还提供了equals、canEqual、hashCode、toString方法。</p>
<pre><code class="java">@Data
public class Demo &#123;
    private int id;
    private String name;
&#125;
</code></pre>
<h3 id="2-2、-Setter-amp-Getter"><a href="#2-2、-Setter-amp-Getter" class="headerlink" title="2.2、@Setter&amp;@Getter"></a>2.2、@Setter&amp;@Getter</h3><p>​        @Setter和@Getter都能提供默认的构造方法，根据注解的位置，作用有所不同，以@Setter为例。</p>
<p>​        <strong>作用于属性上</strong>，为该属性提供setter方法：</p>
<pre><code class="java">public class Demo &#123;
  private int id;
  @Setter
  @Getter
  private String name;
&#125;
</code></pre>
<p>​        <strong>作用于类上</strong>，为该类所有的属性提供setter方法：</p>
<pre><code class="java">@Setter
@Getter
public class Demo &#123;
    private int id;
    private String name;
&#125;
</code></pre>
<h3 id="2-3、-Builder"><a href="#2-3、-Builder" class="headerlink" title="2.3、@Builder"></a>2.3、@Builder</h3><p>​        @Builder注释为你的类生成相对略微复杂的构建器API。@Builder可以让你以下面显示的那样调用你的代码，来初始化你的实例对象：</p>
<pre><code class="java">import lombok.Builder;

@Builder
public class Demo &#123;
    private int id;
    private String name;
&#125;

class Test &#123;
    public void test() &#123;
        Demo.builder().id(1).name(&quot;xiaoming&quot;).build();
    &#125;
&#125;
</code></pre>
<h3 id="2-4、-NonNull"><a href="#2-4、-NonNull" class="headerlink" title="2.4、@NonNull"></a>2.4、@NonNull</h3><p>​        作用于属性上，提供关于此参数的<strong>非空检查</strong>，如果参数为空，则抛出空指针异常。下面做一个对比。</p>
<pre><code class="java">import lombok.NonNull;

// 使用lombok：
public class NonNullExample extends Something &#123;
    private String name;  
    public NonNullExample(@NonNull Person person) &#123;
    super(&quot;Hello&quot;);
    this.name = person.getName();
&#125;
    
// 不使用lombok：
public class NonNullExample2 extends Something &#123;
    private String name; 
    public NonNullExample2(@NonNull Person person) &#123;
        super(&quot;Hello&quot;);
        if (person == null) &#123;
            throw new NullPointerException2(&quot;person&quot;);
        &#125;
        this.name = person.getName();
    &#125;
&#125;
</code></pre>
<h3 id="2-5、-Log4j-amp-Slf4j"><a href="#2-5、-Log4j-amp-Slf4j" class="headerlink" title="2.5、@Log4j&amp;@Slf4j"></a>2.5、@Log4j&amp;@Slf4j</h3><p>​        @Log4j作用于类上，为该类提供一个属性名为log的log4j日志对象。</p>
<pre><code class="java">@Log4j
public class Demo &#123;
&#125;
</code></pre>
<p>​        该属性一般使用于Controller、Service等业务处理类上。与此注解相同的还有@Log4j2，顾名思义，针对Log4j2。</p>
<p>​        @Slf4j：在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；</p>
<pre><code class="java">@Slf4j
public class Demo &#123;
&#125;
</code></pre>
<h3 id="2-6、-AllArgsConstructor"><a href="#2-6、-AllArgsConstructor" class="headerlink" title="2.6、@AllArgsConstructor"></a>2.6、@AllArgsConstructor</h3><p>​        作用于类上，为该类提供一个<strong>包含全部参数的构造方法</strong>，注意此时默认构造方法不会提供。</p>
<pre><code class="java">@AllArgsConstructor
public class Demo &#123;
    private int id;
    private String name;
&#125;
</code></pre>
<h3 id="2-7、-NoArgsConstructor"><a href="#2-7、-NoArgsConstructor" class="headerlink" title="2.7、@NoArgsConstructor"></a>2.7、@NoArgsConstructor</h3><p>​        作用于类上，提供一个<strong>无参的构造方法</strong>。可以和@AllArgsConstructor同时使用，此时会生成两个构造方法：无参构造方法和全参构造方法。</p>
<pre><code class="java">@NoArgsConstructor
public class Demo &#123;
    private int id;
    private String name;
&#125;
</code></pre>
<h3 id="2-8、-EqualsAndHashCode"><a href="#2-8、-EqualsAndHashCode" class="headerlink" title="2.8、@EqualsAndHashCode"></a>2.8、@EqualsAndHashCode</h3><p>​        作用于类上，生成equals、canEqual、hashCode方法。具体效果参看最开始的@Data效果。</p>
<h3 id="2-9、-RequiredArgsConstructor"><a href="#2-9、-RequiredArgsConstructor" class="headerlink" title="2.9、@RequiredArgsConstructor"></a>2.9、@RequiredArgsConstructor</h3><p>​        作用于类上，由类中所有带有@NonNull注解或者带有final修饰的成员变量作为参数生成构造方法。</p>
<h3 id="2-10、-Cleanup"><a href="#2-10、-Cleanup" class="headerlink" title="2.10、@Cleanup"></a>2.10、@Cleanup</h3><p>​        作用于变量，保证该变量代表的资源会被自动关闭，默认调用资源的close()方法，如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定。</p>
<pre><code class="java">public void jedisExample(String[] args) &#123;
    try &#123;
        @Cleanup Jedis jedis = redisService.getJedis();
    &#125; catch (Exception ex) &#123;
        logger.error(“Jedis异常:”,ex)
    &#125;
&#125;

// 效果如下：
public void jedisExample(String[] args) &#123;

    Jedis jedis= null;
    try &#123;
        jedis = redisService.getJedis();
    &#125; catch (Exception e) &#123;
        logger.error(“Jedis异常:”,ex)
    &#125; finally &#123;
        if (jedis != null) &#123;
            try &#123;
                jedis.close();
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2-11、-ToString"><a href="#2-11、-ToString" class="headerlink" title="2.11、@ToString"></a>2.11、@ToString</h3><p>​        作用于类上，生成包含所有参数的toString方法。见@Data中toString方法。</p>
<pre><code class="java">//排除column列所对应的元素，即在生成toString方法时不包含column参数；
@ToString(exclude=&quot;column&quot;)

//排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数
@ToString(exclude=&#123;&quot;column1&quot;,&quot;column2&quot;&#125;)

//只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；
@ToString(of=&quot;column&quot;)

//只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；
@ToString(of=&#123;&quot;column1&quot;,&quot;column2&quot;&#125;)
public class Demo &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
<h3 id="2-12、-Value"><a href="#2-12、-Value" class="headerlink" title="2.12、@Value"></a>2.12、@Value</h3><p>​        作用于类上，会生成全参数的构造方法、getter方法、equals、hashCode、toString方法。与@Data相比多了全参构造方法，少了默认构造方法、setter方法和canEqual方法。</p>
<p>​        该注解需要注意的是：<strong>会将字段添加上final修饰</strong>。</p>
<h3 id="2-13、-SneakyThrows"><a href="#2-13、-SneakyThrows" class="headerlink" title="2.13、@SneakyThrows"></a>2.13、@SneakyThrows</h3><p>​        作用于方法上，相当于把方法内的代码添加了一个try-catch处理，捕获异常catch中用Lombok.sneakyThrow(e)抛出异常。使用@SneakyThrows(BizException.class)指定抛出具体异常。</p>
<pre><code class="java">@SneakyThrows
public int getValue()&#123;
    int a = 1;
    int b = 0;
    return a/b;
&#125;

// 效果如下：
public int getValue() &#123;
    try &#123;
        int a = 1;
        int b = 0;
        return a / b;
    &#125; catch (Throwable var3) &#123;
        throw var3;
    &#125;
&#125;
</code></pre>
<h3 id="2-14、-Synchronized"><a href="#2-14、-Synchronized" class="headerlink" title="2.14、@Synchronized"></a>2.14、@Synchronized</h3><p>​        作用于类方法或实例方法上，效果与synchronized相同。区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized的锁对象分别是私有静态final对象lock和私有final对象lock。也可以指定锁对象。</p>
<pre><code class="java">public class FooExample &#123;

    private final Object readLock = new Object();

    @Synchronized
    public static void hello() &#123;
        System.out.println(&quot;world&quot;);
    &#125;

    @Synchronized(&quot;readLock&quot;)
    public void foo() &#123;
        System.out.println(&quot;bar&quot;);
    &#125;
&#125;


// 效果如下：
public class FooExample &#123;

    private static final Object $LOCK = new Object[0];
    private final Object readLock = new Object();

    public static void hello() &#123;
        synchronized ($LOCK) &#123;
            System.out.println(&quot;world&quot;);
        &#125;
    &#125;

    public void foo() &#123;
        synchronized (readLock) &#123;
            System.out.println(&quot;bar&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2-15、val"><a href="#2-15、val" class="headerlink" title="2.15、val"></a>2.15、val</h3><p>​        使用val作为局部变量声明的类型，而不是实际写入类型。执行此操作时，将从初始化表达式推断出类型。</p>
<pre><code class="java">public Map&lt;String, String&gt; getMap() &#123;
    val map = new HashMap&lt;String, String&gt;();
    map.put(&quot;1&quot;, &quot;a&quot;);
    return map;
&#125;


// 效果如下：
public Map&lt;String, String&gt; getMap() &#123;
    HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put(&quot;1&quot;, &quot;a&quot;);
    return map;
&#125;
</code></pre>
<p>​        也就是说在局部变量中，Lombok帮你推断出具体的类型，但只能用于局部变量中。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#1bccbc>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Lombok使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/JDBC连接数据库/">
        <h2>
            JDBC连接数据库
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h1><h2 id="一、加载JDBC驱动程序"><a href="#一、加载JDBC驱动程序" class="headerlink" title="一、加载JDBC驱动程序"></a>一、加载JDBC驱动程序</h2><p>​        在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），  这通过java.lang.Class类的<strong>静态方法</strong>forName(String className)实现，成功加载后，会将Driver类的实例注册到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=DriverManager&spm=1001.2101.3001.7020">DriverManager</a>类中。</p>
<pre><code class="java">static&#123;
    try &#123;
        // 加载数据库驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    &#125;
    catch (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h2 id="二、提供JDBC连接的URL"><a href="#二、提供JDBC连接的URL" class="headerlink" title="二、提供JDBC连接的URL"></a>二、提供JDBC连接的URL</h2><pre><code>     JDBC连接的URL格式为：协议：子协议：数据源标识  。 其中：
</code></pre>
<ul>
<li><p>协议：在JDBC中总是以jdbc开始 。</p>
</li>
<li><p>子协议：是桥连接的驱动程序或是数据库管理系统名称。  </p>
</li>
<li><p>数据源标识：标记找到数据库来源的地址与连接端口。</p>
</li>
</ul>
<pre><code class="java">// 连接MySql数据库 

String url = &quot;jdbc:mysql://localhost:3306/数据库名&quot; ;    

String username = &quot;root&quot; ;   

String password = &quot; &quot; ;  
</code></pre>
<h2 id="三、创建数据库的连接"><a href="#三、创建数据库的连接" class="headerlink" title="三、创建数据库的连接"></a>三、创建数据库的连接</h2><pre><code class="csharp">public static Connection getConn()&#123;

    Connection conn = null;
    try &#123;
        // 连接数据库
        conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/数据库名&quot;, &quot;root&quot;,&quot; &quot;);    
    &#125;catch(SQLException e)&#123;
        e.printStackTrace();
    &#125;
    return conn;
&#125;
</code></pre>
<h2 id="四、驱动的区别"><a href="#四、驱动的区别" class="headerlink" title="四、驱动的区别"></a>四、驱动的区别</h2><h3 id="4-1、区别"><a href="#4-1、区别" class="headerlink" title="4.1、区别"></a>4.1、区别</h3><p>​        <code>com.mysql.jdbc.Driver</code> 是 mysql-connector-java 5中的，<br>​        <code>com.mysql.cj.jdbc.Driver</code> 是 mysql-connector-java 6中的</p>
<p>1、JDBC连接Mysql5 <code>com.mysql.jdbc.Driver</code>:</p>
<pre><code class="properties">driverClassName = com.mysql.jdbc.Driver
url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
username = root
password = &quot; &quot;
</code></pre>
<p>2、JDBC连接Mysql6 <code>com.mysql.cj.jdbc.Driver</code>， 需要指定时区<strong>serverTimezone</strong>:</p>
<pre><code class="properties">driverClassName = com.mysql.cj.jdbc.Driver
url = jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC&amp;?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
username = root
password = &quot; &quot;
</code></pre>
<p>​        在设定时区的时候，如果设定serverTimezone=UTC，会比中国时间早8个小时，如果在中国，可以选择Asia/Shanghai或者Asia/Hongkong，例如：</p>
<pre><code class="properties">driverClassName = com.mysql.cj.jdbc.Driver
url = jdbc:mysql://localhost:3306/数据库名?serverTimezone=Shanghai&amp;?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
username = root
password = &quot; &quot;
</code></pre>
<h3 id="4-2、依赖区别"><a href="#4-2、依赖区别" class="headerlink" title="4.2、依赖区别"></a>4.2、依赖区别</h3><p>1、如果mysql-connector-java用的6.0以上的，如下：</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        但是你的driver用的还是<code>com.mysql.jdbc.Driver</code>，就会报错：</p>
<pre><code class="java">Loading class &#39;com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is &#39;com.mysql.cj.jdbc.Driver&#39;. 
The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
</code></pre>
<p>​        此时需要把<code>com.mysql.jdbc.Driver</code> 改为<code>com.mysql.cj.jdbc.Driver</code></p>
<p>2、还有一个警告：</p>
<pre><code class="java">WARN: Establishing SSL connection without server’s identity verification is not recommended. 
According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. 
For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. 
You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
</code></pre>
<p>​        不推荐不使用服务器身份验证来建立SSL连接。<br>​        如果未明确设置，MySQL 5.5.45+、5.6.26+ 以及 5.7.6+版本默认要求建立SSL连接。<br>​        为了符合当前不使用SSL连接的应用程序，<code>verifyServerCertificate</code>属性设置为<strong>false</strong>。<br>​        如果你不需要使用SSL连接，你需要通过设置<code>useSSL=false</code>来显式禁用SSL连接。<br>​        如果你需要用SSL连接，就要为服务器证书验证提供信任库，并设置<code>useSSL=true</code>。</p>
<p>​        SSL – Secure Sockets Layer（安全套接层）</p>
<h3 id="4-2、MySql驱动8-0-11版本的一些使用注意事项"><a href="#4-2、MySql驱动8-0-11版本的一些使用注意事项" class="headerlink" title="4.2、MySql驱动8.0.11版本的一些使用注意事项"></a>4.2、MySql驱动8.0.11版本的一些使用注意事项</h3><p>1、解决java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone.</p>
<p>添加格式：</p>
<pre><code class="ruby">?serverTimezone = GMT%2B8;
</code></pre>
<p>​        使用的数据库是MySQL，驱动是8.0.11，这是由于数据库和系统时区差异所造成的，在jdbc连接的url后面加上serverTimezone=GMT即可解决问题，如果需要使用gmt+8时区，需要写成GMT%2B8，否则会被解析为空。再一个解决办法就是使用低版本的MySQL jdbc驱动，5.1.28不会存在时区的问题。</p>
<p>2、解决：Fri May 18 15:00:19 CST 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</p>
<p>​        在后面加入：</p>
<pre><code class="java">useSSL=false
</code></pre>
<p>3、解决：Loading class <code>com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is </code>com.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</p>
<pre><code class="java">// 改变驱动，改为下方驱动
driverClass=&quot;com.mysql.jdbc.Driver&quot;

driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
</code></pre>
<p><strong>最终如下：</strong></p>
<pre><code class="xml">&lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
     connectionURL=&quot;jdbc:mysql://localhost:3306/springmvc?serverTimezone=GMT%2B8&amp;useSSL=false&quot; 
     userId=&quot;root&quot; password=&quot;root&quot;&gt;
&lt;/jdbcConnection&gt;
</code></pre>
<h2 id="五、创建Statement"><a href="#五、创建Statement" class="headerlink" title="五、创建Statement"></a>五、创建Statement</h2><p>​        要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：</p>
<ul>
<li><p>  执行<strong>静态SQL</strong>语句。通常通过Statement实例实现。</p>
</li>
<li><p>  执行<strong>动态SQL</strong>语句。通常通过PreparedStatement实例实现。</p>
</li>
<li><p>  执行<strong>数据库存储</strong>过程。通常通过CallableStatement实例实现。</p>
</li>
</ul>
<p>  ​    代码如下：</p>
<pre><code class="typescript">public static Statement getStmt(Connection conn)&#123;
    
    Statement stmt = null;

    try &#123;
        stmt = conn.createStatement();
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125;
    
    return stmt;
&#125;
</code></pre>
<h2 id="六、执行SQL语句"><a href="#六、执行SQL语句" class="headerlink" title="六、执行SQL语句"></a>六、执行SQL语句</h2><p>​        Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate  和execute 。</p>
<ul>
<li><p>  ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句  ，返回一个结果集（ResultSet）对象。</p>
</li>
<li><p>  int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或  DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等  </p>
</li>
<li><p>  execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的  语句。</p>
</li>
</ul>
<p>  ​    代码如下：</p>
<pre><code class="java">public static ResultSet executeQuery(Statement stmt,String sql)&#123;
    ResultSet rs = null;
    try &#123;
        rs = stmt.executeQuery(sql);
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125;
    return rs; 
&#125;
</code></pre>
<h2 id="七、处理结果"><a href="#七、处理结果" class="headerlink" title="七、处理结果"></a>七、处理结果</h2><p>​         两种情况：  </p>
<ul>
<li><p>  执行更新返回的是本次操作影响到的记录数。  </p>
</li>
<li><p>执行查询返回的结果是一个ResultSet对象。  </p>
<pre><code>     ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问。
</code></pre>
</li>
</ul>
<p>  ​      使用结果集（ResultSet）对象的访问方法获取数据，代码如下：</p>
<pre><code class="java">while(rs.next())&#123;             
    String name = rs.getString(&quot;name&quot;) ;        
    String pass = rs.getString(1) ; // 此方法比较高效         
&#125;
</code></pre>
<h2 id="八、关闭JDBC对象"><a href="#八、关闭JDBC对象" class="headerlink" title="八、关闭JDBC对象"></a>八、关闭JDBC对象</h2><p>​         操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：</p>
<ul>
<li><p>  关闭记录集</p>
</li>
<li><p>  关闭声明  </p>
</li>
<li><p>  关闭连接对象</p>
</li>
</ul>
<p>  ​    代码如下：</p>
<pre><code class="java">//关闭结果集
public static void closeRs(ResultSet rs)&#123;
    try &#123;
        if(rs != null )&#123;
            rs.close();
            rs = null;
        &#125;
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125; 
&#125;

//关闭执行方法
public static void closeStmt(Statement stmt)&#123;
    try &#123;
        if(stmt != null )&#123;
            stmt.close();
            stmt = null;
        &#125;
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125; 

&#125;

//关闭连接
public static void closeConn(Connection conn)&#123;
    try &#123;
        if(conn != null )&#123;
            conn.close();
            conn = null;
        &#125;
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h2 id="九、JDBC连接数据库工具类"><a href="#九、JDBC连接数据库工具类" class="headerlink" title="九、JDBC连接数据库工具类"></a>九、JDBC连接数据库工具类</h2><pre><code class="java">import java.sql.*;

public class DB &#123;
    static&#123;
        try &#123;
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载数据库驱动
        &#125;
        catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private DB() &#123;&#125;

    public static Connection getConn()&#123;
        Connection conn = null;
        try &#123;
            //连接数据库    
            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db_baima&quot;, &quot;root&quot;,&quot;123456&quot;);
            
        &#125;catch(SQLException e)&#123;
            e.printStackTrace();
        &#125;
        return conn;
    &#125;

    public static void closeConn(Connection conn)&#123;
        try &#123;
            if(conn != null )&#123;
                conn.close();
                conn = null;
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static Statement getStmt(Connection conn)&#123;
        Statement stmt = null;
        try &#123;
            stmt = conn.createStatement();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return stmt;
    &#125;

    public static PreparedStatement getPStmt(Connection conn,String sql)&#123;
        PreparedStatement pstmt = null;
        try &#123;
            pstmt = conn.prepareStatement(sql);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return pstmt;
    &#125;

    public static void closeStmt(Statement stmt)&#123;
        try &#123;
            if(stmt != null )&#123;
                stmt.close();
                stmt = null;
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; 

    &#125;

    public static ResultSet executeQuery(Statement stmt,String sql)&#123;
        ResultSet rs = null;
        try &#123;
            rs = stmt.executeQuery(sql);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return rs; 
    &#125;

    public static void closeRs(ResultSet rs)&#123;
        try &#123;
            if(rs != null )&#123;
                rs.close();
                rs = null;
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; 
    &#125; 

    public static ResultSet executeQuery(Connection conn,String sql)&#123;//重载
        ResultSet rs = null;
        try &#123;
            rs = conn.createStatement().executeQuery(sql);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return rs;  
    &#125; 
&#125;
</code></pre>
<p>工具类使用说明代码：</p>
<pre><code class="java">//插入数据
public static void saveinfo(Object[] data) throws ParseException&#123;
    Connection conn = null;
    PreparedStatement pstmt = null;
try &#123;
    conn= DB.getConn();
    String sql = &quot;insert into information value (null,?,?,?,?,?,?,?) &quot;;
    pstmt = DB.getPStmt(conn, sql);
    pstmt.setString(1,(String) data[0]);
    pstmt.setString(2, (String) data[1]);
    pstmt.setString(3,(String) data[2]);
    pstmt.setString(4,(String) data[3]); 
    pstmt.setString(5,(String) data[4]);
    pstmt.setString(6,(String) data[5]);
    pstmt.setTimestamp(7 ,(Timestamp)data[6]);
    pstmt.executeUpdate();
    &#125; 
    catch (SQLException e) &#123;
        e.printStackTrace();
    &#125;
    finally&#123;
        DB.closeStmt(pstmt);
        DB.closeConn(conn);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#879cff>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/JDBC连接数据库/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/">
        <h2>
            Mybaits知识点
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、概念、使用方法向的问题"><a href="#一、概念、使用方法向的问题" class="headerlink" title="一、概念、使用方法向的问题"></a>一、概念、使用方法向的问题</h2><h3 id="1-1、Mybaits介绍"><a href="#1-1、Mybaits介绍" class="headerlink" title="1.1、Mybaits介绍"></a>1.1、Mybaits介绍</h3><p>​        （1）Mybatis是一个<strong>半ORM框架</strong>，它<strong>内部封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>​        （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后<u>由mybatis框架执行sql并将结果映射为java对象并返回</u>。</p>
<h3 id="1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</h3><p>​        <strong>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。</strong>Hibernate是个完整的ORM框架，而MyBatis只完成了<strong>关系-&gt;对象</strong>，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>​        （1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>​        （2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询。</p>
<p>​        （3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3、-Mybaits的优点"><a href="#1-3、-Mybaits的优点" class="headerlink" title="1.3、 Mybaits的优点?"></a><strong>1.3、 Mybaits的优点?</strong></h3><p>​        （1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>​        （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>​        （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>​        （4）能够与Spring很好的集成；</p>
<p>​        （5）<strong>提供映射标签</strong>，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-、MyBatis框架的缺点"><a href="#1-4-、MyBatis框架的缺点" class="headerlink" title="1.4 、MyBatis框架的缺点?"></a>1.4 、MyBatis框架的缺点?</h3><p>​        （1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>​        （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5、-和-的区别"><a href="#1-5、-和-的区别" class="headerlink" title="1.5、 #{}和${}的区别?"></a>1.5、 #{}和${}的区别?</h3><p>​        （1）**${}<strong>是properties文件中的</strong>变量占位符**，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>​        （2）**#{}<strong>是sql的</strong>参数占位符<strong>，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。</strong>使用#{}可以有效的防止 SQL 注入**，提高系统安全性。</p>
<pre><code class="sql">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，
举例：
order by $&#123;param&#125;
则解析成的sql为：
order by id


#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，
举例：
select * from table where name = #&#123;param&#125;，
则解析成的sql为：
select * from table where name = &quot;id&quot;
</code></pre>
<h3 id="1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</h3><p>​        （1）通过在查询的sql语句中定义字段名的<strong>别名</strong>，使字段名的别名和实体类的属性名一致</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; parameterType=&quot;java.lang.Integer&quot; resultetype=&quot;com.en.entity.user&quot;&gt;
    select user_id as id, user_no as no from test where user_id = #&#123;id&#125;;
&lt;/select&gt;
</code></pre>
<p>​        （2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<pre><code class="xml">&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;
    &lt;!–用id标签来映射主键字段–&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&gt;
        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;
        &lt;result property=&quot;no&quot; column=&quot;user_no&quot;/&gt;
    &lt;/id&gt;
&lt;/reslutMap&gt;
</code></pre>
<h3 id="1-7、-如何在mapper中传递多个参数"><a href="#1-7、-如何在mapper中传递多个参数" class="headerlink" title="1.7、 如何在mapper中传递多个参数?"></a>1.7、 如何在mapper中传递多个参数?</h3><p>​        （1）使用 <a target="_blank" rel="noopener" href="https://github.com/param">@param</a> 注解：</p>
<pre><code class="java">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);
</code></pre>
<p>​        （2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap();
map.put(&quot;start&quot;, start);
map.put(&quot;end&quot;, end);
sqlSession.selectList(&quot;student.selectUser&quot;, map);
</code></pre>
<h3 id="1-8、-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8、-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8、 MyBatis的接口绑定有哪些实现方式？"></a>1.8、 MyBatis的接口绑定有哪些实现方式？</h3><p>​        <strong>接口绑定</strong>有两种实现方式：</p>
<p>​        （1）一种是<strong>通过注解绑定</strong>，就是在接口的方法上面加上<a target="_blank" rel="noopener" href="https://github.com/Select">@Select</a>、<a target="_blank" rel="noopener" href="https://github.com/Update">@Update</a>等注解里面包含Sql语句来绑定。</p>
<pre><code class="java">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)
@Results(
         id = &quot;distTypeMap&quot;,
         value =&#123;
            @Result(id =true,property=&quot;id&quot;,column=&quot;ID&quot;)，
            @Result(property=&quot;code&quot;,column=&quot;CODE&quot;)，
            @Result(property=&quot;name&quot;,column=&quot;NAME&quot;)，
            @Result(
                property = &quot;dictDtos&quot; ,
                column = &quot;ID&quot;,
                many = @Many(
                    select = &quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,
                    fetchType = FetchType.EAGER
                )
            )
        &#125;
)
List&lt;SysDictTypeDto&gt; getAllDist();
</code></pre>
<p>​        （2）另外一种就是<strong>通过xml里面写SQL来绑定</strong>，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<pre><code class="java">&lt;mapper namespace=&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;
&lt;select id=&quot;queryFileDisposeInfo&quot; parameterType=&quot;FileDisposeVo&quot; resultMap=&quot;illegalcollection-map&quot;&gt;
   SELECT 
        BATCH_NUMBER,
        FINISH_DATE,
        FILE_NAME,
        FILE_SIZE,
        DATA_SIZE,
        FILE_TYPE,
        ORG_CODE
   FROM 
        T_FILE_DISPOSE
&lt;/select&gt;
</code></pre>
<h3 id="1-9、-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9、-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9、 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9、 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>​        （1）Mapper接口<strong>方法名</strong>和mapper.xml中定义的每个<strong>sql的id</strong>相同；<br>​        （2）Mapper接口方法的<strong>输入参数类型</strong>和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>​        （3）Mapper接口方法的<strong>输出参数类型</strong>和mapper.xml中定义的每个sql的resultType的类型相同；<br>​        （4）Mapper.xml文件中的namespace即是mapper接口的<strong>类路径</strong>;</p>
<h2 id="二、源码向的问题"><a href="#二、源码向的问题" class="headerlink" title="二、源码向的问题"></a>二、源码向的问题</h2><h3 id="2-1、-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1、-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1、 解释下MyBatis面向Mapper编程工作原理？"></a>2.1、 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>​        Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的<strong>动态代理</strong>，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2、 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2、 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>​        在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了<strong>接口全限名+方法名</strong>的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<pre><code class="java">id = applyCurrentNamespace(id, false);
public String applyCurrentNamespace(String base, boolean isReference) &#123;
   ...
   // 返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)
   return currentNamespace + &quot;.&quot; + base;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200920171405540.png" alt="img"></p>
<h3 id="2-3、-Mybatis动态sql执行原理"><a href="#2-3、-Mybatis动态sql执行原理" class="headerlink" title="2.3、 Mybatis动态sql执行原理?"></a>2.3、 Mybatis动态sql执行原理?</h3><p>​        （1）<strong>初始化阶段：</strong>通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>​        （2）<strong>代理阶段：</strong>先从Configuration配置类的MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>​        （3）<strong>数据读写阶段：</strong>通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4、-Mybatis的一级、二级缓存实现原理"><a href="#2-4、-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4、 Mybatis的一级、二级缓存实现原理?"></a>2.4、 Mybatis的一级、二级缓存实现原理?</h3><p>​        （1）<strong>一级缓存：</strong> 基于 PerpetualCache 的 HashMap 本地缓存，<strong>其存储作用域为 Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092018550771.png" alt="img"></p>
<p>​        （2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于<strong>其存储作用域为 Mapper(Namespace)级别</strong>。</p>
<p>​        Mybatis默认不打开二级缓存，可以在config文件中xml<code> &lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920190114946.png" alt="img"></p>
<p>​        （3）对于<strong>缓存数据更新机制</strong>，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-、Mybatis是如何进行分页的？"><a href="#2-5-、Mybatis是如何进行分页的？" class="headerlink" title="2.5 、Mybatis是如何进行分页的？"></a>2.5 、Mybatis是如何进行分页的？</h3><p>​        （1）<strong>SQL分页</strong>(物理分页)：</p>
<pre><code class="xml">&lt;select id=&quot;queryStudentsBySql&quot; parameterType=&quot;map&quot; resultMap=&quot;studentmapper&quot;&gt; 
    select * from student limit #&#123;start&#125; , #&#123;end&#125;
&lt;/select&gt;
</code></pre>
<p>​        （2）使用<strong>RowBounds</strong>实现分页(逻辑分页)：</p>
<pre><code class="java">Service:
    publicList queryRolesByPage(String roleName,int start,int limit) &#123;
        returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));
    &#125;


Dao:
    public List queryUsersByPage(String userName, RowBounds rowBounds);
</code></pre>
<p>​        （3）使用<strong>分页插件PageHelper</strong>：</p>
<p>​        添加依赖：</p>
<pre><code class="xml">&lt;!--分页--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        在mybatis-config.xml中配置PageInterceptor拦截器:</p>
<pre><code class="xml">&lt;!--2.配置分页插件，此插件必须配置在typeAliases后面--&gt;
&lt;plugins&gt;
     &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
&lt;!--分页合理化参数，默认文false；pageNum&lt;=0，查询第一页；pageNum&gt;总页数，查询最后一页--&gt;
         &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<pre><code class="java">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;
    PageHelper.startPage(pageNum, pageSize);
    List&lt;User&gt; userList = userMapper.queryByPage(userParam);
    Json json = new Json();
    return json;
&#125;
</code></pre>
<h3 id="2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>Executor</strong>是mybatis中的<strong>执行器接口</strong>:</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>BaseExecutor（基础执行器）：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了<strong>缓存管理和事务管理</strong>的能力，使用了<strong>模板模式</strong>，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现。BaseExecutor的一级缓存是会话级别的，增、删、改都会清空一级缓存；而CachingExecutor的二级缓存是应用级的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>CachingExecutor（缓存执行器）：</strong>直接实现Executor接口，使用装饰器模式<strong>提供二级缓存能力</strong>。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200705191437604.png"></p>
<p>​        <strong>BatchExecutor（批处理执行器）：</strong>BaseExecutor具体子类实现，在doUpdate方法中，<strong>提供批量执行多条SQL语句的能力</strong>；</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>SimpleExecutor（简单执行器）：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor（可重用执行器）：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-7、-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7、-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7、 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7、 Mybatis中如何指定使用哪一种Executor执行器？</h3><p>​        在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920183713811.png" alt="img"></p>
<blockquote>
<p>&lt;class=”reference-link”&gt;</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200920183657317.png" alt="img"></p>
<h3 id="2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092018294130.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200920183022252.png" alt="img"></p>
<p>​        Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9、-Mybatis中用到了哪些设计模式？"><a href="#2-9、-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9、 Mybatis中用到了哪些设计模式？"></a>2.9、 Mybatis中用到了哪些设计模式？</h3><p>​        日志模块：代理模式、适配器模式</p>
<p>​        数据源模块：代理模式、工厂模式</p>
<p>​        缓存模块：装饰器模式</p>
<p>​        初始化阶段：建造者模式</p>
<p>​        代理阶段：策略模式</p>
<p>​        数据读写阶段：模板模式</p>
<p>​        插件化开发：责任链模式</p>
<h2 id="三、Mybaits源码结构"><a href="#三、Mybaits源码结构" class="headerlink" title="三、Mybaits源码结构"></a>三、Mybaits源码结构</h2><h3 id="3-1-、源码包功能模块图"><a href="#3-1-、源码包功能模块图" class="headerlink" title="3.1 、源码包功能模块图"></a>3.1 、源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png" alt="img"></p>
<h3 id="3-2-、各包详细功能解析"><a href="#3-2-、各包详细功能解析" class="headerlink" title="3.2 、各包详细功能解析"></a>3.2 、各包详细功能解析</h3><p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                包含所有mapper 接口中用到的注解</p>
<p>​        <strong>org.apache.ibatis.binding：</strong></p>
<p>​                生成mapper 接口的动态代理并进行管理</p>
<p>​        <strong>org.apache.ibatis.builder：</strong></p>
<p>​                1、包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</p>
<p>​                2、BaseBuilder 构建器基类</p>
<p>​                3、XMLConfigBuilder 解析configuration.xml配置文件</p>
<p>​                4、XMLMapperBuilder 解析Mapper.xml配置文件</p>
<p>​                5、XMLStatementBuilder 解析selectupdatedelete 标签MapperAnnotationBuilder 注解式Mapper</p>
<p>​        <strong>org.apache.ibatis.cache：</strong></p>
<p>​                1、缓存功能实现、包含各种缓存装饰器</p>
<p>​                2、TransactionalCache 二级缓存功能实现</p>
<p>​        <strong>org.apache.ibatis.cursor：</strong></p>
<p>​                实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p>​        <strong>org.apache.ibatis.datasource：</strong></p>
<p>​                数据源 包括jndi数据源、连接池功能</p>
<p>​        <strong>org.apache.ibatis.executor：</strong></p>
<p>​                1、包含SQL语句执行器，核心功能包</p>
<p>​                2、功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</p>
<p>​        <strong>org.apache.ibatis.exceptions：</strong></p>
<p>​                框架异常，常见异常：TooManyResultsException</p>
<p>​        <strong>org.apache.ibatis.io：</strong></p>
<p>​                资源文件读取</p>
<p>​        <strong>org.apache.ibatis.jdbc：</strong></p>
<p>​                1、JDBC一些操作</p>
<p>​                2、SqlRunner SQL执行</p>
<p>​                3、ScriptRunner 脚本执行，可以执行建库语句</p>
<p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                1、日志功能，实现多种日志框架的对接</p>
<p>​                2、org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</p>
<p>​        <strong>org.apache.ibatis.mapping：</strong></p>
<p>​                配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p>​        <strong>org.apache.ibatis.parsing：</strong></p>
<p>​                1、解析工具包</p>
<p>​                2、GenericTokenParser：解析#{} ${} 这种占位符</p>
<p>​                3、XPathParser：XPath形式解析XML</p>
<p>​                4、PropertyParser: properties解析器</p>
<p>​        <strong>org.apache.ibatis.scripting：</strong></p>
<p>​                动态SQL语言实现，配置文件中<code>&lt;if&gt; &lt;where&gt; &lt;set&gt; &lt;foreach&gt; &lt;choose&gt; </code>功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p>​        <strong>org.apache.ibatis.session：</strong></p>
<p>​                1、主要实现SqlSession功能，非常核心包</p>
<p>​                2、官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</p>
<p>​        <strong>org.apache.ibatis.transaction：</strong></p>
<p>​                事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p>​        <strong>org.apache.ibatis.type：</strong></p>
<p>​                类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="四、MyBatis初始化阶段"><a href="#四、MyBatis初始化阶段" class="headerlink" title="四、MyBatis初始化阶段"></a>四、MyBatis初始化阶段</h2><p>​        前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是<strong>将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级</strong>。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li>加载配置文件</li>
<li>解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li>根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="4-1、加载配置文件"><a href="#4-1、加载配置文件" class="headerlink" title="4.1、加载配置文件"></a>4.1、<strong>加载配置文件</strong></h3><p>​        下面我们来看一段经典查询操作：</p>
<pre><code class="java">String resouce = &quot;config/mybatis/mybatis-config.xml&quot;;
InputStream is = Resources.getResourceAsStream(resouce);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
SqlSession session = sqlSessionFactory.openSession();
user = session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);
</code></pre>
<p>​        以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="4-2、解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#4-2、解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="4.2、解析配置文件、将配置文件中的信息装载到Configuration中"></a>4.2、解析配置文件、将配置文件中的信息装载到Configuration中</h3><p>​        让我们来看一下梦开始的地方：</p>
<pre><code class="java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
</code></pre>
<p>​        跟进**build()**方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<pre><code class="java">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;
    try &#123;
      // 创建XMLConfigBuilder对象解析XML配置
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      // 将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory
      return build(parser.parse());
    &#125; 
    ....
&#125;
</code></pre>
<p>​        跟进<strong>parse()<strong>方法，我们可以看到parser.evalNode(“/configuration”)，</strong>evalNode</strong>为xml结点解析器，可以解析指定参数结点的信息，而”**/configuration**”则是mybatis.xml的根节点：</p>
<pre><code class="java">public Configuration parse() &#123;
    ...
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
&#125;
</code></pre>
<p>​        看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p>​        <strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p>​        <strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p>​        <strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200915222654319.png" alt="img"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p>​        Configuration类的源码实在太多，可以先了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p>​        <strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br>​        <strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br>​        <strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br>​        <strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>​        接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<pre><code class="java">parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
</code></pre>
<pre><code class="java">private void parseConfiguration(XNode root) &#123;
    try &#123;
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>​        点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915223612191.png" alt="img"></p>
<p>​        在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<pre><code class="java">XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>
<pre><code class="java">private void configurationElement(XNode context) &#123;
    try &#123;
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      ...
      builderAssistant.setCurrentNamespace(namespace);
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      cacheElement(context.evalNode(&quot;cache&quot;));
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>一一对应官网提供的节点信息进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915224121930.png" alt="img"></p>
<p>​        下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<pre><code class="java">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;
    for (XNode context : list) &#123;
      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
      try &#123;
        statementParser.parseStatementNode();
      &#125; catch (IncompleteElementException e) &#123;
        configuration.addIncompleteStatement(statementParser);
      &#125;
    &#125;
  &#125;
</code></pre>
<p>​        继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="4-3、根据Configuration创建SqlSessionFactory并返回"><a href="#4-3、根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="4.3、根据Configuration创建SqlSessionFactory并返回"></a>4.3、根据Configuration创建SqlSessionFactory并返回</h3><p>​        第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<pre><code class="java">public class SqlSessionFactoryBuilder &#123;
   ...
   public SqlSessionFactory build(Configuration config) &#123;
      return new DefaultSqlSessionFactory(config);
   &#125;
&#125;
</code></pre>
<p>​        此工厂内封装了Configuration对象：</p>
<pre><code class="java">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;
  private final Configuration configuration;
  public DefaultSqlSessionFactory(Configuration configuration) &#123;
    this.configuration = configuration;
  &#125;
  ...
&#125;
</code></pre>
<p>​        初始化阶段图解：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915225840294.png" alt="img"></p>
<p>​        至此，MyBatis初始化阶段完成。</p>
<h2 id="五、MyBatis代理阶段（binding模块分析）"><a href="#五、MyBatis代理阶段（binding模块分析）" class="headerlink" title="五、MyBatis代理阶段（binding模块分析）"></a>五、MyBatis代理阶段（binding模块分析）</h2><h3 id="5-1、MyBatis是如何做到面向Mapper接口编程？"><a href="#5-1、MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="5.1、MyBatis是如何做到面向Mapper接口编程？"></a>5.1、MyBatis是如何做到面向Mapper接口编程？</h3><p>​        只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User uer = userMapper.selectByPrimarKey(1);
</code></pre>
<p>​        MyBatis动态代理后执行的为下面这段代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
User uer = sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);
</code></pre>
<p>​        我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p>​        <strong>1、找到Session中对应的方法执行</strong></p>
<p>​        <strong>2、找到命名空间和方法名</strong></p>
<p>​        <strong>3、传递参数</strong></p>
<p>​        这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200916211402947.png" alt="img"></p>
<p>​        <strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<pre><code class="java">public class MapperRegistry &#123;
   private final Configuration config;
   //mapper接口和对应的代理对象工厂之间的关系
   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
   ...
&#125;
</code></pre>
<p>​        <strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<pre><code class="java">public class MapperProxyFactory&lt;T&gt; &#123;
  ...
  //key为mapper接口中的某个方法的method对象，value为对应的MapperMethod
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
  ...
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);
  &#125;
&#125;
</code></pre>
<p>​        <strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214700706.png" alt="img"></p>
<p>​        接着跟进**cachedInvoker(method).invoke(proxy, method, args, sqlSession)**方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200916213826490.png" alt="img"></p>
<p>​        我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214239389.png" alt="img"></p>
<p>​        那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214959863.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215029787.png" alt="img"></p>
<p>​        通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916215442588.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215556263.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215523383.png" alt="img"></p>
<h3 id="5-2、代理阶段流程梳理"><a href="#5-2、代理阶段流程梳理" class="headerlink" title="5.2、代理阶段流程梳理"></a>5.2、代理阶段流程梳理</h3><p>​        1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>​        2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>​        3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h2 id="六、MyBatis数据读写阶段"><a href="#六、MyBatis数据读写阶段" class="headerlink" title="六、MyBatis数据读写阶段"></a>六、MyBatis数据读写阶段</h2><h3 id="6-1、MyBatis是怎样的封装jdbc操作的"><a href="#6-1、MyBatis是怎样的封装jdbc操作的" class="headerlink" title="6.1、MyBatis是怎样的封装jdbc操作的"></a>6.1、MyBatis是怎样的封装jdbc操作的</h3><p>​        我们先来回忆一下jdbc代码：</p>
<pre><code class="java">//1.加载驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     
//2.获取连接conn
Connection con=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123&quot;);
//3.创建查询接口
Statement sta= con.createStatement();
//4.执行SQL，返回结果集
ResultSet rs= sta.executeQuery(&quot;SELECT * FROM `user`&quot;);
//5.对结果集数据进行操作
User user = new User();
user.setUserName(String.valueOf(rs.getObject(1)));
</code></pre>
<p>​        其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203050838.png" alt="img"></p>
<p>​        可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p>​        <strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p>​        <strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p>​        <strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>​        一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205236272.png" alt="img"></p>
<p>​        可以看到只有BaseExecutor和CachingExecutor两个类重写了**query()**方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<code>&lt;cache&gt;</code>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205454850.png" alt="img"></p>
<p>​        好的我们继续跟进BaseExecutor的**query()**方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210415293.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200917210606702.png" alt="img"></p>
<p>​        可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210831277.png" alt="img"></p>
<p>​        我们跟进默认实现SimpleExecutor的**doQuery()**方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211035123.png" alt="img"></p>
<p>​        这段代码有两点值得我们注意，一个是**prepareStatement(handler, ms.getStatementLog())**这个方法，我们跟进去会发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211124589.png" alt="img"></p>
<p>​        <strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919104808424.png" alt="img"></p>
<p>​        <strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p>​        <strong>CallableStatementHandler：</strong>调用存储过程</p>
<p>​        <strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p>​        <strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p>​        <strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>​        RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211725203.png" alt="img"></p>
<p>​        接上文调用SimpleStatementHandler的query方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211854628.png" alt="img"></p>
<p>​        <strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919110111271.png" alt="img"></p>
<p>​        处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li>创建multipleResults集合，保存最终返回的结果。</li>
<li>取出第一个结果集</li>
<li>获取对应的resultMap</li>
<li>根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</li>
<li>resultset.close()关闭结果集，将multipleResults集合返回</li>
</ol>
<h3 id="6-2、sqlSession查询流程图和Executor内部调用流程图"><a href="#6-2、sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="6.2、sqlSession查询流程图和Executor内部调用流程图"></a>6.2、sqlSession查询流程图和Executor内部调用流程图</h3><h4 id="6-2-1、sqlSession查询流程图："><a href="#6-2-1、sqlSession查询流程图：" class="headerlink" title="6.2.1、sqlSession查询流程图："></a>6.2.1、sqlSession查询流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911381497.png" alt="img"></p>
<h4 id="6-2-2、Executor内部调用流程图："><a href="#6-2-2、Executor内部调用流程图：" class="headerlink" title="6.2.2、Executor内部调用流程图："></a>6.2.2、Executor内部调用流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911204922.png" alt="img"></p>
<p>此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#ff7d73>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            Shuyan
        </div>
        <div class="descriptions">
            
            <div class="description">
                正しさなんてもの
            </div>
            
            <div class="description">
                人のモノサシによって変わる
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://en.korilin.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://jp.korilin.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>