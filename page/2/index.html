<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shuyan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ShuyanCoding......">
<meta property="og:type" content="website">
<meta property="og:title" content="Shuyan">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="ShuyanCoding......">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shuyan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shuyan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shuyan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JAVA/Spring框架/Mybaits/Mybaits知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9/">Mybaits知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、概念、使用方法向的问题"><a href="#一、概念、使用方法向的问题" class="headerlink" title="一、概念、使用方法向的问题"></a>一、概念、使用方法向的问题</h2><h3 id="1-1、Mybaits介绍"><a href="#1-1、Mybaits介绍" class="headerlink" title="1.1、Mybaits介绍"></a>1.1、Mybaits介绍</h3><p>​        （1）Mybatis是一个<strong>半ORM框架</strong>，它<strong>内部封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>​        （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后<u>由mybatis框架执行sql并将结果映射为java对象并返回</u>。</p>
<h3 id="1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</h3><p>​        <strong>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。</strong>Hibernate是个完整的ORM框架，而MyBatis只完成了<strong>关系-&gt;对象</strong>，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>​        （1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>​        （2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询。</p>
<p>​        （3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3、-Mybaits的优点"><a href="#1-3、-Mybaits的优点" class="headerlink" title="1.3、 Mybaits的优点?"></a><strong>1.3、 Mybaits的优点?</strong></h3><p>​        （1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>​        （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>​        （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>​        （4）能够与Spring很好的集成；</p>
<p>​        （5）<strong>提供映射标签</strong>，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-、MyBatis框架的缺点"><a href="#1-4-、MyBatis框架的缺点" class="headerlink" title="1.4 、MyBatis框架的缺点?"></a>1.4 、MyBatis框架的缺点?</h3><p>​        （1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>​        （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5、-和-的区别"><a href="#1-5、-和-的区别" class="headerlink" title="1.5、 #{}和${}的区别?"></a>1.5、 #{}和${}的区别?</h3><p>​        （1）**${}<strong>是properties文件中的</strong>变量占位符**，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>​        （2）**#{}<strong>是sql的</strong>参数占位符<strong>，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。</strong>使用#{}可以有效的防止 SQL 注入**，提高系统安全性。</p>
<pre><code class="sql">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，
举例：
order by $&#123;param&#125;
则解析成的sql为：
order by id


#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，
举例：
select * from table where name = #&#123;param&#125;，
则解析成的sql为：
select * from table where name = &quot;id&quot;
</code></pre>
<h3 id="1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</h3><p>​        （1）通过在查询的sql语句中定义字段名的<strong>别名</strong>，使字段名的别名和实体类的属性名一致</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; parameterType=&quot;java.lang.Integer&quot; resultetype=&quot;com.en.entity.user&quot;&gt;
    select user_id as id, user_no as no from test where user_id = #&#123;id&#125;;
&lt;/select&gt;
</code></pre>
<p>​        （2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<pre><code class="xml">&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;
    &lt;!–用id标签来映射主键字段–&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&gt;
        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;
        &lt;result property=&quot;no&quot; column=&quot;user_no&quot;/&gt;
    &lt;/id&gt;
&lt;/reslutMap&gt;
</code></pre>
<h3 id="1-7、-如何在mapper中传递多个参数"><a href="#1-7、-如何在mapper中传递多个参数" class="headerlink" title="1.7、 如何在mapper中传递多个参数?"></a>1.7、 如何在mapper中传递多个参数?</h3><p>​        （1）使用 <a target="_blank" rel="noopener" href="https://github.com/param">@param</a> 注解：</p>
<pre><code class="java">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);
</code></pre>
<p>​        （2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap();
map.put(&quot;start&quot;, start);
map.put(&quot;end&quot;, end);
sqlSession.selectList(&quot;student.selectUser&quot;, map);
</code></pre>
<h3 id="1-8、-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8、-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8、 MyBatis的接口绑定有哪些实现方式？"></a>1.8、 MyBatis的接口绑定有哪些实现方式？</h3><p>​        <strong>接口绑定</strong>有两种实现方式：</p>
<p>​        （1）一种是<strong>通过注解绑定</strong>，就是在接口的方法上面加上<a target="_blank" rel="noopener" href="https://github.com/Select">@Select</a>、<a target="_blank" rel="noopener" href="https://github.com/Update">@Update</a>等注解里面包含Sql语句来绑定。</p>
<pre><code class="java">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)
@Results(
         id = &quot;distTypeMap&quot;,
         value =&#123;
            @Result(id =true,property=&quot;id&quot;,column=&quot;ID&quot;)，
            @Result(property=&quot;code&quot;,column=&quot;CODE&quot;)，
            @Result(property=&quot;name&quot;,column=&quot;NAME&quot;)，
            @Result(
                property = &quot;dictDtos&quot; ,
                column = &quot;ID&quot;,
                many = @Many(
                    select = &quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,
                    fetchType = FetchType.EAGER
                )
            )
        &#125;
)
List&lt;SysDictTypeDto&gt; getAllDist();
</code></pre>
<p>​        （2）另外一种就是<strong>通过xml里面写SQL来绑定</strong>，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<pre><code class="java">&lt;mapper namespace=&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;
&lt;select id=&quot;queryFileDisposeInfo&quot; parameterType=&quot;FileDisposeVo&quot; resultMap=&quot;illegalcollection-map&quot;&gt;
   SELECT 
        BATCH_NUMBER,
        FINISH_DATE,
        FILE_NAME,
        FILE_SIZE,
        DATA_SIZE,
        FILE_TYPE,
        ORG_CODE
   FROM 
        T_FILE_DISPOSE
&lt;/select&gt;
</code></pre>
<h3 id="1-9、-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9、-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9、 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9、 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>​        （1）Mapper接口<strong>方法名</strong>和mapper.xml中定义的每个<strong>sql的id</strong>相同；<br>​        （2）Mapper接口方法的<strong>输入参数类型</strong>和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>​        （3）Mapper接口方法的<strong>输出参数类型</strong>和mapper.xml中定义的每个sql的resultType的类型相同；<br>​        （4）Mapper.xml文件中的namespace即是mapper接口的<strong>类路径</strong>;</p>
<h2 id="二、源码向的问题"><a href="#二、源码向的问题" class="headerlink" title="二、源码向的问题"></a>二、源码向的问题</h2><h3 id="2-1、-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1、-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1、 解释下MyBatis面向Mapper编程工作原理？"></a>2.1、 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>​        Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的<strong>动态代理</strong>，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2、 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2、 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>​        在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了<strong>接口全限名+方法名</strong>的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<pre><code class="java">id = applyCurrentNamespace(id, false);
public String applyCurrentNamespace(String base, boolean isReference) &#123;
   ...
   // 返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)
   return currentNamespace + &quot;.&quot; + base;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200920171405540.png" alt="img"></p>
<h3 id="2-3、-Mybatis动态sql执行原理"><a href="#2-3、-Mybatis动态sql执行原理" class="headerlink" title="2.3、 Mybatis动态sql执行原理?"></a>2.3、 Mybatis动态sql执行原理?</h3><p>​        （1）<strong>初始化阶段：</strong>通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>​        （2）<strong>代理阶段：</strong>先从Configuration配置类的MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>​        （3）<strong>数据读写阶段：</strong>通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4、-Mybatis的一级、二级缓存实现原理"><a href="#2-4、-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4、 Mybatis的一级、二级缓存实现原理?"></a>2.4、 Mybatis的一级、二级缓存实现原理?</h3><p>​        （1）<strong>一级缓存：</strong> 基于 PerpetualCache 的 HashMap 本地缓存，<strong>其存储作用域为 Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092018550771.png" alt="img"></p>
<p>​        （2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于<strong>其存储作用域为 Mapper(Namespace)级别</strong>。</p>
<p>​        Mybatis默认不打开二级缓存，可以在config文件中xml<code> &lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920190114946.png" alt="img"></p>
<p>​        （3）对于<strong>缓存数据更新机制</strong>，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-、Mybatis是如何进行分页的？"><a href="#2-5-、Mybatis是如何进行分页的？" class="headerlink" title="2.5 、Mybatis是如何进行分页的？"></a>2.5 、Mybatis是如何进行分页的？</h3><p>​        （1）<strong>SQL分页</strong>(物理分页)：</p>
<pre><code class="xml">&lt;select id=&quot;queryStudentsBySql&quot; parameterType=&quot;map&quot; resultMap=&quot;studentmapper&quot;&gt; 
    select * from student limit #&#123;start&#125; , #&#123;end&#125;
&lt;/select&gt;
</code></pre>
<p>​        （2）使用<strong>RowBounds</strong>实现分页(逻辑分页)：</p>
<pre><code class="java">Service:
    publicList queryRolesByPage(String roleName,int start,int limit) &#123;
        returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));
    &#125;


Dao:
    public List queryUsersByPage(String userName, RowBounds rowBounds);
</code></pre>
<p>​        （3）使用<strong>分页插件PageHelper</strong>：</p>
<p>​        添加依赖：</p>
<pre><code class="xml">&lt;!--分页--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        在mybatis-config.xml中配置PageInterceptor拦截器:</p>
<pre><code class="xml">&lt;!--2.配置分页插件，此插件必须配置在typeAliases后面--&gt;
&lt;plugins&gt;
     &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
&lt;!--分页合理化参数，默认文false；pageNum&lt;=0，查询第一页；pageNum&gt;总页数，查询最后一页--&gt;
         &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<pre><code class="java">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;
    PageHelper.startPage(pageNum, pageSize);
    List&lt;User&gt; userList = userMapper.queryByPage(userParam);
    Json json = new Json();
    return json;
&#125;
</code></pre>
<h3 id="2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>Executor</strong>是mybatis中的<strong>执行器接口</strong>:</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>BaseExecutor（基础执行器）：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了<strong>缓存管理和事务管理</strong>的能力，使用了<strong>模板模式</strong>，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现。BaseExecutor的一级缓存是会话级别的，增、删、改都会清空一级缓存；而CachingExecutor的二级缓存是应用级的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>CachingExecutor（缓存执行器）：</strong>直接实现Executor接口，使用装饰器模式<strong>提供二级缓存能力</strong>。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200705191437604.png"></p>
<p>​        <strong>BatchExecutor（批处理执行器）：</strong>BaseExecutor具体子类实现，在doUpdate方法中，<strong>提供批量执行多条SQL语句的能力</strong>；</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>SimpleExecutor（简单执行器）：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor（可重用执行器）：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-7、-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7、-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7、 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7、 Mybatis中如何指定使用哪一种Executor执行器？</h3><p>​        在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920183713811.png" alt="img"></p>
<blockquote>
<p>&lt;class=”reference-link”&gt;</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200920183657317.png" alt="img"></p>
<h3 id="2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092018294130.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200920183022252.png" alt="img"></p>
<p>​        Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9、-Mybatis中用到了哪些设计模式？"><a href="#2-9、-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9、 Mybatis中用到了哪些设计模式？"></a>2.9、 Mybatis中用到了哪些设计模式？</h3><p>​        日志模块：代理模式、适配器模式</p>
<p>​        数据源模块：代理模式、工厂模式</p>
<p>​        缓存模块：装饰器模式</p>
<p>​        初始化阶段：建造者模式</p>
<p>​        代理阶段：策略模式</p>
<p>​        数据读写阶段：模板模式</p>
<p>​        插件化开发：责任链模式</p>
<h2 id="三、Mybaits源码结构"><a href="#三、Mybaits源码结构" class="headerlink" title="三、Mybaits源码结构"></a>三、Mybaits源码结构</h2><h3 id="3-1-、源码包功能模块图"><a href="#3-1-、源码包功能模块图" class="headerlink" title="3.1 、源码包功能模块图"></a>3.1 、源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png" alt="img"></p>
<h3 id="3-2-、各包详细功能解析"><a href="#3-2-、各包详细功能解析" class="headerlink" title="3.2 、各包详细功能解析"></a>3.2 、各包详细功能解析</h3><p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                包含所有mapper 接口中用到的注解</p>
<p>​        <strong>org.apache.ibatis.binding：</strong></p>
<p>​                生成mapper 接口的动态代理并进行管理</p>
<p>​        <strong>org.apache.ibatis.builder：</strong></p>
<p>​                1、包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</p>
<p>​                2、BaseBuilder 构建器基类</p>
<p>​                3、XMLConfigBuilder 解析configuration.xml配置文件</p>
<p>​                4、XMLMapperBuilder 解析Mapper.xml配置文件</p>
<p>​                5、XMLStatementBuilder 解析selectupdatedelete 标签MapperAnnotationBuilder 注解式Mapper</p>
<p>​        <strong>org.apache.ibatis.cache：</strong></p>
<p>​                1、缓存功能实现、包含各种缓存装饰器</p>
<p>​                2、TransactionalCache 二级缓存功能实现</p>
<p>​        <strong>org.apache.ibatis.cursor：</strong></p>
<p>​                实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p>​        <strong>org.apache.ibatis.datasource：</strong></p>
<p>​                数据源 包括jndi数据源、连接池功能</p>
<p>​        <strong>org.apache.ibatis.executor：</strong></p>
<p>​                1、包含SQL语句执行器，核心功能包</p>
<p>​                2、功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</p>
<p>​        <strong>org.apache.ibatis.exceptions：</strong></p>
<p>​                框架异常，常见异常：TooManyResultsException</p>
<p>​        <strong>org.apache.ibatis.io：</strong></p>
<p>​                资源文件读取</p>
<p>​        <strong>org.apache.ibatis.jdbc：</strong></p>
<p>​                1、JDBC一些操作</p>
<p>​                2、SqlRunner SQL执行</p>
<p>​                3、ScriptRunner 脚本执行，可以执行建库语句</p>
<p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                1、日志功能，实现多种日志框架的对接</p>
<p>​                2、org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</p>
<p>​        <strong>org.apache.ibatis.mapping：</strong></p>
<p>​                配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p>​        <strong>org.apache.ibatis.parsing：</strong></p>
<p>​                1、解析工具包</p>
<p>​                2、GenericTokenParser：解析#{} ${} 这种占位符</p>
<p>​                3、XPathParser：XPath形式解析XML</p>
<p>​                4、PropertyParser: properties解析器</p>
<p>​        <strong>org.apache.ibatis.scripting：</strong></p>
<p>​                动态SQL语言实现，配置文件中<code>&lt;if&gt; &lt;where&gt; &lt;set&gt; &lt;foreach&gt; &lt;choose&gt; </code>功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p>​        <strong>org.apache.ibatis.session：</strong></p>
<p>​                1、主要实现SqlSession功能，非常核心包</p>
<p>​                2、官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</p>
<p>​        <strong>org.apache.ibatis.transaction：</strong></p>
<p>​                事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p>​        <strong>org.apache.ibatis.type：</strong></p>
<p>​                类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="四、MyBatis初始化阶段"><a href="#四、MyBatis初始化阶段" class="headerlink" title="四、MyBatis初始化阶段"></a>四、MyBatis初始化阶段</h2><p>​        前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是<strong>将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级</strong>。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li>加载配置文件</li>
<li>解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li>根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="4-1、加载配置文件"><a href="#4-1、加载配置文件" class="headerlink" title="4.1、加载配置文件"></a>4.1、<strong>加载配置文件</strong></h3><p>​        下面我们来看一段经典查询操作：</p>
<pre><code class="java">String resouce = &quot;config/mybatis/mybatis-config.xml&quot;;
InputStream is = Resources.getResourceAsStream(resouce);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
SqlSession session = sqlSessionFactory.openSession();
user = session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);
</code></pre>
<p>​        以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="4-2、解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#4-2、解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="4.2、解析配置文件、将配置文件中的信息装载到Configuration中"></a>4.2、解析配置文件、将配置文件中的信息装载到Configuration中</h3><p>​        让我们来看一下梦开始的地方：</p>
<pre><code class="java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
</code></pre>
<p>​        跟进**build()**方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<pre><code class="java">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;
    try &#123;
      // 创建XMLConfigBuilder对象解析XML配置
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      // 将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory
      return build(parser.parse());
    &#125; 
    ....
&#125;
</code></pre>
<p>​        跟进<strong>parse()<strong>方法，我们可以看到parser.evalNode(“/configuration”)，</strong>evalNode</strong>为xml结点解析器，可以解析指定参数结点的信息，而”**/configuration**”则是mybatis.xml的根节点：</p>
<pre><code class="java">public Configuration parse() &#123;
    ...
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
&#125;
</code></pre>
<p>​        看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p>​        <strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p>​        <strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p>​        <strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200915222654319.png" alt="img"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p>​        Configuration类的源码实在太多，可以先了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p>​        <strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br>​        <strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br>​        <strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br>​        <strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>​        接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<pre><code class="java">parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
</code></pre>
<pre><code class="java">private void parseConfiguration(XNode root) &#123;
    try &#123;
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>​        点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915223612191.png" alt="img"></p>
<p>​        在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<pre><code class="java">XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>
<pre><code class="java">private void configurationElement(XNode context) &#123;
    try &#123;
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      ...
      builderAssistant.setCurrentNamespace(namespace);
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      cacheElement(context.evalNode(&quot;cache&quot;));
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>一一对应官网提供的节点信息进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915224121930.png" alt="img"></p>
<p>​        下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<pre><code class="java">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;
    for (XNode context : list) &#123;
      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
      try &#123;
        statementParser.parseStatementNode();
      &#125; catch (IncompleteElementException e) &#123;
        configuration.addIncompleteStatement(statementParser);
      &#125;
    &#125;
  &#125;
</code></pre>
<p>​        继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="4-3、根据Configuration创建SqlSessionFactory并返回"><a href="#4-3、根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="4.3、根据Configuration创建SqlSessionFactory并返回"></a>4.3、根据Configuration创建SqlSessionFactory并返回</h3><p>​        第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<pre><code class="java">public class SqlSessionFactoryBuilder &#123;
   ...
   public SqlSessionFactory build(Configuration config) &#123;
      return new DefaultSqlSessionFactory(config);
   &#125;
&#125;
</code></pre>
<p>​        此工厂内封装了Configuration对象：</p>
<pre><code class="java">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;
  private final Configuration configuration;
  public DefaultSqlSessionFactory(Configuration configuration) &#123;
    this.configuration = configuration;
  &#125;
  ...
&#125;
</code></pre>
<p>​        初始化阶段图解：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915225840294.png" alt="img"></p>
<p>​        至此，MyBatis初始化阶段完成。</p>
<h2 id="五、MyBatis代理阶段（binding模块分析）"><a href="#五、MyBatis代理阶段（binding模块分析）" class="headerlink" title="五、MyBatis代理阶段（binding模块分析）"></a>五、MyBatis代理阶段（binding模块分析）</h2><h3 id="5-1、MyBatis是如何做到面向Mapper接口编程？"><a href="#5-1、MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="5.1、MyBatis是如何做到面向Mapper接口编程？"></a>5.1、MyBatis是如何做到面向Mapper接口编程？</h3><p>​        只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User uer = userMapper.selectByPrimarKey(1);
</code></pre>
<p>​        MyBatis动态代理后执行的为下面这段代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
User uer = sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);
</code></pre>
<p>​        我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p>​        <strong>1、找到Session中对应的方法执行</strong></p>
<p>​        <strong>2、找到命名空间和方法名</strong></p>
<p>​        <strong>3、传递参数</strong></p>
<p>​        这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200916211402947.png" alt="img"></p>
<p>​        <strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<pre><code class="java">public class MapperRegistry &#123;
   private final Configuration config;
   //mapper接口和对应的代理对象工厂之间的关系
   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
   ...
&#125;
</code></pre>
<p>​        <strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<pre><code class="java">public class MapperProxyFactory&lt;T&gt; &#123;
  ...
  //key为mapper接口中的某个方法的method对象，value为对应的MapperMethod
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
  ...
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);
  &#125;
&#125;
</code></pre>
<p>​        <strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214700706.png" alt="img"></p>
<p>​        接着跟进**cachedInvoker(method).invoke(proxy, method, args, sqlSession)**方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200916213826490.png" alt="img"></p>
<p>​        我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214239389.png" alt="img"></p>
<p>​        那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214959863.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215029787.png" alt="img"></p>
<p>​        通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916215442588.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215556263.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215523383.png" alt="img"></p>
<h3 id="5-2、代理阶段流程梳理"><a href="#5-2、代理阶段流程梳理" class="headerlink" title="5.2、代理阶段流程梳理"></a>5.2、代理阶段流程梳理</h3><p>​        1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>​        2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>​        3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h2 id="六、MyBatis数据读写阶段"><a href="#六、MyBatis数据读写阶段" class="headerlink" title="六、MyBatis数据读写阶段"></a>六、MyBatis数据读写阶段</h2><h3 id="6-1、MyBatis是怎样的封装jdbc操作的"><a href="#6-1、MyBatis是怎样的封装jdbc操作的" class="headerlink" title="6.1、MyBatis是怎样的封装jdbc操作的"></a>6.1、MyBatis是怎样的封装jdbc操作的</h3><p>​        我们先来回忆一下jdbc代码：</p>
<pre><code class="java">//1.加载驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     
//2.获取连接conn
Connection con=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123&quot;);
//3.创建查询接口
Statement sta= con.createStatement();
//4.执行SQL，返回结果集
ResultSet rs= sta.executeQuery(&quot;SELECT * FROM `user`&quot;);
//5.对结果集数据进行操作
User user = new User();
user.setUserName(String.valueOf(rs.getObject(1)));
</code></pre>
<p>​        其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203050838.png" alt="img"></p>
<p>​        可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p>​        <strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p>​        <strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p>​        <strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>​        一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205236272.png" alt="img"></p>
<p>​        可以看到只有BaseExecutor和CachingExecutor两个类重写了**query()**方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<code>&lt;cache&gt;</code>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205454850.png" alt="img"></p>
<p>​        好的我们继续跟进BaseExecutor的**query()**方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210415293.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200917210606702.png" alt="img"></p>
<p>​        可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210831277.png" alt="img"></p>
<p>​        我们跟进默认实现SimpleExecutor的**doQuery()**方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211035123.png" alt="img"></p>
<p>​        这段代码有两点值得我们注意，一个是**prepareStatement(handler, ms.getStatementLog())**这个方法，我们跟进去会发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211124589.png" alt="img"></p>
<p>​        <strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919104808424.png" alt="img"></p>
<p>​        <strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p>​        <strong>CallableStatementHandler：</strong>调用存储过程</p>
<p>​        <strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p>​        <strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p>​        <strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>​        RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211725203.png" alt="img"></p>
<p>​        接上文调用SimpleStatementHandler的query方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211854628.png" alt="img"></p>
<p>​        <strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919110111271.png" alt="img"></p>
<p>​        处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li>创建multipleResults集合，保存最终返回的结果。</li>
<li>取出第一个结果集</li>
<li>获取对应的resultMap</li>
<li>根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</li>
<li>resultset.close()关闭结果集，将multipleResults集合返回</li>
</ol>
<h3 id="6-2、sqlSession查询流程图和Executor内部调用流程图"><a href="#6-2、sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="6.2、sqlSession查询流程图和Executor内部调用流程图"></a>6.2、sqlSession查询流程图和Executor内部调用流程图</h3><h4 id="6-2-1、sqlSession查询流程图："><a href="#6-2-1、sqlSession查询流程图：" class="headerlink" title="6.2.1、sqlSession查询流程图："></a>6.2.1、sqlSession查询流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911381497.png" alt="img"></p>
<h4 id="6-2-2、Executor内部调用流程图："><a href="#6-2-2、Executor内部调用流程图：" class="headerlink" title="6.2.2、Executor内部调用流程图："></a>6.2.2、Executor内部调用流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911204922.png" alt="img"></p>
<p>此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl0utfldz000sugvs38ho9otj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybaits/" rel="tag">Mybaits</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/Mybaits/Spring与Mybaits整合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Spring%E4%B8%8EMybaits%E6%95%B4%E5%90%88/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Spring%E4%B8%8EMybaits%E6%95%B4%E5%90%88/">Spring整合Mybaits</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Mybaits-Spring包"><a href="#一、Mybaits-Spring包" class="headerlink" title="一、Mybaits-Spring包"></a>一、Mybaits-Spring包</h2><p>MyBatis-Spring 会帮助我们将 MyBatis 代码无缝地整合到 Spring 中，MyBatis-Spring 需要以下版本：</p>
<pre><code class="java">| MyBatis-Spring | MyBatis | Spring 框架 | Spring Batch | Java   |
| -------------- | ------- | --------- | ------------ | ------- |
| 2.0            | 3.5+    | 5.0+      | 4.0+         | Java 8+ |
| 1.3            | 3.4+    | 3.2.2+    | 2.1+         | Java 6+ |
</code></pre>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        要和 Spring 一起使用 MyBatis，首先需要<code>SqlSessionFactory</code>，在MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>,配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>注</strong>：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 <code>DataSource</code>，只需要和配置其它 Spring 数据库连接一样配置它就可以了</p>
<p><strong><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。</strong></p>
<p>作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。<code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
<p>可以使用 <code>SqlSessionFactory</code> 作为构造方法的参数来创建 <code>SqlSessionTemplate</code> 对象。</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样:</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
  private SqlSession sqlSession;
  public void setSqlSession(SqlSession sqlSession) &#123;
    this.sqlSession = sqlSession;
  &#125;
  public User getUser(String userId) &#123;
    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);
  &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;
  &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="二、Spring整个Mybaits"><a href="#二、Spring整个Mybaits" class="headerlink" title="二、Spring整个Mybaits"></a>二、Spring整个Mybaits</h2><h3 id="2-1、user数据表："><a href="#2-1、user数据表：" class="headerlink" title="2.1、user数据表："></a>2.1、<strong>user数据表：</strong></h3><pre><code class="sql">CREATE TABLE user(
    id INT NOT NULL,
    &#39;name&#39; VARCHAR(20) NOT NULL,
    &#39;pwd&#39; VARCHAR(20) NOT NULL,
    PRIMARY KEY(id)
)ENGINE=InnoDB DEFAULT CHARSET=utf-8; 
</code></pre>
<h3 id="2-2、实体类"><a href="#2-2、实体类" class="headerlink" title="2.2、实体类"></a>2.2、<strong>实体类</strong></h3><pre><code class="java">@Data
@ALLArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
<h3 id="2-3、导包"><a href="#2-3、导包" class="headerlink" title="2.3、导包"></a>2.3、<strong>导包</strong></h3><ul>
<li>mybatis-spring整合包 【最重要】</li>
<li>mybaits</li>
<li>mysql驱动的</li>
<li>junit</li>
<li>spring-core</li>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-jdbc 【数据源】</li>
<li>spring-tx 【事务】</li>
<li>…</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--mybaits--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--mysql连接驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.9&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"><a href="#2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件" class="headerlink" title="2.4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"></a>2.4、<strong>配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.westos.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/westos/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="2-5、编写Spring配置文件"><a href="#2-5、编写Spring配置文件" class="headerlink" title="2.5、编写Spring配置文件"></a>2.5、<strong>编写Spring配置文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!--1.配置数据源,我们使用的是spring的数据源，还可以使用第三方的数据源
        dbcp,c3p0
        com.mchange.v2.c3p0.ComboPooledDataSource
        org.apache.commons.dbcp.BasicDataSource
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--2.配置SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--关联mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--3.创建selSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="2-6、接口实现类增加一个属性：sqlSession"><a href="#2-6、接口实现类增加一个属性：sqlSession" class="headerlink" title="2.6、接口实现类增加一个属性：sqlSession"></a>2.6、<strong>接口实现类增加一个属性：sqlSession</strong></h3><pre><code class="java">import org.apache.ibatis.session.SqlSession;
import org.westos.pojo.User;
import java.util.List;

public class UserMapperImpl implements UserMapper &#123;
    private SqlSession sqlSession;
    public void setSqlSession(SqlSession sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;
    public List&lt;User&gt; getUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
    &#125;
&#125;
</code></pre>
<h3 id="2-7、将接口的实现类交给spring来管理"><a href="#2-7、将接口的实现类交给spring来管理" class="headerlink" title="2.7、将接口的实现类交给spring来管理"></a>2.7、<strong>将接口的实现类交给spring来管理</strong></h3><pre><code class="xml">&lt;!--4.接口实现类注入sqlSession--&gt;
&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.westos.dao.UserMapperImpl&quot;&gt;
   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2-8、测试类"><a href="#2-8、测试类" class="headerlink" title="2.8、测试类"></a>2.8、<strong>测试类</strong></h3><pre><code class="java">import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.westos.pojo.User;
import java.util.List;

public class TestUserMapper &#123;
    
    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapperImpl userMapperImpl = (UserMapperImpl) context.getBean(&quot;UserMapperImpl&quot;);
        List&lt;User&gt; users = userMapperImpl.getUser();
        for (User user : users) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="三、整合Druid并开启监控"><a href="#三、整合Druid并开启监控" class="headerlink" title="三、整合Druid并开启监控"></a>三、整合Druid并开启监控</h2><h3 id="3-1、整合Druid"><a href="#3-1、整合Druid" class="headerlink" title="3.1、整合Druid"></a>3.1、整合Druid</h3><h4 id="3-1-1-导入starter"><a href="#3-1-1-导入starter" class="headerlink" title="3.1.1 导入starter"></a>3.1.1 导入starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.1.2、配置yaml</p>
<pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    type: com.alibaba.druid.pool.DruidDataSource
    
    #连接池配置(可选)
    # 连接池的配置信息初始化大小，最小，最大
    name: testDruidDataSource
    initial-size: 5    #初始化连接大小
    max-active: 20    #最大连接数
    min-idle: 5        #最小空闲连接数
    max-wait: 60000   # 配置获取连接等待超时的时间
    
    #######监控配置  说明请参考Druid Wiki
    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙
    filters: stat,wall
    #配置 Web Stat Filter
    web-stat-filter:
      enabled: true
      url-pattern: /*
      exclusions: /druid/*,*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico
      session-stat-enable: true
      session-stat-max-count: 10
      principal-session-name: session_name
      principal-cookie-name: cookie_name
      profile-enable:
      
    # Stat View Servlet 配置  配置默认false
    stat-view-servlet:
      enabled: true
      url-pattern: /druid/*
      reset-enable: false   #禁用HTML页面上的“Reset All”功能
      login-username: admin  #监控页面登录的用户名
      login-password: 123  #监控页面登录的密码
      #IP白名单(没有配置或者为空，则允许所有访问)
      allow:
      #IP黑名单 (存在共同时，deny优先于allow)
      deny:
</code></pre>
<p><strong>由于springboot默认的是hikari，号称最快的数据源，这里我们换成了阿里巴巴的数据源，druid最强大的则是监控功能</strong></p>
<pre><code class="java">class com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper
com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@3f866f50
</code></pre>
<h3 id="3-2、整合Mybaits"><a href="#3-2、整合Mybaits" class="headerlink" title="3.2、整合Mybaits"></a>3.2、整合Mybaits</h3><h4 id="3-2-1、导包"><a href="#3-2-1、导包" class="headerlink" title="3.2.1、导包"></a>3.2.1、导包</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="3-2-2、实体类"><a href="#3-2-2、实体类" class="headerlink" title="3.2.2、实体类"></a>3.2.2、实体类</h4><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student &#123;
    private int id;
    private String name;
    private int tid;
&#125;
</code></pre>
<h4 id="3-2-3、StudentMapper"><a href="#3-2-3、StudentMapper" class="headerlink" title="3.2.3、StudentMapper"></a>3.2.3、StudentMapper</h4><pre><code class="java">@Mapper
@Repository
public interface StudentMapper &#123;
     List&lt;Student&gt; selectAllStudent();
&#125;
</code></pre>
<h4 id="3-2-4、StudentMapper-xml"><a href="#3-2-4、StudentMapper-xml" class="headerlink" title="3.2.4、StudentMapper .xml"></a>3.2.4、StudentMapper .xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.kexing.mapper.StudentMapper&quot;&gt;
    &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt;
        select * from student
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="3-2-5、配置数据源、实体别名、mapper地址"><a href="#3-2-5、配置数据源、实体别名、mapper地址" class="headerlink" title="3.2.5、配置数据源、实体别名、mapper地址"></a>3.2.5、配置数据源、实体别名、mapper地址</h4><pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    
mybatis:
  type-aliases-package: site.kexing.pojo
  mapper-locations: classpath:mapper/*.xml
</code></pre>
<h4 id="3-2-6、测试输出"><a href="#3-2-6、测试输出" class="headerlink" title="3.2.6、测试输出"></a>3.2.6、测试输出</h4><pre><code class="java">@RestController
public class StudentController &#123;
    @Autowired
    StudentMapper studentMapper;
    @RequestMapping(&quot;/selectall&quot;)
    public List&lt;Student&gt; selectAllStudent()&#123;
        List&lt;Student&gt; students = studentMapper.selectAllStudent();
        return students;
    &#125;
&#125;
</code></pre>
<pre><code class="java">[&#123;
    &quot;id&quot;:1,&quot;name&quot;:&quot;小明&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:2,&quot;name&quot;:&quot;小红&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:3,&quot;name&quot;:&quot;小张&quot;,&quot;tid&quot;:2&#125;,&#123;
    &quot;id&quot;:4,&quot;name&quot;:&quot;小李&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:5,&quot;name&quot;:&quot;旺旺&quot;,&quot;tid&quot;:1&#125;]
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Spring%E4%B8%8EMybaits%E6%95%B4%E5%90%88/" data-id="cl0utfle0000uugvs34i14h7y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybaits/" rel="tag">Mybaits</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/JVM/JVM虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、类加载器子系统、运算时数据区、内存分布、执行引擎"><a href="#一、类加载器子系统、运算时数据区、内存分布、执行引擎" class="headerlink" title="一、类加载器子系统、运算时数据区、内存分布、执行引擎"></a>一、类加载器子系统、运算时数据区、内存分布、执行引擎</h2><h3 id="1-JDK中包含了哪些内容"><a href="#1-JDK中包含了哪些内容" class="headerlink" title="1  JDK中包含了哪些内容?"></a>1  JDK中包含了哪些内容?</h3><ul>
<li>①. JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等</li>
<li>②. JRE(Java Runtime Environment Java运行环境)：包括Java虚拟机(Java Virtual Machine，JVM)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可</li>
</ul>
<h3 id="2-三大商业虚拟机"><a href="#2-三大商业虚拟机" class="headerlink" title="2  三大商业虚拟机"></a>2  三大商业虚拟机</h3><ul>
<li>①. sun公司的HotSpot VM(后来被Oracle收购)</li>
<li>②. BEA JRocket VM(后来被Oracle收购)，JRocket虚拟机中没有解释器，全部代码都靠即时编译器编译后执行</li>
<li>③. iBM J9</li>
</ul>
<h3 id="3-谈谈你对JVM整体的理解"><a href="#3-谈谈你对JVM整体的理解" class="headerlink" title="3 谈谈你对JVM整体的理解"></a>3 谈谈你对JVM整体的理解</h3><ul>
<li>①. 类加载器子系统</li>
<li>②. 运行时数据区[我们核心关注这里 的栈、堆、方法区]</li>
<li>③. 执行引擎(解释器和JIT编译器共存)<br><img src="https://img-blog.csdnimg.cn/2021060411352293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-简述Java类加载机制-Java类加载过程"><a href="#4-简述Java类加载机制-Java类加载过程" class="headerlink" title="4 简述Java类加载机制(Java类加载过程)"></a>4 简述Java类加载机制(Java类加载过程)</h3><ul>
<li><strong>加载机制是指类的加载、链接、初始化的过程</strong><br><img src="https://img-blog.csdnimg.cn/20210504185259863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="5-什么是类的加载、链接、初始化"><a href="#5-什么是类的加载、链接、初始化" class="headerlink" title="5  什么是类的加载、链接、初始化"></a>5  什么是类的加载、链接、初始化</h3><ul>
<li><p>①. <strong>加载：</strong>将字节码文件中的.class文件，通过类加载器，加载进运行时数据区的<strong>方法区</strong>内，并创建一个大的<strong>Class对象</strong></p>
</li>
<li><p>②. <strong>链接：</strong>(验证、准备、解析)</p>
<ul>
<li>验证，比如说验证字节码文件开头是CAFFBABA，版本号等</li>
</ul>
<ul>
<li><p>准备，为类变量赋予默认的初始化值，使用static+final修饰，且显示赋值不涉及到方法或者构造器调用的基本数据类型或者String类型的显示赋值都在准备阶段</p>
</li>
<li><p>解析，将类中的符号引用变成直接引用(符号引号在字节码文件的常量池中)</p>
</li>
</ul>
</li>
<li><p>③. <strong>初始化：</strong>为类变量赋予正确的初始化值，执行Clinit方法(静态代码块或使用static修饰的变量)<br>注意：一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
</li>
</ul>
<h3 id="6-类的主动使用和被动使用"><a href="#6-类的主动使用和被动使用" class="headerlink" title="6 类的主动使用和被动使用"></a>6 类的主动使用和被动使用</h3><ul>
<li>①. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li>
<li>②. 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>③. 调用类的静态方法</li>
<li>④. 反射(比如：Class.forName(“com.xiaozhi.Test”))</li>
<li>⑤. 初始化一个子类(当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化)</li>
<li>⑥. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类</li>
<li>⑦. JDK7开始提供的动态语言支持 (涉及解析REF_getStatic、REF_putStatic、REF_invokeSt atic方法句柄对应的类)</li>
</ul>
<h3 id="7-forName-“Java-lang-String”-和loadClass-“Java-lang-String”-有什么区别"><a href="#7-forName-“Java-lang-String”-和loadClass-“Java-lang-String”-有什么区别" class="headerlink" title="7 forName(“Java.lang.String”)和loadClass(“Java.lang.String”)有什么区别?"></a>7 forName(“Java.lang.String”)和loadClass(“Java.lang.String”)有什么区别?</h3><ul>
<li>①. forName()会导致类的<strong>主动加载</strong>，而getClassLoader()不会导致类的主动加载，Class.forName()：是一个静态方法，最常用的是Class.forName(String className)；根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化</li>
<li>②. ClassLoader.loadClass()：这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。(该方法因为需要得到一个ClassLoader 对象，所以可以根据需要指定使用哪个类加载器)</li>
</ul>
<h3 id="8-判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件"><a href="#8-判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件" class="headerlink" title="8 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件"></a>8 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件</h3><ul>
<li>①. 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li>②. 加载该类的类加载器已经被回收。这个条件除非是精心设计的可替换类加载器的场景。如JSP重加载等。否则通常是很难达成的</li>
<li>③. 该类对应的Java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="9-说说类的加载器分类？"><a href="#9-说说类的加载器分类？" class="headerlink" title="9  说说类的加载器分类？"></a>9  说说类的加载器分类？</h3><ul>
<li>①. JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>(Bootstrap ClassLoader)和<strong>自定义类加载器</strong>(User-Defined ClassLoader)</li>
<li>②. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范并没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器<br><img src="https://img-blog.csdnimg.cn/20210426223104306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="10-说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解"><a href="#10-说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解" class="headerlink" title="10  说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解"></a>10  说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解</h3><ul>
<li><p>①. <strong>引导类加载器</strong></p>
<ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
</ul>
<ul>
<li><p>它用来加载Java的核心类库(JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容)，用于提供JVM自身需要的类(String类就是使用的这个类加载器)</p>
</li>
<li><p>由于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>不继承自java.lang.ClassLoader，没有父加载器</p>
</li>
</ul>
</li>
<li><p>②. <strong>扩展类加载器 Extension</strong></p>
<ul>
<li>Java语言编写，由sum.music.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类，父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
<li><p>③. <strong>系统类加载器(Application)</strong></p>
<ul>
<li>Java语言编写，由sum.music.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类，父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
</ul>
<ul>
<li>调用System.getSystemClassLoader() | Thread.currentThread().getContextClassLoader()获取到的是系统类加载器</li>
</ul>
</li>
</ul>
<h3 id="11-谈谈你对双亲委派机制的理解"><a href="#11-谈谈你对双亲委派机制的理解" class="headerlink" title="11  谈谈你对双亲委派机制的理解"></a>11  谈谈你对双亲委派机制的理解</h3><ul>
<li>①. 如果一个类加载收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行</li>
<li>②. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>
<li>③. 如果父类的加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ul>
<h3 id="12-双亲委派机制的优势"><a href="#12-双亲委派机制的优势" class="headerlink" title="12  双亲委派机制的优势"></a>12  双亲委派机制的优势</h3><ul>
<li>①. <strong>避免类的重复加载</strong>，确保一个类的全局唯一性(当父ClassLoader已经加载了该类的时候，就没有必要子ClassLoader再加载一次)<br>比如：我们如果是引导类加载器加载了，就没必要再一次使用扩展类加载器进行加载</li>
<li>②. <strong>保护程序安全</strong>，防止核心API被随意篡改<br><img src="https://img-blog.csdnimg.cn/20210426224243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="13-双亲委托模式的弊端"><a href="#13-双亲委托模式的弊端" class="headerlink" title="13  双亲委托模式的弊端"></a>13  双亲委托模式的弊端</h3><ul>
<li>检查类是否加载的委托过程是<strong>单向</strong>的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类</li>
</ul>
<h3 id="14-双亲委派机制可以打破吗？为什么"><a href="#14-双亲委派机制可以打破吗？为什么" class="headerlink" title="14  双亲委派机制可以打破吗？为什么"></a>14  双亲委派机制可以打破吗？为什么</h3><ul>
<li>①. 双亲委派模型的第一次”被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的”远古”时代</li>
<li>②. 第二次破坏双亲委派机制：线程上下文类加载器(ClassLoader.getSystemClassLoader( ))</li>
<li>③. 双亲委派模型的第三次”被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换(Hot Swap)、模块热部署(Hot Deployment)</li>
</ul>
<h3 id="15-沙箱安全机制谈谈你的认识"><a href="#15-沙箱安全机制谈谈你的认识" class="headerlink" title="15  沙箱安全机制谈谈你的认识"></a>15  沙箱安全机制谈谈你的认识</h3><ul>
<li>①. <strong>自定义String类</strong>，但是在加载String类的时候会使用引导类加载器进行加载，而引导类加载器在加载过程中会先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。在一定程度上可以保护程序安全，保护原生的JDK代码</li>
</ul>
<h3 id="16-谈谈你对ClassLaoder中的loadClass的理解"><a href="#16-谈谈你对ClassLaoder中的loadClass的理解" class="headerlink" title="16  谈谈你对ClassLaoder中的loadClass的理解"></a>16  谈谈你对ClassLaoder中的loadClass的理解</h3><ul>
<li>①. 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>②. 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name， false)接口进行加载</li>
<li>③. 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载</li>
<li>④. 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lan g.ClassLoader接口的defineClass系列的native接口加载目标Java类</li>
</ul>
<h3 id="17-Java中基本数据类型存储在JVM中的存储位置"><a href="#17-Java中基本数据类型存储在JVM中的存储位置" class="headerlink" title="17  Java中基本数据类型存储在JVM中的存储位置"></a>17  Java中基本数据类型存储在JVM中的存储位置</h3><ul>
<li><strong>局部变量存储在栈中，实例变量和静态变量存储在堆中</strong></li>
</ul>
<h3 id="18-字节码文件中都有什么"><a href="#18-字节码文件中都有什么" class="headerlink" title="18  字节码文件中都有什么?"></a>18  字节码文件中都有什么?</h3><ul>
<li>魔术</li>
<li>版本(副版本、主版本)</li>
<li>常量池(字节码文件的基石)</li>
<li>访问标识</li>
<li>类索引|父类索引|接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<h3 id="19-常量池中都有什么？"><a href="#19-常量池中都有什么？" class="headerlink" title="19  常量池中都有什么？"></a>19  常量池中都有什么？</h3><ul>
<li>①. 字面量和符号引号</li>
<li>②. 字面量：Java中的常量和字符串</li>
<li>③. 符号引号：<ul>
<li>类和接口的全限定名</li>
<li>属性的名称和修饰符</li>
<li>方法的名称和修饰符</li>
</ul>
</li>
</ul>
<h3 id="20-JVM的永久代中会发生垃圾回收么"><a href="#20-JVM的永久代中会发生垃圾回收么" class="headerlink" title="20 JVM的永久代中会发生垃圾回收么?"></a>20 JVM的永久代中会发生垃圾回收么?</h3><ul>
<li>①. 方法区中的垃圾回收主要是：废弃的常量和不再使用的类型</li>
<li>②. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li>
<li>③. 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:<ul>
<li>该类<strong>所有的实例</strong>都已经被回收。也就是Java堆中不存在类以及任何派生子类的实例</li>
<li>加载该类的<strong>加载器</strong>已经被回收。这个条件除非是经过设计的可替换类加载器的场景，入OSGI、JSP的重加载等，否则通常是很难达成的</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ul>
<h3 id="21-JVM在加载类的时候，是否按照类的加载、链接-验证、准备、解析-和初始化的顺序执行的？"><a href="#21-JVM在加载类的时候，是否按照类的加载、链接-验证、准备、解析-和初始化的顺序执行的？" class="headerlink" title="21  JVM在加载类的时候，是否按照类的加载、链接(验证、准备、解析)和初始化的顺序执行的？"></a>21  JVM在加载类的时候，是否按照类的加载、链接(验证、准备、解析)和初始化的顺序执行的？</h3><ul>
<li>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
</ul>
<h3 id="22-“父加载器”和”子加载器”之间的关系是继承的吗"><a href="#22-“父加载器”和”子加载器”之间的关系是继承的吗" class="headerlink" title="22 “父加载器”和”子加载器”之间的关系是继承的吗?"></a>22 “父加载器”和”子加载器”之间的关系是继承的吗?</h3><ul>
<li>不是继承的关系，是<strong>包含</strong>的关系</li>
</ul>
<h3 id="23-如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？"><a href="#23-如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？" class="headerlink" title="23  如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？"></a>23  如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？</h3><ul>
<li>会由引导类加载器进行加载，这是因为不管是自定义加载器还是系统类加载器或者扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass (String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineC lass()接口，该接口中提供给了对JDK核心类库的保护</li>
</ul>
<h3 id="24-为什么JDBC需要打破双亲委派机制-tomcat也打破了"><a href="#24-为什么JDBC需要打破双亲委派机制-tomcat也打破了" class="headerlink" title="24  为什么JDBC需要打破双亲委派机制?(tomcat也打破了)"></a>24  为什么JDBC需要打破双亲委派机制?(tomcat也打破了)</h3><ul>
<li>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包，DriverManager类中要加载各个实现了Driver接口的类，然后进行管理，也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类，这就打破了双亲委派机制</li>
</ul>
<h3 id="25-既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢"><a href="#25-既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢" class="headerlink" title="25  既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢"></a>25  既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢</h3><ul>
<li>显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？<strong>tomcat不遵循双亲委派机制</strong>，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader</li>
</ul>
<h3 id="26-我们思考一下-Tomcat是个web容器，那么它要解决什么问题？"><a href="#26-我们思考一下-Tomcat是个web容器，那么它要解决什么问题？" class="headerlink" title="26  我们思考一下:Tomcat是个web容器，那么它要解决什么问题？"></a>26  我们思考一下:Tomcat是个web容器，那么它要解决什么问题？</h3><ul>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离</li>
<li>①. 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份</li>
<li>②. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。<br>默认的类加载器是能够实现的，因为他的职责就是保证唯一性。</li>
<li>③. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来第三个问题和第一个问题一样</li>
<li>④. web容器要支持jsp的修改，我们知道，jsp文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？所以，web容器需要支持jsp修改后不用重启<br>我们想我们要怎么实现jsp文件的热替换，jsp文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件</li>
</ul>
<h3 id="27-如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？"><a href="#27-如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？" class="headerlink" title="27  如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？"></a>27  如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？</h3><ul>
<li>可以使用<strong>线程上下文类加载器</strong>实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作</li>
</ul>
<h3 id="28-为什么java文件放在Eclipse-IDEA中的src文件夹下会优先jar包中的class"><a href="#28-为什么java文件放在Eclipse-IDEA中的src文件夹下会优先jar包中的class" class="headerlink" title="28 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class"></a>28 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class</h3><ul>
<li>Tomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在WEB-INF/class中。</li>
<li>而Eclipse/IDEA外部引用的jar包，则相当于放在WEB-INF/lib中。</li>
<li>因此肯定是java文件或者JSP文件编译出的class优先加载。</li>
</ul>
<h3 id="29-谈谈你对程序计数器的理解"><a href="#29-谈谈你对程序计数器的理解" class="headerlink" title="29 谈谈你对程序计数器的理解"></a>29 谈谈你对程序计数器的理解</h3><ul>
<li>①. 作用:是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</li>
<li>②. 是线程私有的 、不会存在内存溢出(唯一一个运行时数据区没有OOM的区域</li>
<li>③. 如果执行的是一个Native方法，那这个计数器是<strong>undefined</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200220202701869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="30-为什么使用PC寄存器记录当前线程的执行地址呢"><a href="#30-为什么使用PC寄存器记录当前线程的执行地址呢" class="headerlink" title="30  为什么使用PC寄存器记录当前线程的执行地址呢?"></a>30  为什么使用PC寄存器记录当前线程的执行地址呢?</h3><ul>
<li>①. 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li>
<li>②. JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令<br><img src="https://img-blog.csdnimg.cn/20210427211423937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="31-PC寄存器为什么设定为线程私有"><a href="#31-PC寄存器为什么设定为线程私有" class="headerlink" title="31 PC寄存器为什么设定为线程私有?"></a>31 PC寄存器为什么设定为线程私有?</h3><ul>
<li>为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</li>
</ul>
<h3 id="32-说说你对本地方法栈的理解"><a href="#32-说说你对本地方法栈的理解" class="headerlink" title="32 说说你对本地方法栈的理解"></a>32 说说你对本地方法栈的理解</h3><ul>
<li>①.本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须由调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies</li>
<li>②. native方法的举例：Object类中的clone wait notify hashCode等Unsafe类都是native方法<br><img src="https://img-blog.csdnimg.cn/20200505095206157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="33-什么虚拟机栈？"><a href="#33-什么虚拟机栈？" class="headerlink" title="33  什么虚拟机栈？"></a>33  什么虚拟机栈？</h3><ul>
<li>①.虚拟机栈(Java Virtual Machine Stacks)线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈， 所以Java栈也是”线程私有”的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程 [先进后出]<br><img src="https://img-blog.csdnimg.cn/20200228105322185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="34-栈里面存在GC吗？"><a href="#34-栈里面存在GC吗？" class="headerlink" title="34  栈里面存在GC吗？"></a>34  栈里面存在GC吗？</h3><ul>
<li>栈中是<strong>不存在GC</strong>的，存在OOM和StackOverflowError</li>
</ul>
<h3 id="35-静态变量和局部变量的对比？"><a href="#35-静态变量和局部变量的对比？" class="headerlink" title="35  静态变量和局部变量的对比？"></a>35  静态变量和局部变量的对比？</h3><ul>
<li>①. 我们知道类变量表有两次初始化的机会，第一次是在”准备阶段”，执行系统初始化，对类变量设置为零值，另一次则是在”初始化”阶段，赋予程序员在代码中定义的初始值</li>
<li>②. 和类变量初始化不同的是，局部变量表不存在初始化的过程，这意味着一旦定义了局部变量则必须认为初始化</li>
</ul>
<h3 id="36-虚拟机栈中都有什么"><a href="#36-虚拟机栈中都有什么" class="headerlink" title="36 虚拟机栈中都有什么?"></a>36 虚拟机栈中都有什么?</h3><ul>
<li>局部变量表、操作数栈、动态链接、方法的返回地址、附件信息</li>
</ul>
<h3 id="37-谈谈你对局部变量表的理解"><a href="#37-谈谈你对局部变量表的理解" class="headerlink" title="37 谈谈你对局部变量表的理解?"></a>37 谈谈你对局部变量表的理解?</h3><ul>
<li>①. 定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各种基本数据类型、对象引用(reference)以及return Address类型)</li>
<li>②. 由于局部变量是建立在线程的栈上，是<strong>线程私有数据</strong>，因此不存在数据安全问题</li>
<li>③. 局部变量表所需容量大小是在编译期确定下来的。(并保存在方法Code属性的maximum local variables数据项中，在方法运行期间不会改变局部变量表的大小的)</li>
<li>④. 局部变量表，其<strong>基本的存储单元是slot(变量槽)</strong></li>
<li>⑤. 在局部变量表中，32位以内的类型只占有一个slot(包括引用数据类型)，64位的类型(long和double)占有两个slot、byte、short、char在存储前被转换为int，boolean也被转换为int(0表示fasle，非0表示true)long和double则占据两个slot</li>
<li>⑥. Jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>⑦. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可(比如:访问long或double类型变量)</li>
<li>⑧. 如果当前帧是由构造方法或者实例方法创建，那么该对象引用this将会放在index为0的slot处</li>
<li>⑨. 栈帧中的局部变量表中的槽位是可以复用的，如果一个局部变量过了其作用域，那么在其作用域之后申请的新的局部变量就很可能会复用过期局部变量的槽位，从而节省资源的目的</li>
<li>⑩. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li>
</ul>
<h3 id="38-谈谈你对操作数栈的理解"><a href="#38-谈谈你对操作数栈的理解" class="headerlink" title="38 谈谈你对操作数栈的理解?"></a>38 谈谈你对操作数栈的理解?</h3><ul>
<li>①. 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li>
<li>②. 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为<strong>表达式栈</strong></li>
<li>③. 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>④. 栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>⑤. 操作数栈，主要用于保存计算机过程的中间结果，同时作为计算过程中变量临时的存储空间</li>
</ul>
<h3 id="39-说说你对动态链接的理解"><a href="#39-说说你对动态链接的理解" class="headerlink" title="39 说说你对动态链接的理解?"></a>39 说说你对动态链接的理解?</h3><ul>
<li><strong>动态链接就是将字节码文件中的符号引号(字符串常量池中)变成直接引用的过程</strong></li>
</ul>
<h3 id="40-方法返回地址？"><a href="#40-方法返回地址？" class="headerlink" title="40 方法返回地址？"></a>40 方法返回地址？</h3><ul>
<li>①. 存放调用该方法的PC寄存器的值</li>
<li>②. 一个方法的结束，有两种方式:<br>正常执行完成<br>出现未处理的异常，非正常退出</li>
<li>③. 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li>
<li>④. 而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<h3 id="41-附加信息-了解"><a href="#41-附加信息-了解" class="headerlink" title="41 附加信息(了解)"></a>41 附加信息(了解)</h3><ul>
<li>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</li>
</ul>
<h3 id="42-调整栈大小，就能保证不出现溢出吗"><a href="#42-调整栈大小，就能保证不出现溢出吗" class="headerlink" title="42 调整栈大小，就能保证不出现溢出吗?"></a>42 调整栈大小，就能保证不出现溢出吗?</h3><ul>
<li>不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出</li>
</ul>
<h3 id="43-分配的栈内存越大越好吗"><a href="#43-分配的栈内存越大越好吗" class="headerlink" title="43 分配的栈内存越大越好吗?"></a>43 分配的栈内存越大越好吗?</h3><ul>
<li>不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小</li>
</ul>
<h3 id="44-垃圾回收是否会涉及到虚拟机栈"><a href="#44-垃圾回收是否会涉及到虚拟机栈" class="headerlink" title="44 垃圾回收是否会涉及到虚拟机栈?"></a>44 垃圾回收是否会涉及到虚拟机栈?</h3><ul>
<li>①. 不会。<strong>垃圾回收只会涉及到方法区和堆中</strong>，方法区和堆也会存在溢出的可能</li>
<li>②. 程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收</li>
<li>③. 虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收</li>
</ul>
<h3 id="45-方法中定义的局部变量是否线程安全"><a href="#45-方法中定义的局部变量是否线程安全" class="headerlink" title="45 方法中定义的局部变量是否线程安全?"></a>45 方法中定义的局部变量是否线程安全?</h3><ul>
<li>如果局部变量在内部产生并在内部消亡的，那就是线程安全的</li>
</ul>
<h3 id="46-什么情况下会发生栈内存溢出"><a href="#46-什么情况下会发生栈内存溢出" class="headerlink" title="46 什么情况下会发生栈内存溢出?"></a>46 什么情况下会发生栈内存溢出?</h3><ul>
<li>①. 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出</li>
<li>②. 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出</li>
</ul>
<h3 id="47-说说堆和栈的区别"><a href="#47-说说堆和栈的区别" class="headerlink" title="47 说说堆和栈的区别?"></a>47 说说堆和栈的区别?</h3><ul>
<li>①.从GC、OOM、StackOverflowError的角度<br>[栈中不存在GC，当固定大小的栈会发生StackOverflowError，动态的会发生OOM。堆中GC、OOM、StackOverflowError都存在]</li>
<li>②. 从堆栈的执行效率[栈的效率高于堆]</li>
<li>③. 内存大小，数据结构<br>[堆的空间比栈的大一般，栈是一种FIFO先进后出的模型。堆中结构复杂，可以有链表、数组等]</li>
<li>④. 栈管运行，堆管存储</li>
</ul>
<h3 id="48-简单谈谈你对堆的理解-共享-垃圾回收"><a href="#48-简单谈谈你对堆的理解-共享-垃圾回收" class="headerlink" title="48 简单谈谈你对堆的理解?(共享|垃圾回收)"></a>48 简单谈谈你对堆的理解?(共享|垃圾回收)</h3><ul>
<li>①. Java堆区在JVM启动的时候即被创建，其空间大小也是确定的。是Jvm管理最大的一块内存空间</li>
<li>②. <strong>所有的线程共享Java堆</strong>，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer，TLAB)</li>
<li>③. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才有被移除<br>(注意:一个进程就是一个JVM实例，一个进程中包含多个线程)</li>
<li>④. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer， TLAB)</li>
</ul>
<h3 id="49-堆里面的分区-Eden，survival-from-to-，老年代，各自的特点"><a href="#49-堆里面的分区-Eden，survival-from-to-，老年代，各自的特点" class="headerlink" title="49 堆里面的分区:Eden，survival(from+to)，老年代，各自的特点"></a>49 堆里面的分区:Eden，survival(from+to)，老年代，各自的特点</h3><ul>
<li>①. 在JDK1.7中分为: 新生代+老年代+永久代 | 在JDK1.8中分为: 新生代+老年代+元空间</li>
<li>②. 新生代:伊甸园区、幸存者S0、S1(8:1:1)，几乎所有的Java对象都是在Eden区被new出来的，绝大部分的Java对象的销毁都在新生代进行了;</li>
<li>IBM公司的专门研究表明，新生代中 80% 的对象都是”朝生夕死”的老年代:另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致新生代:老年代=1:2</li>
</ul>
<h3 id="50-堆大小通过什么参数设置？"><a href="#50-堆大小通过什么参数设置？" class="headerlink" title="50 堆大小通过什么参数设置？"></a>50 堆大小通过什么参数设置？</h3><ul>
<li>①. -Xms:初始内存(默认为物理内存的1/64)</li>
<li>②. -Xmx:最大内存(默认为物理内存的1/4)</li>
<li>③. -XX:NewRatio=2<br>-XX:SurvivorRatio<br>-XX:HandlePromotionFailure:空间分配担保<br>-Xmn:设置新生代最大内存大小，一般使用默认值就可以了</li>
</ul>
<h3 id="51-初始堆大小和最大堆大小一样，问这样有什么好处"><a href="#51-初始堆大小和最大堆大小一样，问这样有什么好处" class="headerlink" title="51 初始堆大小和最大堆大小一样，问这样有什么好处?"></a>51 初始堆大小和最大堆大小一样，问这样有什么好处?</h3><ul>
<li>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能</li>
</ul>
<h3 id="52-对象在堆中的分配规则"><a href="#52-对象在堆中的分配规则" class="headerlink" title="52 对象在堆中的分配规则?"></a>52 对象在堆中的分配规则?</h3><ul>
<li>①. 优先分配到Eden</li>
<li>②. 大对象直接分配到老年(尽量避免程序中出现过多的大对象)</li>
<li>③. 长期存活的对象分配到老年代</li>
<li>④. 动态对象年龄判断(如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄对象可以直接进入老年代，无须等到MaxTenurningThreshold中要求的年龄</li>
<li>⑤. 空间分配担保 -XX:HandlePromotionFailure<br>(JDK6 Update24之后规则变为只有老年代的连续空间大于新生代对象总大小或者历次晋身的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<h3 id="53-Minor-GC-Major-GC-Full-GC"><a href="#53-Minor-GC-Major-GC-Full-GC" class="headerlink" title="53 Minor GC | Major GC | Full GC"></a>53 Minor GC | Major GC | Full GC</h3><ul>
<li>①. Minor GC 在Eden伊甸园区满的时候会触发，发生在新生代中</li>
<li>②. Major GC 在老年代中满了会进行触发，发生在老年代，major gc的时间比minor gc时间长</li>
<li>③. Full GC 发生在整个堆中</li>
</ul>
<h3 id="54-什么时候会触发minor-gc？"><a href="#54-什么时候会触发minor-gc？" class="headerlink" title="54  什么时候会触发minor gc？"></a>54  什么时候会触发minor gc？</h3><ul>
<li>在Eden伊甸园区满的时候会触发</li>
</ul>
<h3 id="55-是不是所有对象都分配在堆中"><a href="#55-是不是所有对象都分配在堆中" class="headerlink" title="55 是不是所有对象都分配在堆中?"></a>55 是不是所有对象都分配在堆中?</h3><ul>
<li>几乎所有对象是分配在堆中，如果一个对象在方法中没有进行逃逸，也可以分配在栈中进行分配</li>
</ul>
<h3 id="56-方法区中都存放什么东西"><a href="#56-方法区中都存放什么东西" class="headerlink" title="56 方法区中都存放什么东西?"></a>56 方法区中都存放什么东西?</h3><ul>
<li>类型信息、常量、静态变量、即时编译器编译后的代码缓存</li>
</ul>
<h3 id="57-方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误"><a href="#57-方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误" class="headerlink" title="57 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误?"></a>57 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误?</h3><ul>
<li>①. 加载大量的第三方的jar包</li>
<li>②. tomcat部署的工程过多(30-50个)</li>
<li>③. 大量动态的生成反射类</li>
</ul>
<h3 id="58-谈谈你对方法区中字符串常量池、静态变量的变化？"><a href="#58-谈谈你对方法区中字符串常量池、静态变量的变化？" class="headerlink" title="58 谈谈你对方法区中字符串常量池、静态变量的变化？"></a>58 谈谈你对方法区中字符串常量池、静态变量的变化？</h3><ul>
<li>①. Jdk 1.6 及之前：有永久代，静态变量、字符串常量池1.6在方法区</li>
<li>②. Jdk 1.7：有永久代，但已经逐步 “ 去永久代 “，字符串常量池、静态变量移除，保存在堆中</li>
<li>③. jdk 1.8 及之后：无永久代，常量池1.8在元空间。但静态变量、字符串常量池仍在堆中</li>
</ul>
<h3 id="59-为什么要用元空间取代永久代"><a href="#59-为什么要用元空间取代永久代" class="headerlink" title="59 为什么要用元空间取代永久代"></a>59 为什么要用元空间取代永久代</h3><ul>
<li>①.永久代参数设置过小，在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM，比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误</li>
<li>②.永久代参数设置过大，导致空间浪费</li>
<li>③. 默认情况下，元空间的大小受本地内存限制)</li>
<li>④. 对永久代进行调优是很困难的<br>[方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型，而不再使用的类或类的加载器回收比较复杂，full gc 的时间长]</li>
</ul>
<h3 id="60-StringTable为什么要调整"><a href="#60-StringTable为什么要调整" class="headerlink" title="60 StringTable为什么要调整?"></a>60 StringTable为什么要调整?</h3><ul>
<li>①.jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才能触发。而full gc是老年代的空间不足、永久代不足才会触发</li>
<li>②. 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存</li>
</ul>
<h3 id="61-new对象流程？对象的内存分配"><a href="#61-new对象流程？对象的内存分配" class="headerlink" title="61 new对象流程？对象的内存分配?"></a>61 new对象流程？对象的内存分配?</h3><ul>
<li>①. 判断对象对应的类是否加载、链接、初始化</li>
<li>②. 为对象分配内存</li>
<li>③. 处理并发安全问题</li>
<li>④. 初始化分配到的空间</li>
<li>⑤. 设置对象的对象头</li>
<li>⑥. 执行init方法进行初始化</li>
</ul>
<h3 id="62-对象内部结构都有什么"><a href="#62-对象内部结构都有什么" class="headerlink" title="62 对象内部结构都有什么?"></a>62 对象内部结构都有什么?</h3><ul>
<li>对象头、实例数据、对齐填充(保证8个字节的倍数)<br><img src="https://img-blog.csdnimg.cn/20210406193020801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="63-Java对象头里有什么"><a href="#63-Java对象头里有什么" class="headerlink" title="63  Java对象头里有什么?"></a>63  Java对象头里有什么?</h3><ul>
<li>①. 对象标记Mark Word(哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)</li>
<li>②. 类元信息</li>
</ul>
<h3 id="64-谈谈你对执行引擎的理解"><a href="#64-谈谈你对执行引擎的理解" class="headerlink" title="64  谈谈你对执行引擎的理解?"></a>64  谈谈你对执行引擎的理解?</h3><ul>
<li>①. 执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以</li>
<li>②. 解释器(负责响应时间)：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
<li>③. JIT(负责性能) (Just In Time Compiler)编译器(即时编译器)：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言<br>JLT是基于计数器的热点探测技术将热点代码进行缓存，主要分为基于：方法调用计数器用于统计方法的调用次数;回边计数器则用于统计循环体执行的循环次数<br><img src="https://img-blog.csdnimg.cn/20210609154505805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="65-你是怎么指定JVM启动模式？"><a href="#65-你是怎么指定JVM启动模式？" class="headerlink" title="65 你是怎么指定JVM启动模式？"></a>65 你是怎么指定JVM启动模式？</h3><ul>
<li>java -version</li>
</ul>
<h3 id="66-那你知道-server-c2-和-client-c1-的区别吗？"><a href="#66-那你知道-server-c2-和-client-c1-的区别吗？" class="headerlink" title="66 那你知道-server(c2)和-client(c1)的区别吗？"></a>66 那你知道-server(c2)和-client(c1)的区别吗？</h3><ul>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h3 id="67-为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？"><a href="#67-为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？" class="headerlink" title="67  为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？"></a>67  为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？</h3><ul>
<li>①. 使用JLT编译器，针对的是字节码文件，可以跨平台</li>
<li>②. 可以在动态期间对齐进行优化，比如:逃逸分析优化(逃逸分析优化可以有如下几种:栈上分配、标量替换、同步消除)</li>
</ul>
<h3 id="68-什么是垃圾？"><a href="#68-什么是垃圾？" class="headerlink" title="68 什么是垃圾？"></a>68 什么是垃圾？</h3><ul>
<li>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li>
</ul>
<h3 id="69-Java中垃圾回收的重点区域是？"><a href="#69-Java中垃圾回收的重点区域是？" class="headerlink" title="69  Java中垃圾回收的重点区域是？"></a>69  Java中垃圾回收的重点区域是？</h3><ul>
<li>①. 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收</li>
<li>②. 从次数上讲:<br>频繁收集Young区<br>较少收集Old区<br>基本不动Perm区(或元空间)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210614131601172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="70-谈谈你对垃圾判别阶段算法都有哪些"><a href="#70-谈谈你对垃圾判别阶段算法都有哪些" class="headerlink" title="70  谈谈你对垃圾判别阶段算法都有哪些?"></a>70  谈谈你对垃圾判别阶段算法都有哪些?</h3><ul>
<li>①. 引用计数算法</li>
<li>②. 可达性分析算法</li>
</ul>
<h3 id="71-引用计数算法"><a href="#71-引用计数算法" class="headerlink" title="71 引用计数算法"></a>71 引用计数算法</h3><ul>
<li>①. 原理:假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收</li>
<li>②. 最大的缺陷:无法解决循环引用的问题，gc永远都清除不了(这也是引用计数法被淘汰的原因)</li>
<li>③. Java使用的不是引用计数法(Java之所以没有使用引用计数法，是由于不能解决循环引用问题) | (Python使用了是引用计数法)</li>
<li>④. Python如何解决循环引用( 扩展了解 )</li>
</ul>
<ol>
<li>手动解决:很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用(只要发生了回收，弱引用都会被回收)</li>
</ol>
<h3 id="72-你对枚举根节点做可达性分析了解吗"><a href="#72-你对枚举根节点做可达性分析了解吗" class="headerlink" title="72 你对枚举根节点做可达性分析了解吗?"></a>72 你对枚举根节点做可达性分析了解吗?</h3><ul>
<li>①. 基本思路是通过一系列名为”GC Roots”的对象(集合)作为起点，从这个被称为GC ROOTs 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象是不可达对象(被回收)，否则就是可达对象<br><img src="https://img-blog.csdnimg.cn/20190813202011669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="73-在java中，可作为GC-Roots的对象有"><a href="#73-在java中，可作为GC-Roots的对象有" class="headerlink" title="73 在java中，可作为GC Roots的对象有?"></a>73 在java中，可作为GC Roots的对象有?</h3><ul>
<li>注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots 集合。比如: 分代收集和局部回收(面试加分项)<br>解释:如果只针对java堆中的某一区域进行垃圾回收(比如: 典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用时候就需要一并将关联的区域对象也加入到GC Roots 集合中考虑，才能保证可达性分析的准确性</li>
</ul>
<pre><code class="handlebars">    (1).虚拟机栈(栈帧中的局部变量表)中的引用对象(比如各个线程被调用的方法中使用到的参数、
    局部变量等)
    (2).本地方法栈中JNI(即一般来说native方法)中引用的对象[ 线程中的start方法 ]
    (3).静态属性引用的对象(比如:Java类的引用类型静态变量)
    (4).方法区中常量引用的对象(比如:字符串常量池(String Table)里的引用)
        
    (5).所有被synchronized持有的对象
    (6).Java虚拟机内部的引用(基本数据类型对应的Class对象，一些常驻的异常对象
    [如NullPointerException、OutofMemoryError]，系统类加载器)
    (7).反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    (8).注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots集合。比如:分代收集和局部回收(面试加分项)
</code></pre>
<h3 id="74-复制算法及优缺点你是怎么理解的"><a href="#74-复制算法及优缺点你是怎么理解的" class="headerlink" title="74 复制算法及优缺点你是怎么理解的?"></a>74 复制算法及优缺点你是怎么理解的?</h3><ul>
<li>①. 复制算法的过程<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 优缺点</li>
</ul>
<ol>
<li>①.没有标记和清除过程，实现简单，运行高效 ②. 不会产生内存碎片，且对象完整不丢</li>
<li>缺点：①. 浪费了10%的空间 ②. 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
<li>注意:复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。因为新生代中的对象一般都是朝生夕死的，在新生代中使用复制算法是非常好的</li>
</ol>
<ul>
<li>③. 注意:是当伊甸园区满后，会触发minjor gc，进行垃圾的回收</li>
</ul>
<h3 id="75-标记清除算法-Mark一Sweep"><a href="#75-标记清除算法-Mark一Sweep" class="headerlink" title="75 标记清除算法(Mark一Sweep)"></a>75 标记清除算法(Mark一Sweep)</h3><ul>
<li>①. 标记一清除算法(Mark一Sweep)是一种非常基础和常见的垃圾收集算法，该算法被J . McCarthy等人在1960年提出并并应用于Lisp语言</li>
<li>②. 标记:Collector(垃圾回收器)从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>③. 清除: Collector(垃圾回收器)对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
<li>④. 图解: CMS使用这种方式<br><img src="https://img-blog.csdnimg.cn/20210612172349990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优:不需要额外的空间</li>
<li>缺点:①.两次扫描，耗时严重 ②.清理出来的空闲内存不连续，会产生内存碎片，需要维护一个空闲列表 ③.效率比较低:递归与全堆对象遍历两次(经历了两次遍历)</li>
</ol>
<ul>
<li>⑥. 注意:这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放</li>
</ul>
<h3 id="76-标记整理-压缩-算法-Mark-Compact"><a href="#76-标记整理-压缩-算法-Mark-Compact" class="headerlink" title="76 标记整理(压缩)算法(Mark-Compact)"></a>76 标记整理(压缩)算法(Mark-Compact)</h3><ul>
<li><p>①. 背景:</p>
<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li>
</ul>
<ul>
<li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记一压缩(Mark一Compact) 算法由此诞生</li>
<li>1970年前后，G. L. Steele 、C. J. Chene和D.S. Wise 等研究者发布标记一压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</li>
</ul>
</li>
<li><p>②. 执行过程:</p>
<ul>
<li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
</ul>
<ul>
<li><p>最后，清理边界外所有的空间。</p>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</p>
</li>
</ul>
</li>
<li><p>③. 图解:<br><img src="https://img-blog.csdnimg.cn/20200818141849116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. 指针碰撞<br>(如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer))</p>
</li>
<li><p>⑤. 优缺点</p>
<ul>
<li>优点:①. 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可②. 消除了复制算法当中，内存减半的高额代价</li>
<li>缺点:①. 从效率.上来说，标记一整理算法要低于复制算法。②. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序。即: STW</li>
</ul>
</li>
</ul>
<h3 id="77-JVM采用的是分代收集？"><a href="#77-JVM采用的是分代收集？" class="headerlink" title="77 JVM采用的是分代收集？"></a>77 JVM采用的是分代收集？</h3><blockquote>
<p>写在最前面:<br>( 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除)</p>
</blockquote>
<ul>
<li><p>①. 没有最好的算法，只有更合适的算法</p>
</li>
<li><p>②. 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除</p>
</li>
<li><p>③. 新生代(Young Gen)</p>
<ul>
<li>新生代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
</ul>
<ul>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li>
</ul>
</li>
<li><p>④. 老年代(Tenured Gen)</p>
<ul>
<li><p>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
</li>
<li><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记一整理的混合实现。<br>Mark阶段的开销与存活对象的数量成正比<br>Sweep阶段的开销与所管理区域的大小成正相关<br>Compact阶段的开销与存活对象的数据成正比</p>
</li>
</ul>
</li>
</ul>
<h3 id="78-谈谈你对finalize-方法中虚拟机的状态？"><a href="#78-谈谈你对finalize-方法中虚拟机的状态？" class="headerlink" title="78 谈谈你对finalize( )方法中虚拟机的状态？"></a>78 谈谈你对finalize( )方法中虚拟机的状态？</h3><ul>
<li><p>①. 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收，但事实上，也并非是”非死不可”的，这时候它们暂时处于”缓刑”阶段。一个无法触及的对象肯能在某一个条件下”复活”自己，如果这样，那么对它的回收就是不合理的。为此，定义虚拟机中的对象可能有三种状态。如下:(掌握)</p>
<ul>
<li>可触及的:从根节点开始，可以到达这个对象</li>
</ul>
<ul>
<li><p>可复活的:对象的所有引用都被释放，但是对象有可能在finalize( )中复活</p>
</li>
<li><p>不可触及的: 对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize( )只会被调用一次</p>
</li>
</ul>
</li>
<li><p>②. 以上3种状态中，是由于finalize( )方法的存在，进行的区分。只有对象不可触及才可以被回收</p>
</li>
</ul>
<h3 id="79-System-gc-与Runtime-getRuntime-gc-区别"><a href="#79-System-gc-与Runtime-getRuntime-gc-区别" class="headerlink" title="79 System.gc()与Runtime.getRuntime().gc()区别"></a>79 System.gc()与Runtime.getRuntime().gc()区别</h3><ul>
<li>①. 通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存</li>
</ul>
<h3 id="80-什么是内存泄漏？"><a href="#80-什么是内存泄漏？" class="headerlink" title="80 什么是内存泄漏？"></a>80 什么是内存泄漏？</h3><ul>
<li><p>①. javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存</p>
</li>
<li><p>②. 说明Java虚拟机的堆内存不够。原因有二</p>
<ul>
<li>Java虚拟机的堆内存设置不够(比如:可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整)</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</li>
</ul>
</li>
<li><p>③. 这里面隐含着一层意思是，在抛出0utOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如:在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
</ul>
<h3 id="81-什么是内存溢出？"><a href="#81-什么是内存溢出？" class="headerlink" title="81  什么是内存溢出？"></a>81  什么是内存溢出？</h3><ul>
<li>①. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</li>
<li>②. 但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏</li>
<li>③. 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</li>
</ul>
<h3 id="82-Java中内存泄漏的8种情况"><a href="#82-Java中内存泄漏的8种情况" class="headerlink" title="82  Java中内存泄漏的8种情况"></a>82  Java中内存泄漏的8种情况</h3><ul>
<li>①.单例模式(单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。)</li>
<li>②. 一些提供close的资源未关闭导致内存泄漏 数据库连接( dataSourse. getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</li>
<li>③. 静态集合类(如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收)</li>
<li>④. 内部类持有外部类(内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。)</li>
<li>⑤. 变量不合理的作用域(一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生)</li>
<li>⑥. 改变哈希值</li>
<li>⑦. 缓存泄漏(内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据)</li>
<li>⑧. 监听器和回调(内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚)</li>
</ul>
<pre><code class="typescript">//静态集合类
public class MemoryLeak &#123;
    static List list = new ArrayList();

public void oomTests() &#123;
    Object obj = new Object();//局部变量
    list.add(obj);
&#125;
&#125;
//变量不合理的作用域
public class UsingRandom &#123;
    private String msg;
    public void receiveMsg()&#123;
        //private String msg;
        readFromNet();// 从网络中接受数据保存到msg中
        saveDB();// 把msg保存到数据库中
        //msg = null;
    &#125;
&#125;
//改变哈希值
public class ChangeHashCode &#123;
    public static void main(String[] args) &#123;
        HashSet set = new HashSet();
        Person p1 = new Person(1001， &quot;AA&quot;);
        Person p2 = new Person(1002， &quot;BB&quot;);

        set.add(p1);
        set.add(p2);
        p1.name = &quot;CC&quot;;
        set.remove(p1);
        System.out.println(set);//2个对象！

        //        set.add(new Person(1001， &quot;CC&quot;));
        //        System.out.println(set);
        //        set.add(new Person(1001， &quot;AA&quot;));
        //        System.out.println(set);

    &#125;
&#125;
</code></pre>
<h3 id="83-什么情况下会导致stop-the-world"><a href="#83-什么情况下会导致stop-the-world" class="headerlink" title="83 什么情况下会导致stop the world"></a>83 什么情况下会导致stop the world</h3><ul>
<li>①. 可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</li>
<li>②. 进行gc的时候会发生STW现象(调用finalize()方法的时候会暂停用户线程</li>
<li>③. System.gc( ) | 调用finalize( )方法。我们调用System.gc( ) 会触发Full gc</li>
</ul>
<h3 id="84-谈谈你对安全点的理解-？"><a href="#84-谈谈你对安全点的理解-？" class="headerlink" title="84 谈谈你对安全点的理解 ？"></a>84 谈谈你对安全点的理解 ？</h3><ul>
<li>①. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为 “安全点(Safepoint)”</li>
<li>②. Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</li>
<li>③. 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？<ul>
<li>抢先式中断: (目前没有虚拟机采用了) 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li>主动式中断: 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
</li>
</ul>
<h3 id="85-安全区域你知道吗"><a href="#85-安全区域你知道吗" class="headerlink" title="85 安全区域你知道吗?"></a>85 安全区域你知道吗?</h3><ul>
<li><p>①. Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
</li>
<li><p>②. 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
</li>
<li><p>③. 实际执行时:</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发GC，JVM会忽略标识为Safe Region状态的线程；</li>
</ul>
<ul>
<li>当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</li>
</ul>
</li>
</ul>
<h3 id="86-强引用、软引用、弱引用、虚引用的区别？"><a href="#86-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="86 强引用、软引用、弱引用、虚引用的区别？"></a>86 强引用、软引用、弱引用、虚引用的区别？</h3><ul>
<li>①. 强引用:不回收</li>
<li>②. 软引用: 内存不足即回收</li>
<li>③. 弱引用: 发现即回收</li>
<li>④. 虚引用: 对象回收跟踪<br><img src="https://img-blog.csdnimg.cn/20210625145600775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="87-Java中垃圾回收的重点区域是？"><a href="#87-Java中垃圾回收的重点区域是？" class="headerlink" title="87  Java中垃圾回收的重点区域是？"></a>87  Java中垃圾回收的重点区域是？</h3><ul>
<li>①. 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。(其中，Java堆是垃圾收集器的工作重点)</li>
<li>②. 从次数上讲:频繁收集Young区、较少收集Old区、基本不动Perm区(或元空间)<br><img src="https://img-blog.csdnimg.cn/20210625145636718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="88-GC是什么？为什么要有GC？"><a href="#88-GC是什么？为什么要有GC？" class="headerlink" title="88 GC是什么？为什么要有GC？"></a>88 GC是什么？为什么要有GC？</h3><ul>
<li>①. 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</li>
<li>②. 如果不进行垃圾回收，垃圾会占据内存，可能会导致OOM现象</li>
</ul>
<h3 id="89-吞吐量优先选择什么垃圾回收器？响应时间优先呢"><a href="#89-吞吐量优先选择什么垃圾回收器？响应时间优先呢" class="headerlink" title="89 吞吐量优先选择什么垃圾回收器？响应时间优先呢?"></a>89 吞吐量优先选择什么垃圾回收器？响应时间优先呢?</h3><ul>
<li>①. 吞吐量优先选择Parallel GC 垃圾收集器</li>
<li>②. 响应时间优先选择: CMS、G1</li>
</ul>
<h3 id="90-谈谈你对JVM中垃圾收集器的理解？"><a href="#90-谈谈你对JVM中垃圾收集器的理解？" class="headerlink" title="90  谈谈你对JVM中垃圾收集器的理解？"></a>90  谈谈你对JVM中垃圾收集器的理解？</h3><ul>
<li>①. 不同的厂商会考虑使用不同的JVM，不同的JVM会使用不同的垃圾收集器，下面我介绍下主流的垃圾收集器有哪些(主流的7种)，下面你就可以展开去说明七种垃圾收集器的每一个细节</li>
<li>②. 截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器<br><img src="https://img-blog.csdnimg.cn/2020092610513159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>③. 同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合(连线)，如下图:<br><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="91-讲一下CMS垃圾收集器垃圾回收的流程"><a href="#91-讲一下CMS垃圾收集器垃圾回收的流程" class="headerlink" title="91 讲一下CMS垃圾收集器垃圾回收的流程"></a>91 讲一下CMS垃圾收集器垃圾回收的流程</h3><ul>
<li><p>①. 初始标记(Initial一Mark)仅仅只是标记出和GCRoots能直接关联到的对象，有STW现象、暂时时间非常短</p>
</li>
<li><p>②. 并发标记(Concurrent一Mark)阶段:从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行(并发标记阶段有三色标记，下文有记录)</p>
</li>
<li><p>③. 重新标记(Remark) 阶段:有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</p>
</li>
<li><p>④. 并发清除:此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
<li><p>⑤. 补充说明:</p>
<ul>
<li><p>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS收集器的垃圾收集算法采用的是标记一清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择空闲列表(Free List) 执行内存分配。<br>(在并发标记阶段一开始不是垃圾，最后变成了垃圾)</p>
</li>
</ul>
</li>
</ul>
<h3 id="92-CMS优缺点"><a href="#92-CMS优缺点" class="headerlink" title="92  CMS优缺点"></a>92  CMS优缺点</h3><ul>
<li><p>①. 优点:并发收集、低延迟</p>
</li>
<li><p>②. CMS的弊端:</p>
<ul>
<li><p>会产生内存碎片</p>
</li>
<li><p>CMS收集器对CPU资源非常敏感<br>(在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低)</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾。可能出现”Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间</p>
</li>
</ul>
</li>
<li><p>③.区分两个注意事项</p>
<ul>
<li><p>并发标记阶段，在遍历GCRoots，用户线程也在执行，若此时遍历过一个对象发现没有引用，但由于用户线程并发执行，这期间可能导致遍历过的这个对象又被其他对象引用，所以才需要重新标记阶段再遍历一次看又没有漏标记的，否则就会导致被重新引用的对象被清理掉</p>
</li>
<li><p>浮动垃圾:在并发标记阶段一开始不是垃圾，最后变成了垃圾(属于多标的情况)</p>
</li>
</ul>
</li>
</ul>
<h3 id="93-CMS会出现漏标，怎么解决的"><a href="#93-CMS会出现漏标，怎么解决的" class="headerlink" title="93  CMS会出现漏标，怎么解决的?"></a>93  CMS会出现漏标，怎么解决的?</h3><ul>
<li>①. 通过增量更新和写屏障(后)的方式去解决的</li>
<li>②. 在把我们新增的引用放到集合的时候，会实现一种写屏障的方式。在对象前后通过一个dirty card queue将引用信息， 存在card中，这个dirty card queue会放在cardtable中，而cardtable是记忆集的具体实现，最终这个引用就会放在记忆集中的<br>(写屏障我们可以理解为在赋值操作的前面加一个方法，赋值的后面做一些操作，也可以理解为AOP。具体的C++实现代码如下图:)<br><img src="https://img-blog.csdnimg.cn/20201014153100882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="94-三色标志谈谈你的理解是什么样的"><a href="#94-三色标志谈谈你的理解是什么样的" class="headerlink" title="94 三色标志谈谈你的理解是什么样的?"></a>94 三色标志谈谈你的理解是什么样的?</h3><ul>
<li><p>①. 在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色:</p>
<ul>
<li>黑色(black):节点被遍历完成，而且子节点都遍历完成</li>
</ul>
<ul>
<li><p>灰色(gray): 当前正在遍历的节点，而且子节点还没有遍历</p>
</li>
<li><p>白色(white):还没有遍历到的节点，即灰色节点的子节点<br><img src="https://img-blog.csdnimg.cn/20210622094337195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 根据三色扫描算法，如果有下面两种情况发生，则会出现漏扫描的场景:</p>
<ul>
<li><p>把一个白对象的引用存到黑对象的字段里，如果这个情况发生，因为标记为黑色的对象认为是扫描完成的，不会再对他进行扫描。只能通过灰色的对象(CMS垃圾收集器)<br>(如上图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障和增量更新解决)</p>
</li>
<li><p>某个白对象失去了所有能从灰对象到达它的引用路径(直接或间接)(G1垃圾收集器)<br>(如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用写屏障和原始快照)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201014152019497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 三色过程:如下图所示，假如说A引入了B，B引用了C，D没有被任何引用。那么首先我们的CMS首先扫描到了A，发现A有引用B，那么我们的CMS会将A标记为黑色，B标记为灰色，然后这时候，通过B又找到了C那么这个时候发现C已经没有任何引用了就会将C标记为黑色。但是我们的D到目前为止没有被任何引用，记住我这里说的条件!那么D从始至终都没有被扫描，此时就会一直是白色，对于白色的对象来说CMS在执行并发清理的时候就会将此类对象干掉。<br>但是这里有了一个问题:如果我们的扫描过程已经结束这一段了，但是此时此刻我的A突然引用了D类型怎么办，这样一来我们的D只要被GC干掉是不是就会出现问题？也就是说我这里产生了一个漏标的问题。当然，我们的JVM开发人员可不是傻子，这里他们用了一个操作叫做增量更新和写屏障来解决这种问题的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="95-谈谈你对G1垃圾收集器的理解？"><a href="#95-谈谈你对G1垃圾收集器的理解？" class="headerlink" title="95  谈谈你对G1垃圾收集器的理解？"></a>95  谈谈你对G1垃圾收集器的理解？</h3><ul>
<li>①. G1是一个并行回收器，它把堆内存分割为很多不相关的区域(region物理上不连续)，把堆分为2048个区域，每一个region的大小是1 - 32M不等，必须是2的整数次幂。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</li>
<li>②. 每次根据允许的收集时间，优先回收价值最大的Region<br>(每次回收完以后都有一个空闲的region，在后台维护一个优先列表)</li>
<li>③. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字:垃圾优先(Garbage First)</li>
<li>④. 下面说一个问题:既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First(G1)GC？<br>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器”的重任与期望。</li>
</ul>
<h3 id="96-G1垃圾收集器的特点、缺点"><a href="#96-G1垃圾收集器的特点、缺点" class="headerlink" title="96 G1垃圾收集器的特点、缺点"></a>96 G1垃圾收集器的特点、缺点</h3><ul>
<li><p>①. 并行和并发</p>
<ul>
<li>并行性: G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
</ul>
<ul>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p>②. 分代收集</p>
<ul>
<li><p>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p>将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。</p>
</li>
<li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210627185423634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210627185428360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 空间整合<br>(G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记一压缩(Mark一Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显)</p>
</li>
<li><p>④. 可预测的停顿时间模型(即:软实时soft real一time)<br>(这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒、可以通过参数-XX:MaxGCPauseMillis进行设置)</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
</ul>
<ul>
<li><p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。<br>(CMS的最好的情况G1不一定比的上，但是CMS最差的部分，G1可以比上)</p>
</li>
</ul>
</li>
<li><p>⑤. 缺点:</p>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</li>
</ul>
<ul>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间</li>
</ul>
</li>
</ul>
<h3 id="97-谈谈你对G1中的Region的理解"><a href="#97-谈谈你对G1中的Region的理解" class="headerlink" title="97  谈谈你对G1中的Region的理解"></a>97  谈谈你对G1中的Region的理解</h3><ul>
<li>①. 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。可以通过-XX:G1Hea pRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变</li>
<li>②. 一个region 有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于0ld内存区域。图中空白的表示未使用的内存空间</li>
<li>③. 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H<br>(对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926192008566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="98-大致说说G1的回收过程"><a href="#98-大致说说G1的回收过程" class="headerlink" title="98  大致说说G1的回收过程"></a>98  大致说说G1的回收过程</h3><ul>
<li><p>①. G1 GC的垃圾回收过程主要包括如下三个环节:</p>
<ul>
<li>年轻代GC (Young GC)</li>
</ul>
<ul>
<li><p>老年代并发标记过程 (Concurrent Marking)</p>
</li>
<li><p>混合回收(Mixed GC)</p>
</li>
<li><p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/20210627220226998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行(多个垃圾线程)的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</p>
</li>
<li><p>③. 当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程</p>
</li>
<li><p>④. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
</li>
<li><p>⑤. 举个例子:一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收</p>
</li>
</ul>
<h3 id="99-G1的年轻代GC"><a href="#99-G1的年轻代GC" class="headerlink" title="99  G1的年轻代GC?"></a>99  G1的年轻代GC?</h3><blockquote>
<p>回收时机<br>(1). 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区<br>(3). 回收前:<br><img src="https://img-blog.csdnimg.cn/20210627224109323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(4). 回收后:<br><img src="https://img-blog.csdnimg.cn/20210627224114494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>①. 根扫描： 一定要考虑remembered Set，看是否有老年代中的对象引用了新生代对象<br>(根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口)</li>
<li>②.更新RSet:处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用<br>(dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty CardQueue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多)</li>
<li>③. 处理RSet：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</li>
<li>④. 复制对象：复制算法<br>(此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间)</li>
<li>⑤. 处理引用：处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</li>
</ul>
<h3 id="100-并发标记过程"><a href="#100-并发标记过程" class="headerlink" title="100  并发标记过程"></a>100  并发标记过程</h3><ul>
<li>①. 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>②. 根区域扫描(Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成(YoungGC时，会动Survivor区，所以这一过程必须在young GC之前完成)</li>
<li>③. 并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>④. 再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)<br>(在CMS中有详细讲解)</li>
<li>⑤. 独占清理(cleanup，STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)</li>
<li>⑥. 并发清理阶段：识别并清理完全空闲的区域</li>
</ul>
<h3 id="101-混合回收-Mixed-GC"><a href="#101-混合回收-Mixed-GC" class="headerlink" title="101 混合回收 Mixed GC"></a>101 混合回收 Mixed GC</h3><ul>
<li>①. Mixed GC并不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926194129931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="102-G1和CMS相比有哪些优势"><a href="#102-G1和CMS相比有哪些优势" class="headerlink" title="102  G1和CMS相比有哪些优势?"></a>102  G1和CMS相比有哪些优势?</h3><ul>
<li>①. G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片</li>
<li>②. G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间</li>
</ul>
<h3 id="103-我们怎么去选择垃圾收集器？"><a href="#103-我们怎么去选择垃圾收集器？" class="headerlink" title="103  我们怎么去选择垃圾收集器？"></a>103  我们怎么去选择垃圾收集器？</h3><ul>
<li>①. 单CPU或者小内存，单机程序 -XX:+UseSerialGC</li>
<li>②. 多CPU，需要最大吞吐量，如后台计算型应用<br>-XX:+UseParallelGC 或者 -XX:+UseParallelOldGC</li>
<li>③. 多CPU，追求低停顿时间，需快速响应如互联网应用<br>-XX:+UseConcMarkSweepGC 或者 -XX:+ParNewGC</li>
</ul>
<h2 id="二、跨平台原理、分类、三大商业虚拟机"><a href="#二、跨平台原理、分类、三大商业虚拟机" class="headerlink" title="二、跨平台原理、分类、三大商业虚拟机"></a>二、跨平台原理、分类、三大商业虚拟机</h2><h3 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1 什么是JVM？"></a>1 什么是JVM？</h3><ul>
<li>①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</li>
<li>②. jvm是运行在操作系统之上的，与硬件没有任何关系<br><img src="https://img-blog.csdnimg.cn/20210422092200243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="2-Java的跨平台及原理"><a href="#2-Java的跨平台及原理" class="headerlink" title="2 Java的跨平台及原理"></a>2 Java的跨平台及原理</h3><ul>
<li>①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</li>
<li>②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)<br>(Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-JVM的分类"><a href="#3-JVM的分类" class="headerlink" title="3  JVM的分类"></a>3  JVM的分类</h3><ul>
<li>①. 类加载子系统</li>
<li>②. 运行时数据区 [ 我们核心关注这里 的栈、堆、方法区 ]</li>
<li>③. 执行引擎(一般都是JIT编译器和解释器共存)</li>
</ul>
<ol>
<li>JIT编译器(主要影响性能)：编译执行； 一般热点数据会进行二次编译，将字节码指令变成机器指令。将机器指令放在方法区缓存</li>
<li>解释器(负责响应时间)：逐行解释字节码</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200907172633714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907172639931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210422092252198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-三大商业虚拟机"><a href="#4-三大商业虚拟机" class="headerlink" title="4  三大商业虚拟机"></a>4  三大商业虚拟机</h3><ul>
<li><p>①. Sun HotSpot</p>
<ul>
<li>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机</li>
<li>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码， 并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</li>
<li>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务， 使用HotSpot的JIT编译器与混合的运行时系统</li>
</ul>
</li>
<li><p>②. BEA JRocket</p>
<ul>
<li>专注于服务端应用(JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行)</li>
<li>Jrockit JVM 是世界上最快的jvm3. 2008年被oracle收购</li>
</ul>
</li>
<li><p>③. iBM J9</p>
<ul>
<li>市场定位与hotspot接近，服务器端，桌面应用，嵌入式等</li>
<li>目前，是影响力的三大商业虚拟机之一</li>
</ul>
</li>
</ul>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p><img src="https://img-blog.csdnimg.cn/20210518203736751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、程序计数器"><a href="#四、程序计数器" class="headerlink" title="四、程序计数器"></a>四、程序计数器</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1 程序计数器"></a>1 程序计数器</h3><ul>
<li>①. 作用 (是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令)</li>
<li>②. 特点(是线程私有的 、不会存在内存溢出)</li>
<li>③. 注意:在物理上实现程序计数器是在寄存器实现的，整个cpu中最快的一个执行单元</li>
<li>④. 它是唯一一个在java虚拟机规范中没有OOM的区域</li>
</ul>
<blockquote>
<p>解释:<br>(1). 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向下一条指令的地址，也即将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记<br>(2). 这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令<br>(3). 如果执行的是一个Native方法，那这个计数器是undefined<br><img src="https://img-blog.csdnimg.cn/20210525155403577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200220202701869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑤. 使用PC寄存器存储字节码指令地址有什么用呢?<br>为什么使用PC寄存器记录当前线程的执行地址呢?</li>
</ul>
<ol>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li>
<li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令<br><img src="https://img-blog.csdnimg.cn/20210427211423937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>⑥. PC寄存器为什么设定为线程私有?<br>(为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器)</li>
<li>⑦. 关于线程在JVM中的说明:</li>
</ul>
<ol>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<br>(解释:当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建.Java线程执行终止后，本地线程也会被回收)</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化完毕，它就会调用Java线程中的run方法</li>
</ol>
<h3 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2  本地方法栈"></a>2  本地方法栈</h3><ul>
<li>①. Native Interface本地接口</li>
</ul>
<ol>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须由调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies</li>
<li>目前该方法的使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍</li>
</ol>
<ul>
<li>②. 本地方法栈(Native Method Stack)<br>(它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库)</li>
<li>③. native方法的举例: Object类中的clone wait notify hashCode 等 Unsafe类都是native方法<br><img src="https://img-blog.csdnimg.cn/20200505095206157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="五、虚拟机栈概述、局部变量表、操作数栈、动态链接"><a href="#五、虚拟机栈概述、局部变量表、操作数栈、动态链接" class="headerlink" title="五、虚拟机栈概述、局部变量表、操作数栈、动态链接"></a>五、虚拟机栈概述、局部变量表、操作数栈、动态链接</h2><blockquote>
<p>前言:<br>(栈并不是越大越好，越多可以防止出现StackOverflowError晚点出现，但是栈越大，也就代表着虚拟机栈是一定的，你的栈越大，别的栈就会小)</p>
</blockquote>
<h3 id="1-什么是Java-virtual-machine"><a href="#1-什么是Java-virtual-machine" class="headerlink" title="1 什么是Java virtual machine?"></a>1 什么是Java virtual machine?</h3><ul>
<li>①. 栈的概述<br>每创建一个线程就会创建一个Java栈，每一个Java栈中都会有很多栈帧(局部变量表 | 操作数栈 | 动态链接 | 方法返回地址 | 一些附加信息)<br>注意:虚拟机栈中不存在GC，但是存在StackOverflowError和OOM</li>
</ul>
<blockquote>
<p>解释:<br>(1). 虚拟机栈(Java Virtual Machine Stacks)和线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈，所以Java栈也是”线程私有”的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程[先进后出]<br>(2). 栈帧中有如下部分组成:<br><img src="https://img-blog.csdnimg.cn/20200228105322185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">(3). 栈的其他介绍<br><img src="https://img-blog.csdnimg.cn/20190628111731333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>②. 存放于栈中的东西如下<br>(8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配[局部变量])</li>
<li>③. 栈内存溢出(StackOverflowError) <code>-Xss</code>参数</li>
</ul>
<ol>
<li>栈帧过多导致栈内存溢出(方法的递归调用，没设置正确停止条件)</li>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出</li>
</ol>
<pre><code class="java">Exception in thread &quot;main&quot; java.lang.StackOverflowError
    //sayHello()发生了递归
    public class DemoT &#123;
        public static void main(String[] args) &#123;
            sayHello();
        &#125;

        public static void sayHello()&#123;
            sayHello();
        &#125;
    &#125;
</code></pre>
<ul>
<li>④. Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的 掌握</li>
</ul>
<ol>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。</li>
<li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者是在创建新的线程时就没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ol>
<ul>
<li>⑤. 如何设置栈内存的大小？ -Xss size (即:-XX:ThreadStackSize)<br>一般默认为512k-1024k，取决于操作系统(jdk5之前，默认栈大小是256k;jdk5之后，默认栈大小是1024k)<br>栈的大小直接决定了函数调用的最大可达深度</li>
</ul>
<table>
<thead>
<tr>
<th>平台</th>
<th>jdk8</th>
</tr>
</thead>
<tbody><tr>
<td>linux</td>
<td>1024</td>
</tr>
<tr>
<td>MacOS</td>
<td>1024</td>
</tr>
<tr>
<td>window</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>⑥. 栈和堆的区别是什么?</li>
</ul>
<ol>
<li>从GC、OOM、StackOverflowError的角度。<br>(栈中不存在GC，当固定大小的栈会发生StackOverflowError，动态的会发生OOM。堆中GC、OOM、StackOverflowError都存在)</li>
<li>从堆栈的执行效率<br>(栈的效率高于堆)</li>
<li>内存大小，数据结构<br>(堆的空间比栈的大一般，栈是一种FIFO先进后出的模型。堆中结构复杂，可以有链表、数组等)</li>
<li>栈管运行，堆管存储</li>
</ol>
<h3 id="2-局部变量表-LocalVariables"><a href="#2-局部变量表-LocalVariables" class="headerlink" title="2 局部变量表(LocalVariables)"></a>2 局部变量表(LocalVariables)</h3><ul>
<li>①. 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量(这些数据类型包括各种基本数据类型、对象引用(reference)以及return Address类型)</li>
<li>②. 由于局部变量是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题</li>
<li>③. 局部变量表所需容量大小是在编译期确定下来的。(并保存在方法Code属性的maximum local variables数据项中，在方法运行期间不会改变局部变量表的大小的)</li>
</ul>
<pre><code class="java">//使用javap -v 类.class 或者使用jclasslib
public class LocalVariableTest &#123;
    public static void main(String[] args) &#123;
        LocalVariableTest test=new LocalVariableTest();
        int num=10;
        test.test1();
    &#125;
    public static void test1()&#123;
        Date date=new Date();
        String name=&quot;xiaozhi&quot;;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>jclasslib说明:</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020050510515537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200505105323929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200505105818394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>④. 关于slot的理解(引用数据类型(方法的返回地址)占用1个slot)</li>
</ul>
<ol>
<li>局部变量表，是基本的存储单元是slot(变量槽)</li>
<li>在局部变量表中，32位以内的类型只占有一个slot(包括引用数据类型)，64位的类型(long和double)占有两个slot</li>
<li>byte、short、char在存储前被转换为int，boolean也被转换为int(0表示fasle，非0表示true)。long和double则占据两个slot</li>
</ol>
<ul>
<li>⑤. Jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>⑥. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可(比如:访问long或double类型变量)<br><img src="https://img-blog.csdnimg.cn/20200506174737348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑦. 如果当前帧是由构造方法或者实例方法创建，那么该对象引用this将会放在index为0的slot处<br><img src="https://img-blog.csdnimg.cn/20200506174914110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑧. 栈帧中的局部变量表中的槽位是可以复用的，如果一个局部变量过了其作用域，那么在其作用域之后申请的新的局部变量就很可能会复用过期局部变量的槽位，从而节省资源的目的</li>
</ul>
<pre><code class="java">public void localVar2()&#123;
    &#123;
        int a=0;
        System.out.println(a);
    &#125;
    //此时的b就会复用a的槽位
    int b=0;
&#125;
</code></pre>
<ul>
<li>⑨. 与GC Roots的关系<br>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li>
</ul>
<h3 id="3-操作数栈-operand-stack"><a href="#3-操作数栈-operand-stack" class="headerlink" title="3 操作数栈(operand stack)"></a>3 操作数栈(operand stack)</h3><ul>
<li>①. 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</li>
<li>②. 每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈</li>
<li>③. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈或出栈</li>
<li>④. 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>⑤. 栈中的任何一个元素都是可以任意的Java数据类型<br>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度</li>
<li>⑥. 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>⑦. 操作数栈，主要用于保存计算机过程的中间结果，同时作为计算过程中变量临时的存储空间 掌握</li>
<li>⑧. 操作数栈的具体说明[一]<br>这里的代码中操作数栈的长度最大是2，在iload_1、iload_2的时候</li>
</ul>
<pre><code class="java">public void testAddOperation()&#123;
    byte i = 15;
    int j = 8;
    int k = i + j;
&#125;
</code></pre>
<blockquote>
<p>解释:<br><img src="https://img-blog.csdnimg.cn/20200506180527992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602225927370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602225955571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230012665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230027752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230042654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2021060223005548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210602230106519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230114151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑧. 操作数栈的具体说明[二]</li>
</ul>
<ol>
<li>局部变量有多少个?</li>
<li>操作数栈的最大深度是多少?<br><img src="https://img-blog.csdnimg.cn/20210602232149871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<pre><code class="typescript">public class OperandStackTest &#123;
    public void testAddOperation()&#123;
        //byte、short、char、boolean:都以int型保存
        byte i=15;
        short j=8;
        int k=i+j;

        long m=12L;
        int n=800;
        //存在宽化类型转换
        m=m*n;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>解释<br><img src="https://img-blog.csdnimg.cn/20210602233254338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑨. 操作数栈的具体说明[三]<br>操作书栈的最大深度是2，这个2是在(new #2 、dup的时候)</li>
</ul>
<pre><code class="typescript">public class OperandStackTest &#123;
    public static void main(String[] args) &#123;
        OperandStackTest test=new OperandStackTest();
        int num=10;
        test.testAddOperation();
    &#125;
    public void testAddOperation()&#123;
        //byte、short、char、boolean:都以int型保存
        byte i=15;
        short j=8;
        int k=i+j;

        long m=12L;
        int n=800;
        //存在宽化类型转换
        m=m*n;
    &#125;


 0 new #2 &lt;com/xiaozhi/jvm/OperandStackTest&gt; 将new的对象放入操作数栈中
 3 dup 复制一份出来，在操作数栈中，这时操作数栈的长度为2
 下面用了dup出来的对象
 4 invokespecial #3 &lt;com/xiaozhi/jvm/OperandStackTest.&lt;init&gt;&gt;
 7 astore_1 将new出来的放入了局部变量表为1的位置，0的位置放的是arg
 8 bipush 10 将10放入操作数栈
10 istore_2  将操作数栈中的10放入局部变量表为2的位置
11 aload_1   将巨变变量表1的位置放入操作数栈中
下面调用了方法，也就意味着操作数栈1的位置出栈了
12 invokevirtual #4 &lt;com/xiaozhi/jvm/OperandStackTest.testAddOperation&gt;
15 return
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210602234734413.png" alt="在这里插入图片描述"></p>
<ul>
<li>⑩. 何为栈顶缓存技术？ 了解</li>
</ul>
<ol>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个题，HotSpot JVM的设计者们提出了栈顶缓存(ToS，Top-of-Stack Cashing)技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</li>
</ol>
<h3 id="4-动态链接-Dynamic-Linking"><a href="#4-动态链接-Dynamic-Linking" class="headerlink" title="4 动态链接(Dynamic Linking)"></a>4 动态链接(Dynamic Linking)</h3><p><img src="https://img-blog.csdnimg.cn/20200506183809387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>①. 运行时常量池位于方法区，字节码中的常量池结构如下:<br><img src="https://img-blog.csdnimg.cn/20200506183837610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②.为什么需要常量池呢？<br>(常量池的作用，就是为了提供一些符号和常量，便于指令的识别。下面提供一张测试类的运行时字节码文件格式)<br><img src="https://img-blog.csdnimg.cn/20200506183954829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020050618401572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</li>
<li>④. 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Refenrence)保存在class字节码文件(javap反编译查看)的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用</li>
</ul>
<h3 id="5-方法的调用-小插曲-难点"><a href="#5-方法的调用-小插曲-难点" class="headerlink" title="5 方法的调用:(小插曲)难点"></a>5 方法的调用:(小插曲)难点</h3><ul>
<li>①. 静态链接(早期绑定):当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接<br>(invokestatic | invokespecial)</li>
<li>②. 动态链接(晚期绑定):如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。**<code>体现了多态</code>**<br>(invokevirtual | invokeinterface)</li>
<li>③. <strong><code>非虚方法:</code></strong> 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法<br><strong><code>(静态方法、私有方法、final方法、实例构造器(实例已经确定，this()表示本类的构造器)、父类方法(super调用)都是非虚方法)</code></strong></li>
<li>④. 其他所有体现多态特性的方法称为虚方法</li>
<li>⑤. 如下指令要重点掌握</li>
</ul>
<pre><code class="java">普通调用指令:
1.invokestatic:调用静态方法，解析阶段确定唯一方法版本；
    2.invokespecial:调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本；
        3.invokevirtual:调用所有虚方法；
            4.invokeinterface:调用接口方法；
                动态调用指令(Java7新增):
5.invokedynamic:动态解析出需要调用的方法，然后执行 .
    前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由
    用户确定方法版本。
    其中invokestatic指令和invokespecial指令调用的方法称为非虚方法

    其中invokevirtual(final修饰的除外，JVM会把final方法调用也归为invokevirtual指
                    令，但要注意final方法调用不是虚方法)、invokeinterface指令调用的方法称称为虚方法。
    12345678910111213
    /**
 * 解析调用中非虚方法、虚方法的测试
 */
    class Father &#123;
        public Father()&#123;
            System.out.println(&quot;Father默认构造器&quot;);
        &#125;

        public static void showStatic(String s)&#123;
            System.out.println(&quot;Father show static&quot;+s);
        &#125;

        public final void showFinal()&#123;
            System.out.println(&quot;Father show final&quot;);
        &#125;

        public void showCommon()&#123;
            System.out.println(&quot;Father show common&quot;);
        &#125;

    &#125;

public class Son extends Father&#123;
    public Son()&#123;
        super();
    &#125;

    public Son(int age)&#123;
        this();
    &#125;

    public static void main(String[] args) &#123;
        Son son = new Son();
        son.show();
    &#125;

    //不是重写的父类方法，因为静态方法不能被重写
    public static void showStatic(String s)&#123;
        System.out.println(&quot;Son show static&quot;+s);
    &#125;

    private void showPrivate(String s)&#123;
        System.out.println(&quot;Son show private&quot;+s);
    &#125;

    public void show()&#123;
        //invokestatic
        showStatic(&quot; 大头儿子&quot;);
        //invokestatic
        super.showStatic(&quot; 大头儿子&quot;);
        //invokespecial
        showPrivate(&quot; hello!&quot;);
        //invokespecial
        super.showCommon();
        //invokevirtual 因为此方法声明有final 不能被子类重写，所以也认为该方法是非虚方法
        showFinal();
        //虚方法如下
        //invokevirtual
        showCommon();//没有显式加super，被认为是虚方法，因为子类可能重写showCommon
        info();

        MethodInterface in = null;
        //invokeinterface  不确定接口实现类是哪一个 需要重写
        in.methodA();

    &#125;

    public void info()&#123;

    &#125;

&#125;

interface MethodInterface &#123;
    void methodA();
&#125;
</code></pre>
<h3 id="6-关于invokedynamic指令"><a href="#6-关于invokedynamic指令" class="headerlink" title="6 关于invokedynamic指令"></a>6 关于invokedynamic指令</h3><ul>
<li>①. JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li>
<li>②. 动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</li>
<li>③. Java是静态类型语言(尽管lambda表达式为其增加了动态特性)，js，python是动态类型语言</li>
</ul>
<pre><code class="java">Java:String info = &quot;小智&quot;;//静态语言

JS:var name = &quot;小智“；var name = 10;//动态语言

Pythom: info = 130;//更加彻底的动态语言
</code></pre>
<h3 id="7-方法返回地址-Return-Address"><a href="#7-方法返回地址-Return-Address" class="headerlink" title="7 方法返回地址(Return Address)"></a>7 方法返回地址(Return Address)</h3><blockquote>
<p>理解如下话:<br>(pc寄存器每执行一条指令都会被改变<br>而返回地址在调用call之前一直是上一条call后面的地址，不改变)</p>
</blockquote>
<ul>
<li>①. 存放调用该方法的PC寄存器的值</li>
<li>②. 执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口</li>
</ul>
<ol>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含ireturn(当返回值是boolena、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型的)</li>
<li>另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200510181532986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称异常完成出口</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200510181618906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200510181625227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="8-一些附加信息"><a href="#8-一些附加信息" class="headerlink" title="8  一些附加信息"></a>8  一些附加信息</h3><ul>
<li>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</li>
</ul>
<h3 id="9-问题小结与扩展"><a href="#9-问题小结与扩展" class="headerlink" title="9  问题小结与扩展"></a>9  问题小结与扩展</h3><ul>
<li>①. 栈溢出的情况?栈溢出:StackOverflowError<br>栈中是不存在GC的，存在OOM和StackOverflowError</li>
</ul>
<ol>
<li>举个简单的例子:在main方法中调用main方法，就会不断压栈执行，直到栈溢出;</li>
<li>栈的大小可以是固定大小的，也可以是动态变化(动态扩展)的<br>如果是固定的，那么会抛出StackOverflowError<br>如果是动态扩展的，那么会抛出OOM异常(java.lang.OutOfMemoryError)</li>
</ol>
<ul>
<li>②. 调整栈大小，就能保证不出现溢出吗?<br>不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出</li>
<li>③. 分配的栈内存越大越好吗?<br>不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小</li>
<li>④. 垃圾回收是否会涉及到虚拟机栈?<br>不会;垃圾回收只会涉及到方法区和堆中，方法区和堆也会存在溢出的可能<br>程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收<br>虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收</li>
<li>⑤. 方法中定义的局部变量是否线程安全?</li>
</ul>
<pre><code class="typescript">/**方法中定义的局部变量是否线程安全?   具体问题具体分析
 * @author shkstart
 * @create 15:53
 */
public class LocalVariableThreadSafe &#123;
    //s1的声明方式是线程安全的，因为线程私有，在线程内创建的s1 ，不会被其它线程调用
    public static void method1() &#123;
        //StringBuilder:线程不安全
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        //...
    &#125;
    
    //stringBuilder的操作过程:是线程不安全的，
    // 因为stringBuilder是外面传进来的，有可能被多个线程调用
    public static void method2(StringBuilder stringBuilder) &#123;
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        //...
    &#125;

    //stringBuilder的操作:是线程不安全的；因为返回了一个stringBuilder，
    // stringBuilder有可能被其他线程共享
    public static StringBuilder method3() &#123;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        return stringBuilder;
    &#125;

    //stringBuilder的操作:是线程安全的；因为返回了一个stringBuilder.toString()相当于new了一个String，
    // 所以stringBuilder没有被其他线程共享的可能
    public static String method4() &#123;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        return stringBuilder.toString();

        /**
         * 结论:如果局部变量在内部产生并在内部消亡的，那就是线程安全的
         */
    &#125;
&#125;
</code></pre>
<h2 id="六、堆的概述、内存结构"><a href="#六、堆的概述、内存结构" class="headerlink" title="六、堆的概述、内存结构"></a>六、堆的概述、内存结构</h2><h3 id="1-堆的概述-共享-垃圾回收"><a href="#1-堆的概述-共享-垃圾回收" class="headerlink" title="1 堆的概述(共享|垃圾回收)"></a>1 堆的概述(共享|垃圾回收)</h3><ul>
<li>①. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>②. 堆可以在物理上不连续的内存空间中，但在逻辑上是连续的</li>
<li>③. Java堆区在JVM启动的时候即被创建，其空间大小也是确定的。是Jvm管理最大的一块内存空间</li>
<li>④. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer，TLAB)</li>
<li>⑤. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才有被移除<br>(注意:一个进程就是一个JVM实例，一个进程中包含多个线程)</li>
<li>⑥. 举例</li>
</ul>
<pre><code class="typescript">public class SimpleHeap &#123;
    private int id;

    public SimpleHeap(int id) &#123;
        this.id = id;
    &#125;

    public void show() &#123;
        System.out.println(&quot;My ID is &quot; + id);
    &#125;

    public static void main(String[] args) &#123;
        SimpleHeap sl = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200524174157919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-堆的内存结构"><a href="#2-堆的内存结构" class="headerlink" title="2 堆的内存结构"></a>2 堆的内存结构</h3><ul>
<li>①. 现在垃圾收集器大部分都基于分带收集理论设计的，堆空间细分为:<br><img src="https://img-blog.csdnimg.cn/20200524174545571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. jdk1.7 堆中的结构</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019071122574729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. jdk 1.8 堆中的结构<br><img src="https://img-blog.csdnimg.cn/20190711230055189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="3-堆空间大小的设置-Xms-Xmx"><a href="#3-堆空间大小的设置-Xms-Xmx" class="headerlink" title="3  堆空间大小的设置 -Xms -Xmx"></a>3  堆空间大小的设置 -Xms -Xmx</h3><ul>
<li>①. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx 和 -Xms”来设置</li>
<li>②. -Xms(物理内存的1/64):表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>③. -Xmx(物理内存的1/4):则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
<li>④. 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能</li>
<li>⑤. 案列演示</li>
</ul>
<pre><code class="java">package com.xiaozhi.heap;

import java.util.concurrent.TimeUnit;

/**
 * -Xms:600m
 * -Xmx:600m
 * 查看设置的参数:
 * 方式一(cmd中):jps  / jstat -gc 进程id
 * 方式二(XX:+PrintGCDetails)
 */
public class HeapDemo1 &#123;
    public static void main(String[] args)throws Exception &#123;
        //返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory()/1024/1024;
        //返回Java虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory()/1024/1024;
        System.out.println(&quot;-Xms:&quot;+initialMemory+&quot;M&quot;);
        System.out.println(&quot;-Xmx:&quot;+maxMemory+&quot;M&quot;);
        //TimeUnit.SECONDS.sleep(1000000);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200524175021513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-新生代与老年代参数设置-NewRation-SurvivorRatio"><a href="#4-新生代与老年代参数设置-NewRation-SurvivorRatio" class="headerlink" title="4  新生代与老年代参数设置 NewRation SurvivorRatio"></a>4  新生代与老年代参数设置 NewRation SurvivorRatio</h3><ul>
<li>①. 配置新生代与老年代在堆结构占比<br>默认:-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5<br><img src="https://img-blog.csdnimg.cn/20200524175242481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. -XX:SurvivorRatio调整这个空间比例(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1)</li>
<li>③. -Xmn:设置新生代最大内存大小，一般使用默认值就可以了</li>
<li>④. 几乎所有的Java对象都是在Eden区被new出来的，觉大部分的Java对象的销毁都在新生代进行的</li>
</ul>
<h3 id="5-复制算法"><a href="#5-复制算法" class="headerlink" title="5  复制算法"></a>5  复制算法</h3><ul>
<li>①. 一般过程(图解)<img src="https://img-blog.csdnimg.cn/20210603113332602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200524175513674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 复制算法详解 掌握<br>(伊甸园满了，就会触发gc(minor gc)，而gc就会把标识为垃圾的对象干掉，不是垃圾的对象就要转移到幸存区，把伊甸园让出来给新的对象用)</li>
</ul>
<blockquote>
<p>过程:<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190709122909128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190709123104942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="6-Minor-GC-Major-GC-Full-GC"><a href="#6-Minor-GC-Major-GC-Full-GC" class="headerlink" title="6 Minor GC | Major GC | Full GC"></a>6 Minor GC | Major GC | Full GC</h3><ul>
<li>①. YONG GC(minor GC):发生在新生代</li>
</ul>
<ol>
<li>只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快</li>
<li>当Eden代满，会触发minor GC ，Survivor 满不会引发GC</li>
<li>minor gc 会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才能恢复</li>
</ol>
<ul>
<li>②. Major GC:发生在老年代<br>major GC 是回收老年代的垃圾；major gc 的速度一般比Minor gc 慢10倍以上，STW时间更长</li>
<li>③. Full GC:发生在</li>
</ul>
<ol>
<li>full GC 就会出现所谓的STW(stop the world)现象，即所有的进程都挂起等待清理垃圾</li>
<li>full GC是回收老年代和年轻代的垃圾</li>
<li>full gc 是开发调优中尽量避免的，这样暂时时间会短一些</li>
</ol>
<ul>
<li>④. 全局GC(major GC or Full GC):<br>(指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC(但并不是绝对的)。Major GC的速度一般要比Minor GC慢上10倍以上)</li>
</ul>
<h3 id="7-针对不同年龄阶段的对象分配原则"><a href="#7-针对不同年龄阶段的对象分配原则" class="headerlink" title="7  针对不同年龄阶段的对象分配原则"></a>7  针对不同年龄阶段的对象分配原则</h3><ul>
<li>①. 优先分配到Eden</li>
<li>②. 大对象直接分配到老年(尽量避免程序中出现过多的大对象)</li>
<li>③. 长期存活的对象分配到老年代</li>
<li>④. 动态对象年龄判断<br>(如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄对象可以直接进入老年代，无须等到MaxTenurningThreshold中要求的年龄)</li>
<li>⑤. 空间分配担保 -XX:HandlePromotionFailure<br>(JDK6之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<h3 id="8-TLAB-Thread-Local-Allocation-Buffer"><a href="#8-TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="8  TLAB(Thread Local Allocation Buffer)"></a>8  TLAB(Thread Local Allocation Buffer)</h3><ul>
<li>①. 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li>
<li>②. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</li>
<li>③. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然可通过选项”-XX:TLABWasteTargePercent”设置TLAB空间所占用Eden空间的百分比大小</li>
<li>④. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</li>
<li>⑤. 图解:<img src="https://img-blog.csdnimg.cn/20200524180231747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200524180242481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-堆空间参数总结"><a href="#9-堆空间参数总结" class="headerlink" title="9 堆空间参数总结"></a>9 堆空间参数总结</h3><ul>
<li>①. -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</li>
<li>②. -XX:+PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改(:表示修改了)，不再是初始值)</li>
<li>③. 具体查看某个参数的指令:<br>(jps:查看当前运行中的进程<br>jinfo -flag SurvivorRatio 进程id)</li>
<li>④. -Xms:初始堆空间内存 (默认为物理内存的1/64)</li>
<li>⑤. -Xmx:最大堆空间内存(默认为物理内存的1/4)</li>
<li>⑥. -Xmn:设置新生代的大小。(初始值及最大值)</li>
<li>⑦. -XX:NewRatio:配置新生代与老年代在堆结构的占比<br>(默认:-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200525141725242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>⑧. -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例<br>(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1)</li>
<li>⑨. -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄</li>
<li>⑩. -XX:+PrintGCDetails:输出详细的GC处理日志<br>(如下这两种方式是简单的打印<br>打印gc简要信息:① -XX:+PrintGC ② -verbose:gc)</li>
<li>⑩①. -XX:HandlePromotionFailure:是否设置空间分配担保<br>(JDK6之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<blockquote>
<p>内存分配策略(或对象提升(Promotion)规则)<br>(1). 在繁盛Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间<br>====如果大于，则此次Minor GC是安全的<br>====如果小于，则虚拟机会检查查看-XX:HandlePromotionFailure设置值是否允许担保失败<br>=====如果 HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋级到老年代的对象的平均大小<br>========如果大于，则尝试进行一次Minor GC，但是这次Minor GC依然是有风险的<br>========如果小于，则改为一次Full GC<br>=====如果HandlePromotionFailure=false，则改为进行一次Full GC<br>(2). 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响虚拟机的空间分配担保策略，观察OpenJDK中源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它<br>(3). JDK6 Update24之后规则变为只有老年代的连续空间大于新生代对象总大小或者历次晋身的平均大小就会进行Minor GC，否则将进行Full GC</p>
</blockquote>
<h3 id="10-逃逸分析"><a href="#10-逃逸分析" class="headerlink" title="10 逃逸分析"></a>10 逃逸分析</h3><ul>
<li>①. 如何将堆上的对象分配到栈，需要使用逃逸分析手段</li>
</ul>
<ol>
<li>当一个对象在方法中被定义后，对象只在方法内部使用(这里关注的是这个对象的实体)，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</li>
</ol>
<ul>
<li>②. 代码演示</li>
</ul>
<pre><code class="java">//(1). 没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除
public void my_method() &#123;
    V v = new V();
    // use v
    // ....
    v = null;
&#125;
//(2). 下面代码中的 StringBuffer sb 发生了逃逸
public static StringBuffer createStringBuffer(String s1， String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
&#125;
//如果想要StringBuffer sb不发生逃逸，可以这样写
public static String createStringBuffer(String s1， String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
&#125;
</code></pre>
<ul>
<li>③. 逃逸分析的举例</li>
</ul>
<pre><code class="java">/**
 * 逃逸分析
 *
 * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
 */
public class EscapeAnalysis &#123;

    public EscapeAnalysis obj;

    /*
    方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance()&#123;
        return obj == null? new EscapeAnalysis() : obj;
    &#125;

    /*
    为成员属性赋值，发生逃逸
     */
    public void setObj()&#123;
        this.obj = new EscapeAnalysis();
    &#125;
    //思考:如果当前的obj引用声明为static的？ 仍然会发生逃逸。

    /*
    对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis()&#123;
        EscapeAnalysis e = new EscapeAnalysis();
    &#125;

    /*
    引用成员变量的值，发生逃逸
    
     */
    public void useEscapeAnalysis1()&#123;
        EscapeAnalysis e = getInstance(); //这个e对象，本身就是从外面的方法逃逸进来的
        //getInstance().xxx()同样会发生逃逸
    &#125;
&#125;
</code></pre>
<ul>
<li>④. 在JDK1.7版本之后，HotSpot中默认就已经开启了逃逸分析<br>如果使用的是较早的版本，开发人员则可以通过:<br>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析<br>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
<li>结论: ⑤. 开发中能使用局部变量的，就不要使用在方法外定义</li>
<li>⑥. 使用逃逸分析，编译器可以对代码做如下优化:</li>
</ul>
<ol>
<li>栈上分配:将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li>同步省略:如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换:有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在CPU寄存器中</li>
</ol>
<h3 id="11-栈上分配"><a href="#11-栈上分配" class="headerlink" title="11 栈上分配"></a>11 栈上分配</h3><ul>
<li>①. JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配</li>
<li>②.代码举例</li>
</ul>
<pre><code class="java">/**
 * 栈上分配测试
 * -Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 */
public class StackAllocation &#123;
    public static void main(String[] args) &#123;
        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 10000000; i++) &#123;
            alloc();
        &#125;
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;花费的时间为: &quot; + (end - start) + &quot; ms&quot;);
        // 为了方便查看堆内存中对象个数，线程sleep
        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125;

    private static void alloc() &#123;
        User user = new User(); //未发生逃逸
    &#125;

    static class User &#123;

    &#125;
&#125;
</code></pre>
<ul>
<li>③. 未开启逃逸分析的情况<br>-Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</li>
</ul>
<pre><code class="typescript">日志打印发生了GC
[GC (Allocation Failure) [PSYoungGen: 65536K-&gt;560K(76288K)] 65536K-&gt;568K(251392K)， 0.0017179 secs] [Times: user=0.01 sys=0.00， real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 66096K-&gt;464K(76288K)] 66104K-&gt;480K(251392K)， 0.0017602 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] 
花费的时间为: 74 ms
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210603154652195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>④. 开启逃逸分析的情况<br>-Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</li>
</ul>
<pre><code class="typescript">日志打印:并没有发生 GC，耗时 3ms ，栈上分配是真的快啊
花费的时间为: 4 ms
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210603154749586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="12-同步替换-锁消除"><a href="#12-同步替换-锁消除" class="headerlink" title="12  同步替换 锁消除"></a>12  同步替换 锁消除</h3><ul>
<li>①. 从JIT角度看相当于无视它了，这个锁对象没有被共享给其他线程</li>
<li>②. 例如下面的智障代码，根本起不到锁的作用<br>代码中对hellis这个对象加锁(每个线程都有一个hellis对象的锁)，但是hellis对象的生命周期只在f( )方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成:</li>
</ul>
<pre><code class="java">public void f() &#123;
    Object hellis = new Object();
    synchronized(hellis) &#123;
        System.out.println(hellis);
    &#125;
&#125;
// JIT会将它变成这样
public void f() &#123;
      Object hellis = new Object();
        System.out.println(hellis);
&#125;
</code></pre>
<ul>
<li>③. 注意:字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的<br><img src="https://img-blog.csdnimg.cn/20210603160130874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="13-分离对象或标量替换"><a href="#13-分离对象或标量替换" class="headerlink" title="13 分离对象或标量替换"></a>13 分离对象或标量替换</h3><ul>
<li>①. 标量(scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</li>
<li>②. 相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</li>
<li>③. 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</li>
<li>④. 举列子</li>
</ul>
<pre><code class="typescript">public static void main(String args[]) &#123;
    alloc();
&#125;
class Point &#123;
    private int x;
    private int y;
&#125;
private static void alloc() &#123;
    Point point = new Point(1，2);
    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);
&#125;
//以上代码，经过标量替换后，就会变成
private static void alloc() &#123;
    int x = 1;
    int y = 2;
    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);
&#125;
</code></pre>
<h2 id="七、方法区的概述"><a href="#七、方法区的概述" class="headerlink" title="七、方法区的概述"></a>七、方法区的概述</h2><h3 id="1-方法区的概述"><a href="#1-方法区的概述" class="headerlink" title="1 方法区的概述"></a>1 方法区的概述</h3><ul>
<li>①. 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的 | 关闭Jvm就会释放这个区域的内存</li>
<li>②. 方法区时逻辑上是堆的一个组成部分，但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)<br>(注意：方法区时一种规范，而永久代和元空间是它的一种实现方式)</li>
<li>③. 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：(java.lang.OutOfMemoryError:PermGen space、java.lang.OutOfMemoryError:Metaspace)</li>
</ul>
<ol>
<li>加载大量的第三方的jar包</li>
<li>tomcat部署的工程过多(30-50个)</li>
<li>大量动态的生成反射类</li>
</ol>
<ul>
<li>④. 对于HotspotJVM而言，方法区还有一个别名叫非堆(Non-heap)，目的就是要和堆分开，方法区可以看成一块独立于Java堆的内存空间</li>
</ul>
<h3 id="2-方法区的内部结构"><a href="#2-方法区的内部结构" class="headerlink" title="2 方法区的内部结构"></a>2 方法区的内部结构</h3><ul>
<li>①. 深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等<br><img src="https://img-blog.csdnimg.cn/20200821102437479.png#pic_center" alt="在这里插入图片描述"></li>
<li>②. 类型信息(对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必 .须在方法区中存储以下类型信息：</li>
</ul>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public， abstract， final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<ul>
<li>③. 域信息（成员变量）</li>
</ul>
<ol>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li>
</ol>
<ul>
<li>④. 方法信息：JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序</li>
</ul>
<ol>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li>
<li>异常表（ abstract和native方法除外）<br>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<ul>
<li><strong>⑤. non-final的类变量</strong><br>(Order.class字节码文件，右键Open in Teminal打开控制台，使用javap -v -p Order.class &gt; tst.txt 将字节码文件反编译并输出为txt文件，可以看到被声明为static final的常量number在编译的时候就被赋值了，这不同于没有被final修饰的static变量count是在类加载的准备阶段被赋值为默认的初始化值，在初始化的时候赋予正确的初始化值</li>
</ul>
<pre><code class="java">public static int count;
descriptor: I
    flags: ACC_PUBLIC， ACC_STATIC

        public static final int number;
descriptor: I
    flags: ACC_PUBLIC， ACC_STATIC， ACC_FINAL
        ConstantValue: int 2
</code></pre>
<p><strong><code>以下代码不会报空指针异常</code></strong></p>
<pre><code class="java">public class MethodAreaTest &#123;
    public static void main(String[] args) &#123;
        Order order = null;
        order.hello();
        System.out.println(order.count);
    &#125;
&#125;

class Order &#123;
    public static int count = 1;
    public static final int number = 2;


    public static void hello() &#123;
        System.out.println(&quot;hello!&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3-方法区的演进细节"><a href="#3-方法区的演进细节" class="headerlink" title="3 方法区的演进细节"></a>3 方法区的演进细节</h3><ul>
<li>①. Jdk 1.6 及之前：有永久代，静态变量、字符串常量池1.6在方法区</li>
<li>②. Jdk 1.7 ：有永久代，但已经逐步 “ 去永久代 “，字符串常量池、静态变量移除，保存在堆中</li>
<li>③. jdk 1.8 及之后： 无永久代，常量池1.8在元空间。但静态变量、字符串常量池仍在堆中<br><img src="https://img-blog.csdnimg.cn/2020082110325625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 为什么要用元空间取代永久代</li>
</ul>
<ol>
<li>为永久代设置空间大小是很难确定的<br>(①. 永久代参数设置过小，在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM，比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误<br>②. 永久代参数设置过大，导致空间浪费<br>③. 默认情况下，元空间的大小受本地内存限制)</li>
<li>对永久代进行调优是很困难的<br>(方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型，而不再使用的类或类的加载器回收比较复杂，full gc 的时间长)</li>
</ol>
<ul>
<li>⑤. StringTable为什么要调整</li>
</ul>
<ol>
<li>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才能触发。而full gc是老年代的空间不足、永久代不足才会触发</li>
<li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存</li>
</ol>
<h3 id="4-设置方法区大小"><a href="#4-设置方法区大小" class="headerlink" title="4 设置方法区大小"></a>4 设置方法区大小</h3><ul>
<li>①. jdk7及以前:</li>
</ul>
<ol>
<li>-XX:PermSize=100m(默认值是20.75M)</li>
<li>-XX:MaxPermSize=100m(32位机器默认是64M，64位机器模式是82M)</li>
<li>图解：<br><img src="https://img-blog.csdnimg.cn/20200821103602612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. jdk1.8及以后</li>
</ul>
<ol>
<li>-XX:MetaspaceSize=100m(windows下，默认约等于21M)</li>
<li>-XX:MaxMetaspaceSize=100m(默认是-1，即没有限制)</li>
</ol>
<h3 id="5-常量池的理解"><a href="#5-常量池的理解" class="headerlink" title="5 常量池的理解"></a>5 常量池的理解</h3><ul>
<li>①. 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息</li>
</ul>
<pre><code class="java">Constant pool:
   #1 = Methodref          #7.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Methodref          #24.#25        // com/xiaozhi/heap/Order.hello:()V
   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Fieldref           #24.#28        // com/xiaozhi/heap/Order.count:I
   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V
</code></pre>
<ul>
<li>②. 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Poo1 Table），包括各种字面量和对类型域和方法的符号引用。</li>
<li>③. 个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</li>
<li>④. 比如如下代码，虽然只有 194 字节，但是里面却使用了 string、System、Printstream 及 Object 等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多！</li>
</ul>
<pre><code class="java">Public class Simpleclass &#123;
    public void sayhelloo() &#123;
        System.out.Println (hello) &#125;
&#125;
</code></pre>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6 运行时常量池"></a>6 运行时常量池</h3><ul>
<li>①. 运行时常量池，常量池是 <code>*.class</code> 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
<li>②. 运行时常量池（ Runtime Constant Pool）是方法区的一部分。</li>
<li>③. 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>④. 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用此时不再是常量池中的符号地址了，这里换为真实地址。<br>(方法区内常量池之中主要存放的两大类常量：字面量和符号引用。<br>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。<br>而符号引用则属于编译原理方面的概念，包括下面三类常量：<br>1、类和接口的全限定名<br>2、字段的名称和描述符<br>3、方法的名称和描述符)</li>
</ul>
<h3 id="7-如何证明静态变量存在哪"><a href="#7-如何证明静态变量存在哪" class="headerlink" title="7 如何证明静态变量存在哪"></a>7 如何证明静态变量存在哪</h3><pre><code class="java">/**
 * 《深入理解Java虚拟机》中的案例：
 * staticObj、instanceObj、localObj存放在哪里？
 */
public class StaticObjTest &#123;
    static class Test &#123;
        static ObjectHolder staticObj = new ObjectHolder();
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() &#123;
            ObjectHolder localObj = new ObjectHolder();
            System.out.println(&quot;done&quot;);
        &#125;
    &#125;

    private static class ObjectHolder &#123;
    &#125;

    public static void main(String[] args) &#123;
        Test test = new StaticObjTest.Test();
        test.foo();
    &#125;
&#125;
</code></pre>
<ul>
<li>①. staticObj随着Test的类型信息存放在方法区，instance0bj 随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中</li>
</ul>
<pre><code class="handlebars">hsdb&gt;scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_ _TestCase$Obj ectHolder
0x00007f32c7a7c458 JHSDB_ TestCase$Obj ectHolder
0x00007f32c7a7c480 JHSDB_ TestCase$Obj ectHolder
0x00007f32c7a7c490 JHSDB_ TestCase$Obj ectHolder
</code></pre>
<ul>
<li>②. 测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配</li>
<li>③. 接着，找到了一个引用该staticObj对象的地方，是在一个java. lang . Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个<br>java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：<br><img src="https://img-blog.csdnimg.cn/20200824150445739.png#pic_center" alt="在这里插入图片描述"></li>
<li>④. 从《Java 虛拟机规范》所定义的概念模型来看，所有 C1ass 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 C1ass 对象存放在一起，存储于】ava 堆之中，从我们的实验中也明确验证了这一点.</li>
</ul>
<h3 id="8-方法区的垃圾回收"><a href="#8-方法区的垃圾回收" class="headerlink" title="8 方法区的垃圾回收"></a>8 方法区的垃圾回收</h3><blockquote>
<p>前言：<br>(1).有些人认为方法区（如Hotspot，虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 ZGC 收集器就不支持类卸载）<br>(2). 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。</p>
</blockquote>
<ul>
<li><p>①. 方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型</p>
</li>
<li><p>②. 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><p>③. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。</p>
</li>
<li><p>④. 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li>
</ul>
<ul>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
<li><p>⑤. Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一Xnoclassgc 参数进行控制，还可以使用一verbose：class以及一XX： +TraceClass一Loading、一XX：+TraceClassUnLoading查 看类加载和卸载信息</p>
</li>
<li><p>⑥. 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</p>
</li>
</ul>
<h2 id="八、对象的实例化"><a href="#八、对象的实例化" class="headerlink" title="八、对象的实例化"></a>八、对象的实例化</h2><blockquote>
<p>前言：<br>(1).new 最常见的方式 | 变形1 ： Xxx的静态方法 | 变形2 ： XxBuilder/XxoxFactory的静态方法<br>(2).Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public<br>(3).Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求<br>(4).使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）<br>(5).使用反序列化：从文件中、从网络中获取一个对象的二进制流<br>(6).第三方库Objenesis</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200825090915939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-从字节码角度看待对象的创建过程"><a href="#1-从字节码角度看待对象的创建过程" class="headerlink" title="1  从字节码角度看待对象的创建过程"></a>1  从字节码角度看待对象的创建过程</h3><ul>
<li>①. 从最简单的Object ref = new Object()</li>
<li><img src="https://img-blog.csdnimg.cn/20210609100228772.png" alt="在这里插入图片描述"></li>
<li>②. new:如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。</li>
<li>③. dup:在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。</li>
<li>④. invokespecial:调用对象实例方法，通过栈顶的引用变量调用init方法。<br>补充:clinit是类初始化时执行的方法， 而init 是对象初始化时执行的方法。</li>
</ul>
<h3 id="2-对象的实例化-六个步骤"><a href="#2-对象的实例化-六个步骤" class="headerlink" title="2 对象的实例化(六个步骤)"></a>2 对象的实例化(六个步骤)</h3><ul>
<li><p>①. 判断对象对应的类是否加载、链接、初始化<br>(虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。( 即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象)</p>
</li>
<li><p>②. 为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小<br>(byte、int、float、引用数据类型4个字节大小 | double、long 占八个字节)</p>
<ul>
<li>如果内存规整，使用指针碰撞<br>如果内存是规整的，那么虚拟机将采用的是指针碰撞法(BumpThePointer)来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact (整理)过程的收集器时，使用指针碰撞。</li>
<li>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配(CMS)<br>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表(Free List)</li>
<li>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。<br><img src="https://img-blog.csdnimg.cn/20210609100527176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210609100706722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>③. 处理并发安全问题<br>(在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：)</p>
<ul>
<li>CAS ( Compare And Swap )失败重试、区域加锁：保证指针更新操作的原子性</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过一XX：+/一UseTLAB参数来 设定</li>
</ul>
</li>
<li><p>④. 初始化分配到的空间:赋予默认的初始化值；比如int=0| boolean=false(默认的值)</p>
</li>
<li><p>⑤. 设置对象的对象头：将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p>⑥. 执行init方法进行初始化(进行赋值的处理)<br>(在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespecial指令所决定)，new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。)</p>
</li>
<li><p>⑦. 代码展示</p>
</li>
</ul>
<pre><code class="java">/**
 * 测试对象实例化的过程
 *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
 *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
 *
 *  给对象的属性赋值的操作：
 *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
 * 
 */
public class Customer&#123;
    int id = 1001;
    String name;
    Account acct;

    &#123;
        name = &quot;匿名客户&quot;;
    &#125;
    public Customer()&#123;
        acct = new Account();
    &#125;

&#125;

class Account&#123;

&#125;
</code></pre>
<h3 id="3-对象的内存布局"><a href="#3-对象的内存布局" class="headerlink" title="3 对象的内存布局"></a>3 对象的内存布局</h3><ul>
<li>①. 对象内部结构分为：对象头、实例数据、对齐填充(保证8个字节的倍数)</li>
<li>②. 对象头分为对象标记(markOop)和类元信息(klassOop)，类元信息存储的是指向该对象类元数据(klass)的首地址<br><img src="https://img-blog.csdnimg.cn/20210406193020801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-对象头-Header"><a href="#4-对象头-Header" class="headerlink" title="4 对象头(Header)"></a>4 对象头(Header)</h3><ul>
<li>①. 对象标记Mark Word 默认存储 (哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)等信息</li>
</ul>
<ol>
<li>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。</li>
<li>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。<br><img src="https://img-blog.csdnimg.cn/20210406193237787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 对象头多大 在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节<br><img src="https://img-blog.csdnimg.cn/20210406193345417.png" alt="在这里插入图片描述"></li>
<li>③. 类元信息(又叫类型指针) 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
<h3 id="5-实例数据（Instance-Data）"><a href="#5-实例数据（Instance-Data）" class="headerlink" title="5  实例数据（Instance Data）"></a>5  实例数据（Instance Data）</h3><ul>
<li>说明:它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段) 规则:</li>
</ul>
<ol>
<li>相同宽度的字段总被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true)，子类的窄变量可能插入到父类变量的空隙</li>
</ol>
<h3 id="6-对齐填充（Padding）"><a href="#6-对齐填充（Padding）" class="headerlink" title="6  对齐填充（Padding）"></a>6  对齐填充（Padding）</h3><ul>
<li>①. 不是必须的，也没特别含义，仅仅起到占位符作用</li>
<li>②. 解释如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200825093157382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><ul>
<li>①. 代码演示</li>
</ul>
<pre><code class="java">public class CustomerTest &#123;
    public static void main(String[] args) &#123;
        Customer cust = new Customer();
    &#125;
&#125;
</code></pre>
<ul>
<li>②. 图解代码<br><img src="https://img-blog.csdnimg.cn/20200825093342514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="8-对象的访问定位"><a href="#8-对象的访问定位" class="headerlink" title="8 对象的访问定位"></a>8 对象的访问定位</h3><blockquote>
<p>前言：<br>JVM是如何通过栈帧中的对象引|用访问到其内部的对象实例的呢？-&gt; 定位，通过栈上reference访问</p>
</blockquote>
<ul>
<li>①. 句柄访问<br><img src="https://img-blog.csdnimg.cn/20200825093620622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②. 直接指针(HotSpot采用)<br><img src="https://img-blog.csdnimg.cn/20200825093643739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-直接内存-Direct-Memory"><a href="#9-直接内存-Direct-Memory" class="headerlink" title="9  直接内存(Direct Memory)"></a>9  直接内存(Direct Memory)</h3><ul>
<li>①. 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li>
<li>②. 直接内存是Java堆外的、直接向系统申请的内存区间</li>
<li>③. 代码演示：</li>
</ul>
<pre><code class="java">/**
 *  IO                  NIO (New IO / Non-Blocking IO)
 *  byte[] / char[]     Buffer
 *  Stream              Channel
 *
 * 查看直接内存的占用与释放
 */
public class BufferTest &#123;
    private static final int BUFFER = 1024 * 1024 * 1024;//1GB

    public static void main(String[] args)&#123;
        //直接分配本地内存空间
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
        System.out.println(&quot;直接内存分配完毕，请求指示！&quot;);

        Scanner scanner = new Scanner(System.in);
        scanner.next();

        System.out.println(&quot;直接内存开始释放！&quot;);
        byteBuffer = null;
        System.gc();
        scanner.next();
    &#125;
&#125;
</code></pre>
<ul>
<li>④. 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200827085808614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200827085847326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 通常，访问直接内存的速度会优于Java堆。即读写性能高</li>
<li>⑥. 直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致</li>
<li>⑦. 简单理解： java process memory = java heap + native memory<br><img src="https://img-blog.csdnimg.cn/20200827085948662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h2 id="九、字符串常量池"><a href="#九、字符串常量池" class="headerlink" title="九、字符串常量池"></a>九、字符串常量池</h2><h3 id="1-String的基本特性"><a href="#1-String的基本特性" class="headerlink" title="1  String的基本特性"></a>1  String的基本特性</h3><ul>
<li><p>①. String：字符串，使用一对””引起来表示。</p>
<ul>
<li>String sl = “hello”；//字面量的定义方式</li>
<li>String s2 = new String（“hello”）</li>
</ul>
</li>
<li><p>②. String声明为final的，不可被继承</p>
</li>
<li><p>③. String实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>④. String在jdk8及以前内部定义了final char[ ]，value用于存储字符串数据。jdk9时改为byte[ ]</p>
</li>
</ul>
<pre><code class="java">public final class String implements 
    java.io.Serializable， Comparable&lt;String&gt;，CharSequence &#123;
    @Stable
    private final byte[] value；
&#125;
</code></pre>
<ul>
<li>⑤. String：代表不可变的字符序列。简称：不可变性。</li>
<li>⑥. 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中</li>
<li>⑦. 字符串常量池中是不会存储相同内容的字符串的</li>
</ul>
<ol>
<li>String的String Pool 是一个固定大小的Hashtable，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String. intern时性能会大幅下降。</li>
<li>使用 - XX:StringTableSize可设置StringTable的长度</li>
<li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求</li>
<li>在jdk7中，StringTable的长度默认值是60013</li>
<li>jdk8开始，1009是StringTable长度可设置的最小值</li>
</ol>
<h3 id="2-String的内存分配"><a href="#2-String的内存分配" class="headerlink" title="2 String的内存分配"></a>2 String的内存分配</h3><ul>
<li>①. 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：</li>
</ul>
<ol>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中(比如： String info = “abc” )</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法</li>
</ol>
<ul>
<li>②.String的基本操作<br><img src="https://img-blog.csdnimg.cn/20200831091630754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<pre><code class="java">class Memory &#123;
    public static void main(String[] args) &#123;//line 1
        int i = 1;//line 2
        Object obj = new Object();//line 3
        Memory mem = new Memory();//line 4
        mem.foo(obj);//line 5
    &#125;//line 9

    private void foo(Object param) &#123;//line 6
        String str = param.toString();//line 7
        System.out.println(str);
    &#125;//line 8
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083109165877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-字符串拼接操作"><a href="#3-字符串拼接操作" class="headerlink" title="3 字符串拼接操作"></a>3 字符串拼接操作</h3><ul>
<li>①. 常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>②. 常量池中不会存在相同内容的常量。</li>
<li>③. 只要其中有一个是变量，结果就在堆中<br>(只有有一个是变量，那么它会在堆中创建一个StringBuilder，调用append( )方法进行添加操作，调用toString( )方法转换为字符串【toString( )方法其实就是:new String( )】)</li>
<li>④. 如果拼接的结果调用intern（）方法分为两种情况：</li>
</ul>
<ol>
<li>JDK1.6，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它会在常量池中创建一个对象放入串池中，并返回串池中的对象地址</li>
<li>JDK1.7，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它不会创建一个对象，如果堆中已经这个字符串，那么会将堆中的引用地址赋给它</li>
<li><strong>test3、test4<code>重点掌握</code></strong></li>
</ol>
<pre><code class="java">@Test
public void test1()&#123;
    String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//编译期优化：等同于&quot;abc&quot; 在字节码文件中，s1=&quot;abc&quot;
    String s2 = &quot;abc&quot;; //&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2
    /*
         * 最终.java编译成.class，再执行.class
         * String s1 = &quot;abc&quot;;
         * String s2 = &quot;abc&quot;
         */
    System.out.println(s1 == s2); //true
    System.out.println(s1.equals(s2)); //true
&#125;

@Test
public void test2()&#123;
    String s1 = &quot;javaEE&quot;;
    String s2 = &quot;hadoop&quot;;

    String s3 = &quot;javaEEhadoop&quot;;
    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;//编译期优化
    //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop
    String s5 = s1 + &quot;hadoop&quot;;
    String s6 = &quot;javaEE&quot; + s2;
    String s7 = s1 + s2;

    System.out.println(s3 == s4);//true
    System.out.println(s3 == s5);//false
    System.out.println(s3 == s6);//false
    System.out.println(s3 == s7);//false
    System.out.println(s5 == s6);//false
    System.out.println(s5 == s7);//false
    System.out.println(s6 == s7);//false
    //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；
    //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。
    String s8 = s6.intern();
    System.out.println(s3 == s8);//true
&#125;


@Test
public void test3()&#123;
    String s1 = &quot;a&quot;;
    String s2 = &quot;b&quot;;
    String s3 = &quot;ab&quot;;
    /*
        如下的s1 + s2 的执行细节：(变量s是我临时定义的）
        ① StringBuilder s = new StringBuilder();
        ② s.append(&quot;a&quot;)
        ③ s.append(&quot;b&quot;)
        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)

        补充：在jdk5.0之后使用的是StringBuilder，
        在jdk5.0之前使用的是StringBuffer
         */
    String s4 = s1 + s2;//
    System.out.println(s3 == s4);//false
&#125;

/*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
@Test
public void test4()&#123;
    final String s1 = &quot;a&quot;;
    final String s2 = &quot;b&quot;;
    String s3 = &quot;ab&quot;;
    String s4 = s1 + s2;
    System.out.println(s3 == s4);//true
&#125;

//练习：
@Test
public void test5()&#123;
    String s1 = &quot;javaEEhadoop&quot;;
    String s2 = &quot;javaEE&quot;;
    String s3 = s2 + &quot;hadoop&quot;;
    System.out.println(s1 == s3);//false

    final String s4 = &quot;javaEE&quot;;//s4:常量
    String s5 = s4 + &quot;hadoop&quot;;
    System.out.println(s1 == s5);//true

&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200831094734720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-拼接操作与append的效率对比"><a href="#4-拼接操作与append的效率对比" class="headerlink" title="4 拼接操作与append的效率对比"></a>4 拼接操作与append的效率对比</h3><ul>
<li>append效率要比字符串拼接高很多</li>
</ul>
<pre><code class="java">/*
    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串 拼接方式！
    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象
           使用String的字符串拼接方式：创建过多个StringBuilder和String的对象
         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，
           内存占用更大；如果进行GC，需要花费额外的时间。

     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel
     的情况下，建议使用构造器实例化：
     StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]
     */
@Test
public void test6()&#123;

    long start = System.currentTimeMillis();

    //        method1(100000);//4014
    method2(100000);//7

    long end = System.currentTimeMillis();

    System.out.println(&quot;花费的时间为：&quot; + (end - start));
&#125;

public void method1(int highLevel)&#123;
    String src = &quot;&quot;;
    for(int i = 0;i &lt; highLevel;i++)&#123;
        src = src + &quot;a&quot;;//每次循环都会创建一个StringBuilder、String
    &#125;
    //        System.out.println(src);

&#125;

public void method2(int highLevel)&#123;
    //只需要创建一个StringBuilder
    StringBuilder src = new StringBuilder();
    for (int i = 0; i &lt; highLevel; i++) &#123;
        src.append(&quot;a&quot;);
    &#125;
    //        System.out.println(src);
&#125;
</code></pre>
<h3 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="5 intern()的使用"></a>5 intern()的使用</h3><blockquote>
<p>前言：<br>(1). 如果不是用双引号声明的String对象，可以使用String提供的intern方法： intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中<br>(2). 比如： String myInfo = new String(“I love u”).intern()；<br>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下 列表达式的值必定是true：<br>（“a” + “b” + “c”）.intern（）== “abc”;<br>(3). 通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
</blockquote>
<h3 id="6-new-String-“ab”-会创建几个对象"><a href="#6-new-String-“ab”-会创建几个对象" class="headerlink" title="6 new String(“ab”)会创建几个对象"></a>6 new String(“ab”)会创建几个对象</h3><ul>
<li>①. new String(“ab”)会创建几个对象<br>(new String(“ab”)会创建几个对象？看字节码，就知道是两个)</li>
</ul>
<ol>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
<li>如下图：(常量池中已经有了该对象)<br><img src="https://img-blog.csdnimg.cn/20200831095508336.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="7-new-String-“a”-new-String-“b”-创建几个对象呢？"><a href="#7-new-String-“a”-new-String-“b”-创建几个对象呢？" class="headerlink" title="7 new String(“a”) + new String(“b”)创建几个对象呢？"></a>7 new String(“a”) + new String(“b”)创建几个对象呢？</h3><ul>
<li>②. new String(“a”) + new String(“b”)呢？<br>(在常量池中是没有ab存在的 [很关键] )</li>
</ul>
<ol>
<li>对象1：new StringBuilder()</li>
<li>对象2： new String(“a”)</li>
<li>对象3： 常量池中的”a”</li>
<li>对象4： new String(“b”)</li>
<li>对象5： 常量池中的”b”<br><img src="https://img-blog.csdnimg.cn/20200831095655825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>深入剖析： StringBuilder的toString(): 对象6 ：new String(“ab”)</li>
<li>注意：强调一下，toString()的调用，在字符串常量池中，没有生成”ab” 没有ldc指令</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200831095834664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="8-关于String-intern-的面试题"><a href="#8-关于String-intern-的面试题" class="headerlink" title="8 关于String.intern( )的面试题"></a>8 关于String.intern( )的面试题</h3><ul>
<li>③. 关于String.intern( )的面试题</li>
</ul>
<pre><code class="java">/**
 * 如何保证变量s指向的是字符串常量池中的数据呢？
 * 有两种方式：
 * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式
 * 方式二： 调用intern()
 *         String s = new String(&quot;shkstart&quot;).intern();
 *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();
 *  */
public class StringIntern &#123;
    public static void main(String[] args) &#123;
        String s = new String(&quot;1&quot;);
        String s1 = s.intern();//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;
        String s2 = &quot;1&quot;;
        //s  指向堆空间&quot;1&quot;的内存地址
        //s1 指向字符串常量池中&quot;1&quot;的内存地址
        //s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2
        System.out.println(s == s2);//jdk6：false   jdk7/8：false
        System.out.println(s1 == s2);//jdk6: true   jdk7/8：true
        System.out.println(System.identityHashCode(s));//491044090
        System.out.println(System.identityHashCode(s1));//644117698
        System.out.println(System.identityHashCode(s2));//644117698

        //s3变量记录的地址为：new String(&quot;11&quot;)
        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！

        //在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;，也就有新的地址。
        //jdk7:此时常量中并没有创建&quot;11&quot;，而是创建一个指向堆空间中new String(&quot;11&quot;)的地址
        s3.intern();
        //s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址
        String s4 = &quot;11&quot;;
        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083110084534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code class="java">public class StringIntern1 &#123;
    public static void main(String[] args) &#123;
        //StringIntern.java中练习的拓展：
        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//new String(&quot;11&quot;)
        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！
        String s4 = &quot;11&quot;;//在字符串常量池中生成对象&quot;11&quot;
        String s5 = s3.intern();
        System.out.println(s3 == s4);//false
        System.out.println(s5 == s4);//true
    &#125;
&#125;
</code></pre>
<h3 id="9-总结String的intern（）的使用"><a href="#9-总结String的intern（）的使用" class="headerlink" title="9 总结String的intern（）的使用"></a>9 总结String的intern（）的使用</h3><ul>
<li>④. 如果拼接的结果调用intern（）方法分为两种情况：</li>
</ul>
<ol>
<li>JDK1.6，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它会在常量池中创建一个对象放入串池中，并返回串池中的对象地址</li>
<li>JDK1.7，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它不会创建一个对象，如果堆中已经这个字符串，那么会将堆中的引用地址赋给它</li>
</ol>
<pre><code class="java">public class StringExer1 &#123;
    public static void main(String[] args) &#123;
        //String x = &quot;ab&quot;;
        String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);//new String(&quot;ab&quot;)
        //在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;

        String s2 = s.intern();//jdk6中：在串池中创建一个字符串&quot;ab&quot;
                               //jdk8中：串池中没有创建字符串&quot;ab&quot;，而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回

        System.out.println(s2 == &quot;ab&quot;);//jdk6:true  jdk8:true
        System.out.println(s == &quot;ab&quot;);//jdk6:false  jdk8:true
    &#125;
&#125;
</code></pre>
<blockquote>
<p>intern题目：<br><img src="https://img-blog.csdnimg.cn/20200831101207929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200831101248253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200831101255983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="10-intern-效率测试"><a href="#10-intern-效率测试" class="headerlink" title="10  intern()效率测试"></a>10  intern()效率测试</h3><ul>
<li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern（）方法，就会明显降低内存的大小。</li>
</ul>
<pre><code class="java">/**
 * 使用intern()测试执行效率：空间使用上
 *
 * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。
 *
 */
public class StringIntern2 &#123;
    static final int MAX_COUNT = 1000 * 10000;
    static final String[] arr = new String[MAX_COUNT];

    public static void main(String[] args) &#123;
        Integer[] data = new Integer[]&#123;1，2，3，4，5，6，7，8，9，10&#125;;

        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; MAX_COUNT; i++) &#123;
//            arr[i] = new String(String.valueOf(data[i % data.length]));
            arr[i] = new String(String.valueOf(data[i % data.length])).intern();

        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;花费的时间为：&quot; + (end - start));

        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.gc();
    &#125;
&#125;
</code></pre>
<h3 id="11-StrtingTable的垃圾回收-了解"><a href="#11-StrtingTable的垃圾回收-了解" class="headerlink" title="11 StrtingTable的垃圾回收(了解)"></a>11 StrtingTable的垃圾回收(了解)</h3><pre><code class="java">/**
 * String的垃圾回收:
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails
 *
 */
public class StringGCTest &#123;
    public static void main(String[] args) &#123;
//        for (int j = 0; j &lt; 100; j++) &#123;
//            String.valueOf(j).intern();
//        &#125;
        //发生垃圾回收行为
        for (int j = 0; j &lt; 100000; j++) &#123;
            String.valueOf(j).intern();
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083110150090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十、执行引擎概述"><a href="#十、执行引擎概述" class="headerlink" title="十、执行引擎概述"></a>十、执行引擎概述</h2><blockquote>
<p>总结写在最前面<br>为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？<br>(1). 使用JLT编译器，针对的是字节码文件，可以跨平台<br>(2). 可以在动态期间对齐进行优化，比如:逃逸分析优化(逃逸分析优化可以有如下几种:栈上分配、标量替换、同步消除)<br><img src="https://img-blog.csdnimg.cn/20200907110204890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1 执行引擎概述"></a>1 执行引擎概述</h3><ul>
<li>①. 执行引擎是Java虚拟机的核心组成部分之一</li>
<li>②. JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM锁识别的字节码指令、符号表和其他辅助信息</li>
<li>③. 那么，如果想让一个Java程序运行起来、执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者</li>
<li>④. 执行引擎的工作过程 (从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果)<ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907093642615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2  Java代码编译和执行过程"></a>2  Java代码编译和执行过程</h3><ul>
<li><p>①. 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤：<br><img src="https://img-blog.csdnimg.cn/20200907094155908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>②. 什么是解释器( Interpreter)，什么是JIT编译器？</p>
<ul>
<li>解释器:当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
</ul>
<ul>
<li>JIT (Just In Time Compiler)编译器(即时编译器):就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li>
</ul>
</li>
<li><p>③. 为什么说Java是半编译半解释型语言?如下图要记住</p>
<ul>
<li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器</li>
<li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。<br><img src="https://img-blog.csdnimg.cn/20200907094820559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h3 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3 机器码、指令、汇编语言"></a>3 机器码、指令、汇编语言</h3><ul>
<li><p>①. 机器码：各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言(0 | 1 组成的)</p>
<ul>
<li><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错</p>
</li>
<li><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快</p>
</li>
<li><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>
</li>
</ul>
</li>
<li><p>②. 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好<br>(由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同)</p>
</li>
<li><p>③. 指令集</p>
<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集</li>
<li>如常见的 (x86指令集，对应的是x86架构的平台 | ARM指令集，对应的是ARM架构的平台 )</li>
</ul>
</li>
<li><p>④. 汇编语言</p>
<ul>
<li><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址</p>
</li>
<li><p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令<br>(由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行)</p>
</li>
</ul>
</li>
<li><p>⑤. 高级语言(如下图需要记住)</p>
<ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li>
<li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907100443910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-解释器-负责响应时间"><a href="#4-解释器-负责响应时间" class="headerlink" title="4 解释器 -负责响应时间"></a>4 解释器 -负责响应时间</h3><ul>
<li><p>①.JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。<br><img src="https://img-blog.csdnimg.cn/20200907104403611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>②. 解释器真正意义上所承担的角色就是<code>一个运行时“翻译者”</code>，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行</p>
</li>
<li><p>③. 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作</p>
</li>
<li><p>④. 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器(了解)<br><img src="https://img-blog.csdnimg.cn/20200907104454410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>⑤. 现状(了解)</p>
<ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C+ +程序员所调侃</li>
</ul>
<ul>
<li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术(JLT)。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升</p>
</li>
<li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-JIT编译器-主要影响性能"><a href="#5-JIT编译器-主要影响性能" class="headerlink" title="5 JIT编译器 -主要影响性能"></a>5 JIT编译器 -主要影响性能</h3><ul>
<li>①. HostSpot JVM的执行方式：当虛拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li>
<li>②. HotSpot VM 为何解释器与JIT编译器共存?①是结论，②是解释：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907104933157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907104949435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测(采用基于计数器的热点探测，HotSpot VM将会为每一个 方法都建立2个不同类型的计数器，分别为方法调用计数器(Invocation Counter) 和回边计数器(BackEdge Counter) )</p>
<ul>
<li><p>方法调用计数器用于统计方法的调用次数</p>
</li>
<li><p>回边计数器则用于统计循环体执行的循环次数</p>
</li>
</ul>
</li>
<li><p>④. 方法调用计数器</p>
<ul>
<li><p>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译</p>
</li>
<li><p>这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求</p>
<p><img src="https://img-blog.csdnimg.cn/20210609152321253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>⑤. 回边计数器<br>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”边”(Back Edge)。显然，建立回边计数器统计的目的就是为了触发OSR编译(n-Stack Replacem ent)<br><img src="https://img-blog.csdnimg.cn/20210609151247376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>⑥. 热度衰减<br><img src="https://img-blog.csdnimg.cn/20200907105339641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="6-HotSpot-VM-可以设置程序执行方式"><a href="#6-HotSpot-VM-可以设置程序执行方式" class="headerlink" title="6 HotSpot VM 可以设置程序执行方式"></a>6 HotSpot VM 可以设置程序执行方式</h3><ul>
<li>①. 缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：<br><img src="https://img-blog.csdnimg.cn/20200907105626586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②.-Xint:完全采用解释器模式执行程序；</li>
<li>③.-Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>④.-Xmixed:采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<h3 id="7-HotSpot-VM中的JIT分类"><a href="#7-HotSpot-VM中的JIT分类" class="headerlink" title="7 HotSpot VM中的JIT分类"></a>7 HotSpot VM中的JIT分类</h3><ul>
<li><p>①. 在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server<br>Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命.令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：<br><img src="https://img-blog.csdnimg.cn/20210609152102305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>②. C1和C2编译器不同的优化策略：<br><img src="https://img-blog.csdnimg.cn/20210609152138792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>③. 总结</p>
<ul>
<li><p>一般来讲，JIT编译出来的机器码性能比解释器高。</p>
</li>
<li><p>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-AOT编译器"><a href="#8-AOT编译器" class="headerlink" title="8 AOT编译器"></a>8 AOT编译器</h3><ul>
<li>①. jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)</li>
<li>②.所谓AOT编译，是与即时编译相对立的一个概念<br>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程 .java -&gt; .class -&gt; .so</li>
<li>③. 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>④. 缺点<br>破坏了java”一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。<br>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知</li>
</ul>
<h2 id="十一、引用计数法"><a href="#十一、引用计数法" class="headerlink" title="十一、引用计数法"></a>十一、引用计数法</h2><blockquote>
<p>前言:<br>(1). 判断对象存活的两种方式(引用计数算法、枚举根节点做可达性分析)<br>(2). 标记阶段(引用计数法、枚举根节点做可达性分析)<br>(3). 清除阶段(复制算法、标记清除算法、标记整理(压缩)算法、分代收集、增量收集算法、分区算法)</p>
</blockquote>
<h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1 引用计数法"></a>1 引用计数法</h3><ul>
<li>①. 原理:假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收</li>
<li>②. 最大的缺陷:无法解决循环引用的问题，gc永远都清除不了(这也是引用计数法被淘汰的原因)</li>
<li>③. 代码展示:</li>
</ul>
<pre><code class="java">/**
 * -XX:+PrintGCDetails
 * 证明:java使用的不是引用计数算法
 */
public class RefCountGC &#123;
    //这个成员属性唯一的作用就是占用一点内存
    private byte[] bigSize = new byte[5 * 1024 * 1024];//5MB

    Object reference = null;

    public static void main(String[] args) &#123;
        RefCountGC obj1 = new RefCountGC();
        RefCountGC obj2 = new RefCountGC();

        obj1.reference = obj2;
        obj2.reference = obj1;

        obj1 = null;
        obj2 = null;
        //显式的执行垃圾回收行为
        //这里发生GC，obj1和obj2能否被回收？
        System.gc();

        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200818105810942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>④. 注意:Java使用的不是引用计数法(Java之所以没有使用引用计数法，是由于不能解决循环引用问题) | (Python使用了是引用计数法)</li>
<li>⑥. Python如何解决循环引用( 扩展了解 )</li>
</ul>
<ol>
<li>手动解决:很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用(只要发生了回收，弱引用都会被回收)</li>
</ol>
<h3 id="2-枚举根节点做可达性分析"><a href="#2-枚举根节点做可达性分析" class="headerlink" title="2 枚举根节点做可达性分析"></a>2 枚举根节点做可达性分析</h3><ul>
<li>①. 基本思路是通过一系列名为”GC Roots”的对象(集合)作为起点，从这个被称为GC ROOTs 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象是不可达对象(被回收)，否则就是可达对象<br><img src="https://img-blog.csdnimg.cn/20190813201726657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190813202011669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 在java中，可作为GC Roots的对象有</li>
</ul>
<pre><code class="handlebars">    (1).虚拟机栈(栈帧中的局部变量表)中的引用对象(比如各个线程被调用的方法中使用到的参数、
    局部变量等)
    (2).本地方法栈中JNI(即一般来说native方法)中引用的对象[ 线程中的start方法 ]
    (3).静态属性引用的对象(比如:Java类的引用类型静态变量)
    (4).方法区中常量引用的对象(比如:字符串常量池(String Table)里的引用)

    (5).所有被synchronized持有的对象
    (6).Java虚拟机内部的引用(基本数据类型对应的Class对象，一些常驻的异常对象
    [如NullPointerException、OutofMemoryError]，系统类加载器)
    (7).反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    (8).注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域
不同，还可以有其他对象临时加入，共同构架完成整GC Roots集合。比如:分代收集和局部回收(面试加分项)
</code></pre>
<ul>
<li>③. 关于GCroot对象集合 注意事项:<br>注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots 集合。比如: 分代收集和局部回收(面试加分项)<br>解释:如果只针对java堆中的某一区域进行垃圾回收(比如: 典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用时候就需要一并将关联的区域对象也加入到GC Roots 集合中考虑，才能保证可达性分析的准确性</li>
<li>④. 小技巧:由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root<br><img src="https://img-blog.csdnimg.cn/20200818113337135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>⑤. 优势:</li>
</ul>
<ol>
<li>相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效 等特点，更重要的是该算法可以有效解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集</li>
</ol>
<ul>
<li>⑥. 可达性分析算法的 注意事项:如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在 一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。 (即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的)</li>
</ul>
<h3 id="3-finalization机制"><a href="#3-finalization机制" class="headerlink" title="3 finalization机制"></a>3 finalization机制</h3><h4 id="3-1-finalization机制说明"><a href="#3-1-finalization机制说明" class="headerlink" title="3.1 finalization机制说明"></a>3.1 finalization机制说明</h4><ul>
<li>①. finalize( ) 方法允许在子类中被重写，用于对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等</li>
<li>②. 当垃圾回收器发现没有引用指向一个对象，即:垃圾收集此对象之前，总会先调用这个对象的finalize( )方法</li>
<li>③. Java语言提提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义逻辑</li>
</ul>
<h4 id="3-2-不主动调用某个对象的finalize-方法，应该交给垃圾回收机制调用，理由包括下面三点"><a href="#3-2-不主动调用某个对象的finalize-方法，应该交给垃圾回收机制调用，理由包括下面三点" class="headerlink" title="3.2 不主动调用某个对象的finalize( ) 方法，应该交给垃圾回收机制调用，理由包括下面三点"></a>3.2 不主动调用某个对象的finalize( ) 方法，应该交给垃圾回收机制调用，理由包括下面三点</h4><ul>
<li>①. 在finalize( )时可能会导致对象复活</li>
<li>②. finalize( )方法执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize( ) 方法将没有执行机会</li>
<li>③. 一个糟糕的finalize( )会严重影响GC的性能</li>
<li>④. 由于finalize( )方法的存在，虚拟机中的对象一般处于三种可能的状态</li>
</ul>
<h4 id="3-3-finalize-方法中虚拟机的状态"><a href="#3-3-finalize-方法中虚拟机的状态" class="headerlink" title="3.3 finalize( )方法中虚拟机的状态"></a>3.3 finalize( )方法中虚拟机的状态</h4><ul>
<li>①. 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收，但事实上，也并非是”非死不可”的，这时候它们暂时处于”缓刑”阶段。一个无法触及的对象肯能在某一个条件下”复活”自己，如果这样，那么对它的回收就是不合理的。为此，定义虚拟机中的对象可能有三种状态。如下:(掌握)</li>
</ul>
<ol>
<li>可触及的:从根节点开始，可以到达这个对象</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize( )中复活</li>
<li>不可触及的: 对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize( )只会被调用一次</li>
</ol>
<ul>
<li>②. 以上3种状态中，是由于finalize( )方法的存在，进行的区分。只有对象不可触及才可以被回收</li>
</ul>
<h4 id="3-4-判断一个对象是否可以进行回收-理解"><a href="#3-4-判断一个对象是否可以进行回收-理解" class="headerlink" title="3.4 判断一个对象是否可以进行回收(理解)"></a>3.4 判断一个对象是否可以进行回收(理解)</h4><ul>
<li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。 判定是否可以回收具体过程 判定一个对象objA是否可回收，至少要经历两次标记过程:<br><img src="https://img-blog.csdnimg.cn/20200818113908998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h4 id="3-5-代码演示"><a href="#3-5-代码演示" class="headerlink" title="3.5 代码演示"></a>3.5 代码演示</h4><pre><code class="java">/**
 * 测试Object类中finalize()方法，即对象的finalization机制。
 *
 */
public class CanReliveObj &#123;
    public static CanReliveObj obj;//类变量，属于 GC Root


    //此方法只能被调用一次
    @Override
    protected void finalize() throws Throwable &#123;
        super.finalize();
        System.out.println(&quot;调用当前类重写的finalize()方法&quot;);
        obj = this;//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系
    &#125;


    public static void main(String[] args) &#123;
        try &#123;
            obj = new CanReliveObj();
            // 对象第一次成功拯救自己
            obj = null;
            System.gc();//调用垃圾回收器
            System.out.println(&quot;第1次 gc&quot;);
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) &#123;
                System.out.println(&quot;obj is dead&quot;);
            &#125; else &#123;
                System.out.println(&quot;obj is still alive&quot;);
            &#125;
            System.out.println(&quot;第2次 gc&quot;);
            // 下面这段代码与上面的完全相同，但是这次自救却失败了
            obj = null;
            System.gc();
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) &#123;
                System.out.println(&quot;obj is dead&quot;);
            &#125; else &#123;
                System.out.println(&quot;obj is still alive&quot;);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-复制算法-Copying"><a href="#4-复制算法-Copying" class="headerlink" title="4  复制算法(Copying)"></a>4  复制算法(Copying)</h3><ul>
<li>①. 核心思想:将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在.使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li>
<li>②. 描述(重点掌握)<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 一般过程(图解)<br><img src="https://img-blog.csdnimg.cn/2020081814111378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 优缺点 掌握</li>
</ul>
<ol>
<li>:①.没有标记和清除过程，实现简单，运行高效 ②. 不会产生内存碎片，且对象完整不丢</li>
<li>缺点:①. 浪费了10%的空间 ②. 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
<li>注意:复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。因为新生代中的对象一般都是朝生夕死的，在新生代中使用复制算法是非常好的</li>
</ol>
<ul>
<li>⑤. 注意:是当伊甸园区满后，会触发minjor gc，进行垃圾的回收</li>
</ul>
<h3 id="5-标记清除算法-Mark一Sweep"><a href="#5-标记清除算法-Mark一Sweep" class="headerlink" title="5 标记清除算法(Mark一Sweep)"></a>5 标记清除算法(Mark一Sweep)</h3><ul>
<li>①. 标记一清除算法(Mark一Sweep)是一种非常基础和常见的垃圾收集算法，该算法被J . McCarthy等人在1960年提出并并应用于Lisp语言</li>
<li>②. 标记:Collector(垃圾回收器)从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>③. 清除: Collector(垃圾回收器)对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
<li>④. 图解: CMS使用这种方式<br><img src="https://img-blog.csdnimg.cn/20210612172349990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优:不需要额外的空间</li>
<li>缺点:①.两次扫描，耗时严重 ②.清理出来的空闲内存不连续，会产生内存碎片，需要维护一个空闲列表 ③.效率比较低:递归与全堆对象遍历两次(经历了两次遍历)</li>
</ol>
<ul>
<li>⑥. 注意:这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放</li>
</ul>
<h3 id="6-标记整理-压缩-算法-Mark-Compact"><a href="#6-标记整理-压缩-算法-Mark-Compact" class="headerlink" title="6 标记整理(压缩)算法(Mark-Compact)"></a>6 标记整理(压缩)算法(Mark-Compact)</h3><ul>
<li>①. 背景:</li>
</ul>
<ol>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li>
<li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记一压缩(Mark一Compact) 算法由此诞生</li>
<li>1970年前后，G. L. Steele 、C. J. Chene和D.S. Wise 等研究者发布标记一压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</li>
</ol>
<ul>
<li>②. 执行过程:</li>
</ul>
<ol>
<li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>最后，清理边界外所有的空间。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</li>
</ol>
<ul>
<li>③. 图解:<br><img src="https://img-blog.csdnimg.cn/20200818141849116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 指针碰撞<br>(如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer))</li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优点:①. 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可②. 消除了复制算法当中，内存减半的高额代价</li>
<li>缺点:①. 从效率.上来说，标记一整理算法要低于复制算法。②. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序。即: STW</li>
</ol>
<h3 id="7-分代收集"><a href="#7-分代收集" class="headerlink" title="7 分代收集"></a>7 分代收集</h3><blockquote>
<p>写在最前面:<br>( 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除)</p>
</blockquote>
<ul>
<li>①. 没有最好的算法，只有更合适的算法</li>
<li>②. 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除</li>
<li>③. 新生代(Young Gen)</li>
</ul>
<ol>
<li>新生代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li>
</ol>
<ul>
<li>④. 老年代(Tenured Gen)</li>
</ul>
<ol>
<li>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记一整理的混合实现。<br>Mark阶段的开销与存活对象的数量成正比<br>Sweep阶段的开销与所管理区域的大小成正相关<br>Compact阶段的开销与存活对象的数据成正比</li>
</ol>
<h3 id="8-增量收集算法-了解"><a href="#8-增量收集算法-了解" class="headerlink" title="8 增量收集算法(了解)"></a>8 增量收集算法(了解)</h3><ul>
<li>①. 上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集(Incremental Collecting) 算法的诞生</li>
<li>②. 基本思想(理解)</li>
</ul>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li>
<li>总的来说，增量收集算法的基础仍是传统的标记一清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
</ol>
<ul>
<li>③. 缺点:<br>(使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。)</li>
</ul>
<h3 id="9-分区算法-了解"><a href="#9-分区算法-了解" class="headerlink" title="9  分区算法(了解)"></a>9  分区算法(了解)</h3><ul>
<li>①. 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>②. 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间</li>
<li>③. 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200818143418977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十二、System-gc"><a href="#十二、System-gc" class="headerlink" title="十二、System.gc"></a>十二、System.gc</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1 System.gc()的理解"></a>1 System.gc()的理解</h3><ul>
<li>①. 在默认情况下，通过System.gc( )或者Runtime . getRuntime( ).gc( )的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>②. 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(无法保证马上触发GC)。[不保证一定会发生垃圾收集，只是给jvm发出提示]</li>
<li>③. JVM实现者可以通过system.gc( )调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc( )</li>
<li>④. 以下代码，如果注掉System.runFinalization( ); 那么控制台不保证一定打印，证明了System.gc( )无法保证GC一定执行</li>
</ul>
<pre><code class="java">public class SystemGCTest &#123;
    public static void main(String[] args) &#123;
        new SystemGCTest();
        System.gc();//提醒jvm的垃圾回收器执行gc，但是不确定是否马上执行gc
        //与Runtime.getRuntime().gc();的作用一样。
        System.runFinalization();//强制调用使用引用的对象的finalize()方法
    &#125;

    @Override
    protected void finalize() throws Throwable &#123;
        super.finalize();
        System.out.println(&quot;SystemGCTest 重写了finalize()&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>⑤. 手动gc理解不可达对象的回收行为</li>
</ul>
<pre><code class="java">public class LocalVarGC &#123;
    public void localvarGC1() &#123;
        byte[] buffer = new byte[10 * 1024 * 1024];//10MB
        System.gc();
        //输出: 不会被回收， FullGC时被放入老年代
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10788K(251392K)， 0.0089741 secs] [Times: user=0.01 sys=0.00， real=0.01 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 52K-&gt;10649K(175104K)] 10788K-&gt;10649K(251392K)， [Metaspace: 3253K-&gt;3253K(1056768K)]， 0.0074098 secs] [Times: user=0.01 sys=0.02， real=0.01 secs]
    &#125;

    public void localvarGC2() &#123;
        byte[] buffer = new byte[10 * 1024 * 1024];
        buffer = null;
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;544K(76288K)] 14174K-&gt;552K(251392K)， 0.0011742 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 544K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 552K-&gt;410K(251392K)， [Metaspace: 3277K-&gt;3277K(1056768K)]， 0.0054702 secs] [Times: user=0.01 sys=0.00， real=0.01 secs]

    &#125;

    public void localvarGC3() &#123;
        &#123;
            byte[] buffer = new byte[10 * 1024 * 1024];
        &#125;
        System.gc();
        //输出: 不会被回收， FullGC时被放入老年代
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10784K(251392K)， 0.0076032 secs] [Times: user=0.02 sys=0.00， real=0.01 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 48K-&gt;10649K(175104K)] 10784K-&gt;10649K(251392K)， [Metaspace: 3252K-&gt;3252K(1056768K)]， 0.0096328 secs] [Times: user=0.01 sys=0.01， real=0.01 secs]
    &#125;

    public void localvarGC4() &#123;
        &#123;
            byte[] buffer = new byte[10 * 1024 * 1024];
        &#125;
        int value = 10;
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;496K(76288K)] 14174K-&gt;504K(251392K)， 0.0016517 secs] [Times: user=0.01 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 496K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 504K-&gt;410K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0055183 secs] [Times: user=0.00 sys=0.00， real=0.01 secs]
    &#125;

    public void localvarGC5() &#123;
        localvarGC1();
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10720K(76288K)] 14174K-&gt;10744K(251392K)， 0.0121568 secs] [Times: user=0.02 sys=0.00， real=0.02 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10720K-&gt;0K(76288K)] [ParOldGen: 24K-&gt;10650K(175104K)] 10744K-&gt;10650K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0101068 secs] [Times: user=0.01 sys=0.02， real=0.01 secs]
        //[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10650K-&gt;10650K(251392K)， 0.0005717 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10650K-&gt;410K(175104K)] 10650K-&gt;410K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0045963 secs] [Times: user=0.01 sys=0.00， real=0.00 secs]
    &#125;

    public static void main(String[] args) &#123;
        LocalVarGC local = new LocalVarGC();
        local.localvarGC5();
    &#125;
&#125;
</code></pre>
<h3 id="2-内存溢出-out-of-Memory"><a href="#2-内存溢出-out-of-Memory" class="headerlink" title="2 内存溢出(out of Memory)"></a>2 内存溢出(out of Memory)</h3><ul>
<li><p>①. javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存</p>
</li>
<li><p>②. 说明Java虚拟机的堆内存不够。原因有二</p>
<ul>
<li>Java虚拟机的堆内存设置不够(比如:可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整)</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</li>
</ul>
</li>
<li><p>③. 这里面隐含着一层意思是，在抛出0utOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如:在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p><strong>④. 当然，也不是在任何情况下垃圾收集器都会被触发的</strong><br>(比如，我们去分配一一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError)</p>
</li>
</ul>
<h3 id="3-内存泄漏-Memory-Leak"><a href="#3-内存泄漏-Memory-Leak" class="headerlink" title="3 内存泄漏(Memory Leak)"></a>3 内存泄漏(Memory Leak)</h3><ul>
<li><p>①. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</p>
</li>
<li><p>②. 但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏</p>
</li>
<li><p>③. 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p>
</li>
<li><p>④. Java中内存泄漏的8种情况</p>
<ul>
<li>单例模式(单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。)</li>
<li>一些提供close的资源未关闭导致内存泄漏 数据库连接( dataSourse. getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</li>
<li>静态集合类(如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收)</li>
<li>内部类持有外部类(内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。)</li>
<li>变量不合理的作用域(一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生)</li>
</ul>
<ul>
<li><p>改变哈希值</p>
</li>
<li><p>缓存泄漏(内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据)</p>
</li>
<li><p>监听器和回调(内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚)</p>
</li>
</ul>
</li>
</ul>
<pre><code class="typescript">//静态集合类
public class MemoryLeak &#123;
    static List list = new ArrayList();

    public void oomTests() &#123;
        Object obj = new Object();//局部变量
        list.add(obj);
    &#125;
&#125;
//变量不合理的作用域
public class UsingRandom &#123;
     private String msg;
     public void receiveMsg()&#123;
        //private String msg;
        readFromNet();// 从网络中接受数据保存到msg中
        saveDB();// 把msg保存到数据库中
        //msg = null;
     &#125;
&#125;
//改变哈希值
public class ChangeHashCode &#123;
    public static void main(String[] args) &#123;
        HashSet set = new HashSet();
        Person p1 = new Person(1001， &quot;AA&quot;);
        Person p2 = new Person(1002， &quot;BB&quot;);

        set.add(p1);
        set.add(p2);
        p1.name = &quot;CC&quot;;
        set.remove(p1);
        System.out.println(set);//2个对象！
        
//        set.add(new Person(1001， &quot;CC&quot;));
//        System.out.println(set);
//        set.add(new Person(1001， &quot;AA&quot;));
//        System.out.println(set);

    &#125;
&#125;
</code></pre>
<h3 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4 Stop The World"></a>4 Stop The World</h3><ul>
<li><p>①. Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW</p>
</li>
<li><p>②. STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li><p>③. 哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p>④. STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉</p>
</li>
<li><p>⑤. 开发中不要用System.gc()，会导致full gc，会导致Stop一the一world的发生</p>
</li>
<li><p>⑥. 什么情况下会导致stop the world 记住</p>
<ul>
<li>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</li>
</ul>
<ul>
<li>进行gc的时候会发生STW现象(调用finalize()方法的时候会暂停用户线程</li>
<li>System.gc( ) | 调用finalize( )方法</li>
</ul>
</li>
</ul>
<h3 id="5-多线程中的并行与并发"><a href="#5-多线程中的并行与并发" class="headerlink" title="5 多线程中的并行与并发"></a>5 多线程中的并行与并发</h3><ul>
<li><p>①. 并发(Concurrent)</p>
<ul>
<li>在操作系统中，是指一个时间段中有几个程序都处于己启动运行到运行完毕之间，且这几个程序都是在同一个处理器_上运行</li>
<li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li>
</ul>
<ul>
<li>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163718413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>②. 并行(Parallel)</p>
<ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)</li>
</ul>
<ul>
<li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以 并行</p>
</li>
<li><p>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163818501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="6-垃圾回收的并行、串行、并发"><a href="#6-垃圾回收的并行、串行、并发" class="headerlink" title="6 垃圾回收的并行、串行、并发"></a>6 垃圾回收的并行、串行、并发</h3><ul>
<li><p>①. 并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、 Parallel Scavenge、 Parallel 0ld；</p>
</li>
<li><p>②. 串行(Serial)</p>
<ul>
<li>相较于并行的概念，单线程执行。</li>
</ul>
<ul>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
<li>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163928870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>③. 并发</p>
<ul>
<li><p>指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行</p>
</li>
<li><p>在同一个时间段，用户线程和垃圾回收线程同时执行</p>
</li>
<li><p>图解<br><img src="https://img-blog.csdnimg.cn/20200818164027906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-安全点-Safepoint"><a href="#7-安全点-Safepoint" class="headerlink" title="7 安全点(Safepoint)"></a>7 安全点(Safepoint)</h3><ul>
<li><p>①. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为 “安全点(Safepoint)”</p>
</li>
<li><p>②. Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</p>
</li>
<li><p>③. 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><p>抢先式中断: (目前没有虚拟机采用了) 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
</li>
<li><p>主动式中断: 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-安全区域-Safe-Region"><a href="#8-安全区域-Safe-Region" class="headerlink" title="8 安全区域(Safe Region)"></a>8 安全区域(Safe Region)</h3><ul>
<li><p>①. Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
</li>
<li><p>②. 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
</li>
<li><p>③. 实际执行时:</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发GC，JVM会忽略标识为Safe Region状态的线程；</li>
</ul>
<ul>
<li>当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</li>
</ul>
</li>
</ul>
<h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9 引用"></a>9 引用</h3><ul>
<li><p>①. 我们希望能描述这样一类对象: 当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。 -【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用.场景是什么？</p>
</li>
<li><p>②. 在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong<br>Reference)、软引用(Soft Reference) 、弱引用(Weak Reference) 和虚引用(Phantom Reference) 4种，这4种引用强度依次逐渐减弱</p>
</li>
<li><p>③. 除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。<br><img src="https://img-blog.csdnimg.cn/20200819092213852.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
</li>
<li><p>⑤. 简单介绍下强软弱虚引用</p>
<ul>
<li>强引用(StrongReference)I :最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object( )”这种引用关系。 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
</ul>
<ul>
<li><p>软引用(SoftReference) :在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常 内存不足即回收</p>
</li>
<li><p>弱引用(WeakReference) :被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。 发现即回收</p>
</li>
<li><p>虚引用(PhantomReference) :一个对象是否有虛引用的存在，完全不会对其生存时 间构成影响，也无法通过虚引用来获得一个对象的实例。 为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210331225705856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="9-1-强引用-不回收"><a href="#9-1-强引用-不回收" class="headerlink" title="9.1  强引用:不回收"></a>9.1  强引用:不回收</h4><ul>
<li>在Java程序中，最常见的引用类型是强引用(普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。</li>
<li>当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li>
<li>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li>
</ul>
<h4 id="9-2-软引用-内存不足即回收"><a href="#9-2-软引用-内存不足即回收" class="headerlink" title="9.2 软引用: 内存不足即回收"></a>9.2 软引用: 内存不足即回收</h4><ul>
<li><p>①. 软引用是用来描述一 些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>注意:一次回收是回收强引用中没有引用的对象</p>
</li>
<li><p>②. 软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存</p>
</li>
<li><p>③. 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得.已才清理</p>
</li>
<li><p>④. 软引用:</p>
<ul>
<li><p>当内存足够: 不会回收软用的可达对象</p>
</li>
<li><p>当内存不够时: 会回收软引用的可达对象</p>
</li>
</ul>
</li>
<li><p>⑤. 在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
</li>
</ul>
<pre><code class="java">Object obj = new object()； //声明强引用
SoftReference&lt;0bject&gt; sf = new SoftReference&lt;0bject&gt;(obj)；
obj = null； //销毁强引用
</code></pre>
<ul>
<li>⑥. 测试代码</li>
</ul>
<pre><code class="java">/**
 * 软引用的测试:内存不足即回收
 * -Xms10m -Xmx10m -XX:+PrintGCDetails
 */
public class SoftReferenceTest &#123;
    public static class User &#123;
        public User(int id， String name) &#123;
            this.id = id;
            this.name = name;
        &#125;

        public int id;
        public String name;

        @Override
        public String toString() &#123;
            return &quot;[id=&quot; + id + &quot;， name=&quot; + name + &quot;] &quot;;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //创建对象，建立软引用
//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1， &quot;songhk&quot;));
        //上面的一行代码，等价于如下的三行代码
        User u1 = new User(1，&quot;songhk&quot;);
        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(u1);
        u1 = null;//取消强引用


        //从软引用中重新获得强引用对象
        System.out.println(userSoftRef.get());

        System.gc();
        System.out.println(&quot;After GC:&quot;);
//        //垃圾回收之后获得软引用中的对象
        System.out.println(userSoftRef.get());//由于堆空间内存足够，所有不会回收软引用的可达对象。
//
        try &#123;
            //让系统认为内存资源紧张、不够
//            byte[] b = new byte[1024 * 1024 * 7];
            byte[] b = new byte[1024 * 7168 - 399 * 1024];//恰好能放下数组又放不下u1的内存分配大小 不会报OOM
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //再次从软引用中获取数据
            System.out.println(userSoftRef.get());//在报OOM之前，垃圾回收器会回收软引用的可达对象。
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="9-3-弱引用-发现即回收"><a href="#9-3-弱引用-发现即回收" class="headerlink" title="9.3 弱引用: 发现即回收"></a>9.3 弱引用: 发现即回收</h4><ul>
<li>①. 弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</li>
<li>②. 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li>
<li>③. 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li>
<li>④. 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</li>
<li>⑤. 在JDK1.2版之后提后了java.lang.ref.WeakReference类来实现弱引用</li>
</ul>
<pre><code class="java">Object obj = new object()； //声明强引用
WeakReference&lt;0bject&gt; sf = new WeakReference&lt;0bject&gt;(obj)；
obj = null； //销毁强引用
</code></pre>
<ul>
<li>⑥. 面试题:你开发中使用过WeakHashMap吗？</li>
</ul>
<ol>
<li>通过查看WeakHashMap源码，可以看到其内部类Entry使用的就是弱引用</li>
<li>line 702 -&gt; private static class Entry&lt;K，V&gt; extends WeakReference implements Map.Entry&lt;K，V&gt; {…}</li>
</ol>
<pre><code class="java">public class WeakReferenceTest &#123;
    public static class User &#123;
        public User(int id， String name) &#123;
            this.id = id;
            this.name = name;
        &#125;

        public int id;
        public String name;

        @Override
        public String toString() &#123;
            return &quot;[id=&quot; + id + &quot;， name=&quot; + name + &quot;] &quot;;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //构造了弱引用
        WeakReference&lt;User&gt; userWeakRef = new WeakReference&lt;User&gt;(new User(1， &quot;songhk&quot;));
        //从弱引用中重新获取对象
        System.out.println(userWeakRef.get());

        System.gc();
        // 不管当前内存空间足够与否，都会回收它的内存
        System.out.println(&quot;After GC:&quot;);
        //重新尝试从弱引用中获取对象
        System.out.println(userWeakRef.get());
    &#125;
&#125;
</code></pre>
<h4 id="9-4-虚引用-对象回收跟踪"><a href="#9-4-虚引用-对象回收跟踪" class="headerlink" title="9.4 虚引用: 对象回收跟踪"></a>9.4 虚引用: 对象回收跟踪</h4><ul>
<li>①. 虚引用(Phantom Reference)，也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li>
<li>②. 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知。</li>
<li>③. 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。虚引用的get方法总是返回给null，因此无法访问对应的引用对象 理解</li>
<li>④. 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录‘’</li>
<li>⑤. 在JDK 1. 2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<pre><code class="java">object obj = new object();
ReferenceQueuephantomQueue = new ReferenceQueue( ) ;
PhantomReference&lt;object&gt; pf = new PhantomReference&lt;object&gt;(obj， phantomQueue); 
obj = null;
</code></pre>
<ul>
<li>⑥. 测试代码</li>
</ul>
<pre><code class="java">/***
 * -xms10m -xmx10m
 */
public class MyObject &#123;
    public static void main(String[] args) &#123;

        ReferenceQueue&lt;MyObject&gt; referenceQueue = new ReferenceQueue();
        PhantomReference&lt;MyObject&gt; phantomReference = new PhantomReference&lt;&gt;(new MyObject()，referenceQueue);
        //System.out.println(phantomReference.get());

        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();

        new Thread(() -&gt; &#123;
            while (true)
            &#123;
                list.add(new byte[1 * 1024 * 1024]);
                try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;
                System.out.println(phantomReference.get());
            &#125;
        &#125;，&quot;t1&quot;).start();

        new Thread(() -&gt; &#123;
            while (true)
            &#123;
                Reference&lt;? extends MyObject&gt; reference = referenceQueue.poll();
                if (reference != null) &#123;
                    //下面这句话被打印出说明进行了gc，然后将对象放在了引用队列中，我们可以使用poll方法获取
                    System.out.println(&quot;***********有虚对象加入队列了&quot;+reference);
                &#125;
            &#125;
        &#125;，&quot;t2&quot;).start();

        //暂停几秒钟线程
        try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;

    &#125;

    @Override
    protected void finalize() throws Throwable &#123;
        // gc finalize method over 这句话被打印出来，说明进行了gc
        System.out.println(&quot;gc finalize method over&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="十三、评估GC性能指标"><a href="#十三、评估GC性能指标" class="headerlink" title="十三、评估GC性能指标"></a>十三、评估GC性能指标</h2><blockquote>
<p>面试遇到面试官问这部分可以这样回答:<br>不同的厂商会考虑使用不同的JVM，不同的JVM会使用不同的垃圾收集器，下面我介绍下主流的垃圾收集器有哪些(主流的7种)，下面你就可以展开去说明七种垃圾收集器的每一个细节。<br>(1).截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器<br><img src="https://img-blog.csdnimg.cn/2020092610513159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>(2).不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合(连线)，如下图:<br><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200926105608725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-评估GC的性能指标"><a href="#1-评估GC的性能指标" class="headerlink" title="1 评估GC的性能指标"></a>1 评估GC的性能指标</h3><ul>
<li>①. 吞吐量:运行用户代码的时间占总运行时间的比例<br>吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)<br>比如:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%<br>吞吐量优先，意味着在单位时间内，STW的时间最短:0.2 + 0.2 = 0.4</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621105540919.png" alt="在这里插入图片描述"></p>
<ul>
<li>②. 暂停时间:执行垃圾收集时，程序的工作线程被暂停的时间<br>暂停时间优先，意味着尽可能让单次STW的时间最短:0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621105512858.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 内存占用: Java堆区所占的内存大小</p>
</li>
<li><p>④. 垃圾收集开销:吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p>
</li>
<li><p>⑤. 收集频率:相对于应用程序的执行，收集操作发生的频率<br>(类似于大学洗衣服，天天洗，每次很快洗完;一周洗，洗很久)<br>(手机频率高，垃圾线程所用时间短，吞吐量低)</p>
</li>
<li><p>⑥. 评估GC的性能指标:吞吐量vs暂停时间</p>
<ul>
<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用 多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
</ul>
<ul>
<li><p>简单来说，主要抓住两点:吞吐量、暂停时间</p>
</li>
<li><p>现在JVM调优标准:在最大吞吐量优先的情况下，降低停顿时间</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2 不同的垃圾回收器概述"></a>2 不同的垃圾回收器概述</h3><ul>
<li><p>①. 垃圾收集器发展史<br>1999年随JDK1.3.1一起来的是串行方式的Serial GC ，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本<br>2002年2月26日，Parallel GC 和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布<br>Parallel GC在JDK6之后成为HotSpot默认GC<br>2012年，在JDK1.7u4版本中，G1可用。-XX:+UseG1GC<br>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS<br>2018年3月，JDK 10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟<br>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为”No-Op(无操作)”回收器。同时，引入ZGC:可伸缩的低延迟垃圾回收器(Experimental)<br>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC:低停顿时间的GC(Experimental)<br>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统<br>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</p>
</li>
<li><p>②. 7款经典的垃圾收集器<br>串行回收器:Serial、Serial Old<br>并行回收器:ParNew、Parallel Scavenge、Parallel Old<br>并发回收器:CMS、G1</p>
</li>
<li><p>③. 7款经典的垃圾收集器与垃圾分代之间的关系<br>新生代收集器: Serial GC、ParNew GC、Parallel Scavenge GC<br>老年代收集器: Serial 0ld GC、 Parallel 0ld GC、 CMS GC<br>整堆收集器: G1 GC<br><img src="https://img-blog.csdnimg.cn/20200926110651301.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. 垃圾收集器的组合关系</p>
<ul>
<li><p>两个收集器间有连线，表明它们可以搭配使用:Serial/Serial 01d、Serial/CMS、 ParNew/Serial 01d、ParNew/CMS、Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；</p>
</li>
<li><p>其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial 01d这两个组合声明为废弃(JEP 173) ，并在JDK 9中完全取消了这些组合的支持(JEP214)，即:移除。(绿色虚线)JDK 14中:弃用Parallel Scavenge和Serial0ld GC组合(JEP366 )(青色虚线)JDK 14中:删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/37b129b3e4a7405b992584c91962da37.png" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 查看默认的垃圾收集器</li>
</ul>
<ol>
<li>-xx:+PrintCommandLineFlags: 查看命令行相关参数(包含使用的垃圾收集器)</li>
</ol>
<pre><code class="java">/**
 *  -XX:+PrintCommandLineFlags
 *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC
 *  -XX:+UseParNewGC:标明新生代使用ParNew GC
 *  -XX:+UseParallelGC:表明新生代使用Parallel GC
 *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC
 *  说明:二者可以相互激活
 *  -XX:+UseConcMarkSweepGC:表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用
 */
public class GCUseTest &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();

        while(true)&#123;
            byte[] arr = new byte[100];
            list.add(arr);
            try &#123;
                Thread.sleep(10);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
输出:
(-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 
-XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers 
-XX:+UseCompressedOops -XX:+UseParallelGC)
</code></pre>
<ol>
<li>使用命令行指令: jinfo 一flag 相关垃圾回收器参数进程ID<br>( jinfo -flag UseParallelGC 进程id<br>jinfo -flag UseParallelOldGC 进程id )<br><img src="https://img-blog.csdnimg.cn/20200926111157662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="3-Serial、SerialOld-回收器-串行回收-了解"><a href="#3-Serial、SerialOld-回收器-串行回收-了解" class="headerlink" title="3 Serial、SerialOld 回收器:串行回收(了解)"></a>3 Serial、SerialOld 回收器:串行回收(了解)</h3><ul>
<li>①. Serial收集器采用复制算法、串行回收和”Stop一 the一World”机制的方式执行内存回收</li>
<li>②. Serial 0ld收集器同样也采用了串行回收 和”Stop the World”机制，只不过内存回收算法使用的是标记一压缩算法</li>
<li>③. 单线程回收:使用一个cpu或一条线程去完成垃圾收集工作 | 必须暂停其他所有的工作线程</li>
<li>④. 使用 -XX: +UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器<br>等价于新生代用Serial GC，且老年代用Serial 0ld GC<br>控制台输出:<br>-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC<br><img src="https://img-blog.csdnimg.cn/20210621204739933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-ParNew回收器-并行回收-了解"><a href="#4-ParNew回收器-并行回收-了解" class="headerlink" title="4 ParNew回收器:并行回收(了解)"></a>4 ParNew回收器:并行回收(了解)</h3><ul>
<li>①. 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本</li>
<li>②. ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop一 the一World”机制</li>
<li>③. 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li>
<li>④. 在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用.ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器， 不影响老年代</li>
<li>⑤. -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数。<br><img src="https://img-blog.csdnimg.cn/20210621204818609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. SerialGC 和 ParNewGC哪个更好?<ul>
<li>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销</li>
</ul>
</li>
</ul>
<h3 id="5-Parallel、ParallelOld-吞吐量优先"><a href="#5-Parallel、ParallelOld-吞吐量优先" class="headerlink" title="5 Parallel、ParallelOld:吞吐量优先"></a>5 Parallel、ParallelOld:吞吐量优先</h3><ul>
<li><p>①. HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scav enge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。在Java8中，默认是此垃圾收集器</p>
</li>
<li><p>②. 那么Parallel收集器的出现是否多此一举？</p>
<ul>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughp ut)，它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别</p>
</li>
</ul>
</li>
<li><p>③. 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>④. Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 Parallel 0ld收集器，用来代替老年代的Serial 0ld收集器</p>
</li>
<li><p>⑤. Parallel 0ld收集器采用了标记一压缩算法，但同样也是基于并行回收和”Stop一the一World”机制<br><img src="https://img-blog.csdnimg.cn/20210621205034323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>⑥. 在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错</p>
</li>
<li><p>⑦. 参数配置<br>-XX:+UseParallelGC手动指定年轻代使用Parallel并行收集器执行内存回收任务<br>-XX:+UseParallelOldGC手动指定老年代都是使用并行回收收集器。<br>(分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活))<br>-XX:ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能<br>(在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。<br>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]/8] )<br>-XX:MaxGCPauseMillis:设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒<br>(为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数<br>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制<br>该参数使用需谨慎)<br>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略<br>(在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio)和停顿时间(MaxGCPauseMills)，让虚拟机自己完成调优工作)</p>
</li>
</ul>
<h3 id="6-详解-XX-PrintGCDetails"><a href="#6-详解-XX-PrintGCDetails" class="headerlink" title="6 详解-XX:+PrintGCDetails"></a>6 详解-XX:+PrintGCDetails</h3><ul>
<li>①. Minor GC<br><img src="https://img-blog.csdnimg.cn/20200926194721899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②. Full GC<br><img src="https://img-blog.csdnimg.cn/20200926194816173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>③. 举例补充</li>
</ul>
<pre><code class="java">/**
 * 在jdk7 和 jdk8中分别执行
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
 */
public class GCLogTest1 &#123;
    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() &#123;
        byte[] allocation1， allocation2， allocation3， allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    &#125;

    public static void main(String[] agrs) &#123;
        testAllocation();
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200926194908760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-其他垃圾回收器概述"><a href="#7-其他垃圾回收器概述" class="headerlink" title="7 其他垃圾回收器概述"></a>7 其他垃圾回收器概述</h3><ul>
<li><p>①. Open JDK12的Shenandoah GC</p>
<ul>
<li>暂时时间短、吞吐量下降</li>
<li>red hot 团队</li>
</ul>
</li>
<li><p>②. 革命性的ZGC(jdk11-oracle)<br>( 在尽可能对吞吐量影响不大的前提下.实现在任意堆内存大小都可以把垃圾收集的停顿时间控制在10毫秒之内)</p>
</li>
</ul>
<h2 id="十四、字节码文件"><a href="#十四、字节码文件" class="headerlink" title="十四、字节码文件"></a>十四、字节码文件</h2><h3 id="1-字节码文件的跨平台性-了解"><a href="#1-字节码文件的跨平台性-了解" class="headerlink" title="1 字节码文件的跨平台性(了解)"></a>1 字节码文件的跨平台性(了解)</h3><ul>
<li><p>①. Java语言：跨平台的语言</p>
<ul>
<li>当Java源代码成功编译为字节码后，如果想在不同的平台上运行，则无须再次编译</li>
</ul>
<ul>
<li>这个优势不再那么吸引人了。Python PHP perl ruby lisp等有强大的解释器</li>
<li>跨平台似乎已经快成为一门语言必须的特征</li>
</ul>
</li>
<li><p>②. Java虚拟机：跨语言的平台：<br>( Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 想要让一个Java程序正确地运行在JVM中，Java源码就必须要编译为符合JVM规范的字节码</p>
<ul>
<li><strong>前端编译器的主要任务`</strong> 就是负责将符合Java语言规范的Java代码转换为符合JVM规范的字节码文件</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
</ul>
<ul>
<li>javac编译器在将Java源码编译为一个有效的字节码文件过程中经历了4个步骤：分别是词法解析、语法解析、语义解析以及生成字节码<img src="https://img-blog.csdnimg.cn/20201004103706891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210125201559980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h3 id="2-Java的前端编译器-了解"><a href="#2-Java的前端编译器-了解" class="headerlink" title="2  Java的前端编译器(了解)"></a>2  Java的前端编译器(了解)</h3><ul>
<li>①. 前端编译器 vs 后端编译器<br><img src="https://img-blog.csdnimg.cn/20210125202110613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 图解：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103842512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-透过字节码指令看代码细节"><a href="#3-透过字节码指令看代码细节" class="headerlink" title="3 透过字节码指令看代码细节"></a>3 透过字节码指令看代码细节</h3><ul>
<li>①. Integer：透过字节码可以看出，当Integer的范围在-128 - +127 之间会在数组中直接拿取数值，超过这个范围会重新new对象</li>
</ul>
<pre><code class="java">public class IntegerTest &#123;
    public static void main(String[] args) &#123;

        /*
        * 透过字节码可以看出，当Integer的范围在-128 - +127 之间会在数组中直接拿取数值
        * 超过这个范围会重新new对象
        * */
        Integer x = 5;
        int y = 5;
        System.out.println(x == y);

        Integer i1 = 10;
        Integer i2 = 10;
        System.out.println(i1 == i2);//true

        Integer i3 = 128;
        Integer i4 = 128;
        System.out.println(i3 == i4);//false
    &#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210518210300611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. 在父类中调用方法，如果子类有重写，那么调用的是子类的方法，如代码中的this.print( )<br>注意:这里的this是指的 new son( )</li>
</ul>
<pre><code class="java">/*
成员变量（非静态的）的赋值过程：
 ① 默认初始化 -
 ② 显式初始化 /代码块中初始化 -
 ③ 构造器中初始化 -
 ④ 有了对象之后，可以“对象.属性”或&quot;对象.方法&quot;
 的方式对成员变量进行赋值。
 */
class Father &#123;
    int x = 10;
    public Father() &#123;
        this.print();
        x = 20;
    &#125;
    public void print() &#123;
        System.out.println(&quot;Father.x = &quot; + x);
    &#125;
&#125;
class Son extends Father &#123;
    int x = 30;
//    float x = 30.1F;
    public Son() &#123;
        this.print();
        x = 40;
    &#125;
    public void print() &#123;
        System.out.println(&quot;Son.x = &quot; + x);
    &#125;
&#125;

public class SonTest &#123;
    public static void main(String[] args) &#123;
        Father f = new Son();
        System.out.println(f.x);//编译看左边，执行也看左边
    &#125;
&#125;
    /*
     son.x=0 
     son.x=30
     20
    */
</code></pre>
<h3 id="4-如何解读供虚拟机解释执行的二进制字节码？"><a href="#4-如何解读供虚拟机解释执行的二进制字节码？" class="headerlink" title="4 如何解读供虚拟机解释执行的二进制字节码？"></a>4 如何解读供虚拟机解释执行的二进制字节码？</h3><ul>
<li>①. 一个一个二进制的看。这里用到的是Notepad++，需要安装一个HEX-Editor插件，或者使用Binary Viewer<br><img src="https://img-blog.csdnimg.cn/20210501170009655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 使用javap指令：jdk自带的反解析工具</li>
<li>③. 使用IDEA插件：jclasslib 或jclasslib bytecode viewer客户端工具(可视化更好)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501170050355.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021050117005648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-什么是字节码指令"><a href="#5-什么是字节码指令" class="headerlink" title="5 什么是字节码指令"></a>5 什么是字节码指令</h3><ul>
<li>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码<br>比如:操作码(操作数)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021050121242727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="十五、Class文件结构"><a href="#十五、Class文件结构" class="headerlink" title="十五、Class文件结构"></a>十五、Class文件结构</h2><p><img src="https://img-blog.csdnimg.cn/20210502100311471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-class文件结构细节概述"><a href="#1-class文件结构细节概述" class="headerlink" title="1  class文件结构细节概述"></a>1  class文件结构细节概述</h3><ul>
<li>①. Class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的</li>
<li>②. Class 文件格式采用一种类似于 C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</li>
</ul>
<ol>
<li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。 由于表没有固定长度，所以通常会在其前面加上个数说明</li>
</ol>
<pre><code class="java">public class Demo &#123;
    private int num = 1;

    public int add()&#123;
        num = num + 2;
        return num;

    &#125;
&#125;
123456789
</code></pre>
<ul>
<li>③. Class文件的总体结构如下<br>(魔数、Class文件版本、常量池、访问标识(或标志)、索引，父类索引，接口索引集合、字段表集合、方法表集合、属性表集合)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501213605574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210501213837208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-class文件的魔数是什么"><a href="#2-class文件的魔数是什么" class="headerlink" title="2  class文件的魔数是什么"></a>2  class文件的魔数是什么</h3><ul>
<li>①. 每个Class文件开头的4个字节的无符号整数称为魔数(Magic Number)</li>
<li>②. 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符</li>
<li>③. 魔数值固定为0xCAFEBABE。不会改变</li>
<li>④. 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：<br><img src="https://img-blog.csdnimg.cn/20210501214023654.png" alt="在这里插入图片描述"></li>
<li>⑤. 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</li>
</ul>
<h3 id="3-如何确保高版本的JVM可执行低版本的class文件？"><a href="#3-如何确保高版本的JVM可执行低版本的class文件？" class="headerlink" title="3  如何确保高版本的JVM可执行低版本的class文件？"></a>3  如何确保高版本的JVM可执行低版本的class文件？</h3><ul>
<li>①. 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常(向下兼容)</li>
<li>②. class文件版本号:紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本major_version</li>
<li>③. 它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m</li>
<li>④. 版本号和Java编译器的对应关系如下表：<br>Java 的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。<br><img src="https://img-blog.csdnimg.cn/20210501214355404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-常量池-class文件的基石"><a href="#4-常量池-class文件的基石" class="headerlink" title="4  常量池(class文件的基石)"></a>4  常量池(class文件的基石)</h3><h4 id="4-1-什么是常量池？"><a href="#4-1-什么是常量池？" class="headerlink" title="4.1 什么是常量池？"></a>4.1 什么是常量池？</h4><ul>
<li>①. 常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一</li>
<li>②. 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501215523194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-2-常量池计数器"><a href="#4-2-常量池计数器" class="headerlink" title="4.2 常量池计数器"></a>4.2 常量池计数器</h4><ul>
<li>①. 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
</ul>
<ul>
<li>②. 常量池容量计数值(u2类型):从1开始，表示常量池中有多少项常量。即constant_pool_ count=1表示常量池中有0个常量项</li>
<li>③. Demo的值为：其值为0x0016，掐指一算，也就是22。需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？<br>(通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示)<br><img src="https://img-blog.csdnimg.cn/20210501214923109.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="4-3-常量池表"><a href="#4-3-常量池表" class="headerlink" title="4.3 常量池表"></a>4.3 常量池表</h4><ul>
<li>①. constant_pool是一种表结构，以 1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</li>
<li>②. 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）<br><img src="https://img-blog.csdnimg.cn/20210501215620699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记,用于确定该项的格式,这个字节称为tag byte (标记字节、标签字节)<br><img src="https://img-blog.csdnimg.cn/20210501215300311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="4-4-字面量和符号引用"><a href="#4-4-字面量和符号引用" class="headerlink" title="4.4 字面量和符号引用"></a>4.4 字面量和符号引用</h4><ul>
<li><p>①. 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：<br><img src="https://img-blog.csdnimg.cn/20210501215732234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li></li>
<li><p>②. 全限定名<br>(com/xiaozhi/test/Demo这个就是类的全限定名，仅仅是把包名的”.“替换成”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束)</p>
</li>
<li><p>③. 简单名称<br>(简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num)</p>
</li>
<li><p>③. 描述符</p>
<ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表: (数据类型：基本数据类型 、 引用数据类型))</p>
</li>
<li><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如：<br>方法java.lang.String toString()的描述符为() Ljava/lang/String;，<br>方法int abc(int[] x��� int y)的描述符为([II) I。<br><img src="https://img-blog.csdnimg.cn/20210501215943281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-符号引用、直接引用的理解？"><a href="#4-5-符号引用、直接引用的理解？" class="headerlink" title="4.5  符号引用、直接引用的理解？"></a>4.5  符号引用、直接引用的理解？</h4><ul>
<li>①. 虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行起来时，需要从常量池中获得对应的符号引用，再在类加载过程中(初始化阶段)将其替换直接引用，并翻译到具体的内存地址中</li>
<li>②. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</li>
<li>③. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<h4 id="4-6-常量类型和结构"><a href="#4-6-常量类型和结构" class="headerlink" title="4.6  常量类型和结构"></a>4.6  常量类型和结构</h4><ul>
<li>①. 常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021050122084756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210501220852757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. 这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型</li>
<li>③. 这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_ Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度</li>
</ul>
<h3 id="5-访问标识-或标志"><a href="#5-访问标识-或标志" class="headerlink" title="5 访问标识(或标志)"></a>5 访问标识(或标志)</h3><ul>
<li>①. 在常量池后，紧跟着访问标记。该标记使用两个字节表示(u2)，用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口;是否定义为 public 类型;是否定义为 abstract 类型;如果是类的话，是否被声明为 final 等。各种访问标记如下所示：<img src="https://img-blog.csdnimg.cn/20210502101832506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210502102035820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 类的访问权限通常为 ACC_ 开头的常量。</li>
<li>③. 每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL</li>
<li>④. 带有ACC_INTERFACE标志的calss文件表示的是接口而不是类，反之则表示的是类而不是接口</li>
</ul>
<ol>
<li>如果一个class文件设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志</li>
<li>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表除了ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置</li>
</ol>
<ul>
<li>⑤. ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于JavaSE8及后续版本来说，无论class文件中这个标志实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个Class文件均设置了ACC_SUPER标志</li>
<li>⑥. ACC_SYNTHETIC标志意味着该类或接口由编译器生产的，而不是由源代码生成的</li>
<li>⑦. 注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志</li>
<li>⑧. ACC_ENUM标志标明该类或其父类为枚举类型</li>
</ul>
<h3 id="6-类索引-父类索引-接口索引集合"><a href="#6-类索引-父类索引-接口索引集合" class="headerlink" title="6 类索引|父类索引|接口索引集合"></a>6 类索引|父类索引|接口索引集合</h3><ul>
<li>①. 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：(这三项数据来确定这个类的继承关系)</li>
</ul>
<ol>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的Java类都有父类，因此除了java.lang.Object 外，所有Java类的父类索引都不为 0</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将 implements语句(如果这个类本身是一个接口，则应当是 extends 语句)后的接口顺序从左到右排列在接口索引集合中</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210502104756773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. this_class(类索引)<br>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com/xiaozhi/Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口</li>
<li>③. super_class(父类索引)</li>
</ul>
<ol>
<li>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个</li>
<li>superclass指向的父类不能是final。</li>
</ol>
<ul>
<li>④. interfaces_count (接口计数器):interfaces_count项的值表示当前类或接口的直接超接口数量。</li>
<li>⑤. interfaces <code>[ ](接口索引集合)</code><br>(interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。 每个成员 interfaces[i]必须为 CONSTANT_Class_info结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210502220333243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="7-字段表集合"><a href="#7-字段表集合" class="headerlink" title="7 字段表集合"></a>7 字段表集合</h3><ul>
<li>①. 用于描述接口或类中声明的变量。字段(field)包括 类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量(local variables)</li>
<li>②. 字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述</li>
<li>③. 它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符(public、private或protected)、是类变量还是实例变量(static修饰符)、是否是常量(final修饰符)等</li>
<li>④. 注意事项</li>
</ul>
<ol>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段</li>
<li>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的</li>
</ol>
<ul>
<li>⑤. 字段计数器<br>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示</li>
<li>⑥. 字段表<br><img src="https://img-blog.csdnimg.cn/20210502221818870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. 字段表访问标识<br>(我们知道,一个字段可以被各个关键字去修饰,比如:作用域修饰符(public、private、protected)、static修饰符、final修饰符、volatile修饰符等等。因此,其可像类的访问标志那样,使用一些标志来标记字段。字段的访问标志有如下这些)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210502222218240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="8-方法表集合"><a href="#8-方法表集合" class="headerlink" title="8 方法表集合"></a>8 方法表集合</h3><ul>
<li>①. 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private或protected)，方法的返回值类型以及方法的参数信息等</li>
<li>②. 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来</li>
<li>③. 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如：类(接口)初始化方法()和实例初始化方法())</li>
<li>④. 方法计数器methods_count<br>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示<br>methods 表中每个成员都是一个method_info结构</li>
<li>⑤. 方法表<br><img src="https://img-blog.csdnimg.cn/20210502223428790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. 方法表访问标志<br>(跟字段表一样,方法表也有访问标志,而且他们的标志有部分相同,部分则不同,方法表具体访问标志如下:)<br><img src="https://img-blog.csdnimg.cn/20210502223746347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-属性表集合"><a href="#9-属性表集合" class="headerlink" title="9 属性表集合"></a>9 属性表集合</h3><ul>
<li>①. 属性计数器:attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构</li>
<li>②. 属性的通用格式<br><img src="https://img-blog.csdnimg.cn/20210502224735486.png" alt="在这里插入图片描述"></li>
<li>③. Code属性<br>(Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了)<br>Code属性表的结构，如下图：<br><img src="https://img-blog.csdnimg.cn/20210502224534906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>④. LineNumberTable属性</li>
</ul>
<ol>
<li>LineNumberTable 属性是可选变长属性，位于 Code结构的属性表</li>
<li>LineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数(start_pc，即字节码行号;line_number，即Java源代码行号)</li>
<li>在 Code 属性的属性表中,LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一 一对应<br><img src="https://img-blog.csdnimg.cn/20210502225024359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>⑤.LocalVariableTable属性<br>(LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中,LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVa riableTable 属性)<br><img src="https://img-blog.csdnimg.cn/20210502225140662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. SourceFile属性<br><img src="https://img-blog.csdnimg.cn/20210502225217779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="10-IDEA中集成jclasslib说明Class文件信息"><a href="#10-IDEA中集成jclasslib说明Class文件信息" class="headerlink" title="10 IDEA中集成jclasslib说明Class文件信息"></a>10 IDEA中集成jclasslib说明Class文件信息</h3><h4 id="10-1-Class文件详解"><a href="#10-1-Class文件详解" class="headerlink" title="10.1 Class文件详解"></a>10.1 Class文件详解</h4><p><img src="https://img-blog.csdnimg.cn/20210502225845779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-2-方法表集合"><a href="#10-2-方法表集合" class="headerlink" title="10.2  方法表集合"></a>10.2  方法表集合</h4><p><img src="https://img-blog.csdnimg.cn/2020050510515537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-3-code属性"><a href="#10-3-code属性" class="headerlink" title="10.3 code属性"></a>10.3 code属性</h4><p><img src="https://img-blog.csdnimg.cn/20200505105323929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-4-LineNumberTable、LocalVariableTable"><a href="#10-4-LineNumberTable、LocalVariableTable" class="headerlink" title="10.4 LineNumberTable、LocalVariableTable"></a>10.4 LineNumberTable、LocalVariableTable</h4><p><img src="https://img-blog.csdnimg.cn/20200505105818394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-5-SourceFile属性"><a href="#10-5-SourceFile属性" class="headerlink" title="10.5 SourceFile属性"></a>10.5 SourceFile属性</h4><p><img src="https://img-blog.csdnimg.cn/20210502230349399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="十六、类的生命周期"><a href="#十六、类的生命周期" class="headerlink" title="十六、类的生命周期"></a>十六、类的生命周期</h2><h3 id="1-说说类加载分几步？"><a href="#1-说说类加载分几步？" class="headerlink" title="1 说说类加载分几步？"></a>1 说说类加载分几步？</h3><ul>
<li><p>①. 按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段:</p>
<ul>
<li>第一过程的加载(loading)也称为装载</li>
<li>验证、准备、解析3个部分统称为链接(Linking)</li>
<li>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载<br><img src="https://img-blog.csdnimg.cn/20210504185259863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>②. 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载、类的链接、类的初始化这三个步骤来对类进行初始化。如果不出现意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者初始化<br><img src="https://img-blog.csdnimg.cn/20200216215157575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>③. 从程序中类的使用过程看:<br><img src="https://img-blog.csdnimg.cn/20210504185409460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="2-过程一-类的加载-Loading"><a href="#2-过程一-类的加载-Loading" class="headerlink" title="2 过程一:类的加载(Loading)"></a>2 过程一:类的加载(Loading)</h3><ul>
<li><p>①. 类的加载指的是将类的.class文件中的二进制数据读取到内存中，存放在运行时数据区的方法区中，并创建一个大的Java.lang.Class对象，用来封装方法区内的数据结构 在加载类时，Java虚拟机必须完成以下3件事情:</p>
<ul>
<li><p>通过类的全名，获取类的二进制数据流</p>
</li>
<li><p>解析类的二进制数据流为方法区内的数据结构(Java类模型)</p>
</li>
<li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口<br><img src="https://img-blog.csdnimg.cn/20210504190930335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 对于①的说明，我们也可以这样去理解:所谓装载(加载)，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象<br>(所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用)</p>
</li>
<li><p>③. 对于类的二进制数据流，虚拟机可以通过多种途径产生或获得(只要所读取的字节码符合JVM规范即可)</p>
<ul>
<li><p>虚拟机可能通过文件系统读入一个class后缀的文件(最常见)</p>
</li>
<li><p>读入jar、zip等归档数据包，提取类文件。</p>
</li>
<li><p>事先存放在数据库中的类的二进制数据</p>
</li>
<li><p>使用类似于HTTP之类的协议通过网络进行加载</p>
</li>
<li><p>在运行时生成一段Class的二进制信息等</p>
</li>
</ul>
</li>
<li><p>④. Class实例的位置<br>(类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象)</p>
</li>
</ul>
<h3 id="3-过程二-链接-Linking"><a href="#3-过程二-链接-Linking" class="headerlink" title="3 过程二:链接(Linking)"></a>3 过程二:链接(Linking)</h3><ul>
<li><p>①. 验证:确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</p>
<ul>
<li><p>目的是确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p>
</li>
<li><p>主要包括四种验证:文件格式验证，元数据验证，字节码验证，符号引用验证</p>
</li>
<li><p>格式检查:是否以魔术oxCAFEBABE开头，主版本和副版本是否在当前Java虚拟机的支持范围内，数据中每一项是否都拥有正确的长度等<br><img src="https://img-blog.csdnimg.cn/20210504191300443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 准备(静态变量，不能是常量)</p>
<ul>
<li><p>为类变量分配内存并且设置该类变量的默认初始化值</p>
</li>
<li><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式赋值</p>
</li>
<li><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中</p>
</li>
<li><p>注意:Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值就是false<br><img src="https://img-blog.csdnimg.cn/20210504192223337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>③. 解析:将常量池中的符号引号转换为直接引用的过程(简言之，将类、接口、字段和方法的符号引用转为直接引用)</p>
<ul>
<li>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行起来时，需要从常量池中获得对应的符号引用，再在类加载过程中(初始化阶段)将其替换直接引用，并翻译到具体的内存地址中</li>
</ul>
<ul>
<li><p>符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中</p>
</li>
<li><p>直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>
</li>
<li><p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>符号引号有:类和接口的权限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
<blockquote>
<p>解释什么是符号引号和直接引用?<br>(1). 教室里有个空的位子没坐人，座位上边牌子写着小明的座位(符号引用)，后来小明进来坐下去掉牌子(符号引用换成直接引用)<br>(2). 我们去做菜，看菜谱，步骤都是什么样的(这是符号引号)，当我们实际上去做，这个过程是直接引用<br>(3). 举例:输出操作System.out.println()对应的字节码:<br>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</p>
<p>以方法为例<img src="https://img-blog.csdnimg.cn/20210525215340991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p>
</blockquote>
<h3 id="4-过程三-初始化-Initialization"><a href="#4-过程三-初始化-Initialization" class="headerlink" title="4 过程三:初始化(Initialization)"></a>4 过程三:初始化(Initialization)</h3><ul>
<li>①. 为类变量赋予正确的初始化值</li>
<li>②. 初始化阶段就是执行类构造器方法&lt; clinit &gt;()的过程。此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码快中的语句合并而来</li>
</ul>
<pre><code class="java">public class ClassInitTest &#123;
    private  static int num=1; //类变量的赋值动作
    //静态代码快中的语句
    static&#123;
        num=2;
        number=20;
        System.out.println(num);
        //System.out.println(number); 报错:非法的前向引用
    &#125;
    //Linking之prepare: number=0 --&gt;initial:20--&gt;10
    private static int number=10;

    public static void main(String[] args) &#123;
        System.out.println(ClassInitTest.num);
        System.out.println(ClassInitTest.number);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210426221549496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 若该类具有父类，Jvm会保证子类的&lt; clinit &gt;() 执行前，父类的&lt; clinit &gt;() 已经执行完成。clinit 不同于类的构造方法(init) (由父及子，静态先行)</li>
</ul>
<pre><code class="java">public class ClinitTest1 &#123;
    static class Father&#123;
        public static int A=1;
        static&#123;
            A=2;
        &#125;
    &#125;
    static class Son extends Father&#123;
        public static int B=A;
    &#125;

    public static void main(String[] args) &#123;
        //这个输出2，则说明父类已经全部加载完毕
        System.out.println(Son.B);
    &#125;
&#125;
</code></pre>
<ul>
<li>④. Java编译器并不会为所有的类都产生<code>&lt;clinit&gt;()</code>初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<code>&lt;clinit&gt;()</code>方法？</li>
</ul>
<ol>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
<li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器，则在链接阶段)</li>
</ol>
<pre><code class="java">/**
 * @author TANGZHI
 * @create 2021-01-01 18:49
 * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法
 */
public class InitializationTest1 &#123;
    //场景1:对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法
    public int num = 1;
    //场景2:静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法
    public static int num1;
    //场景3:比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法
    public static final int num2 = 1;
&#125;
</code></pre>
<ul>
<li>⑤. static与final的搭配问题<br>(使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行)</li>
</ul>
<pre><code class="java">/**
 * @author TANGZHI
 * @create 2021-01-01 
 *
 * 说明:使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1:在链接阶段的准备环节赋值
 * 情况2:在初始化阶段&lt;clinit&gt;()中赋值
 * 结论:
 * 在链接阶段的准备环节赋值的情况:
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段&lt;clinit&gt;()中赋值的情况:
 * 排除上述的在准备环节赋值的情况之外的情况。
 * 最终结论:使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。
 */
public class InitializationTest2 &#123;
    public static int a = 1;//在初始化阶段&lt;clinit&gt;()中赋值
    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值

    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段&lt;clinit&gt;()中赋值
    public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段&lt;clinit&gt;()中赋值

    public static final String s0 = &quot;helloworld0&quot;;//在链接阶段的准备环节赋值
    public static final String s1 = new String(&quot;helloworld1&quot;);//在初始化阶段&lt;clinit&gt;()中赋值

    public static String s2 = &quot;helloworld2&quot;;
    public static final int NUM1 = new Random().nextInt(10);//在初始化阶段&lt;clinit&gt;()中赋值
&#125;
</code></pre>
<ul>
<li>⑥. clinit()的调用会死锁吗?</li>
</ul>
<ol>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕</li>
<li>正是因为函数<code>&lt;clinit&gt;()</code>带锁线程安全的，因此，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息</li>
</ol>
<pre><code class="typescript">package com.xiaozhi;

/**
 * @author TANGZHI
 * @create 2021-05-25
 */
class StaticA &#123;
    static &#123;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        try &#123;
            Class.forName(&quot;com.xiaozhi.StaticB&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;StaticA init OK&quot;);
    &#125;
&#125;

class StaticB &#123;
    static &#123;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        try &#123;
            Class.forName(&quot;com.xiaozhi.StaticA&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;StaticB init OK&quot;);
    &#125;
&#125;

public class StaticDeadLockMain extends Thread &#123;
    private char flag;

    public StaticDeadLockMain(char flag) &#123;
        this.flag = flag;
        this.setName(&quot;Thread&quot; + flag);
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            Class.forName(&quot;com.xiaozhi.Static&quot; + flag);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(getName() + &quot; over&quot;);
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        StaticDeadLockMain loadA = new StaticDeadLockMain(&#39;A&#39;);
        loadA.start();
        StaticDeadLockMain loadB = new StaticDeadLockMain(&#39;B&#39;);
        loadB.start();
    &#125;
&#125;
</code></pre>
<h3 id="5-主动引用-触发在初始化阶段的Clinit方法"><a href="#5-主动引用-触发在初始化阶段的Clinit方法" class="headerlink" title="5 主动引用(触发在初始化阶段的Clinit方法)"></a>5 主动引用(触发在初始化阶段的Clinit方法)</h3><ul>
<li>①. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li>
<li>②. 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>③. 调用类的静态方法</li>
<li>④. 反射(比如:Class.forName(“com.xiaozhi.Test”))</li>
<li>⑤. 初始化一个子类(当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化)</li>
<li>⑥. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类</li>
<li>⑦. JDK7开始提供的动态语言支持<br>(涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)</li>
<li>⑧. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li>
</ul>
<pre><code class="java"># 注意，如果把A接口中的默认方法注释，那么就只输出:子类初始化......
输出:
CompareB的初始化
子类初始化.....
public class DemoB implements A&#123;
    static&#123;
        System.out.println(&quot;子类初始化......&quot;);
    &#125;
    public static void main(String[] args) &#123;

    &#125;
&#125;
interface A&#123;
    public static final Thread t = new Thread() &#123;
        &#123;
            System.out.println(&quot;CompareB的初始化&quot;);
        &#125;
    &#125;;
    default void method1()&#123;
        System.out.println(&quot;====&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="6-被动使用"><a href="#6-被动使用" class="headerlink" title="6 被动使用"></a>6 被动使用</h3><ul>
<li>①. 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。意味着没有<code>&lt;clinit&gt;()</code>的调用。</li>
<li>②. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
<li>③. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<br>当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>④. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</li>
<li>⑤. 通过数组定义类引用，不会触发此类的初始化</li>
</ul>
<pre><code class="typescript"># 这里不会进行初始化，因为相当于parent只开辟了空间，没赋值
Parent[]parent=new Parent[10];
</code></pre>
<h3 id="7-过程四-类的Using-使用"><a href="#7-过程四-类的Using-使用" class="headerlink" title="7 过程四:类的Using(使用)"></a>7 过程四:类的Using(使用)</h3><ul>
<li>①. 任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便”万事俱备，只欠东风”就等着开发者使用了</li>
<li>②. 开发人员可以在程序中访问和调用它的静态类成员信息(比如:静态字段、静态方法)或者使用new关键字为其创建对象实例</li>
</ul>
<h3 id="8-过程五-类的Unloading-卸载"><a href="#8-过程五-类的Unloading-卸载" class="headerlink" title="8 过程五:类的Unloading(卸载)"></a>8 过程五:类的Unloading(卸载)</h3><ul>
<li>①. 类、类的加载器、类的实例之间的引用关系</li>
</ul>
<ol>
<li>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系</li>
<li>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象<br><img src="https://img-blog.csdnimg.cn/20210504222427561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 方法区的垃圾回收</li>
</ul>
<ol>
<li>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li>
<li>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210504222534257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 类的卸载</li>
</ul>
<ol>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小</li>
<li>开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如:很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</li>
</ol>
<h2 id="十七、类的概述"><a href="#十七、类的概述" class="headerlink" title="十七、类的概述"></a>十七、类的概述</h2><h3 id="1-类的加载器"><a href="#1-类的加载器" class="headerlink" title="1 类的加载器"></a>1 类的加载器</h3><ul>
<li>①. ClassLoader的作用</li>
</ul>
<ol>
<li>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作、因此，ClassLoader在整个装载(加载)阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定</li>
<li>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而研发出来。但如今类加载器却在OSGI(热部署)、字节码加密解密领域大放异彩。这主要归功于Java虚拟机的设计者当初在设计类加载器的时候，并没有考虑将它绑定在Jvm内部，这样做的好处就是能够更加灵活和动态地执行类加载操作</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210507205510198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式(在日常开发以上两种方式一般会混合使用)</li>
</ul>
<ol>
<li>显式加载:指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象</li>
<li>隐式加载:则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。比如 new User()</li>
</ol>
<h3 id="2-类的加载器分类与测试"><a href="#2-类的加载器分类与测试" class="headerlink" title="2 类的加载器分类与测试"></a>2 类的加载器分类与测试</h3><h4 id="2-1-类加载器的介绍"><a href="#2-1-类加载器的介绍" class="headerlink" title="2.1 类加载器的介绍"></a>2.1 类加载器的介绍</h4><ul>
<li>①. JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)</li>
<li>②. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范并没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li>
<li>③. 无论类加载器的类型如何划分，在程序中我们常见的类加载器如下所示:<br>除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器</li>
<li><img src="https://img-blog.csdnimg.cn/20210426223104306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191207090719392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210427210730635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-2-启动-引导-类加载器-Bootstrap"><a href="#2-2-启动-引导-类加载器-Bootstrap" class="headerlink" title="2.2 启动(引导)类加载器 Bootstrap"></a>2.2 启动(引导)类加载器 Bootstrap</h4><ul>
<li>①. 这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
<li>②. 它用来加载Java的核心类库(JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容)，用于提供JVM自身需要的类(String类就是使用的这个类加载器)</li>
<li>③. 由于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
<li>④. 并不继承自java.lang.ClassLoader，没有父加载器</li>
<li>⑤. 加载扩展类和应用程序类加载器，并指定为他们的父类加载器<br><img src="https://img-blog.csdnimg.cn/20210507212157768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="2-3-扩展类加载器-Extension"><a href="#2-3-扩展类加载器-Extension" class="headerlink" title="2.3 扩展类加载器 Extension"></a>2.3 扩展类加载器 Extension</h4><ul>
<li>①. Java语言编写，由sum.music.Launcher$ExtClassLoader实现</li>
<li>②. 派生于ClassLoader类，父类加载器为启动类加载器</li>
<li>③. 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载<br><img src="https://img-blog.csdnimg.cn/2021050721243536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="2-4-应用程序-系统-类加载器-AppClassLoader"><a href="#2-4-应用程序-系统-类加载器-AppClassLoader" class="headerlink" title="2.4 应用程序(系统)类加载器 AppClassLoader"></a>2.4 应用程序(系统)类加载器 AppClassLoader</h4><ul>
<li>①. java语言编写，由sum.misc.Launcher$AppClassLoader实现</li>
<li>②. 派生于ClassLoader类，父类加载器为扩展类加载器</li>
<li>③. 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>④. 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>⑤. 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<h4 id="2-5-用户自定义类加载器"><a href="#2-5-用户自定义类加载器" class="headerlink" title="2.5 用户自定义类加载器"></a>2.5 用户自定义类加载器</h4><ul>
<li>①. 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们换可以自定义类加载器，来定制类的加载方式(自定义类加载器通常需要继承于 ClassLoader)</li>
<li>②. 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源</li>
<li>③. 自定义 ClassLoader 的子类时候，我们常见的会有两种做法:</li>
</ul>
<ol>
<li>重写loadClass()方法(不推荐，这个方法会保证类的双亲委派机制)</li>
<li>重写findClass()方法 –&gt;推荐</li>
<li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
</ol>
<ul>
<li>④. 如何手写一个简单的自定义加载器</li>
</ul>
<pre><code class="java">public class UserClassLoader extends ClassLoader &#123;
    private String rootDir;

    public UserClassLoader(String rootDir) &#123;
        this.rootDir = rootDir;
    &#125;

    /**
     * 编写findClass方法的逻辑
     */
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;
        // 获取类的class文件字节数组
        byte[] classData = getClassData(name);
        if (classData == null) &#123;
            throw new ClassNotFoundException();
        &#125; else &#123;
            //直接生成class对象
            return defineClass(name， classData， 0， classData.length);
        &#125;
    &#125;

    /**
     * 编写获取class文件并转换为字节码流的逻辑 * @param className * @return
     */
    private byte[] getClassData(String className) &#123;
        // 读取类文件的字节
        String path = classNameToPath(className);
        try &#123;
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len = 0;
            // 读取类文件的字节码
            while ((len = ins.read(buffer)) != -1) &#123;
                baos.write(buffer， 0， len);
            &#125;
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    /**
     * 类文件的完全路径
     */
    private String classNameToPath(String className) &#123;
        return rootDir + &quot;\\&quot; + className.replace(&#39;.&#39;， &#39;\\&#39;) + &quot;.class&quot;;
    &#125;

    public static void main(String[] args) &#123;
        String rootDir = &quot;D:\\code\\workspace_teach\\JVMdachang210416\\chapter02_classload\\src\\&quot;;

        try &#123;
            //创建自定义的类的加载器1
            UserClassLoader loader1 = new UserClassLoader(rootDir);
            Class clazz1 = loader1.findClass(&quot;com.xiaozhi.java3.User&quot;);

            //创建自定义的类的加载器2
            UserClassLoader loader2 = new UserClassLoader(rootDir);
            Class clazz2 = loader2.findClass(&quot;com.xiaozhi.java3.User&quot;);
            //clazz1与clazz2对应了不同的类模板结构
            System.out.println(clazz1 == clazz2); 
            System.out.println(clazz1.getClassLoader());
            System.out.println(clazz2.getClassLoader());
            
            Class clazz3 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.xiaozhi.java3.User&quot;);
            System.out.println(clazz3.getClassLoader());
            System.out.println(clazz1.getClassLoader().getParent());

        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="2-6-测试不同的类加载器"><a href="#2-6-测试不同的类加载器" class="headerlink" title="2.6 测试不同的类加载器"></a>2.6 测试不同的类加载器</h4><ul>
<li>①. 每个Class对象都会包含一个定义它的ClassLoader的一个引用</li>
<li>②. 获取ClassLoader的途径</li>
</ul>
<pre><code class="handlebars">    (1). 获得当前类的ClassLoader
    clazz.getClassLoader()
    (2). 获得当前线程上下文的ClassLoader(系统类加载器)
    Thread.currentThread().getContextClassLoader()
    (3). 获得系统的ClassLoader
    ClassLoader.getSystemClassLoader()
</code></pre>
<ul>
<li>③. 站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值</li>
<li>④. 数组类的Class对象，不是由类加载器去加载的，而是在Java运行期JVM根据需要自动创建的。对于数组的类加载器来说，是通过Class.getClassLoader()返回的，与数组中元素类型的类加载器是一样的;如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的(基本数据类型由虚拟机预先定义)</li>
</ul>
<pre><code class="java">public class ClassLoaderDemo &#123;
    public static void main(String[] args) &#123;
        ClassLoader classloader1 = ClassLoader.getSystemClassLoader();
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(classloader1);
        //获取到扩展类加载器
        //sun.misc.Launcher$ExtClassLoader@424c0bc4
        System.out.println(classloader1.getParent());
        //获取到引导类加载器 null
        System.out.println(classloader1.getParent().getParent());
        //获取系统的ClassLoader
        ClassLoader classloader2 = Thread.currentThread().getContextClassLoader();
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(classloader2);
        String[]strArr=new String[10];
        ClassLoader classLoader3 = strArr.getClass().getClassLoader();
        //null，表示使用的是引导类加载器
        System.out.println(classLoader3);
        ClassLoaderDemo[]refArr=new ClassLoaderDemo[10];
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(refArr.getClass().getClassLoader());
        int[]intArr=new int[10];
        //null，如果数组的元素类型是基本数据类型，数组类是没有类加载器的
        System.out.println(intArr.getClass().getClassLoader());
    &#125;
&#125;
</code></pre>
<h3 id="3-ClassLoader源码剖析"><a href="#3-ClassLoader源码剖析" class="headerlink" title="3 ClassLoader源码剖析"></a>3 ClassLoader源码剖析</h3><h4 id="3-1-ClassLoader与现有类加载器的关系"><a href="#3-1-ClassLoader与现有类加载器的关系" class="headerlink" title="3.1 ClassLoader与现有类加载器的关系"></a>3.1 ClassLoader与现有类加载器的关系</h4><ul>
<li>①. ClassLoader是一个抽象类。如果我们给定了一个类的二进制名称，类加载器应尝试去定位或生成构成定义类的数据。一种典型的策略是将给定的二进制名称转换为文件名，然后去文件系统中读取这个文件名所对应的class文件</li>
<li>②. ClassLoader与现有类加载器的关系<br><img src="https://img-blog.csdnimg.cn/20210509172614178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式</li>
<li>④. AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</li>
</ul>
<h4 id="3-2-抽象类ClassLoader的主要方法-内部没有抽象方法"><a href="#3-2-抽象类ClassLoader的主要方法-内部没有抽象方法" class="headerlink" title="3.2 抽象类ClassLoader的主要方法(内部没有抽象方法)"></a>3.2 抽象类ClassLoader的主要方法(内部没有抽象方法)</h4><ul>
<li>①. public final ClassLoader getParent():返回该类加载器的超类加载器</li>
<li>②. public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException<br>(加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNot FoundException 异常。该方法中的逻辑就是双亲委派模式的实现)</li>
<li>③. protected Class&lt;?&gt; findClass (String name) throws ClassNotFoundException<br>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</li>
<li>④. protected final Class&lt;?&gt; defineClass(String name， byte[] b， int off， int len)<br>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</li>
<li>⑤. protected final void resolveClass(Class&lt;?&gt; c)<br>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用</li>
<li>⑥. 源码解析Classloader方法</li>
</ul>
<pre><code class="java"> 测试代码:
 ClassLoader.getSystemClassLoader().loadClass(&quot;com.xiaozhi.java.User&quot;);
 //resolve==true，加载class的同时需要进行解析操作
 protected Class&lt;?&gt; loadClass(String name， boolean resolve) 
        throws ClassNotFoundException
    &#123;
        //同步操作，保证只能加载一次
        synchronized (getClassLoadingLock(name)) &#123;
            // 在缓存中判断是否已经加载同名的类
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) &#123;
                long t0 = System.nanoTime();
                try &#123;
                    //获取当前类的父类加载器
                    if (parent != null) &#123;
                        //如果存在父类加载器，则调用父类加载器进行类的加载(双亲委派机制)
                        c = parent.loadClass(name， false);
                    &#125; else &#123;
                        //parent==null 父类加载器是引导类加载器
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; catch (ClassNotFoundException e) &#123;
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                &#125;
                // 当前类的加载器的父类加载器未加载此类 or 当前类的加载器未加载此类
                if (c == null) &#123;
                    // 调用当前classloader的findClass
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                &#125;
            &#125;
            //是否进行解析操作
            if (resolve) &#123;
                resolveClass(c);
            &#125;
            return c;
        &#125;
    &#125;
</code></pre>
<h4 id="3-3-SecureClassLoader与URLClassLoader"><a href="#3-3-SecureClassLoader与URLClassLoader" class="headerlink" title="3.3 SecureClassLoader与URLClassLoader"></a>3.3 SecureClassLoader与URLClassLoader</h4><ul>
<li>①. 接着SecureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联</li>
<li>②. 前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<h4 id="3-4-Class-forName-与ClassLoader-loadClass-对比"><a href="#3-4-Class-forName-与ClassLoader-loadClass-对比" class="headerlink" title="3.4 Class.forName()与ClassLoader.loadClass()对比"></a>3.4 Class.forName()与ClassLoader.loadClass()对比</h4><ul>
<li>①. Class.forName():是一个静态方法，最常用的是Class.forName(String className);根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如:Class.forName(“com.atguigu.java.HelloWorld”);</li>
<li>②. ClassLoader.loadClass():这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。</li>
</ul>
<h3 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4 双亲委派机制"></a>4 双亲委派机制</h3><ul>
<li>①. 工作原理</li>
</ul>
<ol>
<li>如果一个类加载收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>
<li>如果父类的加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式<br><img src="https://img-blog.csdnimg.cn/20210426224243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 本质(规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载)<br><img src="https://img-blog.csdnimg.cn/20210509161013261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 源码分析(双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下)</li>
</ul>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name， false)接口进行加载</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lan g.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
<li>双亲委派的模型就隐藏在这第2和第3步中</li>
</ol>
<ul>
<li>④. 双亲委派机制优势:</li>
</ul>
<ol>
<li>避免类的重复加载，确保一个类的全局唯一性(当父ClassLoader已经加载了该类的时候，就没有必要子ClassLoader再加载一次)</li>
<li>保护程序安全，防止核心API被随意篡改<br>(自定义类:java.lang.String | java.lang.ShkStart)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210426224550346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 双亲委托模式的弊端<br>(检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类)</li>
<li>⑥. 结论(由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法)</li>
<li>⑦. 破坏双亲委派机制及举例</li>
</ul>
<ol>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代</li>
<li>第二次破坏双亲委派机制:线程上下文类加载器(ClassLoader.getSystemClassLoader( ))</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换(Hot Swap)、模块热部署(Hot Deployment)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210509174051199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5 沙箱安全机制"></a>5 沙箱安全机制</h3><ul>
<li>①. 如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制，启动加载器会加载java核心类库的String类(BootStrap启动类加载器只加载包名为java、javax、sun等开头的类)，而核心类库中的String并没有main方法<br><img src="https://img-blog.csdnimg.cn/20210426224550346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 自定义String类，但是在加载子弟敬意String类的时候回率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制</li>
<li>③. 沙箱安全机制作用:</li>
</ul>
<ol>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ol>
<ul>
<li>④. JDK1.6时期，当前最新的安全机制实现，则引入了域(Domain)的概念<br>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型(jdk1.6)<br><img src="https://img-blog.csdnimg.cn/2021050917442854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="十八、tomcat打破双亲委派制度"><a href="#十八、tomcat打破双亲委派制度" class="headerlink" title="十八、tomcat打破双亲委派制度"></a>十八、tomcat打破双亲委派制度</h2><h3 id="1-Tomcat类加载机制"><a href="#1-Tomcat类加载机制" class="headerlink" title="1 Tomcat类加载机制"></a>1 Tomcat类加载机制</h3><ul>
<li>①. 可以看到，在原来的 JVM 的类加载机制上面，Tomcat 新增了几个类加载器，包括 3 个基础类加载器和每个 Web 应用的类加载器。3个基础类加载器在 conf/catalina.properties 中进行配置:</li>
</ul>
<pre><code class="typescript">common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;，&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;，&quot;$&#123;catalina.home&#125;/lib&quot;，&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;
server.loader=
shared.loader=
</code></pre>
<ul>
<li>②.Common:以应用类加载器为父类，是Tomcat顶层的公用类加载器，其路径由conf/catalina.pr operties中的common.loader指定，默认指向${catalina.home}/lib下的包</li>
<li>③. Catalina:Tomcat容器私有的类加载器，加载路径中的class对于Webapp不 可见，其路径由server.loader指定，默认为空，此时Tomcat使用Common类加载器加载应用服务器</li>
<li>④. Shared:以Common类加载器为父类，是所有Web应用的父类加载器，其路径由shared.loader指定，默认为空，此时Tomcat使用Common类加载器作为Web应用的父加载器</li>
<li>⑤. Web应用:以Shared类加载器为父类，加载/WEB-INF/classes目录下的未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包，该类加载器只对当前Web应用可见，对其他Web应用均不可见</li>
<li>⑥. Tomcat8 和 Tomcat6比较大的区别是:<br>Tomcat8可以通过配置 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code>表示遵循双亲委派机制</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210529222814729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-Tomcat执行顺序"><a href="#2-Tomcat执行顺序" class="headerlink" title="2 Tomcat执行顺序"></a>2 Tomcat执行顺序</h3><ul>
<li>①. 使用bootstrap引导类加载器加载</li>
<li>②. 使用system系统类加载器加载</li>
<li>③. 使用应用类加载器在WEB-INF/classes中加载</li>
<li>④. 使用应用类加载器在WEB-INF/lib中加载</li>
<li>⑤. 使用common类加载器在CATALINA_HOME/lib中加载</li>
<li>⑥.我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat违背了java推荐的双亲委派模型了吗？答案是:违背了。我们前面说过:双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。<br>很显然，tomcat不是这样实现，tomcat为了实现隔离性，没有遵守这个约定，每个webappClassLoad er加载自己的目录下的class文件，不会传递给父类加载器。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210529224034684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-ClassLoader的创建"><a href="#3-ClassLoader的创建" class="headerlink" title="3 ClassLoader的创建"></a>3 ClassLoader的创建</h3><ul>
<li>①. 加载器类图:<br><img src="https://img-blog.csdnimg.cn/20210529225641796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 先从 BootStrap 的main方法看起:<br>可以看到这里先判断了bootstrap是否为null，如果不为null直接把CatalinaClassLoader设置到了当前线程，如果为null下面是走到了init()方法</li>
</ul>
<pre><code class="java">public static void main(String args[]) &#123;
    synchronized (daemonLock) &#123;
        if (daemon == null) &#123;
            // Don&#39;t set daemon until init() has completed
            Bootstrap bootstrap = new Bootstrap();
            try &#123;
                bootstrap.init();
            &#125; catch (Throwable t) &#123;
                handleThrowable(t);
                t.printStackTrace();
                return;
            &#125;
            daemon = bootstrap;
        &#125; else &#123;
            // When running as a service the call to stop will be on a new
            // thread so make sure the correct class loader is used to
            // prevent a range of class not found exceptions.
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
        &#125;
        // 省略其余代码...
    &#125;
&#125;
</code></pre>
<ul>
<li>③. 接着这里看到了会调用 initClassLoaders() 方法进行类加载器的初始化，初始化完成后，同样会设置 Catalina ClassLoader到当前线程</li>
</ul>
<pre><code class="java">public void init() throws Exception &#123;
    // 初始化类加载器
    initClassLoaders();
    // 设置线程类加载器，将容器的加载器传入
    Thread.currentThread().setContextClassLoader(catalinaLoader);
    // 设置区安全类加载器
    SecurityClassLoad.securityClassLoad(catalinaLoader);
    // 省略其余代码...
&#125;
</code></pre>
<ul>
<li>④ .看到这里应该就清楚了，会创建三个ClassLoader:CommClassLoader，CatalinaClassLoader，SharedCla ssLoader，正好对应前面介绍的三个基础类加载器</li>
</ul>
<pre><code class="java">private void initClassLoaders() &#123;
    try &#123;
        commonLoader = createClassLoader(&quot;common&quot;， null);
        if (commonLoader == null) &#123;
            // no config file， default to this loader - we might be in a &#39;single&#39; env.
            commonLoader = this.getClass().getClassLoader();
        &#125;
        catalinaLoader = createClassLoader(&quot;server&quot;， commonLoader);
        sharedLoader = createClassLoader(&quot;shared&quot;， commonLoader);
    &#125; catch (Throwable t) &#123;
        handleThrowable(t);
        log.error(&quot;Class loader creation threw exception&quot;， t);
        System.exit(1);
    &#125;
&#125;
</code></pre>
<ul>
<li>⑤. 接着进入createClassLoader() 查看代码:<br>可以看到，这里加载的资源正好是我们刚才看到的配置文件conf/catalina.properties 中的 common.loader ，server.loader 和 shared.loader</li>
</ul>
<pre><code class="java">private ClassLoader createClassLoader(String name， ClassLoader parent)
    throws Exception &#123;

    String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;);
    if ((value == null) || (value.equals(&quot;&quot;)))
        return parent;
    value = replace(value);
    List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;();
    String[] repositoryPaths = getPaths(value);
    for (String repository : repositoryPaths) &#123;
        // Check for a JAR URL repository
        try &#123;
            @SuppressWarnings(&quot;unused&quot;)
            URL url = new URL(repository);
            repositories.add(new Repository(repository， RepositoryType.URL));
            continue;
        &#125; catch (MalformedURLException e) &#123;
            // Ignore
        &#125;
        // Local repository
        if (repository.endsWith(&quot;*.jar&quot;)) &#123;
            repository = repository.substring
                (0， repository.length() - &quot;*.jar&quot;.length());
            repositories.add(new Repository(repository， RepositoryType.GLOB));
        &#125; else if (repository.endsWith(&quot;.jar&quot;)) &#123;
            repositories.add(new Repository(repository， RepositoryType.JAR));
        &#125; else &#123;
            repositories.add(new Repository(repository， RepositoryType.DIR));
        &#125;
    &#125;

    return ClassLoaderFactory.createClassLoader(repositories， parent);
&#125;
</code></pre>
<h3 id="4-ClassLoader加载过程"><a href="#4-ClassLoader加载过程" class="headerlink" title="4 ClassLoader加载过程"></a>4 ClassLoader加载过程</h3><ul>
<li>①. 接打开 ParallelWebappClassLoader ，至于为啥不是看 WebappClassLoader ，从名字上就知道 ParallelW ebappClassLoader 是一个并行的 WebappClassLoader<br>然后看下 ParallelWebappClassLoader 的 loadclass 方法是在它的父类 WebappClassLoaderBase 中实现的</li>
</ul>
<pre><code class="typescript"> 1 public Class loadClass(String name， boolean resolve)
 2             throws ClassNotFoundException &#123;
 3         Class clazz = null;
 4         // (0) 先从自己的缓存中查找，有则返回，无则继续
 5         clazz = findLoadedClass0(name);
 6         if (clazz != null) &#123;
 7             if (resolve) resolveClass(clazz);            
 8             return (clazz);
 9         &#125;
10         // (0.1) 再从parent的缓存中查找
11         clazz = findLoadedClass(name);
12         if (clazz != null) &#123;
13             if (resolve) resolveClass(clazz);
14             return (clazz);
15         &#125;
16         // (0.2) 缓存中没有，则首先使用system类加载器来加载
17         clazz = system.loadClass(name);
18          if (clazz != null) &#123;
19              if (resolve) resolveClass(clazz);
20              return (clazz);
21          &#125;
22         //判断是否需要先让parent代理
23         boolean delegateLoad = delegate || filter(name);
24         // (1) 先让parent加载，通常delegateLoad == false，即这一步不会执行
25 
26         if (delegateLoad) &#123;
27             ClassLoader loader = parent;
28             if (loader == null)
29                 loader = system;
30             clazz = loader.loadClass(name);
31             if (clazz != null) &#123;
32                 if (resolve) resolveClass(clazz);
33                 return (clazz);
34             &#125;
35         &#125;
36         // (2) delegateLoad == false 或者 parent加载失败，调用自身的加载机制
37         clazz = findClass(name);
38         if (clazz != null) &#123;
39             if (resolve) resolveClass(clazz);
40             return (clazz);
41         &#125;
42         // (3) 自己加载失败，则请求parent代理加载
43 
44         if (!delegateLoad) &#123;
45             ClassLoader loader = parent;
46             if (loader == null)
47                 loader = system;
48             clazz = loader.loadClass(name);
49             if (clazz != null) &#123;
50                 return (clazz);
51             &#125;
52         &#125;
53         throw new ClassNotFoundException(name);
54     &#125;
</code></pre>
<ul>
<li>②. 总结如上源码:</li>
</ul>
<ol>
<li>先从缓存中加载(自己的缓存和父类中的缓存)</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载；</li>
<li>如果没有，则从当前类加载器加载(按照 WEB-INF/classes 、 WEB-INF/lib 的顺序)</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是 AppClassLoader 、 Common 、 Shared</li>
</ol>
<h3 id="5-Tomcat破坏双亲委派机制带来的面试题"><a href="#5-Tomcat破坏双亲委派机制带来的面试题" class="headerlink" title="5 Tomcat破坏双亲委派机制带来的面试题"></a>5 Tomcat破坏双亲委派机制带来的面试题</h3><ul>
<li>①. 既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？(阿里面试问题)<br>显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？<br>tomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader</li>
<li>②. 我们思考一下:Tomcat是个web容器，那么它要解决什么问题？</li>
</ul>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？所以，web容器需要支持jsp修改后不用重启。</li>
</ol>
<ul>
<li>③. Tomcat如果使用默认的类加载机制行不行？<br>答案是不行的。为什么？我们看:<br>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。<br>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。<br>第三个问题和第一个问题一样。<br>第四个问题，我们想我们要怎么实现jsp文件的热替换，jsp文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</li>
<li>④. 如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？<br>看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。</li>
<li>⑤. 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class?<br>tomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在WEB-INF/class中。<br>而Eclipse/IDEA外部引用的jar包，则相当于放在WEB-INF/lib中。<br>因此肯定是java文件或者JSP文件编译出的class优先加载。</li>
<li>⑥. 为什么JDBC需要打破双亲委派机制<br>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包，DriverManager类中要加载各个实现了Driver接口的类，然后进行管理，也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类，这就打破了双亲委派机制</li>
</ul>
<h2 id="十九、CMS低延迟垃圾收集器"><a href="#十九、CMS低延迟垃圾收集器" class="headerlink" title="十九、CMS低延迟垃圾收集器"></a>十九、CMS低延迟垃圾收集器</h2><h3 id="1-CMS概述"><a href="#1-CMS概述" class="headerlink" title="1 CMS概述"></a>1 CMS概述</h3><ul>
<li>①. 在JDK1.5时期， HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器: CMS (Concurrent 一Mark 一 Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</li>
<li>②. CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。</li>
<li>③. CMS的垃圾收集算法采用标记一清除算法，并且也会” stop一the一world”</li>
<li>④. 不幸的是，CMS 作为老年代的收集器，却无法与JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1. 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</li>
<li>⑤. 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC<br><img src="https://img-blog.csdnimg.cn/20210621212300976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. CMS收集器在JDK9中被废弃，在JDK14中被移除</li>
</ul>
<h3 id="2-CMS过程-原理"><a href="#2-CMS过程-原理" class="headerlink" title="2 CMS过程(原理)"></a>2 CMS过程(原理)</h3><ul>
<li>①. 初始标记(Initial一Mark)仅仅只是标记出和GCRoots能直接关联到的对象，有STW现象、暂时时间非常短</li>
<li>②. 并发标记(Concurrent一Mark)阶段:从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行(并发标记阶段有三色标记，下文有记录)</li>
<li>③. 重新标记(Remark) 阶段:有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li>
<li>④. 并发清除:此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
<li>⑤. 补充说明:</li>
</ul>
<ol>
<li>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>CMS收集器的垃圾收集算法采用的是标记一清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择空闲列表(Free List) 执行内存分配。<br>(在并发标记阶段一开始不是垃圾，最后变成了垃圾)</li>
</ol>
<h3 id="3-CMS优缺点"><a href="#3-CMS优缺点" class="headerlink" title="3 CMS优缺点"></a>3 CMS优缺点</h3><ul>
<li>①. 优点:并发收集、低延迟</li>
<li>②. CMS的弊端:</li>
</ul>
<ol>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源非常敏感<br>(在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低)</li>
<li>CMS收集器无法处理浮动垃圾。可能出现”Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间</li>
</ol>
<ul>
<li>③.区分两个注意事项</li>
</ul>
<ol>
<li>并发标记阶段，在遍历GCRoots，用户线程也在执行，若此时遍历过一个对象发现没有引用，但由于用户线程并发执行，这期间可能导致遍历过的这个对象又被其他对象引用，所以才需要重新标记阶段再遍历一次看又没有漏标记的，否则就会导致被重新引用的对象被清理掉</li>
<li>浮动垃圾:在并发标记阶段一开始不是垃圾，最后变成了垃圾(属于多标的情况)</li>
</ol>
<h3 id="4-CMS参数设置"><a href="#4-CMS参数设置" class="headerlink" title="4 CMS参数设置"></a>4 CMS参数设置</h3><ul>
<li>①. -XX:+UseConcMarkSweepGc:手动指定使用CMS收集器执行内存回收任务<br>(开启该参数后会自动将一XX: +UseParNewGc打开。即: ParNew (Young区用) +CMS (0ld区用) +Serial 0ld的组合)</li>
<li>②. -XX:CMSlnitiatingOccupanyFraction:设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</li>
</ul>
<ol>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上版本默认值为92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数</li>
</ol>
<ul>
<li>③. -XX:+UseCMSCompactAtFullCollection:用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</li>
<li>④. -XX:CMSFullGCsBeforeCompaction:设置在执行多少次Full GC后对内存空间进行压缩整理</li>
<li>⑤. -XX:ParallelCMSThreads:设置CMS的线程数量<br>(CMS 默认启动的线程数是(ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕)</li>
</ul>
<h3 id="5-CMS三色标记概述、问题、解决方案"><a href="#5-CMS三色标记概述、问题、解决方案" class="headerlink" title="5 CMS三色标记概述、问题、解决方案"></a>5 CMS三色标记概述、问题、解决方案</h3><ul>
<li>①. 在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色:</li>
</ul>
<ol>
<li>黑色(black):节点被遍历完成，而且子节点都遍历完成</li>
<li>灰色(gray): 当前正在遍历的节点，而且子节点还没有遍历</li>
<li>白色(white):还没有遍历到的节点，即灰色节点的子节点<br><img src="https://img-blog.csdnimg.cn/20210622094337195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 根据三色扫描算法，如果有下面两种情况发生，则会出现漏扫描的场景:</li>
</ul>
<ol>
<li>把一个白对象的引用存到黑对象的字段里，如果这个情况发生，因为标记为黑色的对象认为是扫描完成的，不会再对他进行扫描。只能通过灰色的对象(CMS垃圾收集器)<br>(如上图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障和增量更新解决)</li>
<li>某个白对象失去了所有能从灰对象到达它的引用路径(直接或间接)(G1垃圾收集器)<br>(如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用写屏障和原始快照)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201014152019497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 三色过程:如下图所示，假如说A引入了B，B引用了C，D没有被任何引用。那么首先我们的CMS首先扫描到了A，发现A有引用B，那么我们的CMS会将A标记为黑色，B标记为灰色，然后这时候，通过B又找到了C那么这个时候发现C已经没有任何引用了就会将C标记为黑色。但是我们的D到目前为止没有被任何引用，记住我这里说的条件!那么D从始至终都没有被扫描，此时就会一直是白色，对于白色的对象来说CMS在执行并发清理的时候就会将此类对象干掉。<br>但是这里有了一个问题:如果我们的扫描过程已经结束这一段了，但是此时此刻我的A突然引用了D类型怎么办，这样一来我们的D只要被GC干掉是不是就会出现问题？也就是说我这里产生了一个漏标的问题。当然，我们的JVM开发人员可不是傻子，这里他们用了一个操作叫做增量更新和写屏障来解决这种问题的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="6-原始快照SATB-和-增量更新Incremental-Update"><a href="#6-原始快照SATB-和-增量更新Incremental-Update" class="headerlink" title="6 原始快照SATB 和 增量更新Incremental Update"></a>6 原始快照SATB 和 增量更新Incremental Update</h3><ul>
<li>①. 增量更新(Incremental Update):在并发标记过程中，把赋值的这种新增的引用，做一个集合存起来。 在重新标记的时候会找到集合里面的引用然后重新去扫描，再把源头标记为灰色。这就是我们的增量更新<br>(如下图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障(这个写屏障在之后)和增量更新解决)<br><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 在把我们新增的引用放到集合的时候，会实现一种写屏障的方式。在对象前后通过一个dirty card queue将引用信息， 存在card中，这个dirty card queue会放在cardtable中，而cardtable是记忆集的具体实现，最终这个引用就会放在记忆集中的<br>(写屏障我们可以理解为在赋值操作的前面加一个方法，赋值的后面做一些操作，也可以理解为AOP。具体的C++实现代码如下图:)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201014153100882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 原始快照(SATB)算法认为开始标记的都认为是活的对象，如上下图所示，引用B到D的引用改为B到C时，通过write barrier写屏障技术，会把B到D的引用推到gc遍历执行的堆栈上，保证还可以遍历到D对象，相对于d来说，引用从B–&gt;A，SATB 是从源入手解决的，即上面说的第2种情况，<br>这也能理解为啥叫satb了，即认为开始时所有能遍历到的对象都是需要标记的，即都认为是活的。如果我把b = null，那么d就是垃圾了， satb算法也还是会把D最终标记为黑色，导致D在本轮gc不能回收，成了浮动垃圾<br>(自己的理解:如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用原始快照和写屏障 注意:这个写屏障在前面)<img src="https://img-blog.csdnimg.cn/20210622102523886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201014153730621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="7-记忆集与卡表"><a href="#7-记忆集与卡表" class="headerlink" title="7 记忆集与卡表"></a>7 记忆集与卡表</h3><ul>
<li>①. 在刚刚我们再说写屏障的时候提到了卡表，那么我们现在就来说说卡表是干什么用的。但是在说记忆集与卡表之前，我们要先知道what is 跨带引用~</li>
<li>②. 跨带引用:<br>所谓跨带引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。</li>
<li>③. 记忆集(在新生代中)<br>记忆集也叫rememberSet，垃圾收集器在新生代中建立了记忆集这样的数据结构，用来避免把整个老年代加入到GC ROOTS的扫描范围中。对于记忆集来说，我们可以理解为他是一个抽象类，那么具体实现它的方法将由子类去完成。这里我们简单列举一下实现记忆集的三种方式:<br>1.字长精度<br>2.对象精度<br>3.卡精度(卡表)</li>
<li>④. 卡表(在老年代中)<br>卡表(Card Table)是一种对记忆集的具体实现。主要定义了记忆集的记录精度、与堆内存的映射关系等。卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块我们称之为卡页(card page)，当存在跨带引用的时候，它会将卡页标记为dirty。那么JVM对于卡页的维护也是通过写屏障的方式，这也就是为什么刚刚我们跟进写屏障操作到最后会发现它会对卡表进行一系列的操作。</li>
<li>注意:(1). 卡表是使用一个字节数组实现:CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为”卡页”。hotSpot使用的卡页是2^9大小，即512字节<br>(2). 一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0。GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</li>
</ul>
<h2 id="二十、G1垃圾收集器概述"><a href="#二十、G1垃圾收集器概述" class="headerlink" title="二十、G1垃圾收集器概述"></a>二十、G1垃圾收集器概述</h2><h3 id="1-什么是G1垃圾收集器"><a href="#1-什么是G1垃圾收集器" class="headerlink" title="1 什么是G1垃圾收集器"></a>1 什么是G1垃圾收集器</h3><ul>
<li>①. G1(Garbage-First)是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征</li>
<li>②. 在JDK1.7版本正式启用，是JDK 9以后的默认垃圾收集器，取代了CMS 回收器。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210627185110429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-为什么名字叫Garbage-First"><a href="#2-为什么名字叫Garbage-First" class="headerlink" title="2 为什么名字叫Garbage First"></a>2 为什么名字叫Garbage First</h3><ul>
<li>①. G1是一个并行回收器，它把堆内存分割为很多不相关的区域(region物理上不连续)，把堆分为2048个区域，每一个region的大小是1 - 32M不等，必须是2的整数次幂。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</li>
<li>②. 每次根据允许的收集时间，优先回收价值最大的Region<br>(每次回收完以后都有一个空闲的region，在后台维护一个优先列表)</li>
<li>③. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字:垃圾优先(Garbage First)</li>
<li>④. 下面说一个问题:既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First(G1)GC？<br>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器”的重任与期望。</li>
</ul>
<h3 id="3-G1垃圾收集器的特点、缺点"><a href="#3-G1垃圾收集器的特点、缺点" class="headerlink" title="3 G1垃圾收集器的特点、缺点"></a>3 G1垃圾收集器的特点、缺点</h3><ul>
<li>①. 并行和并发</li>
</ul>
<ol>
<li>并行性: G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ol>
<ul>
<li>②. 分代收集</li>
</ul>
<ol>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210627185423634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210627185428360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 空间整合<br>(G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记一压缩(Mark一Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显)</li>
<li>④. 可预测的停顿时间模型(即:软实时soft real一time)<br>(这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒、可以通过参数-XX:MaxGCPauseMillis进行设置)</li>
</ul>
<ol>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。<br>(CMS的最好的情况G1不一定比的上，但是CMS最差的部分，G1可以比上)</li>
</ol>
<ul>
<li>⑤. 缺点:</li>
</ul>
<ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间</li>
</ol>
<h3 id="4-参数设置"><a href="#4-参数设置" class="headerlink" title="4 参数设置"></a>4 参数设置</h3><ul>
<li>①. -XX:+UseG1GC:手动指定使用G1收集器执行内存回收任务</li>
<li>②. -XX:G1HeapRegionSize:设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000</li>
<li>③. -XX:MaxGCPauseMillis:设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms<br>(如果这个值设置很小，如20ms，那么它收集的region会少，这样长时间后，堆内存会满。产生FullGC，FullGC会出现STW，反而影响用户体验)</li>
<li>④. -XX:ParallelGCThread:设置stw时GC线程数的值。最多设置为8(垃圾回收线程)</li>
<li>⑤. -XX:ConcGCThreads:设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</li>
<li>⑥. -XX:Ini tiatingHeapOccupancyPercent:设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45</li>
</ul>
<h3 id="5-调优操作步骤"><a href="#5-调优操作步骤" class="headerlink" title="5 调优操作步骤"></a>5 调优操作步骤</h3><ul>
<li>①. G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</li>
</ul>
<ol>
<li>开启G1垃圾收集器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间</li>
</ol>
<ul>
<li>②. G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发</li>
</ul>
<h3 id="6-Region详解"><a href="#6-Region详解" class="headerlink" title="6 Region详解"></a>6 Region详解</h3><ul>
<li>①. 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。可以通过-XX:G1Hea pRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变</li>
<li>②. 一个region 有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于0ld内存区域。图中空白的表示未使用的内存空间</li>
<li>③. 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H<br>(对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926192008566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-记忆集与写屏障"><a href="#7-记忆集与写屏障" class="headerlink" title="7 记忆集与写屏障"></a>7 记忆集与写屏障</h3><ul>
<li>①. 问题:一个Region不可能是孤立的，一个Region中的对象可能被其他对象引用，如新生代中引用了老年代，这个时候垃圾回收时，会去扫描老年代，会出现STW</li>
<li>②. 解决:无论是G1还是分带收集器，JVM都是使用Remembered Set来避免全局扫描。每个Region都有一个对应的Remembered Set；[下面过程需要掌握]</li>
</ul>
<ol>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region (其他收集器:检查老年代对象是否引用了新生代对象)</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏<br><img src="https://img-blog.csdnimg.cn/20200926192909723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="8-G1回收器垃圾回收过程"><a href="#8-G1回收器垃圾回收过程" class="headerlink" title="8 G1回收器垃圾回收过程"></a>8 G1回收器垃圾回收过程</h3><ul>
<li>①. G1 GC的垃圾回收过程主要包括如下三个环节：</li>
</ul>
<ol>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程 (Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
<li>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/20210627220226998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行(多个垃圾线程)的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</li>
<li>③. 当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程</li>
<li>④. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>⑤. 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收</li>
</ul>
<h4 id="8-1-年轻代GC"><a href="#8-1-年轻代GC" class="headerlink" title="8.1 年轻代GC"></a>8.1 年轻代GC</h4><blockquote>
<p>回收时机<br>(1). 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区<br>(3). 回收前:<br><img src="https://img-blog.csdnimg.cn/20210627224109323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(4). 回收后:<br><img src="https://img-blog.csdnimg.cn/20210627224114494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>①. 根扫描: 一定要考虑remembered Set，看是否有老年代中的对象引用了新生代对象<br>(根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口)</li>
<li>②.更新RSet:处理dirty card queue(见备注)中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用<br>(dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty CardQueue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多)</li>
<li>③. 处理RSet:识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</li>
<li>④. 复制对象:复制算法<br>(此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间)</li>
<li>⑤. 处理引用:处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</li>
</ul>
<h4 id="8-2-并发标记过程"><a href="#8-2-并发标记过程" class="headerlink" title="8.2 并发标记过程"></a>8.2 并发标记过程</h4><ul>
<li>①. 初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>②. 根区域扫描(Root Region Scanning):G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成(YoungGC时，会动Survivor区，所以这一过程必须在young GC之前完成)</li>
<li>③. 并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>④. 再次标记(Remark):由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)<br>(在CMS中有详细讲解)</li>
<li>⑤. 独占清理(cleanup，STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)</li>
<li>⑥. 并发清理阶段:识别并清理完全空闲的区域</li>
</ul>
<h4 id="8-3-混合回收-Mixed-GC"><a href="#8-3-混合回收-Mixed-GC" class="headerlink" title="8.3 混合回收 Mixed GC"></a>8.3 混合回收 Mixed GC</h4><ul>
<li>①. Mixed GC并不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926194129931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="8-4-Full-GC"><a href="#8-4-Full-GC" class="headerlink" title="8.4 Full GC"></a>8.4 Full GC</h4><ul>
<li>①. 堆内存过小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决</li>
<li>②. 暂停时间-XX:MaxGCPauseMillis设置短，回收频繁。由于用户线程和GC线程一起执行，可能用户线程产生的垃圾大于GC线程回收的垃圾，会导致内存不足，触发Full gc</li>
</ul>
<h3 id="9-优化建议"><a href="#9-优化建议" class="headerlink" title="9 优化建议"></a>9 优化建议</h3><ul>
<li>①. 年轻代发送GC频率高，避免使用-Xmn或-XX:NewRatio，让JVM自己设置</li>
<li>②. 暂停时间目标不要太过严苛</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="cl0utfle1000xugvs8zcs1u6c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/SpringMVC/SpringMVC使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">SpringMVC使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringMVC使用详解"><a href="#SpringMVC使用详解" class="headerlink" title="SpringMVC使用详解"></a>SpringMVC使用详解</h1><h2 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h2><h3 id="1-1、什么是-SpringMVC"><a href="#1-1、什么是-SpringMVC" class="headerlink" title="1.1、什么是 SpringMVC"></a>1.1、什么是 SpringMVC</h3><p>​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架</p>
<h3 id="1-2、为什么学习-SpringMVC"><a href="#1-2、为什么学习-SpringMVC" class="headerlink" title="1.2、为什么学习 SpringMVC"></a>1.2、为什么学习 SpringMVC</h3><p>​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定大于配置，能够进行简单的 junit 测试，支持 Restful 风格，异常处理，本地化，国际化，数据验证，类型转换，拦截器，等等</p>
<h3 id="1-3、SpringMVC-的特点"><a href="#1-3、SpringMVC-的特点" class="headerlink" title="1.3、SpringMVC 的特点"></a>1.3、SpringMVC 的特点</h3><ul>
<li>简单好学</li>
<li>高效（基于请求相应的 MVC 框架）</li>
<li>与 Spring 无缝集成，兼容性好</li>
<li>约定大于配置</li>
<li>功能强大（Restful、数据验证、格式化、本地化、类型转换、等等）</li>
<li>简洁灵活</li>
</ul>
<h2 id="二、中心控制器"><a href="#二、中心控制器" class="headerlink" title="二、中心控制器"></a>二、中心控制器</h2><p>​        Spring 的 web 框架围绕 DispatcherServlet 设计。<strong>DispatcherServlet 的作用是将请求分发到不同的处理器</strong>。从 Spring 2.5 开始，使用 Java 5 或者以上版本的用户可以采用基于注解的 controller 声明方式。</p>
<p>​        Spring MVC 框架像许多其他 MVC 框架一样, 以请求为驱动 , 围绕一个中心 Servlet 分派请求及提供其他功能，DispatcherServlet 是一个实际的 Servlet (它继承自 HttpServlet 基类)。</p>
<p><img src="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        SpringMVC的原理如下图所示：</p>
<ul>
<li>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</li>
</ul>
<h2 id="三、SpringMVC原理"><a href="#三、SpringMVC原理" class="headerlink" title="三、SpringMVC原理"></a>三、SpringMVC原理</h2><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringMVC执行原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet 表示前置控制器，是整个 SpringMVC 的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。</p>
<p>​        我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p>​        如上 url 拆分成三部分：</p>
<ul>
<li><p> <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 服务器域名</p>
</li>
<li><p> SpringMVC 部署在服务器上的 web 站点</p>
</li>
<li><p>hello 表示控制器</p>
</li>
</ul>
<p> 通过分析，如上 url 表示为：请求位于服务器 localhost:8080上的Spring MVC站点的 hello 控制器。</p>
</li>
<li><p>HandlerMapping 为处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</p>
</li>
<li><p>HandlerExecution 表示具体的Handler，其主要作用是根据 url 查找控制器，如上 url 被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution 将解析后的信息传递给 DispatcherServlet，如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行 Handler。</p>
</li>
<li><p>Handler 让具体的 Controller 执行。</p>
</li>
<li><p>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</p>
</li>
<li><p>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="四、HelloSpringMVC"><a href="#四、HelloSpringMVC" class="headerlink" title="四、HelloSpringMVC"></a>四、HelloSpringMVC</h2><h3 id="4-1、配置版"><a href="#4-1、配置版" class="headerlink" title="4.1、配置版"></a>4.1、配置版</h3><p><strong>步骤：</strong></p>
<ol>
<li>新建一个 项目，添加 web 支持</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件（springmvc-service.xml）</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
</ol>
<pre><code class="xml">&lt;!--配置DispatchServlet：这个是SpringMVC的核心：请求分发器，前端控制器--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--DispatchServlet要绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-service.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--
    在Spring中，/ 与 /* 的区别
    /:只匹配所有的请求，不会去匹配jsp
    /*：匹配所有请求，包括jsp页面
--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>继续配置 SpringMVC 的配置文件（springmvc-servlet.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>添加 <strong>处理映射器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>处理器适配器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>视图解析器</strong></li>
</ul>
<pre><code class="xml">&lt;!--视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="6">
<li>编写操作业务的 Controller</li>
</ol>
<ul>
<li>要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图</li>
</ul>
<pre><code class="java">public class HelloController implements Controller &#123;
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //业务代码
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC！&quot;);
        
        //视图解释
        mv.setViewName(&quot;hello&quot;);//需要拼接的视图名称，参考视图解析器的代码实际地址就是（/WEB-INF/jsp/hello.jsp）
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>注册 bean（将 HelloController 这个类交给 Spring 容器【IOC】）</li>
</ol>
<pre><code class="xml">&lt;!--BeanNameUrlHandlerMapping:匹配的id(Handler)--&gt;
&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.aze.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="8">
<li>编写跳转页面，显示 ModelandView 存放的数据，以及我们编写的页面</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><strong>大多数都会遇到的问题！</strong></p>
<p>即使你的代码正确，但是却一直报出 404 错误！</p>
<ul>
<li><p>问题原因可能就在于 IDEA 项目发布中，缺少了 springMVC 相关的 jar 包</p>
</li>
<li><p>解决办法：</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>在 WEB-INF 下创建一个 lib 目录，在这个目录下存放 相关的 jar 包</p>
<p><img src="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将所有的<strong>包</strong>导入，点击 ok</p>
</li>
</ul>
</li>
</ul>
<p>​                </p>
<p><img src="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2、注解版（-）"><a href="#4-2、注解版（-）" class="headerlink" title="4.2、注解版（*）"></a>4.2、注解版（*）</h3><p>步骤：</p>
<ol>
<li>新建一个项目，添加 web 支持</li>
<li>解决 Maven 可能存在资源过滤的问题</li>
</ol>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ol start="3">
<li><p>在 pom.xml 文件引入相关的依赖：主要有 Spring 框架核心库、Spring MVC、servlet , JSTL 等</p>
</li>
<li><p>配置 web.xml</p>
</li>
</ol>
<pre><code class="xml">&lt;!--这是使用注解开发时固定的配置--&gt;
&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--初始化Spring配置文件的位置--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动顺序，数字越小，启动越早--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--所有的请求都会被SpringMVC拦截--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>编写 springmvc-servlet.xml 配置文件</li>
</ol>
<ul>
<li>配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能</li>
<li>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问<ul>
<li>让IOC的注解生效（context:component-scan base-package=””）</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …（mvc:default-servlet-handler）</li>
<li>MVC的注解驱动（mvc:annotation-driven）</li>
<li>配置视图解析器（开发中，程序员只需要配置这一步，其他的都是死的，CV 就可以）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
    &lt;!--这也是固定配置，需要修改的只有需要注入IOC的包--&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="6">
<li>编写一个 Java 控制类 HelloController.java</li>
</ol>
<ul>
<li>@Controller 是为了让 Spring IOC 容器初始化时自动扫描到；</li>
<li>@RequestMapping 是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是 /hello/hi；</li>
<li>方法中声明 Model 类型的参数是为了把 Action 中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称 hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</li>
</ul>
<pre><code class="java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    //类上注册了@RequestMapping方法就自动下移，实际地址：项目名/hello/hi
    @RequestMapping(&quot;/hi&quot;)
    public String sayHello(Model model)&#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVCAnnotatiom!&quot;);
        //web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>编写视图层 hello.jsp</li>
</ol>
<ul>
<li>视图可以直接取出并展示从 Controller 带回的信息；</li>
<li>可以通过 EL 表示取出 Model 中存放的值，或者对象</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h3 id="4-3、结论"><a href="#4-3、结论" class="headerlink" title="4.3、结论"></a>4.3、结论</h3><p>实现步骤：</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
<li><p>编写 web.xml , 注册 DispatcherServlet</p>
</li>
<li><p>编写 springmvc 配置文件</p>
</li>
<li><p>接下来就是去创建对应的控制类 , controller</p>
</li>
<li><p>最后完善前端视图和 controller 之间的对应</p>
</li>
<li><p>测试运行调试.</p>
</li>
</ol>
<p><strong>使用springMVC必须配置的三大件：</strong></p>
<ul>
<li><p>处理器映射器</p>
</li>
<li><p>处理器适配器</p>
</li>
<li><p>视图解析器</p>
</li>
</ul>
<p>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。</p>
<h2 id="五、注解"><a href="#五、注解" class="headerlink" title="五、注解"></a>五、注解</h2><h3 id="5-1、Controller"><a href="#5-1、Controller" class="headerlink" title="5.1、Controller"></a>5.1、Controller</h3><p>Controller 控制器</p>
<p>负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
<p>负责解析用户的请求并将其转换为一个模型。</p>
<p>在 Spring MVC 中一个控制器类可以包含多个方法</p>
<p>在 Spring MVC 中，对于 Controller 的配置方式有很多种</p>
<h4 id="5-1-1、实现-Controller-接口"><a href="#5-1-1、实现-Controller-接口" class="headerlink" title="5.1.1、实现 Controller 接口"></a>5.1.1、实现 Controller 接口</h4><p>Controller是一个接口</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p>步骤：（上面 HelloSpringMVC 的配置版就是 实现 Controller 接口）</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入 SpringMVC 的依赖</p>
</li>
<li><p>创建 SpringMVC 的配置文件（springmvc-service.xml）</p>
<ul>
<li>删掉 HelloController</li>
<li>只留下 视图解析器！</li>
</ul>
</li>
<li><p>配置 web.xml，注册 DispatcherServlet</p>
</li>
<li><p>编写一个 Controller 类</p>
</li>
<li><p>编写完毕后，去 Spring 配置文件中注册请求的 bean</p>
<ul>
<li>name 对应请求路径</li>
<li>class 对应处理请求的类</li>
</ul>
</li>
<li><p>编写前端 hello.jsp</p>
<ul>
<li>注意：在 WEB-INF/jsp 目录下编写，对应我们的视图解析器</li>
</ul>
</li>
<li><p>配置 Tomcat 运行测试<br>注意：实现接口 Controller 定义控制器是较老的办法<br>缺点：</p>
<ul>
<li>一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</li>
<li>定义的方式比较麻烦；</li>
</ul>
</li>
</ol>
<h4 id="5-1-2、注解-Controller"><a href="#5-1-2、注解-Controller" class="headerlink" title="5.1.2、注解 @Controller"></a>5.1.2、注解 @Controller</h4><ul>
<li>@Controller 注解类型用于声明 Spring 类的实例是一个控制器（<ul>
<li><strong>@Controller：</strong>用于controller</li>
<li><strong>@Component：</strong>用于组件</li>
<li><strong>@Repository：</strong>用于 dao</li>
<li><strong>@Service：</strong>用于 service</li>
</ul>
</li>
<li>Spring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证 Spring 能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<p>步骤：（4.2 注解版就是用注解 @Controller）</p>
<ol>
<li>新建一个 web 项目</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
<li>编写一个 Controller 类</li>
<li>使用注解（）</li>
<li>编写前端 hello.jsp</li>
<li>配置 Tomcat 运行测试</li>
</ol>
<h3 id="5-2、RequestMapping"><a href="#5-2、RequestMapping" class="headerlink" title="5.2、RequestMapping"></a>5.2、RequestMapping</h3><ul>
<li>@RequestMapping<pre><code>+ @RequestMapping 注解用于映射 url 到控制器类或一个特定的处理程序方法。
</code></pre>
可用于类或方法上<ul>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<ul>
<li>用于方法上，方法的响应请求是该地址</li>
</ul>
</li>
</ul>
<strong>建议：</strong>类上不要使用此注解</li>
</ul>
<h2 id="六、RestFul风格"><a href="#六、RestFul风格" class="headerlink" title="六、RestFul风格"></a>六、RestFul风格</h2><h3 id="6-1、什么是-RestFul"><a href="#6-1、什么是-RestFul" class="headerlink" title="6.1、什么是 RestFul"></a>6.1、什么是 RestFul</h3><p>Restful 就是一个资源定位及资源操作的风格。</p>
<ul>
<li>不是标准也不是协议，只是一种风格</li>
<li>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
</ul>
<h3 id="6-2、RestFul-功能"><a href="#6-2、RestFul-功能" class="headerlink" title="6.2、RestFul 功能"></a>6.2、RestFul 功能</h3><p>资源：互联网所有的事物都可以被抽象为资源</p>
<ul>
<li><p>资源操作：使用 POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
</li>
<li><p>分别对应 添加、 删除、修改、查询。</p>
</li>
</ul>
<p><strong>传统方式操作资源 ：</strong>通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源 ：</strong>可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<h3 id="6-3、测试-RestFul-风格"><a href="#6-3、测试-RestFul-风格" class="headerlink" title="6.3、测试 RestFul 风格"></a>6.3、测试 RestFul 风格</h3><h4 id="6-3-1、使用-RequestMapping"><a href="#6-3-1、使用-RequestMapping" class="headerlink" title="6.3.1、使用 @RequestMapping"></a>6.3.1、使用 @RequestMapping</h4><p>步骤：</p>
<ol>
<li><p>新建一个 Controller 类，用于测试 RestFul 风格</p>
</li>
<li><p>在 Spring MVC 中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
</li>
</ol>
<pre><code class="java">@Controller
public class RestFulTest &#123;

    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;
        int result = a + b;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;hello&quot;;
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>修改下对应的参数类型，再次测试</li>
</ol>
<pre><code class="java">// 将 int b，改为 String b
@PathVariable int a, @PathVariable String b
    
// 对应的 result 也需要改为 String
String result = a+b;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="6-3-2、使用注解变体"><a href="#6-3-2、使用注解变体" class="headerlink" title="6.3.2、使用注解变体"></a>6.3.2、使用注解变体</h4><p>使用method属性指定请求类型：</p>
<ul>
<li>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE 等</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<p>问题？</p>
<p>​        这样写，代码量就会变多，这时候，注解变体他来了！<br>注解变体：（方法级别）</p>
<ul>
<li>@GetMapping：GET 类型</li>
<li>@PostMapping：POST 类型</li>
<li>@PutMapping：PUT 类型</li>
<li>@DeleteMapping：DELETE 类型</li>
<li>@PatchMapping：PATCH 类型</li>
</ul>
<pre><code class="java">// 使用注解变体
@GetMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
// 等价于 @RequestMapping(value = &quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<h3 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h3><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。（注意！！！）</p>
<p><strong>@GetMapping 是一个组合注解</strong>，平时使用的会比较多！</p>
<p>使用浏览器地址栏进行访问默认是 Get 请求，会报错 405</p>
<p>解决办法：将 POST 修改为 GET 就好了</p>
<h2 id="七、转发与重定向"><a href="#七、转发与重定向" class="headerlink" title="七、转发与重定向"></a>七、转发与重定向</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置 ModelAndView 对象 , 根据 view 的名称 , 和视图解析器跳到指定的页面 .</p>
<ul>
<li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li>
</ul>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>controller 类</li>
</ul>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>这是 JavaWeb 中学习到的用法：</p>
<ul>
<li>通过设置 ServletAPI，不需要视图解析器 .<ol>
<li>通过 HttpServletResponse 进行输出</li>
</ol>
</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/test1&quot;)
public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
&#125;
</code></pre>
<p>​        2. 通过 HttpServletResponse 实现重定向（重定向）</p>
<pre><code class="java">@RequestMapping(&quot;test2&quot;)
public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.sendRedirect(&quot;/index.jsp&quot;);
&#125;
</code></pre>
<ol start="3">
<li>通过 HttpServletResponse 实现转发（请求转发）</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/test3&quot;)
public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
    // 转发
    req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
    req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
&#125;
</code></pre>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><h4 id="7-3-1、无视图解析器"><a href="#7-3-1、无视图解析器" class="headerlink" title="7.3.1、无视图解析器"></a>7.3.1、无视图解析器</h4><pre><code class="java">@RequestMapping(&quot;/rsm/t1&quot;)
public String test1()&#123;
    // 默认就是转发
    return &quot;/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t2&quot;)
public String test2()&#123;
    // 也可以显示定义转发
    return &quot;forward:/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t3&quot;)
public String test3()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
<h4 id="7-3-2、有视图解析器"><a href="#7-3-2、有视图解析器" class="headerlink" title="7.3.2、有视图解析器"></a>7.3.2、有视图解析器</h4><p>​        重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方 , 所以注意路径问题.</p>
<pre><code class="java">@RequestMapping(&quot;/rsm2/t1&quot;)
public String test1()&#123;
    // 转发：默认就是转发
    return &quot;test&quot;;
&#125;

@RequestMapping(&quot;/rsm2/t2&quot;)
public String test2()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
    // return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
&#125;
</code></pre>
<h2 id="八、数据处理"><a href="#八、数据处理" class="headerlink" title="八、数据处理"></a>八、数据处理</h2><h3 id="8-1、处理提交数据"><a href="#8-1、处理提交数据" class="headerlink" title="8.1、处理提交数据"></a>8.1、处理提交数据</h3><ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数名不一致，就需要使用注解 @RequestParam 来解决</li>
</ol>
<pre><code class="java">// @RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<ul>
<li>实体类</li>
</ul>
<pre><code class="java">// 这里使用的是 Lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private int age;
&#125;
</code></pre>
<ul>
<li>Controller 类</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<h3 id="8-2、数据显示到前端"><a href="#8-2、数据显示到前端" class="headerlink" title="8.2、数据显示到前端"></a>8.2、数据显示到前端</h3><ol>
<li>通过 ModelAndView</li>
</ol>
<pre><code class="java">public class ControllerTest implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>通过ModelMap</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>通过 Model</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<p>区别：</p>
<ul>
<li><p>Model：只有寥寥几个方法只适合用于储存数据，简化了新手对于 Model 对象的操作和理解</p>
</li>
<li><p>ModelMap：继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView：可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<h2 id="九、中文乱码问题"><a href="#九、中文乱码问题" class="headerlink" title="九、中文乱码问题"></a>九、中文乱码问题</h2><p>解决办法：</p>
<ol>
<li>自我编写一个过滤器，再注册到 web.xml 文件中</li>
</ol>
<pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;

    // 初始化：web 服务器启动，就已经初始化了，随时等待过滤对象的出现
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    // 销毁：web 服务器关闭时，过滤器会销毁
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用 SpringMVC 自带的过滤器</li>
</ol>
<ul>
<li>导入相关依赖后，直接配置 web.xml 即可</li>
</ul>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="3">
<li>使用大佬配置的过滤器</li>
</ol>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                                       .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
<p>​        以上都不行可能是你的 Tomcat 没有配置好！去修改 tomcat 配置文件 ：设置编码</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<h2 id="十、Json"><a href="#十、Json" class="headerlink" title="十、Json"></a>十、Json</h2><ul>
<li>JSON（JavaScript Object Notation, JS 对象标记） 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。（前后端分离）</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<h3 id="10-1、JSON-与-JavaScript"><a href="#10-1、JSON-与-JavaScript" class="headerlink" title="10.1、JSON 与 JavaScript"></a>10.1、JSON 与 JavaScript</h3><p>在 JavaScript 语言中，一切都是对象。因此，任何 JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li><p>对象表示为键值对，数据由逗号分隔</p>
</li>
<li><p>花括号保存对象</p>
</li>
<li><p>方括号保存数组</p>
</li>
</ul>
<p>​        <strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值（ {“键” : “值”} ）。</p>
<p>​        JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br><strong>JSON 和 JavaScript 对象互转：</strong></p>
<ul>
<li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法</li>
</ul>
<pre><code class="java">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);
</code></pre>
<ul>
<li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法</li>
</ul>
<pre><code class="java">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
<h3 id="10-2、Controller-返回-JSON-数据"><a href="#10-2、Controller-返回-JSON-数据" class="headerlink" title="10.2、Controller 返回 JSON 数据"></a>10.2、Controller 返回 JSON 数据</h3><ul>
<li>Jackson 应该是目前比较好的 json 解析工具了</li>
<li>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</li>
<li>这里使用的是 Jackson，使用它需要导入它的 jar 包；</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>web.xml 配置 SpringMVC 需要的配置<ul>
<li>servlet 注册 SpringMVC</li>
<li>filter 注册字符过滤器</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ul>
<li>编写 springmvc-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>编写一个实体类 User，去测试<ul>
<li>需要导入 lombok 的 jar 包</li>
</ul>
</li>
</ul>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<ul>
<li>编写 UserController<ul>
<li>@ResponseBody：将 java 对象转化为 json</li>
<li>ObjectMapper：创建一个 jackson 的对象映射器，用来解析数据</li>
</ul>
</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置 Tomcat</li>
<li>配置 Artifacts</li>
</ul>
<p>问题：乱码问题</p>
<p><img src="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center" alt="在这里插入图片描述"></p>
<p>解决办法：通过 @RequestMaping 的 produces 属性来实现</p>
<pre><code class="java">// produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
<h3 id="10-3、Controller-返回-JSON-数据代码优化"><a href="#10-3、Controller-返回-JSON-数据代码优化" class="headerlink" title="10.3、Controller 返回 JSON 数据代码优化"></a>10.3、Controller 返回 JSON 数据代码优化</h3><h4 id="10-3-1、将乱码问题统一解决"><a href="#10-3-1、将乱码问题统一解决" class="headerlink" title="10.3.1、将乱码问题统一解决"></a>10.3.1、将乱码问题统一解决</h4><p>上面解决乱码的方法在项目请求多的情况下就不适用了</p>
<p>就可以使用 Spring 配置统一指定返回类型和编码，等等</p>
<ul>
<li>在 spring-mvc 的配置文件上添加一段消息<ul>
<li>StringHttpMessageConverter 转换配置</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<h4 id="10-3-2、统一解决返回为-json-字符串问题"><a href="#10-3-2、统一解决返回为-json-字符串问题" class="headerlink" title="10.3.2、统一解决返回为 json 字符串问题"></a>10.3.2、统一解决返回为 json 字符串问题</h4><p>如果类中有所有的方法都需要返回 json 字符串，那么所有的方法都需要标识注释 @ResponseBody，这将会特别麻烦</p>
<ul>
<li>所以直接在类上使用 @RestController 来标注这个类的所有方法返回的都是 json 字符串<ul>
<li>这样就不用再每个方法上写 @ResponseBody</li>
<li>前后端分离开发中，一般都会使用 @RestController ，十分便捷</li>
</ul>
</li>
</ul>
<h3 id="10-4、测试集合的输出"><a href="#10-4、测试集合的输出" class="headerlink" title="10.4、测试集合的输出"></a>10.4、测试集合的输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
public String json2() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();

    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛逼1&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼2&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼3&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼4&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼5&quot;,18,&quot;男&quot;));

    return mapper.writeValueAsString(userList);
&#125;
</code></pre>
<h3 id="10-5、测试时间对象输出"><a href="#10-5、测试时间对象输出" class="headerlink" title="10.5、测试时间对象输出"></a>10.5、测试时间对象输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();
    Date date = new Date();
    // 默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式
    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<p>默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式：</p>
<ul>
<li>取消 timestamps（时间戳）形式，自定义时间格式</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();

    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<h3 id="10-6、将重复代码抽取为工具类"><a href="#10-6、将重复代码抽取为工具类" class="headerlink" title="10.6、将重复代码抽取为工具类"></a>10.6、将重复代码抽取为工具类</h3><p>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中</p>
<pre><code class="java">public class JsonUtils &#123;
    public static String getJson(Object object)&#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat)&#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>使用工具类后的代码量</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    return JsonUtils.getJson(new Date());
&#125;
</code></pre>
<h3 id="10-7、FastJson"><a href="#10-7、FastJson" class="headerlink" title="10.7、FastJson"></a>10.7、FastJson</h3><p>fastjson.jar 是阿里开发的一款专门用于 Java 开发的包，可以方便的实现多种转换，最后的实现结果都是一样的。</p>
<ul>
<li><p>实现 json 对象与 JavaBean 对象的转换</p>
</li>
<li><p>实现 JavaBean 对象与 json 字符串的转换</p>
</li>
<li><p>实现 json 对象与 json 字符串的转换。实现 son的 转换方法很多</p>
</li>
</ul>
<p><strong>fastjson 的 pom 依赖：</strong></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.78&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject 实现了 Map 接口, 猜想 JSONObject 底层操作是由 Map 实现的。</li>
<li>JSONObject 对应 json对 象，通过各种形式的 get() 方法可以获取 json 对象中的数据，也可利用诸如 size()，isEmpty() 等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有 List 接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON 代表 JSONObject 和 JSONArray 的转化</strong></p>
<ul>
<li>JSON 类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现 json 对象，json 对象数组，javabean 对象，json 字符串之间的相互转化。</li>
</ul>
<p>代码测试：</p>
<pre><code class="java">@RequestMapping(&quot;/json6&quot;)
public String json6()&#123;
    //创建一个对象
    User user1 = new User(&quot;1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    userList.add(user4);

    System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
    String str1 = JSON.toJSONString(userList);
    System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
    String str2 = JSON.toJSONString(user1);
    System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

    System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
    User jp_user1=JSON.parseObject(str2,User.class);
    System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

    System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
    JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
    System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

    System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
    User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
    System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    
    return JSON.toJSONString(userList);
&#125;
</code></pre>
<h2 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h2><h3 id="11-1、什么是-Ajax"><a href="#11-1、什么是-Ajax" class="headerlink" title="11.1、什么是 Ajax"></a>11.1、什么是 Ajax</h3><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML。</li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
<li>传统的网页（即不用 ajax 技术的网页），想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</li>
</ul>
<h3 id="11-2、Ajax-原理"><a href="#11-2、Ajax-原理" class="headerlink" title="11.2、Ajax 原理"></a>11.2、Ajax 原理</h3><p><img src="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="11-3、伪造-Ajax"><a href="#11-3、伪造-Ajax" class="headerlink" title="11.3、伪造 Ajax"></a>11.3、伪造 Ajax</h3><ol>
<li>新建一个项目，导入 web 支持</li>
<li>编写一个 前端页面，使用 iframe 进行测试</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function x() &#123;
            var url =  document.getElementById(&#39;url&#39;).value;
            document.getElementById(&#39;iframePosition&#39;).src = url;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;p&gt;请输入地址：&lt;/p&gt;
    &lt;p&gt;
        &lt;input id=&quot;url&quot; type=&quot;text&quot; placeholder=&quot;网页地址&quot;/&gt;
        &lt;input type=&quot;button&quot; value=&quot;前往&quot; onclick=&quot;x()&quot;&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 666px&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-4、jQuery-操作-ajax"><a href="#11-4、jQuery-操作-ajax" class="headerlink" title="11.4、jQuery 操作 ajax"></a>11.4、jQuery 操作 ajax</h3><ul>
<li>使用jquery提供的，方便，有兴趣的可以自己去了解下 JS 原生 XMLHttpRequest ！<ul>
<li>Ajax 的核心是 XMLHttpRequest 对象（XHR）。XHR 为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
</ul>
</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="js">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<h3 id="11-5、原始的-HttpServletResponse-实现"><a href="#11-5、原始的-HttpServletResponse-实现" class="headerlink" title="11.5、原始的 HttpServletResponse 实现"></a>11.5、原始的 HttpServletResponse 实现</h3><ol>
<li>配置 web.xml</li>
</ol>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="2">
<li>springmvc 配置文件（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li><p>静态资源过滤和注解驱动配置（我的父工程已经配置了，所以这就不配了）</p>
</li>
<li><p>编写 Controller 类</p>
</li>
</ol>
<pre><code class="java">@RestController
public class UserController &#123;

    @RequestMapping(&quot;/a&quot;)
    public void ajax(String name, HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().write(&quot;true&quot;);
        &#125;else &#123;
            response.getWriter().write(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>导入 jQuery</p>
</li>
<li><p>编写前端页面</p>
</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ajaxTest&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function a1()&#123;
        $.post(&#123;
          url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
          data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
          success:function (data,status) &#123;
            alert(data);
            alert(status);
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; οnblur=&quot;a1()&quot;/&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="11-6、SpringMVC-实现异步加载数据"><a href="#11-6、SpringMVC-实现异步加载数据" class="headerlink" title="11.6、SpringMVC 实现异步加载数据"></a>11.6、SpringMVC 实现异步加载数据</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛&quot;,10,&quot;男&quot;));
    userList.add(new User(&quot;中牛&quot;,11,&quot;女&quot;));
    userList.add(new User(&quot;小牛&quot;,12,&quot;男&quot;));
    return userList;
&#125;
</code></pre>
<ol start="2">
<li>在 index 中增加内容</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;取得信息&quot;&gt;
  &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">$(function () &#123;
    $(&quot;#btn&quot;).click(function () &#123;
        $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
            console.log(data)
            var html=&quot;&quot;;
            for (let i = 0; i &lt; data.length ; i++) &#123;
                html+= &quot;&lt;tr&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;/tr&gt;&quot;
            &#125;
            $(&quot;#content&quot;).html(html);
        &#125;);
    &#125;)
&#125;)
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-7、注册提示效果"><a href="#11-7、注册提示效果" class="headerlink" title="11.7、注册提示效果"></a>11.7、注册提示效果</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String oldPwd,String newPwd, String newPwd2)&#123;
    String msg = &quot;&quot;;
    if (name != null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;用户名不存在&quot;;
        &#125;
    &#125;
    if (oldPwd != null)&#123;
        if (&quot;123456&quot;.equals(oldPwd))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;旧密码有误&quot;;
        &#125;
    &#125;
    return msg;
&#125;
</code></pre>
<ol start="2">
<li>编写前端</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;name&quot; οnblur=&quot;a3_1()&quot;&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
    旧密码：&lt;input type=&quot;password&quot; id=&quot;oldPwd&quot; οnblur=&quot;a3_2()&quot;&gt;
    &lt;span id=&quot;oldPwdInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function a3_1() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;name&quot;:$(&#39;#name&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#userInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
function a3_2() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;oldPwd&quot;:$(&#39;#oldPwd&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#oldPwdInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
</code></pre>
<ol start="3">
<li>解决乱码问题（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<h2 id="十二、拦截器"><a href="#十二、拦截器" class="headerlink" title="十二、拦截器"></a>十二、拦截器</h2><h3 id="12-1、什么是拦截器"><a href="#12-1、什么是拦截器" class="headerlink" title="12.1、什么是拦截器"></a>12.1、什么是拦截器</h3><p>​        SpringMVC 的处理器、拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<ul>
<li><p>过滤器</p>
<ul>
<li>servlet 规范中的一部分，任何 java web工程都可以使用</li>
<li>在 url-pattern 中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是 jsp、html、css、image、js 是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="12-2、自定义拦截器"><a href="#12-2、自定义拦截器" class="headerlink" title="12.2、自定义拦截器"></a>12.2、自定义拦截器</h3><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>配置 web.xml 和 applicationContext.xml</p>
</li>
<li><p>编写一个拦截器</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在 springmvc 配置文件中配置拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class TestController &#123;

    @RequestMapping(&quot;/t1&quot;)
    public String test()&#123;
        System.out.println(&quot;控制器方法执行！&quot;);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="12-3、验证用户是否登录（认证用户）"><a href="#12-3、验证用户是否登录（认证用户）" class="headerlink" title="12.3、验证用户是否登录（认证用户）"></a>12.3、验证用户是否登录（认证用户）</h3><p><strong>测试思路：</strong></p>
<ul>
<li>有一个登陆页面，需要写一个 controller 访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在 controller 中处理。判断用户名密码是否正确。如果正确，向 session 中写入用户信息。返回登陆成功。</li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>编写登录页面（login.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;

    &lt;h1&gt;登录页面&lt;/h1&gt;
    &lt;hr&gt;

    &lt;body&gt;
        &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt;
            用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;br&gt;
            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; required&gt; &lt;br&gt;
            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>编写 Controller 类处理请求</li>
</ol>
<pre><code class="java">package com.aze.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>编写登录成功页面（success.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;登录成功页面&lt;/h1&gt;
        &lt;hr&gt;

        $&#123;user&#125;
        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>编写首页，来测试页面跳转（index.jsp）</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 16:29
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
  &lt;/div&gt;

  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;hr&gt;
    &lt;%--登录--%&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>编写用户登录拦截器</li>
</ol>
<pre><code class="java">package com.aze.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;url: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>在 springmvc 配置文件中注册拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.aze.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="7">
<li><p>配置 Tomcat</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="13、文件上传和下载"><a href="#13、文件上传和下载" class="headerlink" title="13、文件上传和下载"></a>13、文件上传和下载</h2><h3 id="13-1、准备测试"><a href="#13-1、准备测试" class="headerlink" title="13.1、准备测试"></a>13.1、准备测试</h3><p>​        文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是 SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用 Spring 的文件上传功能，则需要在上下文中配置 MultipartResolver。</p>
<p>​        前端表单要求：为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p>对表单中的 enctype 属性做个详细的说明：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>​        一旦设置了 enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的 HTTP 响应。在2003年，Apache Software Foundation 发布了开源的 Commons FileUpload 组件，其很快成为 Servlet/JSP 程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0 规范已经提供方法来处理文件上传，但这种上传需要在 Servlet中完成。</li>
<li>而 Spring MVC 则提供了更简单的封装。</li>
<li>Spring MVC 为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver 实现的。</li>
<li>Spring MVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。</li>
<li>因此，SpringMVC 的文件上传还需要依赖 Apache Commons FileUpload 的组件。</li>
</ul>
<h3 id="13-2、文件上传"><a href="#13-2、文件上传" class="headerlink" title="13.2、文件上传"></a>13.2、文件上传</h3><ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
</ol>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--文件上传--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet-api导入高版本的--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--统一的解决乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>在 applicationContext.xml 中添加 bean 配置</li>
</ol>
<ul>
<li><strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong></li>
</ul>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 17:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;form action=&quot;/upload2&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class FileController &#123;
    
&#125;
</code></pre>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="java">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
//批量上传CommonsMultipartFile则为数组即可
@RequestMapping(&quot;/upload&quot;)
public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

    //获取文件名 : file.getOriginalFilename();
    String uploadFileName = file.getOriginalFilename();

    //如果文件名为空，直接回到首页！
    if (&quot;&quot;.equals(uploadFileName))&#123;
        return &quot;redirect:/index.jsp&quot;;
    &#125;
    System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    //如果路径不存在，创建一个
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    InputStream is = file.getInputStream(); //文件输入流
    OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

    //读取写出
    int len=0;
    byte[] buffer = new byte[1024];
    while ((len=is.read(buffer))!=-1)&#123;
        os.write(buffer,0,len);
        os.flush();
    &#125;
    os.close();
    is.close();
    return &quot;success&quot;;
&#125;
</code></pre>
<ul>
<li>方式二：采用 file.Transto 来保存上传的文件</li>
</ul>
<pre><code class="java">/*
    * 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;success&quot;;
&#125;
</code></pre>
<p>7.配置 Tomcat</p>
<ol start="8">
<li>测试</li>
</ol>
<h3 id="13-3、文件下载"><a href="#13-3、文件下载" class="headerlink" title="13.3、文件下载"></a>13.3、文件下载</h3><p>步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>Controller 类添加</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;baidu.png&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端添加</p>
<pre><code class="html">&lt;div&gt;
  &lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
&lt;/div&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" data-id="cl0utfle1000zugvsau9xea7o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Mybatis/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Mybatis/">SpringBoot整合Mybaits</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h1><h2 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h2><h3 id="1-1、选择项目所需要的依赖"><a href="#1-1、选择项目所需要的依赖" class="headerlink" title="1.1、选择项目所需要的依赖"></a>1.1、选择项目所需要的依赖</h3><p><img src="https://img-blog.csdn.net/20180926174507971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="1-2、pom-xml"><a href="#1-2、pom-xml" class="headerlink" title="1.2、pom.xml"></a>1.2、pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;demo&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
 
    &lt;name&gt;demo&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
 
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
 
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
 
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
 
 
&lt;/project&gt;
</code></pre>
<h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>​        本文不使用application.properties文件 而使用更加简洁的application.yml文件。将resource文件夹下原有的application.properties文件删除，创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties），本文创建了两个yml文件（application.yml和application-dev.yml），分别来看一下内容</p>
<ul>
<li>application.yml</li>
</ul>
<pre><code class="yml">spring:
  profiles:
    active: dev
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8080
 
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
</code></pre>
<p>​        两个文件的意思是：</p>
<blockquote>
<p>在项目中配置多套环境的配置方法。<br>因为现在一个项目有好多环境，开发环境，测试环境，准生产环境，生产环境，每个环境的参数不同，所以我们就可以把每个环境的参数配置到yml文件中，这样在想用哪个环境的时候只需要在主配置文件中将用的配置文件写上就行如application.yml</p>
<p>笔记：在Spring Boot中多环境配置文件名需要满足application-{profile}.yml的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.yml：开发环境<br>application-test.yml：测试环境<br>application-prod.yml：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.yml文件中通过<strong>spring.profiles.active属性</strong>来设置，其值对应{profile}值。</p>
</blockquote>
<p>​        还有配置文件中最好不要有中文注释，会报错。</p>
<p>​        接下来把启动文件移到com.example下，而且springboot的启动类不能放在java目录下！！！必须要个包将它包进去</p>
<p>​        否则会报错误：</p>
<pre><code class="java">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.
</code></pre>
<p>​        这个原因值得注意就是因为有时候很难在IDEA中的项目目录认出来这个错误并且还容易扫描不到一些类</p>
<h2 id="二、创建类"><a href="#二、创建类" class="headerlink" title="二、创建类"></a>二、创建类</h2><p>​        创建包controller、entity、mapper、service。resources下创建mapping文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。下面直接贴代码</p>
<h3 id="2-1、创建实体类"><a href="#2-1、创建实体类" class="headerlink" title="2.1、创建实体类"></a>2.1、创建实体类</h3><h4 id="2-1-1、数据库表结构"><a href="#2-1-1、数据库表结构" class="headerlink" title="2.1.1、数据库表结构"></a>2.1.1、数据库表结构</h4><pre><code class="sql">CREATE TABLE `user` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `userName` varchar(32) NOT NULL,
  `passWord` varchar(50) NOT NULL,
  `realName` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre>
<p><img src="https://img-blog.csdn.net/20180927092715962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>entity.java</li>
</ul>
<pre><code class="java">package com.example.entity;
 
@Data
public class User &#123;
    private Integer id;
    private String userName;
    private String passWord;
    private String realName;
&#125;
</code></pre>
<ul>
<li>UserController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
@RequestMapping(&quot;/testBoot&quot;)
public class UserController &#123;
 
    @Autowired
    private UserService userService;
 
    @RequestMapping(&quot;getUser/&#123;id&#125;&quot;)
    public String GetUser(@PathVariable int id)&#123;
        return userService.Sel(id).toString();
    &#125;
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
&#125;
</code></pre>
<ul>
<li>UserMappering.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;com.example.entity.User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
&lt;/mapper&gt;
</code></pre>
<p>最终框架结构</p>
<p><img src="https://img-blog.csdn.net/20180927095234881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>启动类</li>
</ul>
<pre><code class="java">package com.example;
 
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
 
@MapperScan(&quot;com.example.mapper&quot;) //扫描的mapper
@SpringBootApplication
public class DemoApplication &#123;
 
    public static void main(String[] args) &#123;
        SpringApplication.run(DemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="三、注册、登录以及拦截器配置"><a href="#三、注册、登录以及拦截器配置" class="headerlink" title="三、注册、登录以及拦截器配置"></a>三、注册、登录以及拦截器配置</h2><ul>
<li>添加依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8888
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    prefix: classpath:/templates/
    suffix: .html
    encoding: utf-8
    mode: html5
    servlet:
      content-type: text/html
</code></pre>
<ul>
<li>register.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;form action=&quot;/user/register&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Register&quot;/&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot; type=&quot;text/css&quot; /&gt;--&gt;
&lt;form action=&quot;/user/loginUser&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;
    &lt;a href=&quot;/user/toRegister&quot;&gt;--注册--&lt;/a&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>welcome.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
注册或登录后才能看到的界面
 
&lt;a href=&quot;/user/outUser&quot;&gt;退出登录&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>LoginController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController &#123;
    @Autowired
    private UserService userService;
 
    //跳转首页（登录页）
    @RequestMapping(&quot;/toIndex&quot;)
    public String show()&#123;
        return &quot;index&quot;;
    &#125;
 
    //登录操作
    @ResponseBody
    @RequestMapping(&quot;/loginUser&quot;)
    public String login(User user, HttpServletRequest request)&#123;
        String userName = user.getUserName();
        String passWord = user.getPassWord();
        User u1 =userService.login(userName,passWord);
        if (u1==null)&#123;
            return &quot;用户名或密码错误&quot;;
        &#125;else&#123;
            request.getSession().setAttribute(&quot;session_user&quot;,user);//登录成功后将用户放入session中，用于拦截
            return &quot;登录成功&quot;;
        &#125;
    &#125;
 
    //跳转注册页
    @RequestMapping(&quot;/toRegister&quot;)
    public String toRegister()&#123;
        return &quot;register&quot;;
    &#125;
 
    //注册操作
    @RequestMapping(&quot;/register&quot;)
    public String register(User user)&#123;
        int su = userService.register(user);
        if(su==0)&#123;
            System.out.println(&quot;----&quot;);
        &#125;
        return &quot;welcome&quot;;
    &#125;
 
    //测试未登陆拦截页面
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome()&#123;
        return &quot;welcome&quot;;
    &#125;
 
    //退出登录
    @RequestMapping(&quot;/outUser&quot;)
    public void outUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        request.getSession().removeAttribute(&quot;session_user&quot;);
        response.sendRedirect(&quot;/user/toIndex&quot;);
    &#125;
 
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
 
    public User login(String userName, String passWord) &#123;
        return userMapper.login(userName,passWord);
    &#125;
 
    public int register(User user) &#123;
        return userMapper.register(user);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
 
    User login(String userName,String passWord);
 
    int register(User user);
&#125;
</code></pre>
<ul>
<li>UserMapping.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
    &lt;select id=&quot;login&quot; resultType=&quot;User&quot;&gt;
        SELECT * FROM user where userName = #&#123;param1&#125; and passWord = #&#123;param2&#125;
    &lt;/select&gt;
 
    &lt;insert id=&quot;register&quot; parameterType=&quot;User&quot;&gt;
        INSERT INTO user (userName, passWord) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>其实注册登录也诶逻辑也很简单，就不多赘述了，接下来讲讲实现拦截器功能（敲黑板，本章的重点）</p>
<p>首先在com.example下新建intercetor包，然后新建UserIntercetor.java实现HandlerInterceptor接口并重写方法，更多介绍都写在里面注释了</p>
<ul>
<li>UserIntercetor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import com.example.entity.User;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Component
public class UserInterceptor implements HandlerInterceptor &#123;
 
    /*
     * 进入controller层之前拦截请求
     * 返回值：表示是否将当前的请求拦截下来  false：拦截请求，请求别终止。true：请求不被拦截，继续执行
     * Object obj:表示被拦的请求的目标对象（controller中方法）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;
        System.out.println(&quot;执行到了preHandle方法&quot;);
        System.out.println(handler);
        User user = (User) request.getSession().getAttribute(&quot;session_user&quot;);
        if (user==null)&#123;
            response.sendRedirect(request.getContextPath()+&quot;/user/toIndex&quot;);//拦截后跳转的方法
            System.out.println(&quot;已成功拦截并转发跳转&quot;);
            return false;
        &#125;
        System.out.println(&quot;合格不需要拦截，放行&quot;);
        return true;
    &#125;
 
    /*
     * 处理请求完成后视图渲染之前的处理操作
     * 通过ModelAndView参数改变显示的视图，或发往视图的方法
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;
        System.out.println(&quot;执行了postHandle方法&quot;);
    &#125;
 
    /*
     * 视图渲染之后的操作
     */
    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;
        System.out.println(&quot;执行到了afterCompletion方法&quot;);
    &#125;
 
&#125;
</code></pre>
<p>新建类SessionInterceptor实现WebMvcConfigurer接口来注册拦截器</p>
<ul>
<li>SessionInterceptor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
import java.util.ArrayList;
import java.util.List;

@Configuration
public class SessionInterceptor implements WebMvcConfigurer &#123;
 
    /**
     * 自定义拦截器，添加拦截路径和排除拦截路径
     * addPathPatterns():添加需要拦截的路径
     * excludePathPatterns():添加不需要拦截的路径
     */
    //注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        List list = new ArrayList();
        list.add(&quot;/user/toIndex&quot;);
        list.add(&quot;/user/loginUser&quot;);
        list.add(&quot;/user/toRegister&quot;);
        list.add(&quot;/user/register&quot;);
        registry.addInterceptor(new UserInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(list);
 
    &#125;
&#125;
</code></pre>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>4.1、application.yml文件中文注释乱码</p>
<pre><code class="yml">server:
  port: 8080
  servlet:
    jsp:
      init-parameters:
        # jsp修改之后立即生效
        development: true
</code></pre>
<p><img src="https://img-blog.csdn.net/20180908114638271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4ODcwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Mybatis/" data-id="cl0utfle20012ugvs07v46ion" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/Spring/SSM整合笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/SSM%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/SSM%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/">SSM整合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SSM整合笔记"><a href="#SSM整合笔记" class="headerlink" title="SSM整合笔记"></a>SSM整合笔记</h1><h2 id="一、数据库环境"><a href="#一、数据库环境" class="headerlink" title="一、数据库环境"></a>一、数据库环境</h2><h3 id="1-1、创建数据库及数据表"><a href="#1-1、创建数据库及数据表" class="headerlink" title="1.1、创建数据库及数据表"></a>1.1、创建数据库及数据表</h3><pre><code class="sql">CREATE TABLE `books`(    
    `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,    
    `bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;, 
    `bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,    
    `detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,   
    KEY `bookId` (`bookId`)
) ENGINE=INNODB DEFAULT CHARSET=utf8; 

INSERT INTO books(`bookId`,`bookName`,`bookCounts`,`detail`) 
    VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;), (2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;), (3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);
</code></pre>
<h2 id="二、导入依赖"><a href="#二、导入依赖" class="headerlink" title="二、导入依赖"></a>二、导入依赖</h2><h3 id="2-1、导入jar包"><a href="#2-1、导入jar包" class="headerlink" title="2.1、导入jar包"></a>2.1、导入jar包</h3><p>​        创建一个maven工程，导入依赖和静态资源处理的配置。</p>
<pre><code class="xml">&lt;dependencies&gt;
    
    &lt;!--Junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--数据库驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.35&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--连接池--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--servlet--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jsp--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--JSTL--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--mybatis-spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jdbc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--静态资源导出问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="2-2、建包："><a href="#2-2、建包：" class="headerlink" title="2.2、建包："></a>2.2、建包：</h3><p>​        连接数据库；    </p>
<p>​        在src/main/java下创建pojo、service、controller、dao、util。</p>
<p>​        在resource文件夹下创建mybatis-config.xml、applicationContext.xml、database.properties。</p>
<h3 id="2-3、修改resource下的配置文件："><a href="#2-3、修改resource下的配置文件：" class="headerlink" title="2.3、修改resource下的配置文件："></a>2.3、修改resource下的配置文件：</h3><h4 id="2-3-1、mybatis-config-xml"><a href="#2-3-1、mybatis-config-xml" class="headerlink" title="2.3.1、mybatis-config.xml"></a>2.3.1、mybatis-config.xml</h4><p>​        关联数据库文件源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--
        数据源配置交给spring做
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.example.pojo&quot;/&gt;
        &lt;/typeAliases&gt;
    --&gt;
    
    &lt;!--写一些mapper配置文件的注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<p>​        编写pojo文件夹下的实体类：Books；</p>
<p>​        编写dao文件夹下的接口：BookMapper；</p>
<p>​        编写BookMapper.xml</p>
<h4 id="2-3-2、applicationContext-xml"><a href="#2-3-2、applicationContext-xml" class="headerlink" title="2.3.2、applicationContext.xml"></a>2.3.2、applicationContext.xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--将其他三层的spring配置文件合在一起即可--&gt;
    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="2-3-3、database-properties"><a href="#2-3-3、database-properties" class="headerlink" title="2.3.3、database.properties"></a>2.3.3、database.properties</h4><p>​        数据库的配置文件    </p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
# 如果使用MySQL8.0，还需要增加一个时区的配置 &amp;serverTimezone=Asia/Shanghai
jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=123456
</code></pre>
<h2 id="三、Mybatis层的配置："><a href="#三、Mybatis层的配置：" class="headerlink" title="三、Mybatis层的配置："></a>三、Mybatis层的配置：</h2><h3 id="3-1、创建pojo对象"><a href="#3-1、创建pojo对象" class="headerlink" title="3.1、创建pojo对象"></a>3.1、创建pojo对象</h3><p>​    采用lombok依赖对这个pojo生成get、set方法等一系列方法。</p>
<pre><code class="xml">&lt;!--lombok--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    
    &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@Data       //get、set等方法
@AllArgsConstructor     //有参构造
@NoArgsConstructor      //无参构造
public class Book &#123;
    private Integer bookId;
    private String bookName;
    private Integer bookCounts;
    private String detail;
&#125;
</code></pre>
<h3 id="3-2、创建dao接口。"><a href="#3-2、创建dao接口。" class="headerlink" title="3.2、创建dao接口。"></a>3.2、创建dao接口。</h3><pre><code class="java">public interface BookMapper &#123;
    int addBook(Book book);
    int deleteBookById(@Param(&quot;id&quot;) Integer id);
    int updateBook(Book book);
    Book queryBookById(@Param(&quot;id&quot;) Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<h3 id="3-3、创建mapper配置文件"><a href="#3-3、创建mapper配置文件" class="headerlink" title="3.3、创建mapper配置文件"></a>3.3、创建mapper配置文件</h3><p>​        并在全局配置中进行注册</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.example.pojo.Book&quot;&gt;
        insert into books(`bookName`,`bookCounts`,`detail`) values
        (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;details&#125;)
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot;&gt;
        delete from books where bookId = #&#123;id&#125;
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot;&gt;
        update books set `bookName` = #&#123;bookName&#125;,`bookCounts` = #&#123;bookCounts&#125;,
        `detail` = #&#123;detail&#125; where `bookId` = #&#123;bookId&#125;
    &lt;/update&gt;

    &lt;select id=&quot;queryBookById&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books where `bookId` = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBooks&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="3-4、创建service业务。"><a href="#3-4、创建service业务。" class="headerlink" title="3.4、创建service业务。"></a>3.4、创建service业务。</h3><pre><code class="java">public interface BookService &#123;
    int addBook(Book book);
    int deleteBookById(Integer id);
    int updateBook(Book book);
    Book queryBookById(Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<pre><code class="java">public class BookServiceImpl implements BookService&#123;
    // 之后用spring自动注入
    // service调dao层：组合Dao
    private BookMapper bookMapper;
    
    @Override
    public int addBook(Book book) &#123;
        return bookMapper.addBook(book);
    &#125;
    @Override
    public int deleteBookById(Integer id) &#123;
        return bookMapper.deleteBookById(id);
    &#125;
    @Override
    public int updateBook(Book book) &#123;
        return bookMapper.updateBook(book);
    &#125;
    @Override
    public Book queryBookById(Integer id) &#123;
        return bookMapper.queryBookById(id);
    &#125;
    @Override
    public List&lt;Book&gt; queryAllBooks() &#123;
        return bookMapper.queryAllBooks();
    &#125;
&#125;
</code></pre>
<h2 id="四、Spring层的配置："><a href="#四、Spring层的配置：" class="headerlink" title="四、Spring层的配置："></a>四、Spring层的配置：</h2><h3 id="4-1、创建一个新的spring配置文件去整合dao层"><a href="#4-1、创建一个新的spring配置文件去整合dao层" class="headerlink" title="4.1、创建一个新的spring配置文件去整合dao层"></a>4.1、创建一个新的spring配置文件去整合dao层</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--关联数据库配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
    
    &lt;!--连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--绑定数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--绑定mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--配置dao接口扫描包，可以将dao接口注入到spring的容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描dao包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.example.dao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="4-2、创建一个新的spring配置文件去整合service层。"><a href="#4-2、创建一个新的spring配置文件去整合service层。" class="headerlink" title="4.2、创建一个新的spring配置文件去整合service层。"></a>4.2、创建一个新的spring配置文件去整合service层。</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service包--&gt;
    &lt;context:component-scan base-package=&quot;com.example.service&quot;/&gt;

    &lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--aop事务支持--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.example.dao.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="五、springMVC层配置："><a href="#五、springMVC层配置：" class="headerlink" title="五、springMVC层配置："></a>五、springMVC层配置：</h2><h3 id="5-1、添加web支持，创建web-xml"><a href="#5-1、添加web支持，创建web-xml" class="headerlink" title="5.1、添加web支持，创建web.xml"></a>5.1、添加web支持，创建web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    
    &lt;!--配置前端处理器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--绑定的是spring的全局配置文件--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;!--
            /  :
            /* :会过滤到jsp等资源
        --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;!--配置乱码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!--配置session--&gt;
    &lt;session-config&gt;
        &lt;!--配置session超时时间--&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="5-2、创建spring的mvc配置文件"><a href="#5-2、创建spring的mvc配置文件" class="headerlink" title="5.2、创建spring的mvc配置文件"></a>5.2、创建spring的mvc配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--注解驱动--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--扫描controller--&gt;
    &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt;
    &lt;!--视图解析器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="5-3、在WEB-INF下创建jsp目录。"><a href="#5-3、在WEB-INF下创建jsp目录。" class="headerlink" title="5.3、在WEB-INF下创建jsp目录。"></a>5.3、在WEB-INF下创建jsp目录。</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/SSM%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/" data-id="cl0utfle50015ugvseftzhuy6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/Spring/Sping整合Log4j" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Sping%E6%95%B4%E5%90%88Log4j/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Sping%E6%95%B4%E5%90%88Log4j/">Spring整合Log4j</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Sping整合Log4j"><a href="#Sping整合Log4j" class="headerlink" title="Sping整合Log4j"></a>Sping整合Log4j</h1><h2 id="一、log4j日志简介"><a href="#一、log4j日志简介" class="headerlink" title="一、log4j日志简介"></a>一、log4j日志简介</h2><p>​        Log4j是Apache的一个开放源代码项目，通过使用Log4j，控制日志信息输送的目的地可以为控制台、文件、数据库、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；可以控制每一条日志的信息内容和信息输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；甚至还可以在不需要修改业务逻辑代码、重启web服务，只需要通过一个修改配置文件就可以实现控制项目的日志动作。</p>
<p>​        Log4j由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p>
<h2 id="二、定义配置文件"><a href="#二、定义配置文件" class="headerlink" title="二、定义配置文件"></a>二、定义配置文件</h2><p>​        其实您也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件（键=值）。下面我们介绍使用Java特性文件做为配置文件的方法：</p>
<h3 id="2-1、配置根Logger"><a href="#2-1、配置根Logger" class="headerlink" title="2.1、配置根Logger"></a>2.1、配置根Logger</h3><pre><code class="java">log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre>
<p>​        其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p>
<p>eg：</p>
<pre><code class="properties">### set log levels ###  
log4j.rootLogger = debug,stdout,D,E  
 
log4j.appender.stdout = org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.Target = System.out  
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout  
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  
 
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.D.File = F://logs/log.log  
log4j.appender.D.Append = true  
log4j.appender.D.Threshold = DEBUG   
log4j.appender.D.layout = org.apache.log4j.PatternLayout  
log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n  
 
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.E.File =F://logs/error.log   
log4j.appender.E.Append = true  
log4j.appender.E.Threshold = ERROR   
log4j.appender.E.layout = org.apache.log4j.PatternLayout  
log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n
</code></pre>
<h3 id="2-2、配置日志信息输出目的地Appender"><a href="#2-2、配置日志信息输出目的地Appender" class="headerlink" title="2.2、配置日志信息输出目的地Appender"></a>2.2、配置日志信息输出目的地Appender</h3><pre><code class="properties">log4j.appender.appenderName = fully.qualified.name.of.appender.class
 
log4j.appender.appenderName.option1 = value1
 
…
 
log4j.appender.appenderName.option = valueN
</code></pre>
<p>​        其中，Log4j提供的appender有以下几种：</p>
<pre><code class="properties">org.apache.log4j.ConsoleAppender（控制台），
 
org.apache.log4j.FileAppender（文件），
 
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），
 
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
 
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre>
<h3 id="2-3、配置日志信息的格式（布局）"><a href="#2-3、配置日志信息的格式（布局）" class="headerlink" title="2.3、配置日志信息的格式（布局）"></a>2.3、配置日志信息的格式（布局）</h3><pre><code class="properties">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
 
log4j.appender.appenderName.layout.option1 = value1
 
…
 
log4j.appender.appenderName.layout.option = valueN
</code></pre>
<p>​        其中，Log4j提供的layout有以e几种：</p>
<pre><code class="css">org.apache.log4j.HTMLLayout（以HTML表格形式布局），
 
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
 
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
 
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre>
<p>​        Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息</p>
<pre><code class="properties">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  
%r 输出自应用启动到输出该log信息耗费的毫秒数  
%c 输出所属的类目，通常就是所在类的全名  
%t 输出产生该日志事件的线程名  
%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  
%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  
%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)
</code></pre>
<p>首先，日志的级别有：OFF 、FATAL 、ERROR、WARN、INFO、DEBUG、TRACE 、ALL 等等。</p>
<ul>
<li><p>OFF：关闭了日志信息  </p>
</li>
<li><p>FATAL：可能导致应用中止的严重事件错误  </p>
</li>
<li><p>ERROR：严重错误 主要是程序的错误  </p>
</li>
<li><p>WARN：一般警告，比如session丢失  </p>
</li>
<li><p>INFO：一般要显示的信息，比如登录登出  </p>
</li>
<li><p>DEBUG：程序的调试信息  </p>
</li>
<li><p>TRACE：比DEBUG更细粒度的事件信息  </p>
</li>
<li><p>ALL：打开所有级别的日志</p>
</li>
</ul>
<p>log4j提供了一系列的Appender，允许将日志输送到不同的地方，如控制台、文件、数据库等：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.jdbc.JDBCAppender（数据库）</li>
<li>org.apache.log4j.net.SMTPAppender（邮件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h2 id="三、Spring框架整合log4j"><a href="#三、Spring框架整合log4j" class="headerlink" title="三、Spring框架整合log4j"></a>三、Spring框架整合log4j</h2><h3 id="3-1、pom-xml-引入log4j组件依赖包："><a href="#3-1、pom-xml-引入log4j组件依赖包：" class="headerlink" title="3.1、pom.xml 引入log4j组件依赖包："></a>3.1、pom.xml 引入log4j组件依赖包：</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："><a href="#3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：" class="headerlink" title="3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："></a>3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：</h3><pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:conf/log4j.properties&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;!-- 5000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; 
&lt;context-param&gt;
      &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;
      &lt;param-value&gt;5000&lt;/param-value&gt;
&lt;/context-param&gt;
 
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>​        首先是这个关于JavaWeb的工程的总配置位置。我们要在里面声明要使用Spring与Log4j。值得注意的Log4j的配置必须在Spring配置之前，否则如果先启动Spring，那个必须整合Log4j才不吐警告的Spring，由于Log4j还没有启动，找不到Spring，又会在任性地吐警告。当然，你设置那些什么优先级也行，不过，先启动的直接放前面，这个文件不是更好看吗？</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
    version=&quot;3.0&quot;&gt;
    &lt;!-- Log4j配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!-- 指定Log4j的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
    
    &lt;!-- Spring配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    
&lt;/web-app&gt;  
</code></pre>
<p>​        这里，我将log4j.properties配置文件存放到classpath的conf目录下，并启动一个watchdog线程每5秒扫描配置文件的变化，重新调整日志的策略，实现在不调整逻辑代码即可实现日志的策略变更。通过log4j.properties详细配置了日志的策略，如下：</p>
<pre><code class="properties"># +======================================================================+#
log4j.rootLogger=$&#123;log4j.log.level&#125;,$&#123;log4j.log.target&#125;
log4j.addivity.org.apache=true
# +======================================================================+#
# | [target] - Console
# +----------------------------------------------------------------------+#
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.CONSOLE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.CONSOLE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - FILE
# +----------------------------------------------------------------------+#
log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.FILE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.FILE.File=$&#123;log4j.log.dir&#125;/runtime.log
log4j.appender.FILE.Append=true
log4j.appender.FILE.MaxFileSize=2048KB
log4j.appender.FILE.MaxBackupIndex=10
log4j.appender.FILE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.FILE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - DATABASE
# +----------------------------------------------------------------------+#
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.DATABASE.Threshold=ERROR
log4j.appender.DATABASE.URL=jdbc:mysql://127.0.0.1:3306/spring
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver
log4j.appender.DATABASE.user=root
log4j.appender.DATABASE.password=liuriqi
log4j.appender.DATABASE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.DATABASE.sql=INSERT INTO tv_log4j(message)VALUES(&#39;$&#123;log4j.log.layout.pattern&#125;&#39;)
# +======================================================================+#
# | [target] - EMAIL
# +----------------------------------------------------------------------+#
log4j.appender.EMAIL=org.apache.log4j.net.SMTPAppender
log4j.appender.EMAIL.Threshold=FATAL
log4j.appender.EMAIL.BufferSize=10
log4j.appender.EMAIL.From=fromuser@gmail.com
log4j.appender.EMAIL.SMTPHost=localhost
log4j.appender.EMAIL.Subject=Log4J Message
log4j.appender.EMAIL.To=touser@gmail.com
log4j.appender.EMAIL.layout=$&#123;log4j.log.layout&#125;
log4j.appender.EMAIL.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
上面配置相关的变量，我提取出来统一放到变量配置文件里边，如下：
 
# +======================================================================+#
# | log4j config
# +----------------------------------------------------------------------+#
log4j.log.dir=logs/
#log4j.log.level=ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF
log4j.log.level=DEBUG
#log4j.log.target=CONSOLE,FILE,DATABASE,EMAIL,SOCKET
log4j.log.target=CONSOLE,FILE
log4j.log.encoding=UTF-8
log4j.log.layout=org.apache.log4j.PatternLayout
log4j.log.layout.pattern=[%d %r] [%-5p] [%t] [%l] [%m]%n
# +======================================================================+#
</code></pre>
<p>​        通过以上配置，在项目启动的时候，会将DEBUG日志信息发送到控制台和文件日志中。</p>
<p>​        另一种配置方式：</p>
<pre><code class="properties">#log4j.rootLogger = [ level ] , appenderName, appenderName, ...
log4j.rootLogger = all, console, R

#Console
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] %m%n

#File
log4j.appender.R = org.apache.log4j.RollingFileAppender
log4j.appender.R.File = c:/log.txt
log4j.appender.R.MaxFileSize = 500KB
log4j.appender.R.MaxBackupIndex = 1
log4j.appender.R.layout = org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] - %m%n
</code></pre>
<p>​        首先第一部分是log4j的总配置部分，all代表debug,info,error,fatal四种类型的信息都会输出。一般不设置为all。因为那些debug,info信息对我们半点意义没有，还因为有很多系统内部的文件运行都会输出debug与info信息刷屏、刷版。关键是输出到磁盘的日志文件会极速递增，浪费磁盘空间。玩SQL Server的时候大家又不知道那个.ldb是多么恐怖？</p>
<p>​        因此第一部分，一般写成：</p>
<pre><code class="properties">log4j.rootLogger = ERROR, console, R
</code></pre>
<p>​        代表仅输出error与fatal错误。<br>​        之后的console，R分别代表在控制台与文件输出。同时在之后的代码必须配置好这个两输出。</p>
<p>​        第二部分控制台#Console<br>​        首先要使用log4j特定的包，这个没有什么好说，最后一句指明输出格式。一会儿大招对照输出结果就明白怎么回事了。</p>
<p>​        第三部分文件#File</p>
<p>​        log4j.appender.R.File=c:/log.txt是指这个Web工程错误日志皆输出到c:/log.txt。不要像网上那些大神输出一个什么.log后缀，关键是能够直接打开。</p>
<p>​        之后log4j.appender.R.MaxFileSize = 500KB指明这个log.txt文件大小最多为500KB，如果超过这个大小，自动开一个新文件，而log4j.appender.R.MaxBackupIndex=1指明此工程顶多只能有1个这个的日志文件。注：新内容覆盖旧内容。</p>
<p>​        最后，可以在应用程序中采用log4j自带的debug()、info()、warn()、error()方法来记录你想要记录的操作，至于如何存储日志及日志的目的地发送的工作就交给log4j好了。</p>
<p>​        最后一点说明的问题：配置较低级别的错误日志策略会记录高级的错误信息，配置高级的错误日志策略会忽略低级错误信息。如将错误日志的level配置为debug，则log4j组件会记录包含debug以上所有的级别日志如debug、info、warn、error、fatal等。加入你配置的为error级别，则不会记录error以下级别的日志信息如debug、info、warn等等。</p>
<pre><code class="java">import org.apache.log4j.Logger;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
public class Log4jTest &#123;
     private static Logger logger =Logger.getLogger(Log4jTest.class);
     
     @RequestMapping(&quot;/log&quot;)
     public void writeLog() &#123;
            // 记录debug级别的信息    
            logger.debug(&quot;This is debug message.&quot;);    
            // 记录info级别的信息    
            logger.info(&quot;This is info message.&quot;);    
            // 记录error级别的信息    
            logger.error(&quot;This is error message.&quot;); 
     &#125;
     
&#125;
</code></pre>
<h2 id="四、Spring整合log4j2"><a href="#四、Spring整合log4j2" class="headerlink" title="四、Spring整合log4j2"></a>四、Spring整合log4j2</h2><p>4.1、pom.xml文件</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;!-- something --&gt;
 
        &lt;!-- log配置 --&gt;
        &lt;!-- 排除springboot原有的log依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 添加log4j2依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>4.2、log4j2.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 
&lt;!-- 日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL --&gt;
&lt;!-- status：设置log4j2本身的日志信息打印级别，可以不设置。当设置为info及以下级别时，在更改当前log4j2.xml文件后，自动检测功能发现xml文件有更改，将会打印更改日志，可以在console中看到。因此该status是log4j2.xml文件的日志设置。 --&gt;
&lt;!-- monitorInterval：设置间隔时间，单位为秒。Log4j2能够自动检测修改，并在monitorInterval设定的时间周期重新加载配置，无需重启应用 --&gt;
&lt;configuration status=&quot;info&quot; monitorInterval=&quot;5&quot;&gt;
    &lt;!-- 自定义属性 --&gt;
    &lt;Properties&gt;
        &lt;!-- 缺省配置（用于开发环境），配置日志文件输出目录和动态参数。其他环境需要在VM参数中指定； --&gt;
        &lt;!-- “sys:”表示：如果VM参数中没指定这个变量值，则使用本文件中定义的缺省全局变量值 --&gt;
        &lt;Property name=&quot;instance&quot;&gt;spring-boot-demo-log4j2&lt;/Property&gt;
        &lt;Property name=&quot;log.dir&quot;&gt;D:\log4j2&lt;/Property&gt;
    &lt;/Properties&gt;
    
    &lt;!-- 定义所有的appender --&gt;
    &lt;Appenders&gt;
        &lt;!--这个是输出控制台的配置--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT --&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!--输出日志的格式--&gt;
            &lt;!-- PatternLayout:输出格式，不设置默认为:%m%n --&gt;
            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%level] [%l] - %message%n&quot;/&gt;
            
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;accept&quot; onMismatch=&quot;deny&quot;/&gt;
            &lt;/Filters&gt;
        &lt;/Console&gt;
        
        &lt;!-- info及以上级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- fileName:指定输出日志的目的文件带全路径的文件名 --&gt;
        &lt;!-- filePattern:指定新建日志文件的名称格式 --&gt;
        &lt;RollingRandomAccessFile name=&quot;infoLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-info.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            
            &lt;!-- PatternLayout:日志输出格式，不设置默认为:%m%n --&gt;
            &lt;!-- &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%level][%class][%line]:%message%n&quot;/&gt; --&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;!-- 过滤器 --&gt;
            &lt;!-- 注意，这里要做一些特点说明： --&gt;
            &lt;!-- 等级大小关系为：OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL。 --&gt;
            &lt;!-- 在ThresholdFilter配置中，level属性是用来标识“匹配范围”的，且“被匹配（onMatch）范围”为该level及其以上的等级（例如level=&quot;WARN&quot;，那么onMatch范围为“OFF,FATAL,ERROR,WARN”），而“未匹配（onMismatch）范围”为所匹配途中剩下未被匹配的范围（例如level=&quot;WARN&quot;，那么onMismatch范围为“INFO,DEBUG,TRACE,ALL”）。 --&gt;
            &lt;!-- 需要注意，如果在一个&lt;Filters&gt;里面有多个&lt;ThresholdFilter&gt;，那么这些&lt;ThresholdFilter&gt;的书写是有上下关系的。 --&gt;
            &lt;!-- 写在上面的&lt;ThresholdFilter&gt;将通过level属性确定了已经匹配过的范围，那么，写在下面的&lt;ThresholdFilter&gt;的level必须在未被匹配的范围内选择，否则将无法生效（例如第一个&lt;ThresholdFilter&gt;中的level=&quot;WARN&quot;，那么第二个&lt;ThresholdFilter&gt;中的level属性值只能在“INFO、DEBUG、TRACE、ALL”里面选择）。 --&gt;
            &lt;!-- 因此，我们做一个规定： --&gt;
            &lt;!-- 在一个含有多个&lt;ThresholdFilter&gt;的&lt;Filters&gt;里面，在从上到下的&lt;ThresholdFilter&gt;列表顺序中，每一个&lt;ThresholdFilter&gt;中的level属性值我们规定必须由高等级至低等级填写。 --&gt;
            &lt;!-- 例如： --&gt;
            &lt;!-- 
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;XXX&quot;/&gt;
            --&gt;
            &lt;Filters&gt;
                &lt;!-- onMatch=&quot;ACCEPT&quot; 表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;DENY&quot; 表示拒绝该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;NEUTRAL&quot; 表示中立，该级别及以上的日志的onMatch通过性，将由下一个ThresholdFilter的onMatch属性处理，如果当前ThresholdFilter是最后一个，则表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMismatch=&quot;ACCEPT&quot; 表示允许该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;DENY&quot; 表示拒绝该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;NEUTRAL&quot; 表示中立，该级别以下的日志的onMismatch通过性，将由下一个ThresholdFilter的onMismatch属性处理，如果当前是最后一个，则允许该级别以下的日志--&gt;
                &lt;!-- level属性缺省，默认为level=&quot;ERROR&quot;，注意：缺省意思是没有该属性，而非level=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMatch属性缺省，默认为onMatch=&quot;accept&quot;，注意：缺省意思是没有该属性，而非onMatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMismatch属性缺省，默认为onMismatch=&quot;deny&quot;，注意：缺省意思是没有该属性，而非onMismatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;!-- Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 --&gt;
            &lt;Policies&gt;
                &lt;!-- 基于时间的滚动策略 --&gt;
                &lt;!-- interval：表示历史日志封存间隔时间，单位为hour，默认是1 --&gt;
                &lt;!-- modulate：表示是否历史日志生成时间纠偏，纠偏以零点为基准进行。比如：17:30生成了$&#123;instance&#125;-info-2019032817.log.gz文件，那么纠偏后会在18:00生成$&#123;instance&#125;-info-2019032818.log.gz --&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;!-- 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小 --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
            
            &lt;!-- DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个(通过max属性定义)日志文件时开始删除最旧的，创建新的 --&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot;&gt;
                &lt;Delete basePath=&quot;$&#123;log.dir&#125;&quot; maxDepth=&quot;1&quot;&gt;
                    &lt;IfFileName glob=&quot;*.log.gz&quot; /&gt;
                    &lt;!-- 小时：H，天：d --&gt;
                    &lt;IfLastModified age=&quot;5d&quot; /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
 
        &lt;!-- warn级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;warnLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-warn.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- error级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;errorLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-error.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- 测试日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;testLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-test.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-test-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;deny&quot; onMismatch=&quot;accept&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
    &lt;/Appenders&gt;
    
    &lt;!-- 用来配置Logger，包含一个root和若干个logger --&gt;
    &lt;!-- additivity指定是否同时输出当前logger的父类的日志，缺省为true --&gt;
    &lt;!-- 一个logger可以绑定多个不同的Appender。只有定义了logger并通过AppenderRef引入appender，该appender才会生效 --&gt;
    &lt;!-- &lt;logger&gt;可以不配置&lt;AppenderRef&gt;，这样可以控制指定的包在控制台的日志打印，而无需考虑日志文件的存储问题 --&gt;
    &lt;!--     （等效于在application.properties文件配置logging.level.xxx=LEVEL，xxx代指包名，如org.apache.kafka，LEVEL代指日志基本，如error等） --&gt;
    &lt;!--     （例如要屏蔽org.apache.kafka包下的所用日志打印，则可以这样写logging.level.org.apache.kafka=off） --&gt;
    &lt;Loggers&gt;
        &lt;!-- Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 --&gt;
        &lt;!-- additivity：这个属性的意思是需不需要打印此logger继承的父logger，默认为true，如果是false则只打印当前logger；如果是true则继续打印上一层的logger，直到root --&gt;
        &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- 屏蔽kafka的日志打印 --&gt;
        &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;off&quot;&gt;&lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.config&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.web&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;testLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- Root节点用来指定项目的根日志，如果没有类似上面所配置的单独指定的logger，那么就会默认使用该Root日志输出 --&gt;
        &lt;!-- &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt; --&gt;
        &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt;
            &lt;!-- 用来指定该日志输出到哪个Appender --&gt;
            &lt;AppenderRef ref=&quot;Console&quot;/&gt;
        &lt;/Root&gt;
 
        &lt;!-- AsyncRoot - 异步记录日志 - 需要LMAXDisruptor的支持 --&gt;
        &lt;!--
        &lt;AsyncRoot level=&quot;info&quot; additivity=&quot;false&quot;&gt;
          &lt;AppenderRef ref=&quot;Console&quot;/&gt;
          &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
          &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/AsyncRoot&gt;
        --&gt;
    &lt;/Loggers&gt;
 
&lt;/configuration&gt;
</code></pre>
<p>参数说明</p>
<pre><code>    ********************************************************************************************************************
    参数        说明                                         举例                    输出显示媒介
    ********************************************************************************************************************
    %c          列出logger名字空间的全称，如果加上&#123;&lt;层数&gt;&#125;，   假设当前logger的命名空间是&quot;a.b.c&quot;
                则表示列出从最内层算起的指定层数的名字空间
                                                            %c                  a.b.c
                                                            %c&#123;2&#125;               b.c
                                                            %20c                （若名字空间长度小于20，则左边用空格填充）
                                                            %-20c               （若名字空间长度小于20，则右边用空格填充）
                                                            %.30c               （若名字空间长度超过30，截去多余字符）
                                                            %20.30c             （若名字空间长度小于20，则左边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
                                                            %-20.30c            （若名字空间长度小于20，则右边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
    ********************************************************************************************************************
    %C          列出调用logger的类的全名（包含包路径）         假设当前类是&quot;org.apache.xyz.SomeClass&quot;
                                                            %C                  org.apache.xyz.SomeClass
                                                            %C&#123;1&#125;               SomeClass
    %class
    ********************************************************************************************************************
    %d          显示日志记录时间，&#123;&lt;日期格式&gt;&#125;使用ISO8601定义的日期格式
                                                            %d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;     2005/10/12 22:23:30,117
                                                            %d&#123;ABSOLUTE&#125;        22:23:30,117
                                                            %d&#123;DATE&#125;            12 Oct 2005 22:23:30,117
                                                            %d&#123;ISO8601&#125;         2005-10-12 22:23:30,117
    ********************************************************************************************************************
    %F          显示调用logger的源文件名                     %F                   MyClass.java
    ********************************************************************************************************************
    %l          显示日志事件的发生位置，包含包路径、方法名、
                源文件名，以及在代码中的行数                  %l                   com.a.b.MyClass.main(MyClass.java:168)
    ********************************************************************************************************************
    %L          显示调用logger的代码行                       %L                   129
    %line                                                  %line                129
    ********************************************************************************************************************
    %level      显示该条日志的优先级                         %level               INFO
    %p                                                     %p                   INFO
    ********************************************************************************************************************
    %m          显示输出消息                                 %m                  This is a message for debug.
    %message                                                %message            This is a message for debug.
    ********************************************************************************************************************
    %M          显示调用logger的方法名                       %M                   main
    ********************************************************************************************************************
    %n          当前平台下的换行符                           %n                   Windows平台下表示rn，UNIX平台下表示n
    ********************************************************************************************************************
    %p          显示该条日志的优先级                         %p                   INFO
    %level                                                 %level               INFO
    ********************************************************************************************************************
    %r          显示从程序启动时到记录该条日志时已经经过的毫秒数  %r                 1215
    ********************************************************************************************************************
    %t          输出产生该日志事件的线程名                    %t                   http-nio-8080-exec-10
    %thread                                                 %thread              http-nio-8080-exec-10
    ********************************************************************************************************************
    %x          按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志           假设某程序调用顺序是MyApp调用com.foo.Bar
                                                            %c %x - %m%n        MyApp - Call com.foo.Bar.
                                                                                com.foo.Bar - Log in Bar
                                                                                MyApp - Return to MyApp.
    ********************************************************************************************************************
    %X          按MDC（Mapped Diagnostic Context，线程映射表）
                输出日志。通常用于多个客户端连接同一台服务器，
                方便服务器区分是那个客户端访问留下来的日志。     %X&#123;5&#125;             （记录代号为5的客户端的日志）
    ********************************************************************************************************************
    %%          显示一个百分号                               %%                  %
    ********************************************************************************************************************
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Sping%E6%95%B4%E5%90%88Log4j/" data-id="cl0utfle60019ugvs5bdi8g2z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/SpringBoot/SpringBoot使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">SpringBoot使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringBoot使用详解"><a href="#SpringBoot使用详解" class="headerlink" title="SpringBoot使用详解"></a>SpringBoot使用详解</h1><h2 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h2><p>​        什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p>
<p>​        所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p>
<p>​        这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p>
<p>​        随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p>
<p>​        Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置</strong>的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>
<p>​        简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p><strong>Spring Boot的主要优点：</strong></p>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<h2 id="二、HelloSpringBoot"><a href="#二、HelloSpringBoot" class="headerlink" title="二、HelloSpringBoot"></a>二、HelloSpringBoot</h2><h3 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h3><p><strong>环境准备：</strong></p>
<ul>
<li>java version “1.8.0_181”</li>
<li>Maven-3.6.1</li>
<li>SpringBoot 2.x 最新版</li>
</ul>
<h3 id="2-2、创建项目说明"><a href="#2-2、创建项目说明" class="headerlink" title="2.2、创建项目说明"></a>2.2、创建项目说明</h3><p>Spring官方提供了非常方便的工具让我们快速构建应用</p>
<p>Spring Initializr：<a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p><strong>项目创建方式一：</strong>使用Spring Initializr 的 Web页面创建项目</p>
<p>1、打开  <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p>2、填写项目信息</p>
<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>
<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>
<p><strong>项目创建方式二：</strong>使用 IDEA 直接创建项目</p>
<p>1、创建一个新项目</p>
<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>
<p>3、填写项目信息</p>
<p>4、选择初始化的组件（初学勾选 Web 即可）</p>
<p>5、填写项目路径</p>
<p>6、等待项目构建成功</p>
<p><strong>项目结构分析：</strong></p>
<p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p>
<p>1、程序的主启动类</p>
<p>2、一个 application.properties 配置文件</p>
<p>3、一个 测试类</p>
<p>4、一个 pom.xml</p>
<h3 id="2-3、搭建项目"><a href="#2-3、搭建项目" class="headerlink" title="2.3、搭建项目"></a>2.3、搭建项目</h3><p><strong>pom.xml分析</strong></p>
<pre><code class="xml">&lt;!-- 父依赖 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!-- web场景启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- springboot单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;!-- 剔除依赖 --&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 打包插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p><strong>http接口类</strong></p>
<p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p>
<p>2、在包中新建一个HelloController类</p>
<pre><code class="java">@RestController
public class HelloController &#123;

    @RequestMapping(&quot;/hello&quot;)
    public String hello() &#123;
        return &quot;Hello World&quot;;
    &#125;
    
&#125;
</code></pre>
<p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p>
<h3 id="2-4、打包项目"><a href="#2-4、打包项目" class="headerlink" title="2.4、打包项目"></a>2.4、打包项目</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZiczfno2TOQbfItia25xQzicMFnkicKh5pVD7IrHrUicb03y381CicrLFKXNMw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果遇到以上错误，可以配置打包时，跳过项目运行测试用例</p>
<pre><code class="xml">&lt;!--
    在工作中,很多情况下我们打包是不想执行测试用例的
    可能是测试用例不完事,或是测试用例会影响数据库数据
    跳过测试用例执
    --&gt;

&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;!--跳过项目运行测试用例--&gt;
        &lt;skipTests&gt;true&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>如果打包成功，则会在target目录下生成一个 jar 包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZic03vupvIqMbibWh4aIKyjiaQfwuvDWKo033g9kRvj6aXnJO4brKTdwnvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、SpringBoot运行原理"><a href="#三、SpringBoot运行原理" class="headerlink" title="三、SpringBoot运行原理"></a>三、SpringBoot运行原理</h2><h3 id="3-1、pom-xml"><a href="#3-1、pom-xml" class="headerlink" title="3.1、pom.xml"></a>3.1、pom.xml</h3><h4 id="3-1-1、父依赖"><a href="#3-1-1、父依赖" class="headerlink" title="3.1.1、父依赖"></a>3.1.1、父依赖</h4><p>​        其中它主要是依赖一个父项目，主要是<strong>管理项目的资源过滤及插件</strong>！</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>​        点进去，发现还有一个父依赖</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>​        这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的<strong>版本控制中心</strong>；</p>
<p>​        <strong>注</strong>：导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</p>
<h4 id="3-1-2、启动类-spring-boot-starter"><a href="#3-1-2、启动类-spring-boot-starter" class="headerlink" title="3.1.2、启动类 spring-boot-starter"></a>3.1.2、启动类 spring-boot-starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>​        SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h3 id="3-2、主启动类"><a href="#3-2、主启动类" class="headerlink" title="3.2、主启动类"></a>3.2、主启动类</h3><h4 id="3-2-1、默认的主启动类"><a href="#3-2-1、默认的主启动类" class="headerlink" title="3.2.1、默认的主启动类"></a>3.2.1、默认的主启动类</h4><pre><code class="java">//@SpringBootApplication 来标注一个主程序类
//说明这是一个Spring Boot应用

@SpringBootApplication
public class SpringbootApplication &#123;

   public static void main(String[] args) &#123;
     //以为是启动了一个方法，没想到启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   &#125;

&#125;
</code></pre>
<h4 id="3-2-2、-SpringBootApplication"><a href="#3-2-2、-SpringBootApplication" class="headerlink" title="3.2.2、@SpringBootApplication"></a>3.2.2、@SpringBootApplication</h4><p>​        作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<pre><code class="java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
public @interface SpringBootApplication &#123;
    // ......
&#125;
</code></pre>
<h4 id="3-2-3、-ComponentScan"><a href="#3-2-3、-ComponentScan" class="headerlink" title="3.2.3、@ComponentScan"></a>3.2.3、@ComponentScan</h4><p>​        这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>​        作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h4 id="3-2-4、-SpringBootConfiguration"><a href="#3-2-4、-SpringBootConfiguration" class="headerlink" title="3.2.4、@SpringBootConfiguration"></a>3.2.4、@SpringBootConfiguration</h4><p>​        作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>​        继续查看注解：</p>
<pre><code class="java">// 点进去得到下面的 @Component
@Configuration
public @interface SpringBootConfiguration &#123;&#125;

@Component
public @interface Configuration &#123;&#125;
</code></pre>
<p>​        这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>​        里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>​        我们回到 SpringBootApplication 注解中继续看。</p>
<h4 id="3-2-5、-EnableAutoConfiguration"><a href="#3-2-5、-EnableAutoConfiguration" class="headerlink" title="3.2.5、@EnableAutoConfiguration"></a>3.2.5、@EnableAutoConfiguration</h4><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>​        以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>​        点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<pre><code class="java">@Import(&#123;Registrar.class&#125;)
public @interface AutoConfigurationPackage &#123;
&#125;
</code></pre>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>​        Registrar.class 作用：<u>将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器</u> ；</p>
<p>​        这个分析完了，退到上一步，继续看</p>
<p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<p>​        AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<pre><code class="java">// 获得候选的配置
protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
    // 这里的getSpringFactoriesLoaderFactoryClass（）方法
    // 返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
&#125;
</code></pre>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！查看SpringFactoriesLoader类loadFactoryNames() 方法</p>
<pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;
    String factoryClassName = factoryClass.getName();
    //这里它又调用了 loadSpringFactories 方法
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
&#125;
</code></pre>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<pre><code class="ava">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;
    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) &#123;
        return result;
    &#125; else &#123;
        try &#123;
            //去获取一个资源 &quot;META-INF/spring.factories&quot;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            //将读取到的资源遍历，封装成为一个Properties
            while(urls.hasMoreElements()) &#123;
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) &#123;
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    &#125;
                &#125;
            &#125;

            cache.put(classLoader, result);
            return result;
        &#125; catch (IOException var13) &#123;
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、发现一个多次出现的文件：spring.factories，进行全局搜索</p>
<h4 id="3-2-6、spring-factories"><a href="#3-2-6、spring-factories" class="headerlink" title="3.2.6、spring.factories"></a>3.2.6、spring.factories</h4><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicEIZDCZKtTPxQrKTvEdxHFGsG824OkO8XN8CfP2x4OdpC8DwjHYwcFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicaV7UfSRiaRdCHNmHE1wS10QwbLEVZJLB2sN9ztcvjx7n2dKDJ0HrCmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>​        所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值；</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<h3 id="3-3、SpringApplication"><a href="#3-3、SpringApplication" class="headerlink" title="3.3、SpringApplication"></a>3.3、SpringApplication</h3><h4 id="3-3-1、不简单的方法"><a href="#3-3-1、不简单的方法" class="headerlink" title="3.3.1、不简单的方法"></a>3.3.1、不简单的方法</h4><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p>
<pre><code class="java">@SpringBootApplication
public class SpringbootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootApplication.class, args);
    &#125;
&#125;
</code></pre>
<p><strong>SpringApplication.run分析</strong></p>
<p>​        分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<h4 id="3-3-2、SpringApplication"><a href="#3-3-2、SpringApplication" class="headerlink" title="3.3.2、SpringApplication"></a>3.3.2、SpringApplication</h4><p><strong>这个类主要做了以下四件事情：</strong></p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
&#125;
</code></pre>
<h4 id="3-3-3、run方法流程分析"><a href="#3-3-3、run方法流程分析" class="headerlink" title="3.3.3、run方法流程分析"></a>3.3.3、run方法流程分析</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="四、yaml配置注入"><a href="#四、yaml配置注入" class="headerlink" title="四、yaml配置注入"></a>四、yaml配置注入</h2><h3 id="4-1、配置文件"><a href="#4-1、配置文件" class="headerlink" title="4.1、配置文件"></a>4.1、配置文件</h3><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li><p>application.properties</p>
</li>
<li><ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li><p>application.yml</p>
</li>
<li><ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<h3 id="4-2、使用yaml"><a href="#4-2、使用yaml" class="headerlink" title="4.2、使用yaml"></a>4.2、使用yaml</h3><h4 id="4-2-1、yaml概述"><a href="#4-2-1、yaml概述" class="headerlink" title="4.2.1、yaml概述"></a>4.2.1、yaml概述</h4><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p>
<p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p>
<h4 id="4-2-2、yaml基础语法"><a href="#4-2-2、yaml基础语法" class="headerlink" title="4.2.2、yaml基础语法"></a>4.2.2、yaml基础语法</h4><p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: “kuang \n shen”  输出 ：kuang  换行  shen</p>
</li>
<li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘kuang \n shen’  输出 ：kuang  \n  shen</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="yaml">#对象、Map格式
k: 
    v1:
    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="yaml">student:
    name: qinjiang
    age: 3
</code></pre>
<p>行内写法</p>
<pre><code class="yaml">student: &#123;name: qinjiang,age: 3&#125;
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="yaml">server:
  port: 8082
</code></pre>
<h3 id="4-3、注入配置文件"><a href="#4-3、注入配置文件" class="headerlink" title="4.3、注入配置文件"></a>4.3、注入配置文件</h3><h4 id="4-3-1、yaml注入配置文件"><a href="#4-3-1、yaml注入配置文件" class="headerlink" title="4.3.1、yaml注入配置文件"></a>4.3.1、yaml注入配置文件</h4><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="java">package com.kuang.springboot.pojo;
@Component  //注册bean到容器中
public class Dog &#123;    
    private String name;    
    private Integer age;        
    //有参无参构造、get、set方法、toString()方法  
&#125;
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="java">@Component //注册bean
public class Dog &#123;    
    @Value(&quot;阿黄&quot;)    
    private String name;    
    @Value(&quot;18&quot;)    
    private Integer age;
&#125;
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;
    @Autowired //将狗狗自动注入进来    
    Dog dog;
    @Test    
    public void contextLoads() &#123;                            System.out.println(dog); //打印看下狗狗对象    
    &#125;
&#125;
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYUjoO9N8358vr0uTf3KR0FP0C5QOC3uQOIrlcuy7v0jmkXw0PPM4U5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="java">@Component //注册bean到容器中
public class Person &#123;
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
&#125;
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="yaml">person:
  name: qinjiang
  age: 3
  happy: false
  birth: 2000/01/01
  maps: &#123;k1: v1,k2: v2&#125;
  lists:
   - code
   - girl
   - music
  dog:
    name: 旺财
    age: 1
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="java">/*
    @ConfigurationProperties作用：
    将配置文件中配置的每一个属性的值，映射到这个组件中；
    告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
    参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person &#123;
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
&#125;
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYFrPO6PAYI7eQAEVzql1Sfic03AbzpiboQLP9eWo5I2McfQ2dicibIibh0fw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYhxNnwKv6bDsrCvMS4OscxxV0EWU7ibUD9G0N164rxEUNfaT9NFTVU4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() &#123;
        System.out.println(person); //打印person信息
    &#125;

&#125;
</code></pre>
<p>结果：所有值全部注入成功！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYTwpS5awY7ja8vibH3ncyGbgj69gSkKc80UN2AFNvTqotgkYMbw5K6zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-2、加载指定的配置文件"><a href="#4-3-2、加载指定的配置文件" class="headerlink" title="4.3.2、加载指定的配置文件"></a>4.3.2、加载指定的配置文件</h4><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="properties">name=kuangshen
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person &#123;

    @Value(&quot;$&#123;name&#125;&quot;)
    private String name;

    ......  
&#125;
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYAyueVvGpddTEkyGqCwbKsJrfQCbkWrZAFdL3ibMwTYhLKE9GclVyQ7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-3、配置文件占位符"><a href="#4-3-3、配置文件占位符" class="headerlink" title="4.3.3、配置文件占位符"></a>4.3.3、配置文件占位符</h4><p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="yaml">person:
    name: qinjiang$&#123;random.uuid&#125; # 随机uuid
    age: $&#123;random.int&#125;  # 随机int
    happy: false
    birth: 2000/01/01
    maps: &#123;k1: v1,k2: v2&#125;
    lists:
      - code
      - girl
      - music
    dog:
      name: $&#123;person.hello:other&#125;_旺财
      age: 1
</code></pre>
<h4 id="4-3-4、回顾properties配置"><a href="#4-3-4、回顾properties配置" class="headerlink" title="4.3.4、回顾properties配置"></a>4.3.4、回顾properties配置</h4><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings–&gt;FileEncodings 中配置；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYAr9nCaBDe8o7JeMWACZicQkicqrVMeiaWFgrTamHjc668RNx4c4z8UcXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="java">@Component //注册bean
public class User &#123;
    private String name;
    private int age;
    private String sex;
&#125;
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="properties">user1.name=kuangshen
user1.age=18
user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User &#123;
    //直接使用@value
    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SPEL&#125; Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
&#125;
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;

    @Autowired
    User user;

    @Test
    public void contextLoads() &#123;
        System.out.println(user);
    &#125;

&#125;
</code></pre>
<p>结果正常输出：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYxFwDQMxmyVQjVPt794RCuhfVOEbqDrpH2u84DT8y01xAhuQh47AFYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-4、对比"><a href="#4-3-4、对比" class="headerlink" title="4.3.4、对比"></a>4.3.4、对比</h4><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYjMibiaov73iaTsiaWEPoArDcAB1Ooibx9uR5JxtacIuicHblEtUI9SrySX2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
<h2 id="五、JSR303数据校验及多环境切换"><a href="#五、JSR303数据校验及多环境切换" class="headerlink" title="五、JSR303数据校验及多环境切换"></a>五、JSR303数据校验及多环境切换</h2><h3 id="5-1、JSR303数据校验"><a href="#5-1、JSR303数据校验" class="headerlink" title="5.1、JSR303数据校验"></a>5.1、JSR303数据校验</h3><h4 id="5-1-1、使用"><a href="#5-1-1、使用" class="headerlink" title="5.1.1、使用"></a>5.1.1、使用</h4><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<pre><code class="java">@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated  //数据校验
public class Person &#123;

    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式
    private String name;
&#125;
</code></pre>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDYdR5f05BDysj0YVJMxadN0psDJKzXe7zyTrL9wFpTEHoiba0MsM11Fw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>使用数据校验，可以保证数据的正确性；</strong> </p>
<h4 id="5-1-2、常见参数"><a href="#5-1-2、常见参数" class="headerlink" title="5.1.2、常见参数"></a>5.1.2、常见参数</h4><pre><code>@NotNull(message=&quot;名字不能为空&quot;)
private String userName;
@Max(value=120,message=&quot;年龄最大不能查过120&quot;)
private int age;
@Email(message=&quot;邮箱格式错误&quot;)
private String email;

空检查
@Null       验证对象是否为null
@NotNull    验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   检查约束元素是否为NULL或者是EMPTY.
    
Booelan检查
@AssertTrue     验证 Boolean 对象是否为 true  
@AssertFalse    验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) string is between min and max included.

日期检查
@Past       验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    验证 String 对象是否符合正则表达式的规则

.......等等
除此以外，我们还可以自定义一些数据校验规则
</code></pre>
<h3 id="5-2、多环境切换"><a href="#5-2、多环境切换" class="headerlink" title="5.2、多环境切换"></a>5.2、多环境切换</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<pre><code class="properties">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<h4 id="5-2-1、yaml的多文档块"><a href="#5-2-1、yaml的多文档块" class="headerlink" title="5.2.1、yaml的多文档块"></a>5.2.1、yaml的多文档块</h4><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<pre><code class="yaml">server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: prod

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<h4 id="5-2-2、配置文件加载位置"><a href="#5-2-2、配置文件加载位置" class="headerlink" title="5.2.2、配置文件加载位置"></a>5.2.2、配置文件加载位置</h4><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>官方外部配置文件说明参考文档</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDUoiazZ6ehegLG4doZK0uSJHribIqwVKiaNibSaYZSgjZf4kGzhLdGrkzzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<pre><code class="yaml">#配置项目的访问路径
server.servlet.context-path=/kuang
</code></pre>
<h4 id="5-2-3、运维小技巧"><a href="#5-2-3、运维小技巧" class="headerlink" title="5.2.3、运维小技巧"></a>5.2.3、运维小技巧</h4><p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<pre><code class="shell">java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
</code></pre>
<h2 id="六、自动配置原理"><a href="#六、自动配置原理" class="headerlink" title="六、自动配置原理"></a>六、自动配置原理</h2><h3 id="6-1、分析自动配置原理"><a href="#6-1、分析自动配置原理" class="headerlink" title="6.1、分析自动配置原理"></a>6.1、分析自动配置原理</h3><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<pre><code class="java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
@Configuration 

//启动指定类的ConfigurationProperties功能；
  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
  //并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) 

//Spring底层@Conditional注解
  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
  //如果不存在，判断也是成立的
  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = &#123;&quot;enabled&quot;&#125;,
    matchIfMissing = true
)

public class HttpEncodingAutoConfiguration &#123;
    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;
        this.properties = properties.getEncoding();
    &#125;
    
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() &#123;
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    &#125;
    //。。。。。。。
&#125;
</code></pre>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<pre><code class="java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;) 
public class HttpProperties &#123;
    // .....
&#125;
</code></pre>
<p>我们去配置文件里面试试前缀，看提示！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD4hfI8rrZuGnuFRBjKdaR8mvkyuGfHG1IxBPw0vcTP5LoXIJT9davlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="6-2、深入理解"><a href="#6-2、深入理解" class="headerlink" title="6.2、深入理解"></a>6.2、深入理解</h3><p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<h3 id="6-3、了解-Conditional"><a href="#6-3、了解-Conditional" class="headerlink" title="6.3、了解@Conditional"></a>6.3、了解@Conditional</h3><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDGcJRvdK3PtqHPAWYBBmpe1XBVjQJeiatU4vasEaxckHlOga1BV9RPaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<pre><code class="yaml">#开启springboot的调试类
debug=true
</code></pre>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
<h2 id="七、自定义Starter"><a href="#七、自定义Starter" class="headerlink" title="七、自定义Starter"></a>七、自定义Starter</h2><h3 id="7-1、说明"><a href="#7-1、说明" class="headerlink" title="7.1、说明"></a>7.1、说明</h3><p>启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库；</p>
<p><strong>命名归约：</strong></p>
<p>官方命名：</p>
<ul>
<li>前缀：spring-boot-starter-xxx</li>
<li>比如：spring-boot-starter-web….</li>
</ul>
<p>自定义命名：</p>
<ul>
<li>xxx-spring-boot-starter</li>
<li>比如：mybatis-spring-boot-starter</li>
</ul>
<h3 id="7-2、编写启动器"><a href="#7-2、编写启动器" class="headerlink" title="7.2、编写启动器"></a>7.2、编写启动器</h3><p>1、在IDEA中新建一个空项目 spring-boot-starter-diy</p>
<p>2、新建一个普通Maven模块：kuang-spring-boot-starter</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD3ibDQhiaQib3L94Y8joxBzUfegDicVpSamYoysTZ54lMp3oXw0cprPIPQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDhebhQQvGxRRLX8FezGo8Qk3bGEQElY6K2SqeDazGUZ6XqLDMvq6RDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、点击apply即可，基本结构</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDTPIzxXJqk27EGiaIBJtSpic5NcibXFX2eHXMxezmURLbibFXahiaFk5uW4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、在我们的 starter 中 导入  autoconfigure 的依赖！</p>
<pre><code class="xml">&lt;!-- 启动器 --&gt;
&lt;dependencies&gt;
    &lt;!--  引入自动配置模块 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDNLrzEP3HC2HYHicHmmLGian64wdOw3wiauDttoUbQLMdX4XcFV2HqyVvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>7、我们编写一个自己的服务</p>
<pre><code class="java">package com.kuang;

public class HelloService &#123;

    HelloProperties helloProperties;

    public HelloProperties getHelloProperties() &#123;
        return helloProperties;
    &#125;

    public void setHelloProperties(HelloProperties helloProperties) &#123;
        this.helloProperties = helloProperties;
    &#125;

    public String sayHello(String name)&#123;
        return helloProperties.getPrefix() + name + helloProperties.getSuffix();
    &#125;

&#125;
</code></pre>
<p>8、编写HelloProperties 配置类</p>
<pre><code class="java">package com.kuang;

import org.springframework.boot.context.properties.ConfigurationProperties;

// 前缀 kuang.hello
@ConfigurationProperties(prefix = &quot;kuang.hello&quot;)
public class HelloProperties &#123;

    private String prefix;
    private String suffix;

    public String getPrefix() &#123;
        return prefix;
    &#125;

    public void setPrefix(String prefix) &#123;
        this.prefix = prefix;
    &#125;

    public String getSuffix() &#123;
        return suffix;
    &#125;

    public void setSuffix(String suffix) &#123;
        this.suffix = suffix;
    &#125;
&#125;
</code></pre>
<p>9、编写我们的自动配置类并注入bean，测试！</p>
<pre><code class="java">package com.kuang;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication //web应用生效
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration &#123;

    @Autowired
    HelloProperties helloProperties;

    @Bean
    public HelloService helloService()&#123;
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    &#125;

&#125;
</code></pre>
<p>10、在resources编写一个自己的 META-INF\spring.factories</p>
<pre><code class="xml"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.kuang.HelloServiceAutoConfiguration
</code></pre>
<p>11、编写完成后，可以安装到maven仓库中！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDmUxYwOTicxVZGSRD3H93l6SLJCEDGXiaxpO6ciaicUbwiaA9FmJiaQhnhicTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、测试启动器"><a href="#7-3、测试启动器" class="headerlink" title="7.3、测试启动器"></a>7.3、测试启动器</h3><p>1、新建一个SpringBoot 项目</p>
<p>2、导入我们自己写的启动器</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.kuang&lt;/groupId&gt;
    &lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写一个 HelloController  进行测试我们自己的写的接口！</p>
<pre><code class="java">
package com.kuang.controller;

@RestController
public class HelloController &#123;

    @Autowired
    HelloService helloService;

    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        return helloService.sayHello(&quot;zxc&quot;);
    &#125;

&#125;
</code></pre>
<p>4、编写配置文件 application.properties</p>
<pre><code class="properties">
kuang.hello.prefix=&quot;ppp&quot;
kuang.hello.suffix=&quot;sss&quot;
</code></pre>
<p>5、启动项目进行测试，结果成功 !</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDTCQ0YaF3yVM8icJ1jKJ6frZibJuegdk4FwEfOUbia4tBABndicA9kV1efg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="八、整合JDBC"><a href="#八、整合JDBC" class="headerlink" title="八、整合JDBC"></a>八、整合JDBC</h2><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<p>Sping Data 官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p>
<p>数据库相关的启动器 ：可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>
<h3 id="8-1、测试数据源"><a href="#8-1、测试数据源" class="headerlink" title="8.1、测试数据源"></a>8.1、测试数据源</h3><p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuW0A5wz8gu4q4AMoBCoYic2Juyiate9VBZe4S0sgkCZVFV2lD6quLKVZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写yaml配置文件连接数据库；</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>
<pre><code class="java">@SpringBootTest
class SpringbootDataJdbcApplicationTests &#123;

    //DI注入数据源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException &#123;
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection =   dataSource.getConnection();
        System.out.println(connection);
        //关闭连接
        connection.close();
    &#125;
&#125;
</code></pre>
<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>
<p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p>
<pre><code class="java">@Import(
    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;
)
protected static class PooledDataSourceConfiguration &#123;
    protected PooledDataSourceConfiguration() &#123;
    &#125;
&#125;
</code></pre>
<p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p>
<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>
<p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p>
<p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>
<h3 id="8-2、JDBCTemplate"><a href="#8-2、JDBCTemplate" class="headerlink" title="8.2、JDBCTemplate"></a>8.2、JDBCTemplate</h3><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="8-3、测试"><a href="#8-3、测试" class="headerlink" title="8.3、测试"></a>8.3、测试</h3><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/jdbc&quot;)
public class JdbcController &#123;

    /**
     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate
     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作
     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接
     */
    @Autowired
    JdbcTemplate jdbcTemplate;

    //查询employee表中所有数据
    //List 中的1个 Map 对应数据库的 1行数据
    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值
    @GetMapping(&quot;/list&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;
        String sql = &quot;select * from employee&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);
        return maps;
    &#125;
    
    //新增一个用户
    @GetMapping(&quot;/add&quot;)
    public String addUser()&#123;
        //插入语句，注意时间问题
        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +
                &quot; values (&#39;狂神说&#39;,&#39;24736743@qq.com&#39;,1,101,&#39;&quot;+ new Date().toLocaleString() +&quot;&#39;)&quot;;
        jdbcTemplate.update(sql);
        //查询
        return &quot;addOk&quot;;
    &#125;

    //修改用户信息
    @GetMapping(&quot;/update/&#123;id&#125;&quot;)
    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;
        //插入语句
        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;
        //数据
        Object[] objects = new Object[2];
        objects[0] = &quot;秦疆&quot;;
        objects[1] = &quot;24736743@sina.com&quot;;
        jdbcTemplate.update(sql,objects);
        //查询
        return &quot;updateOk&quot;;
    &#125;

    //删除用户
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;
        //插入语句
        String sql = &quot;delete from employee where id=?&quot;;
        jdbcTemplate.update(sql,id);
        //查询
        return &quot;deleteOk&quot;;
    &#125;
    
&#125;
</code></pre>
<h2 id="九、整合Druid"><a href="#九、整合Druid" class="headerlink" title="九、整合Druid"></a>九、整合Druid</h2><h3 id="9-1、Druid简介"><a href="#9-1、Druid简介" class="headerlink" title="9.1、Druid简介"></a>9.1、Druid简介</h3><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p>
<p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeupdhDcaDPRLHgnULFbaJB5kPtC8n5QVLaUbbTRfa4ZyqficzZYrd2llA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeubiciawTdz0tg1EKDjZ1xaIgjRW9CZ4Apr4hvNz3iaQVQIKS3sXy629Lgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuaVD6mK3LJrtZ4B6fRKCLDgYicAVGzTUTzWdCNB5lF4tLpbcCT0uq1EA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="9-2、配置数据源"><a href="#9-2、配置数据源" class="headerlink" title="9.2、配置数据源"></a>9.2、配置数据源</h3><p>1、添加上 Druid 数据源依赖。</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.21&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源
</code></pre>
<p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuuxN8UrBxIAhgFpAvyQOgKyZLVbPXRhtvVO764zeJpXiaBFTX2e4cYVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
</code></pre>
<p>5、导入Log4j 的依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<pre><code class="java">package com.kuang.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DruidConfig &#123;

    /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效
       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中
     */
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druidDataSource() &#123;
        return new DruidDataSource();
    &#125;

&#125;
</code></pre>
<p>7、去测试类中测试一下；看是否成功！</p>
<pre><code class="java">@SpringBootTest
class SpringbootDataJdbcApplicationTests &#123;

    //DI注入数据源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException &#123;
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection =   dataSource.getConnection();
        System.out.println(connection);

        DruidDataSource druidDataSource = (DruidDataSource) dataSource;
        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());
        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());

        //关闭连接
        connection.close();
    &#125;
&#125;
</code></pre>
<p>输出结果 ：可见配置参数已经生效！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeu14qkV9vFaME5ficcLe7MqPFgOH4iaEicia05eNNkSvhoVhWodykDXMtUcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="9-3、配置Druid数据源监控"><a href="#9-3、配置Druid数据源监控" class="headerlink" title="9.3、配置Druid数据源监控"></a>9.3、配置Druid数据源监控</h3><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<pre><code class="java">//配置 Druid 监控管理后台的Servlet；
//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式
@Bean
public ServletRegistrationBean statViewServlet() &#123;
    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);

    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet 
    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号
    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码

    //后台允许谁可以访问
    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问
    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问
    initParams.put(&quot;allow&quot;, &quot;&quot;);
    //deny：Druid 后台拒绝谁访问
    //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问

    //设置初始化参数
    bean.setInitParameters(initParams);
    return bean;
&#125;
</code></pre>
<p>配置完毕后，我们可以选择访问 ：<a target="_blank" rel="noopener" href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeu5TbyjT1Hib2vCDW9988ibXicDcXEnvooGfvNbchJrZ7TUwe3wJm0ktooA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>进入之后</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuaibKTBtqpoSiaZib9WTRdZaZhIYBRLB8Em7a5aLGw88uKjR8UCian11yCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<pre><code class="java">//配置 Druid 监控 之  web 监控的 filter
//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计
@Bean
public FilterRegistrationBean webStatFilter() &#123;
    FilterRegistrationBean bean = new FilterRegistrationBean();
    bean.setFilter(new WebStatFilter());

    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);
    bean.setInitParameters(initParams);

    //&quot;/*&quot; 表示过滤所有请求
    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
    return bean;
&#125;
</code></pre>
<h2 id="十、整合Mybaits"><a href="#十、整合Mybaits" class="headerlink" title="十、整合Mybaits"></a>十、整合Mybaits</h2><p>官方文档：<a target="_blank" rel="noopener" href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>
<p>Maven仓库地址：<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</a></p>
<h3 id="10-1、整合"><a href="#10-1、整合" class="headerlink" title="10.1、整合"></a>10.1、整合</h3><p>1、导入 MyBatis 所需要的依赖</p>
<pre><code class="xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置数据库连接信息（不变）</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
</code></pre>
<p><strong>3、测试数据库是否连接成功！</strong></p>
<p><strong>4、创建实体类，导入 Lombok！</strong></p>
<p>Department.java</p>
<pre><code class="java">package com.kuang.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Department &#123;

    private Integer id;
    private String departmentName;

&#125;
</code></pre>
<p><strong>5、创建mapper目录以及对应的 Mapper 接口</strong></p>
<p>DepartmentMapper.java</p>
<pre><code class="java">//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface DepartmentMapper &#123;

    // 获取所有部门信息
    List&lt;Department&gt; getDepartments();

    // 通过id获得部门
    Department getDepartment(Integer id);

&#125;
</code></pre>
<p><strong>6、对应的Mapper映射文件</strong></p>
<p>DepartmentMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.DepartmentMapper&quot;&gt;

    &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt;
       select * from department;
    &lt;/select&gt;

    &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt;
       select * from department where id = #&#123;id&#125;;
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p><strong>7、maven配置资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<p><strong>8、编写部门的 DepartmentController 进行测试！</strong></p>
<pre><code class="java">@RestController
public class DepartmentController &#123;
    
    @Autowired
    DepartmentMapper departmentMapper;
    
    // 查询全部部门
    @GetMapping(&quot;/getDepartments&quot;)
    public List&lt;Department&gt; getDepartments()&#123;
        return departmentMapper.getDepartments();
    &#125;

    // 查询全部部门
    @GetMapping(&quot;/getDepartment/&#123;id&#125;&quot;)
    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return departmentMapper.getDepartment(id);
    &#125;
    
&#125;
</code></pre>
<h3 id="10-2、测试"><a href="#10-2、测试" class="headerlink" title="10.2、测试"></a>10.2、测试</h3><p>1、新建一个pojo类 Employee ；</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Employee &#123;

    private Integer id;
    private String lastName;
    private String email;
    //1 male, 0 female
    private Integer gender;
    private Integer department;
    private Date birth;

    private Department eDepartment; // 冗余设计

&#125;
</code></pre>
<p>2、新建一个 EmployeeMapper 接口</p>
<pre><code class="java">//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface EmployeeMapper &#123;

    // 获取所有员工信息
    List&lt;Employee&gt; getEmployees();

    // 新增一个员工
    int save(Employee employee);

    // 通过id获得员工信息
    Employee get(Integer id);

    // 通过id删除员工
    int delete(Integer id);

&#125;
</code></pre>
<p>3、编写 EmployeeMapper.xml 配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.EmployeeMapper&quot;&gt;

    &lt;resultMap id=&quot;EmployeeMap&quot; type=&quot;Employee&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;eid&quot;/&gt;
        &lt;result property=&quot;lastName&quot; column=&quot;last_name&quot;/&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
        &lt;result property=&quot;gender&quot; column=&quot;gender&quot;/&gt;
        &lt;result property=&quot;birth&quot; column=&quot;birth&quot;/&gt;
        &lt;association property=&quot;eDepartment&quot;  javaType=&quot;Department&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;did&quot;/&gt;
            &lt;result property=&quot;departmentName&quot; column=&quot;dname&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;getEmployees&quot; resultMap=&quot;EmployeeMap&quot;&gt;
        select e.id as eid,last_name,email,gender,birth,d.id as did,d.department_name as dname
        from department d,employee e
        where d.id = e.department
    &lt;/select&gt;

    &lt;insert id=&quot;save&quot; parameterType=&quot;Employee&quot;&gt;
        insert into employee (last_name,email,gender,department,birth)
        values (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;department&#125;,#&#123;birth&#125;);
    &lt;/insert&gt;

    &lt;select id=&quot;get&quot; resultType=&quot;Employee&quot;&gt;
        select * from employee where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt;
        delete from employee where id = #&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p>4、编写EmployeeController类进行测试</p>
<pre><code class="java">@RestController
public class EmployeeController &#123;

    @Autowired
    EmployeeMapper employeeMapper;

    // 获取所有员工信息
    @GetMapping(&quot;/getEmployees&quot;)
    public List&lt;Employee&gt; getEmployees()&#123;
        return employeeMapper.getEmployees();
    &#125;

    @GetMapping(&quot;/save&quot;)
    public int save()&#123;
        Employee employee = new Employee();
        employee.setLastName(&quot;kuangshen&quot;);
        employee.setEmail(&quot;qinjiang@qq.com&quot;);
        employee.setGender(1);
        employee.setDepartment(101);
        employee.setBirth(new Date());
        return employeeMapper.save(employee);
    &#125;

    // 通过id获得员工信息
    @GetMapping(&quot;/get/&#123;id&#125;&quot;)
    public Employee get(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return employeeMapper.get(id);
    &#125;

    // 通过id删除员工
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    public int delete(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return employeeMapper.delete(id);
    &#125;

&#125;
</code></pre>
<h2 id="十一、Web开发以及静态资源处理"><a href="#十一、Web开发以及静态资源处理" class="headerlink" title="十一、Web开发以及静态资源处理"></a>十一、Web开发以及静态资源处理</h2><h3 id="11-1、Web开发"><a href="#11-1、Web开发" class="headerlink" title="11.1、Web开发"></a>11.1、Web开发</h3><p>好的，同学们，那么接下来呢，我们开始学习SpringBoot与Web开发，从这一章往后，就属于我们实战部分的内容了；</p>
<p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。</p>
<p><strong>使用SpringBoot的步骤：</strong></p>
<p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p>
<p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p>
<p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p>
<p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p>
<p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p>
<ul>
<li>向容器中自动配置组件 ：*** Autoconfiguration</li>
<li>自动配置类，封装配置文件的内容：***Properties</li>
</ul>
<p>没事就找找类，看看自动装配原理！</p>
<p>我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！</p>
<h3 id="11-2、静态资源处理"><a href="#11-2、静态资源处理" class="headerlink" title="11.2、静态资源处理"></a>11.2、静态资源处理</h3><h4 id="11-2-1、静态资源映射规则"><a href="#11-2-1、静态资源映射规则" class="headerlink" title="11.2.1、静态资源映射规则"></a>11.2.1、静态资源映射规则</h4><p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<pre><code class="java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
    if (!this.resourceProperties.isAddMappings()) &#123;
        // 已禁用默认资源处理
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    &#125;
    // 缓存控制
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    // webjars 配置
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    &#125;
    // 静态资源配置
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    &#125;
&#125;
</code></pre>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h4 id="11-2-2、什么是webjars"><a href="#11-2-2、什么是webjars" class="headerlink" title="11.2.2、什么是webjars"></a>11.2.2、什么是webjars</h4><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：<a target="_blank" rel="noopener" href="https://www.webjars.org/">https://www.webjars.org</a> </p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<pre><code class="xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6wt4N51VrTR1uzYBRo97UEoMJSnY1I0475oCajSe50e3tW5j0SXVwRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6JzDrsHnyDZbfzsBxwR77xMoM2ia3ic9b8uyOngzt3aH8QztXugXM2jhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="11-2-3、第二种静态资源映射规则"><a href="#11-2-3、第二种静态资源映射规则" class="headerlink" title="11.2.3、第二种静态资源映射规则"></a>11.2.3、第二种静态资源映射规则</h4><p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<pre><code class="java">// 进入方法
public String[] getStaticLocations() &#123;
    return this.staticLocations;
&#125;
// 找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
// 找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
&#125;;
</code></pre>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<pre><code>&quot;classpath:/META-INF/resources/&quot;
&quot;classpath:/resources/&quot;
&quot;classpath:/static/&quot;
&quot;classpath:/public/&quot;
</code></pre>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 <a target="_blank" rel="noopener" href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h4 id="11-2-4、自定义静态资源路径"><a href="#11-2-4、自定义静态资源路径" class="headerlink" title="11.2.4、自定义静态资源路径"></a>11.2.4、自定义静态资源路径</h4><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<pre><code class="properties">spring.resources.static-locations=classpath:/coding/,classpath:/kuang/
</code></pre>
<p>spring.resources.static-locations=classpath:/coding/,classpath:/kuang/</p>
<h3 id="11-3、首页处理"><a href="#11-3、首页处理" class="headerlink" title="11.3、首页处理"></a>11.3、首页处理</h3><p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<pre><code class="java">
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                                                           FormattingConversionService mvcConversionService,
                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页
        this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
&#125;
点进去继续看

private Optional&lt;Resource&gt; getWelcomePage() &#123;
    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
    // ::是java8 中新引入的运算符
    // Class::function的时候function是属于Class的，应该是静态方法。
    // this::function的funtion是属于这个对象的。
    // 简而言之，就是一种语法糖而已，是一种简写
    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
&#125;
// 欢迎页就是一个location下的的 index.html 而已
private Resource getIndexHtml(String location) &#123;
    return this.resourceLoader.getResource(location + &quot;index.html&quot;);
&#125;
</code></pre>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p>
<p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a>  看结果！</p>
<p><strong>关于网站图标说明</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6ugmXIE9bON3P8hrtQAZDLnEaG1OPLNcGsuOZGGPibLGgLBuG5pqgibpQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<p>1、关闭SpringBoot默认图标</p>
<pre><code class="properties">
#关闭默认图标
spring.mvc.favicon.enabled=false
</code></pre>
<p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p>
<p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6awkOYiaHoiatBZQrAeAO2MFRWC5kUuyWur0XMIXHAcV8ORgM90fIaVNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十二、Thymeleaf"><a href="#十二、Thymeleaf" class="headerlink" title="十二、Thymeleaf"></a>十二、Thymeleaf</h2><h3 id="12-1、模板引擎"><a href="#12-1、模板引擎" class="headerlink" title="12.1、模板引擎"></a>12.1、模板引擎</h3><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6V42bcomyzTYY0q6ic7AB8lvciaoicxyalNYQYZgslIrIjdXWLFNcOxUmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h3 id="12-2、引入Thymeleaf"><a href="#12-2、引入Thymeleaf" class="headerlink" title="12.2、引入Thymeleaf"></a>12.2、引入Thymeleaf</h3><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>Thymeleaf 在Github 的主页：<a target="_blank" rel="noopener" href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p>
<p>Spring官方文档：找到我们对应的版本</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> </p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<pre><code class="xml">
&lt;!--thymeleaf--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6o4dAJHKh0872nmgaPYMaQDJ8KWfHJYWyoMXHW2pmVOtLVnREViaTziaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="12-3、Thymeleaf分析"><a href="#12-3、Thymeleaf分析" class="headerlink" title="12.3、Thymeleaf分析"></a>12.3、Thymeleaf分析</h3><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<pre><code class="java">
@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties &#123;
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = &quot;classpath:/templates/&quot;;
    private String suffix = &quot;.html&quot;;
    private String mode = &quot;HTML&quot;;
    private Charset encoding;
&#125;
</code></pre>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<h3 id="12-4、测试"><a href="#12-4、测试" class="headerlink" title="12.4、测试"></a>12.4、测试</h3><p>1、编写一个TestController</p>
<pre><code class="java">
@Controller
public class TestController &#123;
    
    @RequestMapping(&quot;/t1&quot;)
    public String test1()&#123;
        //classpath:/templates/test.html
        return &quot;test&quot;;
    &#125;
    
&#125;
</code></pre>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<pre><code class="xml">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目请求测试</p>
<h3 id="12-5、Thymeleaf-语法学习"><a href="#12-5、Thymeleaf-语法学习" class="headerlink" title="12.5、Thymeleaf 语法学习"></a>12.5、Thymeleaf 语法学习</h3><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<pre><code class="java">
@RequestMapping(&quot;/t1&quot;)
public String test1(Model model)&#123;
    //存入数据
    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
    //classpath:/templates/test.html
    return &quot;test&quot;;
&#125;
</code></pre>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<pre><code class="xml">
 xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>3、我们去编写下前端页面</p>
<pre><code class="xml">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;狂神说&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;
&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、启动测试！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ia0fYFrNsXdHekjLfPlq4ZMpF0rtPzFRBTWsw6K8zic3ywna1LgcM6Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6fGYIwv043icVDYuybRJDCGTSNTMEibFzzMdlKS4t07TQoicQJKQAe0slQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2、我们能写哪些表达式呢？</strong></p>
<pre><code>Simple expressions:（表达式语法）
Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：#18
         #ctx : the context object.
         #vars: the context variables.
         #locale : the context locale.
         #request : (only in Web Contexts) the HttpServletRequest object.
         #response : (only in Web Contexts) the HttpServletResponse object.
         #session : (only in Web Contexts) the HttpSession object.
         #servletContext : (only in Web Contexts) the ServletContext object.

    3）、内置的一些工具对象：
　　　　　　#execInfo : information about the template being processed.
　　　　　　#uris : methods for escaping parts of URLs/URIs
　　　　　　#conversions : methods for executing the configured conversion service (if any).
　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
　　　　　　#numbers : methods for formatting numeric objects.
　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
　　　　　　#objects : methods for objects in general.
　　　　　　#bools : methods for boolean evaluation.
　　　　　　#arrays : methods for arrays.
　　　　　　#lists : methods for lists.
　　　　　　#sets : methods for sets.
　　　　　　#maps : methods for maps.
　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
==================================================================================

  Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；
  Message Expressions: #&#123;...&#125;：获取国际化内容
  Link URL Expressions: @&#123;...&#125;：定义URL；
  Fragment Expressions: ~&#123;...&#125;：片段引用表达式

Literals（字面量）
      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
      
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is $&#123;name&#125;|
    
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
    
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
    
Special tokens:
    No-Operation: _
</code></pre>
<h4 id="12-5-2、测试"><a href="#12-5-2、测试" class="headerlink" title="12.5.2、测试"></a>12.5.2、测试</h4><p>1、 我们编写一个Controller，放一些数据</p>
<pre><code class="java">
@RequestMapping(&quot;/t2&quot;)
public String test2(Map&lt;String,Object&gt; map)&#123;
    //存入数据
    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);
    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));
    //classpath:/templates/test.html
    return &quot;test&quot;;
&#125;
</code></pre>
<p>2、测试页面取出数据</p>
<pre><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;狂神说&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;
&lt;!--不转义--&gt;
&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;

&lt;!--遍历数据--&gt;
&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;
&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;

&lt;h4&gt;
    &lt;!--行内写法：官网#12--&gt;
    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;
&lt;/h4&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目测试！</p>
<h2 id="十三、MVC自动配置原理"><a href="#十三、MVC自动配置原理" class="headerlink" title="十三、MVC自动配置原理"></a>十三、MVC自动配置原理</h2><h3 id="13-1、官网阅读"><a href="#13-1、官网阅读" class="headerlink" title="13.1、官网阅读"></a>13.1、官网阅读</h3><p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<pre><code>Spring MVC Auto-configuration
// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
// 自动配置在Spring默认设置的基础上添加了以下功能：
The auto-configuration adds the following features on top of Spring’s defaults:
// 包含视图解析器
Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
// 支持静态资源文件夹的路径，以及webjars
Support for serving static resources, including support for WebJars 
// 自动注册了Converter：
// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型
// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】
Automatic registration of Converter, GenericConverter, and Formatter beans.
// HttpMessageConverters
// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；
Support for HttpMessageConverters (covered later in this document).
// 定义错误代码生成规则的
Automatic registration of MessageCodesResolver (covered later in this document).
// 首页定制
Static index.html support.
// 图标定制
Custom Favicon support (covered later in this document).
// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！
Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).

/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h3 id="13-2、ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#13-2、ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="13.2、ContentNegotiatingViewResolver 内容协商视图解析器"></a>13.2、<strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h3><p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<pre><code class="java">
@Bean
@ConditionalOnBean(ViewResolver.class)
@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)
public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;
    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级
    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return resolver;
&#125;
</code></pre>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<pre><code class="java">@Nullable // 注解说明：@Nullable 即参数可为null
public View resolveViewName(String viewName, Locale locale) throws Exception &#123;
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) &#123;
        // 获取候选的视图对象
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        // 选择一个最适合的视图对象，然后把这个对象返回
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) &#123;
            return bestView;
        &#125;
    &#125;
    // .....
&#125;
</code></pre>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<pre><code class="java">
Iterator var5 = this.viewResolvers.iterator();
</code></pre>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong> </p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<pre><code class="java">
protected void initServletContext(ServletContext servletContext) &#123;
    // 这里它是从beanFactory工具中获取容器中的所有视图解析器
    // ViewRescolver.class 把所有的视图解析器来组合的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;
    if (this.viewResolvers == null) &#123;
        this.viewResolvers = new ArrayList(matchingBeans.size());
    &#125;
    // ...............
&#125;
</code></pre>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<pre><code class="java">
@Bean //放到bean中
public ViewResolver myViewResolver()&#123;
    return new MyViewResolver();
&#125;

//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口
private static class MyViewResolver implements ViewResolver&#123;
    @Override
    public View resolveViewName(String s, Locale locale) throws Exception &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6QBbBv34R87hGpeWiaPnuYhBG1FlfdhtZxlIKicA2Y4kHy9XqRicibmQkWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；</p>
<p>找到this</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6NnU4IPDPs8jKYRjDJGia7t3C5YgjCSHuiaxlpthKpBwGh9m6icsF5zuow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找到视图解析器，我们看到我们自己定义的就在这里了；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp67xW1M2s2aOnolP1tAedrqAtUuBHRjz7ALePedpHkpz9MXVyLwe6wYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h3 id="13-3、转换器和格式化器"><a href="#13-3、转换器和格式化器" class="headerlink" title="13.3、转换器和格式化器"></a>13.3、转换器和格式化器</h3><p>找到格式化转换器：</p>
<pre><code class="java">
@Bean
@Override
public FormattingConversionService mvcConversionService() &#123;
    // 拿到配置文件中的格式化规则
    WebConversionService conversionService = 
        new WebConversionService(this.mvcProperties.getDateFormat());
    addFormatters(conversionService);
    return conversionService;
&#125;
</code></pre>
<p>点进去：</p>
<pre><code class="java">
public String getDateFormat() &#123;
    return this.dateFormat;
&#125;

/**
* Date format to use. For instance, `dd/MM/yyyy`. 默认的
 */
private String dateFormat;
</code></pre>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6zdySrKJPkADN9jtsIpz6QPOyC2nI04l0EiaAOMuU47pwiaPq2RrhUdaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="13-4、修改SpringBoot的默认配置"><a href="#13-4、修改SpringBoot的默认配置" class="headerlink" title="13.4、修改SpringBoot的默认配置"></a>13.4、修改SpringBoot的默认配置</h3><p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<pre><code class="java">
//应为类型要求为WebMvcConfigurer，所以我们实现其接口
//可以使用自定义类扩展MVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer &#123;

    @Override
    public void addViewControllers(ViewControllerRegistry registry) &#123;
        // 浏览器发送/test ， 就会跳转到test页面；
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);
    &#125;
&#125;
</code></pre>
<p>我们去浏览器访问一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6smNnW3fpooPSQpiaoMajpXYGDoH0aQnv8awIibPa9eKkJhewdMrTtLTg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<pre><code class="java">
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    
  // 从容器中获取所有的webmvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;
        if (!CollectionUtils.isEmpty(configurers)) &#123;
            this.configurers.addWebMvcConfigurers(configurers);
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<pre><code class="java">
protected void addViewControllers(ViewControllerRegistry registry) &#123;
    this.configurers.addViewControllers(registry);
&#125;
</code></pre>
<p>5、我们点进去看一下</p>
<pre><code class="java">
public void addViewControllers(ViewControllerRegistry registry) &#123;
    Iterator var2 = this.delegates.iterator();

    while(var2.hasNext()) &#123;
        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
        delegate.addViewControllers(registry);
    &#125;

&#125;
</code></pre>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h3 id="13-5、全面接管SpringMVC"><a href="#13-5、全面接管SpringMVC" class="headerlink" title="13.5、全面接管SpringMVC"></a>13.5、全面接管SpringMVC</h3><p>官方文档：</p>
<pre><code>
If you want to take complete control of Spring MVC
you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ic2wzwiaMd6YwOHuK1fcn3ibhuXD60XiarS9NLdTIDJJicFZJt1wQ0ibuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>给配置类加上注解：@EnableWebMvc</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp68kRH4rPKMyhAdkIL46HW90qsSoyMcNibRxDbfu7iboWM6AMRr5tFSicPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<pre><code class="java">
@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)
public @interface EnableWebMvc &#123;
&#125;
</code></pre>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<pre><code class="java">
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;
  // ......
&#125;
</code></pre>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<pre><code class="java">
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
    ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;
    
&#125;
</code></pre>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<h2 id="十四、国际化"><a href="#十四、国际化" class="headerlink" title="十四、国际化"></a>十四、国际化</h2><h3 id="14-1、准备工作"><a href="#14-1、准备工作" class="headerlink" title="14.1、准备工作"></a>14.1、准备工作</h3><p>先在IDEA中统一设置properties的编码问题！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETgrgicvxqgYPVvcBGBcyId5qbK4pZ6iaFW6DU8DaTibNOqwybhxvvBiapZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h3 id="14-2、配置文件编写"><a href="#14-2、配置文件编写" class="headerlink" title="14.2、配置文件编写"></a>14.2、配置文件编写</h3><p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETBiaXib28mib2iaUyqOTW1VXCLK6b55N9Jy2AbA96KRSyQjCkgCibhDaWung/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们可以在这上面去新建一个文件；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETozDglSZ32ZAdIRzuqn8NicymJyZQUMXIq0icYPwzNstBJdO3dXL1CbRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>弹出如下页面：我们再添加一个英文的；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETv0bcvSfWDIdiaTYIoPL7BhLRb8wb0vAbNmMCpxrkAibibAwVtAJV55tEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETMSkXZicouLDxJiaUbyWRTB3Vib2UBxJWEIqxL5reXbkXT8iaYNQOn2M9Bg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETp6raySXNEHanXLFuq4OsCJOQ0DBKibQyohPUDen5OUYsfYIPD9tFjBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETru2CdF5btNFhLdCCkusK5VkJRIfnBic8iaScfKkkKfFcBQ90pexU05Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们添加一下首页的内容！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETRPAF4T1brBr2pBydUuNjlkkUtThqlJCKN4lQ2rCN0BXrn957u3CdlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后依次添加其他页面内容即可！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETA91ZDRtZ4hBZ1dtn7CLZ9xzlwfDpUhqT8sTQmCncsLYEH5r0fIFF9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<pre><code>login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>英文：</p>
<pre><code>
login.btn=Sign in
login.password=Password
login.remember=Remember me
login.tip=Please sign in
login.username=Username
</code></pre>
<p>中文：</p>
<pre><code>
login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<h3 id="14-3、配置文件生效探究"><a href="#14-3、配置文件生效探究" class="headerlink" title="14.3、配置文件生效探究"></a>14.3、配置文件生效探究</h3><p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<pre><code class="java">// 获取 properties 传递过来的值进行判断
@Bean
public MessageSource messageSource(MessageSourceProperties properties) &#123;
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) &#123;
        // 设置国际化文件的基础名（去掉语言国家代码的）
        messageSource.setBasenames(
            StringUtils.commaDelimitedListToStringArray(
                                       StringUtils.trimAllWhitespace(properties.getBasename())));
    &#125;
    if (properties.getEncoding() != null) &#123;
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    &#125;
    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) &#123;
        messageSource.setCacheMillis(cacheDuration.toMillis());
    &#125;
    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
&#125;
</code></pre>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<pre><code class="xml">
spring.messages.basename=i18n.login
</code></pre>
<h3 id="14-4、配置页面国际化值"><a href="#14-4、配置页面国际化值" class="headerlink" title="14.4、配置页面国际化值"></a>14.4、配置页面国际化值</h3><p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETbj7aBK25N5G2NGibmb9LmHGySYic9myjX0pZ7EOcBfYC03c1yBFEBxfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETN9iagOo88CAiaDf4d09lGGBsEhzdpsz2libgVuHdeBdWPc6QUMZficxFJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="14-5、配置国际化解析"><a href="#14-5、配置国际化解析" class="headerlink" title="14.5、配置国际化解析"></a>14.5、配置国际化解析</h3><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<pre><code class="java">
@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() &#123;
    // 容器中没有就自己配，有的话就用用户配置的
    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    &#125;
    // 接收头国际化分解
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
&#125;
</code></pre>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<pre><code class="java">
public Locale resolveLocale(HttpServletRequest request) &#123;
    Locale defaultLocale = this.getDefaultLocale();
    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123;
        return defaultLocale;
    &#125; else &#123;
        Locale requestLocale = request.getLocale();
        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();
        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123;
            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);
            if (supportedLocale != null) &#123;
                return supportedLocale;
            &#125; else &#123;
                return defaultLocale != null ? defaultLocale : requestLocale;
            &#125;
        &#125; else &#123;
            return requestLocale;
        &#125;
    &#125;
&#125;
</code></pre>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<pre><code class="xml">
&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;/a&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;en_US&#39;)&#125;&quot;&gt;English&lt;/a&gt;
</code></pre>
<p>我们去写一个处理的组件类！</p>
<pre><code class="java">package com.kuang.component;

import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

//可以在链接上携带区域信息
public class MyLocaleResolver implements LocaleResolver &#123;

    //解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest request) &#123;

        String language = request.getParameter(&quot;l&quot;);
        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的
        //如果请求链接不为空
        if (!StringUtils.isEmpty(language))&#123;
            //分割请求参数
            String[] split = language.split(&quot;_&quot;);
            //国家，地区
            locale = new Locale(split[0],split[1]);
        &#125;
        return locale;
    &#125;

    @Override
    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;

    &#125;
&#125;
</code></pre>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean；</p>
<pre><code class="java">
@Bean
public LocaleResolver localeResolver()&#123;
    return new MyLocaleResolver();
&#125;
</code></pre>
<h2 id="十五、集成Swagger"><a href="#十五、集成Swagger" class="headerlink" title="十五、集成Swagger"></a>十五、集成Swagger</h2><h3 id="15-1、Swagger简介"><a href="#15-1、Swagger简介" class="headerlink" title="15.1、Swagger简介"></a>15.1、Swagger简介</h3><p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a target="_blank" rel="noopener" href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h3 id="15-2、SpringBoot整合Swagger"><a href="#15-2、SpringBoot整合Swagger" class="headerlink" title="15.2、SpringBoot整合Swagger"></a>15.2、SpringBoot整合Swagger</h3><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong>Springfox-swagger2</strong></li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<pre><code class="java">@Configuration //配置类
@EnableSwagger2// 开启Swagger2的自动配置
public class SwaggerConfig &#123;  
&#125;
</code></pre>
<p>5、访问测试 ：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZzSgcwYhS2RhtRXv0Wfg9OkiaE6xDEQibt8TSJTt9OHzFzeq9NrQCJNZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-3、配置Swagger"><a href="#15-3、配置Swagger" class="headerlink" title="15.3、配置Swagger"></a>15.3、配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<pre><code>@Bean //配置docket以配置Swagger具体参数
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2);
&#125;
</code></pre>
<p>2、可以通过apiInfo()属性配置文档信息</p>
<pre><code>//配置文档信息
private ApiInfo apiInfo() &#123;
   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);
   return new ApiInfo(
           &quot;Swagger学习&quot;, // 标题
           &quot;学习演示如何配置Swagger&quot;, // 描述
           &quot;v1.0&quot;, // 版本
           &quot;http://terms.service.url/组织链接&quot;, // 组织链接
           contact, // 联系人信息
           &quot;Apach 2.0 许可&quot;, // 许可
           &quot;许可链接&quot;, // 许可连接
           new ArrayList&lt;&gt;()// 扩展
  );
&#125;
</code></pre>
<p>3、Docket 实例关联上 apiInfo()</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
&#125;
</code></pre>
<p>4、重启项目，访问测试 <a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h3 id="15-4、配置扫描接口"><a href="#15-4、配置扫描接口" class="headerlink" title="15.4、配置扫描接口"></a>15.4、配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
      .build();
&#125;
</code></pre>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<pre><code>any() // 扫描所有，项目中的所有接口都会被扫描到
none() // 不扫描接口
// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求
withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)
// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口
withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)
basePackage(final String basePackage) // 根据包路径扫描接口
</code></pre>
<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>5、这里的可选值还有</p>
<pre><code>any() // 任何请求都扫描
none() // 任何请求都不扫描
regex(final String pathRegex) // 通过正则表达式控制
ant(final String antPattern) // 通过ant()控制
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zbja0VwsQkjaNVC5GWsge3SlQeg0jmxdjBMLOoOsqqD6gc6jshv4Qdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-5、配置Swagger开关"><a href="#15-5、配置Swagger开关" class="headerlink" title="15.5、配置Swagger开关"></a>15.5、配置Swagger开关</h3><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<pre><code>@Bean
public Docket docket(Environment environment) &#123;
   // 设置要显示swagger的环境
   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);
   // 判断当前是否处于该环境
   // 通过 enable() 接收此参数判断是否要显示
   boolean b = environment.acceptsProfiles(of);
   
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>3、可以在项目中增加一个dev的配置文件查看效果！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zf87yQGBYZKyqCsjP79C67S0NgdOmrQWJ7tkpPsdkrWQeQiaIZia7VD8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-6、配置API分组"><a href="#15-6、配置API分组" class="headerlink" title="15.6、配置API分组"></a>15.6、配置API分组</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Z7k4Y8iaVnHtPd78o82ff8hItej9Cyf0wvbG8u8KgXic7gVh77NoZw4RQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<pre><code>@Bean
public Docket docket(Environment environment) &#123;
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
      .groupName(&quot;hello&quot;) // 配置分组
       // 省略配置....
&#125;
</code></pre>
<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<pre><code>@Bean
public Docket docket1()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);
&#125;
@Bean
public Docket docket2()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);
&#125;
@Bean
public Docket docket3()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);
&#125;
</code></pre>
<p>4、重启项目查看即可</p>
<h3 id="15-7、实体配置"><a href="#15-7、实体配置" class="headerlink" title="15.7、实体配置"></a>15.7、实体配置</h3><p>1、新建一个实体类</p>
<pre><code>@ApiModel(&quot;用户实体&quot;)
public class User &#123;
   @ApiModelProperty(&quot;用户名&quot;)
   public String username;
   @ApiModelProperty(&quot;密码&quot;)
   public String password;
&#125;
</code></pre>
<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<pre><code>@RequestMapping(&quot;/getUser&quot;)
public User getUser()&#123;
   return new User();
&#125;
</code></pre>
<p>3、重启查看测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZS0qBoaXrHX5r42ic5kUDzv5gaiaVqVeMBne4TDe5JLRPqRShgY3WiaQPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="15-8、常用注解"><a href="#15-8、常用注解" class="headerlink" title="15.8、常用注解"></a>15.8、常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody></table>
<p>我们也可以给请求的接口配置一些注释</p>
<pre><code>@ApiOperation(&quot;狂神的接口&quot;)
@PostMapping(&quot;/kuang&quot;)
@ResponseBody
public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;
   return username;
&#125;
</code></pre>
<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="15-9、拓展"><a href="#15-9、拓展" class="headerlink" title="15.9、拓展"></a>15.9、拓展</h3><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<p>1、默认的  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZrYUroibnsmILAYo1PyuaSDAkrqUvlNibxW9S9niaRomPFd9rrD6SY4wjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、bootstrap-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
   &lt;version&gt;1.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZxQ9fXkPFt9TtX6PiaPDWWFSCJQK6H0ibiagM2w2f99zqHuOJffyRycCIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、Layui-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;
   &lt;version&gt;1.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZYA6g5VyspYIqFMokAGg7dbx47P2ibC8Z80saA7XdrByPFhgmrduSHbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、mg-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;
   &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZBJPCcHFicV2dklg3l88IuYia3OIFNfNVbWZXpppPS93jghTUJiaeJQx6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十六、异步、定时、邮件任务"><a href="#十六、异步、定时、邮件任务" class="headerlink" title="十六、异步、定时、邮件任务"></a>十六、异步、定时、邮件任务</h2><h3 id="16-1、异步任务"><a href="#16-1、异步任务" class="headerlink" title="16.1、异步任务"></a>16.1、异步任务</h3><p>1、创建一个service包</p>
<p>2、创建一个类AsyncService</p>
<p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
<p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<pre><code>@Service
public class AsyncService &#123;

   public void hello()&#123;
       try &#123;
           Thread.sleep(3000);
      &#125; catch (InterruptedException e) &#123;
           e.printStackTrace();
      &#125;
       System.out.println(&quot;业务进行中....&quot;);
  &#125;
&#125;
</code></pre>
<p>3、编写controller包</p>
<p>4、编写AsyncController类</p>
<p>我们去写一个Controller测试一下</p>
<pre><code>@RestController
public class AsyncController &#123;

   @Autowired
   AsyncService asyncService;

   @GetMapping(&quot;/hello&quot;)
   public String hello()&#123;
       asyncService.hello();
       return &quot;success&quot;;
  &#125;

&#125;
</code></pre>
<p>5、访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C3%E7%A7%92%E5%90%8E%E5%87%BA%E7%8E%B0success%EF%BC%8C%E8%BF%99%E6%98%AF%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a></p>
<p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p>
<p>6、给hello方法添加@Async注解；</p>
<pre><code>//告诉Spring这是一个异步方法
@Async
public void hello()&#123;
   try &#123;
       Thread.sleep(3000);
  &#125; catch (InterruptedException e) &#123;
       e.printStackTrace();
  &#125;
   System.out.println(&quot;业务进行中....&quot;);
&#125;
</code></pre>
<p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<pre><code>@EnableAsync //开启异步注解功能
@SpringBootApplication
public class SpringbootTaskApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(SpringbootTaskApplication.class, args);
  &#125;

&#125;
</code></pre>
<p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p>
<h3 id="16-2、定时任务"><a href="#16-2、定时任务" class="headerlink" title="16.2、定时任务"></a>16.2、定时任务</h3><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling</li>
<li>@Scheduled</li>
</ul>
<p><strong>cron表达式：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMKLnW0ibMAiaR5yXOER51iaH9WTkrLhr0rSAnAJxJUM9c8eTGaCWXuYOibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMfyibiaXGFm87zic2Ng3ICjicp4tlAia8MXDafQXZ9UZ7bsreJoTU9VWaBXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>测试步骤：</strong></p>
<p>1、创建一个ScheduledService</p>
<p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p>
<pre><code>@Service
public class ScheduledService &#123;
   
   //秒   分   时     日   月   周几
   //0 * * * * MON-FRI
   //注意cron表达式的用法；
   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)
   public void hello()&#123;
       System.out.println(&quot;hello.....&quot;);
  &#125;
&#125;
</code></pre>
<p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<pre><code>@EnableAsync //开启异步注解功能
@EnableScheduling //开启基于注解的定时任务
@SpringBootApplication
public class SpringbootTaskApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(SpringbootTaskApplication.class, args);
  &#125;

&#125;
</code></pre>
<p>3、我们来详细了解下cron表达式；</p>
<p><a target="_blank" rel="noopener" href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a></p>
<p>4、常用的表达式</p>
<pre><code>（1）0/2 * * * * ?   表示每2秒 执行任务
（1）0 0/2 * * * ?   表示每2分钟 执行任务
（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务
（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业
（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作
（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点
（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时
（6）0 0 12 ? * WED   表示每个星期三中午12点
（7）0 0 12 * * ?   每天中午12点触发
（8）0 15 10 ? * *   每天上午10:15触发
（9）0 15 10 * * ?     每天上午10:15触发
（10）0 15 10 * * ?   每天上午10:15触发
（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发
（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发
（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发
（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发
（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发
（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发
（18）0 15 10 15 * ?   每月15日上午10:15触发
（19）0 15 10 L * ?   每月最后一日的上午10:15触发
（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发
（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发
（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
</code></pre>
<h3 id="16-3、邮件任务"><a href="#16-3、邮件任务" class="headerlink" title="16.3、邮件任务"></a>16.3、邮件任务</h3><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<p><strong>测试：</strong></p>
<p>1、引入pom依赖</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>看它引入的依赖，可以看到 jakarta.mail</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;
   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;
   &lt;version&gt;1.6.4&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、查看自动配置类：MailSenderAutoConfiguration</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMquaTFVg62FCj7M1T6e08TIF0rhlffjxhTZ1C6Q43eDiceibia600KwoZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个类中存在bean，JavaMailSenderImpl</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMJsstibaMQuMsAKmickRKVlc1dsicbp7PR8aaFOdwaVukjBoiaqhyJDrZKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们去看下配置文件</p>
<pre><code>@ConfigurationProperties(
   prefix = &quot;spring.mail&quot;
)
public class MailProperties &#123;
   private static final Charset DEFAULT_CHARSET;
   private String host;
   private Integer port;
   private String username;
   private String password;
   private String protocol = &quot;smtp&quot;;
   private Charset defaultEncoding;
   private Map&lt;String, String&gt; properties;
   private String jndiName;
&#125;
</code></pre>
<p>3、配置文件：</p>
<pre><code>spring.mail.username=24736743@qq.com
spring.mail.password=你的qq授权码
spring.mail.host=smtp.qq.com
# qq需要配置ssl
spring.mail.properties.mail.smtp.ssl.enable=true
</code></pre>
<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMx85j2ATOfy0GUeO3l8bLvWaOX0FrY39NljleEIyPOyrgV8gEaLCwbw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>4736743@qq.com&quot;);
   mailSender.send(message);
&#125;

@Test
public void contextLoads2() throws MessagingException &#123;
   //邮件设置2：一个复杂的邮件
   MimeMessage mimeMessage = mailSender.createMimeMessage();
   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

   helper.setSubject(&quot;通知-明天来狂神这听课&quot;);
   helper.setText(&quot;&lt;b style=&#39;color:red&#39;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);

   //发送附件
   helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));
   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));

   helper.setTo(&quot;24736743@qq.com&quot;);
   helper.setFrom(&quot;24736743@qq.com&quot;);

   mailSender.send(mimeMessage);
&#125;
</code></pre>
<p>查看邮箱，邮件接收成功！</p>
<p>我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！</p>
<h2 id="十七、富文本编辑器"><a href="#十七、富文本编辑器" class="headerlink" title="十七、富文本编辑器"></a>十七、富文本编辑器</h2><h3 id="17-1、简介"><a href="#17-1、简介" class="headerlink" title="17.1、简介"></a>17.1、简介</h3><p>市面上有许多非常成熟的富文本编辑器，比如：</p>
<ul>
<li><p><strong>Editor.md</strong>——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a></li>
</ul>
</li>
<li><p><strong>wangEditor</strong>——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="http://www.wangeditor.com/">http://www.wangeditor.com/</a></li>
</ul>
</li>
<li><p><strong>TinyMCE</strong>——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://www.tiny.cloud/docs/demo/full-featured/">https://www.tiny.cloud/docs/demo/full-featured/</a></li>
<li>博客园</li>
</ul>
</li>
<li><p><strong>百度ueditor</strong>——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://ueditor.baidu.com/website/onlinedemo.html">https://ueditor.baidu.com/website/onlinedemo.html</a></li>
</ul>
</li>
<li><p><strong>kindeditor</strong>——界面经典。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="http://kindeditor.net/demo.php">http://kindeditor.net/demo.php</a></li>
</ul>
</li>
<li><p><strong>Textbox</strong>——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://textbox.io/">https://textbox.io/</a></li>
</ul>
</li>
<li><p><strong>CKEditor</strong>——国外的，界面美观。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://ckeditor.com/ckeditor-5/demo/">https://ckeditor.com/ckeditor-5/demo/</a></li>
</ul>
</li>
<li><p><strong>quill</strong>——功能强大，还可以编辑公式等</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://quilljs.com/">https://quilljs.com/</a></li>
</ul>
</li>
<li><p><strong>simditor</strong>——界面美观，功能较全。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://simditor.tower.im/">https://simditor.tower.im/</a></li>
</ul>
</li>
<li><p><strong>summernote</strong>——UI好看，精美</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://summernote.org/">https://summernote.org/</a></li>
</ul>
</li>
<li><p><strong>jodit</strong>——功能齐全</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://xdsoft.net/jodit/">https://xdsoft.net/jodit/</a></li>
</ul>
</li>
<li><p><strong>froala Editor</strong>——界面非常好看，功能非常强大，非常好用（非免费）</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://www.froala.com/wysiwyg-editor">https://www.froala.com/wysiwyg-editor</a></li>
</ul>
</li>
</ul>
<h3 id="17-2、Editor-md"><a href="#17-2、Editor-md" class="headerlink" title="17.2、Editor.md"></a>17.2、Editor.md</h3><p>我们可以在官网下载它：<a target="_blank" rel="noopener" href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a> ， 得到它的压缩包！</p>
<p>解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！</p>
<p>我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！</p>
<h4 id="17-2-1、基础工程搭建"><a href="#17-2-1、基础工程搭建" class="headerlink" title="17.2.1、基础工程搭建"></a>17.2.1、基础工程搭建</h4><blockquote>
<p>数据库设计</p>
</blockquote>
<p>article：文章表</p>
<table>
<thead>
<tr>
<th>字段</th>
<th></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>文章的唯一ID</td>
</tr>
<tr>
<td>author</td>
<td>varchar</td>
<td>作者</td>
</tr>
<tr>
<td>title</td>
<td>varchar</td>
<td>标题</td>
</tr>
<tr>
<td>content</td>
<td>longtext</td>
<td>文章的内容</td>
</tr>
</tbody></table>
<p>建表SQL：</p>
<pre><code>CREATE TABLE `article` (
`id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#39;int文章的唯一ID&#39;,
`author` varchar(50) NOT NULL COMMENT &#39;作者&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;标题&#39;,
`content` longtext NOT NULL COMMENT &#39;文章的内容&#39;,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<blockquote>
<p>基础项目搭建</p>
</blockquote>
<p>1、建一个SpringBoot项目配置</p>
<pre><code>spring:
datasource:
  username: root
  password: 123456
  #?serverTimezone=UTC解决时区的报错
  url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
  driver-class-name: com.mysql.cj.jdbc.Driver
&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;true&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<p>2、实体类：</p>
<pre><code>//文章类
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Article implements Serializable &#123;

   private int id; //文章的唯一ID
   private String author; //作者名
   private String title; //标题
   private String content; //文章的内容

&#125;
</code></pre>
<p>3、mapper接口：</p>
<pre><code>@Mapper
@Repository
public interface ArticleMapper &#123;
   //查询所有的文章
   List&lt;Article&gt; queryArticles();

   //新增一个文章
   int addArticle(Article article);

   //根据文章id查询文章
   Article getArticleById(int id);

   //根据文章id删除文章
   int deleteArticleById(int id);

&#125;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.ArticleMapper&quot;&gt;

   &lt;select id=&quot;queryArticles&quot; resultType=&quot;Article&quot;&gt;
      select * from article
   &lt;/select&gt;
   
   &lt;select id=&quot;getArticleById&quot; resultType=&quot;Article&quot;&gt;
      select * from article where id = #&#123;id&#125;
   &lt;/select&gt;
   
   &lt;insert id=&quot;addArticle&quot; parameterType=&quot;Article&quot;&gt;
      insert into article (author,title,content) values (#&#123;author&#125;,#&#123;title&#125;,#&#123;content&#125;);
   &lt;/insert&gt;
   
   &lt;delete id=&quot;deleteArticleById&quot; parameterType=&quot;int&quot;&gt;
      delete from article where id = #&#123;id&#125;
   &lt;/delete&gt;
   
&lt;/mapper&gt;
</code></pre>
<p><strong>既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置</strong></p>
<pre><code>mybatis:
mapper-locations: classpath:com/kuang/mapper/*.xml
type-aliases-package: com.kuang.pojo
</code></pre>
<p>编写一个Controller测试下，是否ok；</p>
<h4 id="17-2-2、文章编辑整合"><a href="#17-2-2、文章编辑整合" class="headerlink" title="17.2.2、文章编辑整合"></a>17.2.2、文章编辑整合</h4><p>1、导入 editor.md 资源 ，删除多余文件</p>
<p>2、编辑文章页面 editor.html、需要引入 jQuery；</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html class=&quot;x-admin-sm&quot; lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;

&lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;秦疆&#39;Blog&lt;/title&gt;
   &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi&quot; /&gt;
   &lt;!--Editor.md--&gt;
   &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.css&#125;&quot;/&gt;
   &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://pandao.github.io/editor.md/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div class=&quot;layui-fluid&quot;&gt;
   &lt;div class=&quot;layui-row layui-col-space15&quot;&gt;
       &lt;div class=&quot;layui-col-md12&quot;&gt;
           &lt;!--博客表单--&gt;
           &lt;form name=&quot;mdEditorForm&quot;&gt;
               &lt;div&gt;
                  标题：&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;
               &lt;/div&gt;
               &lt;div&gt;
                  作者：&lt;input type=&quot;text&quot; name=&quot;author&quot;&gt;
               &lt;/div&gt;
               &lt;div id=&quot;article-content&quot;&gt;
                   &lt;textarea name=&quot;content&quot; id=&quot;content&quot; style=&quot;display:none;&quot;&gt; &lt;/textarea&gt;
               &lt;/div&gt;
           &lt;/form&gt;

       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;!--editormd--&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
   var testEditor;

   //window.onload = function()&#123; &#125;
   $(function() &#123;
       testEditor = editormd(&quot;article-content&quot;, &#123;
           width : &quot;95%&quot;,
           height : 400,
           syncScrolling : &quot;single&quot;,
           path : &quot;../editormd/lib/&quot;,
           saveHTMLToTextarea : true,    // 保存 HTML 到 Textarea
           emoji: true,
           theme: &quot;dark&quot;,//工具栏主题
           previewTheme: &quot;dark&quot;,//预览主题
           editorTheme: &quot;pastel-on-dark&quot;,//编辑主题
           tex : true,                   // 开启科学公式TeX语言支持，默认关闭
           flowChart : true,             // 开启流程图支持，默认关闭
           sequenceDiagram : true,       // 开启时序/序列图支持，默认关闭,
           //图片上传
           imageUpload : true,
           imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;],
           imageUploadURL : &quot;/article/file/upload&quot;,
           onload : function() &#123;
               console.log(&#39;onload&#39;, this);
          &#125;,
           /*指定需要显示的功能按钮*/
           toolbarIcons : function() &#123;
               return [&quot;undo&quot;,&quot;redo&quot;,&quot;|&quot;,
                   &quot;bold&quot;,&quot;del&quot;,&quot;italic&quot;,&quot;quote&quot;,&quot;ucwords&quot;,&quot;uppercase&quot;,&quot;lowercase&quot;,&quot;|&quot;,
                   &quot;h1&quot;,&quot;h2&quot;,&quot;h3&quot;,&quot;h4&quot;,&quot;h5&quot;,&quot;h6&quot;,&quot;|&quot;,
                   &quot;list-ul&quot;,&quot;list-ol&quot;,&quot;hr&quot;,&quot;|&quot;,
                   &quot;link&quot;,&quot;reference-link&quot;,&quot;image&quot;,&quot;code&quot;,&quot;preformatted-text&quot;,
                   &quot;code-block&quot;,&quot;table&quot;,&quot;datetime&quot;,&quot;emoji&quot;,&quot;html-entities&quot;,&quot;pagebreak&quot;,&quot;|&quot;,
                   &quot;goto-line&quot;,&quot;watch&quot;,&quot;preview&quot;,&quot;fullscreen&quot;,&quot;clear&quot;,&quot;search&quot;,&quot;|&quot;,
                   &quot;help&quot;,&quot;info&quot;,&quot;releaseIcon&quot;, &quot;index&quot;]
          &#125;,

           /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/
           toolbarIconTexts : &#123;
               releaseIcon : &quot;&lt;span bgcolor=\&quot;gray\&quot;&gt;发布&lt;/span&gt;&quot;,
               index : &quot;&lt;span bgcolor=\&quot;red\&quot;&gt;返回首页&lt;/span&gt;&quot;,
          &#125;,

           /*给自定义按钮指定回调函数*/
           toolbarHandlers:&#123;
               releaseIcon : function(cm, icon, cursor, selection) &#123;
                   //表单提交
                   mdEditorForm.method = &quot;post&quot;;
                   mdEditorForm.action = &quot;/article/addArticle&quot;;//提交至服务器的路径
                   mdEditorForm.submit();
              &#125;,
               index : function()&#123;
                   window.location.href = &#39;/&#39;;
              &#125;,
          &#125;
      &#125;);
  &#125;);
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<p>3、编写Controller，进行跳转，以及保存文章</p>
<pre><code>@Controller
@RequestMapping(&quot;/article&quot;)
public class ArticleController &#123;

   @GetMapping(&quot;/toEditor&quot;)
   public String toEditor()&#123;
       return &quot;editor&quot;;
  &#125;
   
   @PostMapping(&quot;/addArticle&quot;)
   public String addArticle(Article article)&#123;
       articleMapper.addArticle(article);
       return &quot;editor&quot;;
  &#125;
   
&#125;
</code></pre>
<blockquote>
<p>图片上传问题</p>
</blockquote>
<p>1、前端js中添加配置</p>
<pre><code>//图片上传
imageUpload : true,
imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;],
imageUploadURL : &quot;/article/file/upload&quot;, // //这个是上传图片时的访问地址
</code></pre>
<p>2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！</p>
<pre><code>//博客图片上传问题
@RequestMapping(&quot;/file/upload&quot;)
@ResponseBody
public JSONObject fileUpload(@RequestParam(value = &quot;editormd-image-file&quot;, required = true) MultipartFile file, HttpServletRequest request) throws IOException &#123;
   //上传路径保存设置

   //获得SpringBoot当前项目的路径：System.getProperty(&quot;user.dir&quot;)
   String path = System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;;

   //按照月份进行分类：
   Calendar instance = Calendar.getInstance();
   String month = (instance.get(Calendar.MONTH) + 1)+&quot;月&quot;;
   path = path+month;

   File realPath = new File(path);
   if (!realPath.exists())&#123;
       realPath.mkdir();
  &#125;

   //上传文件地址
   System.out.println(&quot;上传文件保存地址：&quot;+realPath);

   //解决文件名字问题：我们使用uuid;
   String filename = &quot;ks-&quot;+UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
   //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
   file.transferTo(new File(realPath +&quot;/&quot;+ filename));

   //给editormd进行回调
   JSONObject res = new JSONObject();
   res.put(&quot;url&quot;,&quot;/upload/&quot;+month+&quot;/&quot;+ filename);
   res.put(&quot;success&quot;, 1);
   res.put(&quot;message&quot;, &quot;upload success!&quot;);

   return res;
&#125;
</code></pre>
<p>3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！</p>
<pre><code>@Configuration
public class MyMvcConfig implements WebMvcConfigurer &#123;

   // 文件保存在真实目录/upload/下，
   // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。
   @Override
   public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
       registry.addResourceHandler(&quot;/upload/**&quot;)
          .addResourceLocations(&quot;file:&quot;+System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;);
  &#125;

&#125;
</code></pre>
<blockquote>
<p>表情包问题</p>
</blockquote>
<p>自己手动下载，emoji 表情包，放到图片路径下：</p>
<p>修改editormd.js文件</p>
<pre><code>// Emoji graphics files url path
editormd.emoji     = &#123;
   path : &quot;../editormd/plugins/emoji-dialog/emoji/&quot;,
   ext   : &quot;.png&quot;
&#125;;
</code></pre>
<h3 id="文章展示"><a href="#文章展示" class="headerlink" title="文章展示"></a>文章展示</h3><p>1、Controller 中增加方法</p>
<pre><code>@GetMapping(&quot;/&#123;id&#125;&quot;)
public String show(@PathVariable(&quot;id&quot;) int id,Model model)&#123;
   Article article = articleMapper.getArticleById(id);
   model.addAttribute(&quot;article&quot;,article);
   return &quot;article&quot;;
&#125;
</code></pre>
<p>2、编写页面 article.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
   &lt;title th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
   &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt;
   &lt;h2 style=&quot;margin: auto 0&quot; th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/h2&gt;
  作者：&lt;span style=&quot;float: left&quot; th:text=&quot;$&#123;article.author&#125;&quot;&gt;&lt;/span&gt;
   &lt;!--文章主体内容--&gt;
   &lt;div id=&quot;doc-content&quot;&gt;
       &lt;textarea style=&quot;display:none;&quot; placeholder=&quot;markdown&quot; th:text=&quot;$&#123;article.content&#125;&quot;&gt;&lt;/textarea&gt;
   &lt;/div&gt;

&lt;/div&gt;

&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.preview.css&#125;&quot; /&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/marked.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/prettify.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/raphael.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/underscore.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/sequence-diagram.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
   var testEditor;
   $(function () &#123;
       testEditor = editormd.markdownToHTML(&quot;doc-content&quot;, &#123;//注意：这里是上面DIV的id
           htmlDecode: &quot;style,script,iframe&quot;,
           emoji: true,
           taskList: true,
           tocm: true,
           tex: true, // 默认不解析
           flowChart: true, // 默认不解析
           sequenceDiagram: true, // 默认不解析
           codeFold: true
      &#125;);&#125;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>重启项目，访问进行测试！大功告成！</p>
<p>小结：</p>
<p>有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！</p>
<h2 id="十八、Dubbo和Zookeeoer集成"><a href="#十八、Dubbo和Zookeeoer集成" class="headerlink" title="十八、Dubbo和Zookeeoer集成"></a>十八、Dubbo和Zookeeoer集成</h2><h3 id="18-1、分布式理论"><a href="#18-1、分布式理论" class="headerlink" title="18.1、分布式理论"></a>18.1、分布式理论</h3><h4 id="18-1-1、什么是分布式系统？"><a href="#18-1-1、什么是分布式系统？" class="headerlink" title="18.1.1、什么是分布式系统？"></a>18.1.1、什么是分布式系统？</h4><p>在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p>
<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是<strong>利用更多的机器，处理更多的数据</strong>。</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p>
<h4 id="18-1-2、Dubbo文档"><a href="#18-1-2、Dubbo文档" class="headerlink" title="18.1.2、Dubbo文档"></a>18.1.2、Dubbo文档</h4><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<p>在Dubbo的官网文档有这样一张图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshLkKFz4W9TBHVg7cBtxDPTFkU2b9C13K1CHPyLApFyAFFlbjnpcWibIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-1-3、单一应用架构"><a href="#18-1-3、单一应用架构" class="headerlink" title="18.1.3、单一应用架构"></a>18.1.3、单一应用架构</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshw2ITicetDcFsg41kISOhuyojGB1Z8ics61xtqnicJTXDk7Qw41dkeXK2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<p><strong>缺点：</strong></p>
<p>1、性能扩展比较难</p>
<p>2、协同开发问题</p>
<p>3、不利于升级维护</p>
<h4 id="18-1-4、垂直应用架构"><a href="#18-1-4、垂直应用架构" class="headerlink" title="18.1.4、垂直应用架构"></a>18.1.4、垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshG4FicWRMjbfStG0Ojr1H9cL1jQ1SbZ0s7rsbsc7w8f3usmdSJog7pHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点：公用模块无法重复利用，开发性的浪费</p>
<h4 id="18-1-5、分布式服务架构"><a href="#18-1-5、分布式服务架构" class="headerlink" title="18.1.5、分布式服务架构"></a>18.1.5、分布式服务架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshwIkic8EicmCwYGRibdWohmDazEDhonhTeJfVx0dfBNlW4dGGxvOMOk0Gg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-1-6、流动计算架构"><a href="#18-1-6、流动计算架构" class="headerlink" title="18.1.6、流动计算架构"></a>18.1.6、流动计算架构</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshxoCosFhoMzIcbBzjCt6ia9Gr7atHlwNHhL0po4YhyE8WkHXnnpN8Ddg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="18-2、RPC简介"><a href="#18-2、RPC简介" class="headerlink" title="18.2、RPC简介"></a>18.2、RPC简介</h3><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>
<p>推荐阅读文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2accc2840a1b">https://www.jianshu.com/p/2accc2840a1b</a></p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshVx3xhf4RyUVtia7Tvo4BBs70SFKRonhrPrNsiap2rEAQCn4IWUoS3HZA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>步骤解析：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshDCibUnIYkolqibQRy7Qlpm9vNibK9IDaFibJoLpIM5pWLe7Yqly7PheYsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RPC两个核心模块：通讯，序列化。</p>
<h3 id="18-3、搭建测试环境"><a href="#18-3、搭建测试环境" class="headerlink" title="18.3、搭建测试环境"></a>18.3、搭建测试环境</h3><h4 id="18-3-1、Dubbo"><a href="#18-3-1、Dubbo" class="headerlink" title="18.3.1、Dubbo"></a>18.3.1、Dubbo</h4><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>dubbo官网 <a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/index.html">http://dubbo.apache.org/zh-cn/index.html</a></p>
<p>1.了解Dubbo的特性</p>
<p>2.查看官方文档</p>
<p><strong>dubbo基本概念</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshLSMRQe7NJpvDFrQMChLxI3BqIYQXrZvfs28iadQ1dDB4p84ydyb3KtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p><strong>调用关系说明</strong></p>
<p>l 服务容器负责启动，加载，运行服务提供者。</p>
<p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h4 id="18-3-2、Dubbo环境搭建"><a href="#18-3-2、Dubbo环境搭建" class="headerlink" title="18.3.2、Dubbo环境搭建"></a>18.3.2、Dubbo环境搭建</h4><p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p>
<p>什么是zookeeper呢？可以查看官方文档</p>
<h4 id="18-3-3、Window下安装zookeeper"><a href="#18-3-3、Window下安装zookeeper" class="headerlink" title="18.3.3、Window下安装zookeeper"></a>18.3.3、Window下安装zookeeper</h4><p>1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper</p>
<p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p>
<p>可能遇到问题：闪退 !</p>
<p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshERcBbh6aAYOxnI1yFCMJ6ia2jsJzW3mIhF9ZUicsOQ2AclNAb2eUCFCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshQM9ha9wq0nRMhQicxYEyI89HCXwVIxZzPthrPHFDur3VbwtFia6GeAicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、修改zoo.cfg配置文件</p>
<p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./  临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181  zookeeper的端口号</p>
<p>修改完成后再次启动zookeeper</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshzuNFWROxUoicw96U1SpicxJNJFedhL6dPzcgpedqIE2XgxZHUpicTYDMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根下保存的所有节点</p>
<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 4] ls /
[zookeeper]
</code></pre>
<p>create –e /kuangshen 123：创建一个kuangshen节点，值为123</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshmI79TweJ88IvdkKgNxduic3xgVpYeDGHN10Wp27u0dIJoTRa3e7Z9TA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>get /kuangshen：获取/kuangshen节点的值</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshpsqHHO1fsq3ucpfWQdqyYkOAxxO6mbD7YiczFdyklEG41cuMomRpUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们再来查看一下节点</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshjRW6icsrmFYiavJaLYBa1UXl2FrQtCvxpqdXTtSwyZpcZvqoFnmae7QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-3-4、window下安装dubbo-admin"><a href="#18-3-4、window下安装dubbo-admin" class="headerlink" title="18.3.4、window下安装dubbo-admin"></a>18.3.4、window下安装dubbo-admin</h4><p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p>
<p>我们这里来安装一下：</p>
<p><strong>1、下载dubbo-admin</strong></p>
<p>地址 ：<a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p>
<p><strong>2、解压进入目录</strong></p>
<p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p>
<pre><code>server.port=7001
spring.velocity.cache=false
spring.velocity.charset=UTF-8
spring.velocity.layout-url=/templates/default.vm
spring.messages.fallback-to-system-locale=false
spring.messages.basename=i18n/message
spring.root.password=root
spring.guest.password=guest

dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3、在项目目录下</strong>打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true
</code></pre>
<p><strong>第一次打包的过程有点慢，需要耐心等待！直到成功！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshho9bzkKPPgVQRh3x35ueIYFGEDfygiaXKjOQQFuC2bxc1ImffuOsH2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>【注意：zookeeper的服务一定要打开！】</p>
<p>执行完毕，我们去访问一下 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p>
<p>登录成功后，查看界面</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshjHbZUAW6UOLfJhknMjgemFYgr2hz27iaBE4tiaKA86ZqIhOjd3vttV5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>安装完成！</p>
<h3 id="18-4、SpringBoot-Dubbo-zookeeper"><a href="#18-4、SpringBoot-Dubbo-zookeeper" class="headerlink" title="18.4、SpringBoot + Dubbo + zookeeper"></a>18.4、SpringBoot + Dubbo + zookeeper</h3><h4 id="18-4-1、框架搭建"><a href="#18-4-1、框架搭建" class="headerlink" title="18.4.1、框架搭建"></a>18.4.1、框架搭建</h4><p><strong>1. 启动zookeeper ！</strong></p>
<p><strong>2. IDEA创建一个空项目；</strong></p>
<p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p>
<p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p>
<p>编写接口</p>
<pre><code>package com.kuang.provider.service;

public interface TicketService &#123;
   public String getTicket();
&#125;
</code></pre>
<p>编写实现类</p>
<pre><code>package com.kuang.provider.service;

public class TicketServiceImpl implements TicketService &#123;
   @Override
   public String getTicket() &#123;
       return &quot;《狂神说Java》&quot;;
  &#125;
&#125;
</code></pre>
<p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p>
<p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p>
<p>编写service</p>
<pre><code>package com.kuang.consumer.service;

public class UserService &#123;
   //我们需要去拿去注册中心的服务
&#125;
</code></pre>
<p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p>
<h4 id="18-4-2、服务提供者"><a href="#18-4-2、服务提供者" class="headerlink" title="18.4.2、服务提供者"></a>18.4.2、服务提供者</h4><p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p>
<p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p>
<pre><code>&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;    
</code></pre>
<p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p>
<pre><code>&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p>
<pre><code>#当前应用名字
dubbo.application.name=provider-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
#扫描指定包下服务
dubbo.scan.base-packages=com.kuang.provider.service
</code></pre>
<p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p>
<pre><code>import org.apache.dubbo.config.annotation.Service;
import org.springframework.stereotype.Component;

@Service //将服务发布出去
@Component //放在容器中
public class TicketServiceImpl implements TicketService &#123;
   @Override
   public String getTicket() &#123;
       return &quot;《狂神说Java》&quot;;
  &#125;
&#125;
</code></pre>
<p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p>
<h4 id="18-4-3、服务消费者"><a href="#18-4-3、服务消费者" class="headerlink" title="18.4.3、服务消费者"></a>18.4.3、服务消费者</h4><p><strong>1、导入依赖，和之前的依赖一样；</strong></p>
<pre><code>&lt;!--dubbo--&gt;
&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--zookeeper--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、<strong>配置参数</strong></p>
<pre><code>#当前应用名字
dubbo.application.name=consumer-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshCZQj2L99hIN2HFHNQSzkSQMaUrbib6H4LJiabJur5V7icM0cq7ib8sK0gA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>4. 完善消费者的服务类</strong></p>
<pre><code>package com.kuang.consumer.service;

import com.kuang.provider.service.TicketService;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.stereotype.Service;

@Service //注入到容器中
public class UserService &#123;

   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名
   TicketService ticketService;

   public void bugTicket()&#123;
       String ticket = ticketService.getTicket();
       System.out.println(&quot;在注册中心买到&quot;+ticket);
  &#125;

&#125;
</code></pre>
<p><strong>5. 测试类编写；</strong></p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class ConsumerServerApplicationTests &#123;

   @Autowired
   UserService userService;

   @Test
   public void contextLoads() &#123;

       userService.bugTicket();

  &#125;

&#125;
</code></pre>
<h4 id="18-4-4、启动测试"><a href="#18-4-4、启动测试" class="headerlink" title="18.4.4、启动测试"></a>18.4.4、启动测试</h4><p><strong>1. 开启zookeeper</strong></p>
<p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p>
<p><strong>3. 开启服务者</strong></p>
<p><strong>4. 消费者消费测试，结果：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshU2j95r3eBhJlZLBEgpoVVHDb8Vm9EU0XB4ZW0xxwhs2q4blguwGcibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>监控中心 ：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60rensh4rC1ED2BCl07c81gxj3uKN5PtDZXDquz8gWS2yJmib46kib1C0SF3ycw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十九、集成SpringSecurity"><a href="#十九、集成SpringSecurity" class="headerlink" title="十九、集成SpringSecurity"></a>十九、集成SpringSecurity</h2><h3 id="一、安全简介"><a href="#一、安全简介" class="headerlink" title="一、安全简介"></a>一、安全简介</h3><p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h3 id="19-2、实战测试"><a href="#19-2、实战测试" class="headerlink" title="19.2、实战测试"></a>19.2、实战测试</h3><h4 id="19-2-1、实验环境搭建"><a href="#19-2-1、实验环境搭建" class="headerlink" title="19.2.1、实验环境搭建"></a>19.2.1、实验环境搭建</h4><p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<pre><code>welcome.html
|views
|level1
1.html
2.html
3.html
|level2
1.html
2.html
3.html
|level3
1.html
2.html
3.html
Login.html
</code></pre>
<p>3、controller跳转！</p>
<pre><code>package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouterController &#123;

   @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)
   public String index()&#123;
       return &quot;index&quot;;
  &#125;

   @RequestMapping(&quot;/toLogin&quot;)
   public String toLogin()&#123;
       return &quot;views/login&quot;;
  &#125;

   @RequestMapping(&quot;/level1/&#123;id&#125;&quot;)
   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level1/&quot;+id;
  &#125;

   @RequestMapping(&quot;/level2/&#123;id&#125;&quot;)
   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level2/&quot;+id;
  &#125;

   @RequestMapping(&quot;/level3/&#123;id&#125;&quot;)
   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level3/&quot;+id;
  &#125;

&#125;
</code></pre>
<p>4、测试实验环境是否OK！</p>
<h4 id="19-2-2、认识SpringSecurity"><a href="#19-2-2、认识SpringSecurity" class="headerlink" title="19.2.2、认识SpringSecurity"></a>19.2.2、认识SpringSecurity</h4><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p> <strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h4 id="19-2-3、认证和授权"><a href="#19-2-3、认证和授权" class="headerlink" title="19.2.3、认证和授权"></a>19.2.3、认证和授权</h4><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> </p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>  #servlet-applications 8.16.4</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXheImAPwVia7gtcx2cNCUXAXbCJpst1geQCOElXLQMMvAibMLmYNqXF5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、编写基础配置类</p>
<pre><code>package com.kuang.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity // 开启WebSecurity模式
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;

   @Override
   protected void configure(HttpSecurity http) throws Exception &#123;
       
  &#125;
&#125;
</code></pre>
<p>4、定制请求的授权规则</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception &#123;
   // 定制请求的授权规则
   // 首页所有人可以访问
   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);
&#125;
</code></pre>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<pre><code>// 开启自动配置的登录功能
// /login 请求来到登录页
// /login?error 重定向到这里表示登录失败
http.formLogin();
</code></pre>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXMBrh9xGQDQjlW4EpV2DscJbUzAMwjqIGGgw8fqWET4swGIue9mbwwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<pre><code>//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
   
   //在内存中定义，也可以在jdbc中去拿....
   auth.inMemoryAuthentication()
          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);
&#125;
</code></pre>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXSHnC5kd7W2DeryMuzoSOx3evDWoqlVIoGxBA3TEjAF54s4cRQsld0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<pre><code>//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
   //在内存中定义，也可以在jdbc中去拿....
   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
   //spring security 官方推荐的是使用bcrypt加密方式。
   
   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);
&#125;
</code></pre>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h4 id="19-2-4、权限控制和注销"><a href="#19-2-4、权限控制和注销" class="headerlink" title="19.2.4、权限控制和注销"></a>19.2.4、权限控制和注销</h4><p>1、开启自动配置的注销的功能</p>
<pre><code>//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception &#123;
   //....
   //开启自动配置的注销的功能
      // /logout 注销请求
   http.logout();
&#125;
</code></pre>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<pre><code>&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
&lt;/a&gt;
</code></pre>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<pre><code>// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>7、修改我们的 前端页面</p>
<ol>
<li><p>导入命名空间</p>
</li>
<li><pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;
</code></pre>
</li>
<li><p>修改导航栏，增加认证判断</p>
</li>
<li><pre><code>&lt;!--登录注销--&gt;
&lt;div class=&quot;right menu&quot;&gt;

   &lt;!--如果未登录--&gt;
   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;!--如果已登录--&gt;
   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;
          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;
          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
       &lt;/a&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<pre><code>http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<pre><code>&lt;!-- sec:authorize=&quot;hasRole(&#39;vip1&#39;)&quot; --&gt;
&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip1&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip2&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip3&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h4 id="19-2-5、记住我"><a href="#19-2-5、记住我" class="headerlink" title="19.2.5、记住我"></a>19.2.5、记住我</h4><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<pre><code>//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception &#123;
//。。。。。。。。。。。
   //记住我
   http.rememberMe();
&#125;
</code></pre>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXqDg8FodHRKUM8K5z79zEghbybrKD6WtqO0B9JBkD6FQNQ6dhARQsTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXS8kt9d3jGhJPZGNa5V97ZKVBIUNdHmtPibNia7U59tbfQyzla4mHFtYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h4 id="19-2-6、定制登录页"><a href="#19-2-6、定制登录页" class="headerlink" title="19.2.6、定制登录页"></a>19.2.6、定制登录页</h4><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<pre><code>http.formLogin().loginPage(&quot;/toLogin&quot;);
</code></pre>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<pre><code>&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
&lt;/a&gt;
</code></pre>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<p>在 loginPage()源码中的注释上有写明：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXCxA0YjyGXDmBHOMYfpwolJ5yZxvMAINJRvTx7HBwyTtO4azI2QuqdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Username&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;
           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Password&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;
&lt;/form&gt;
</code></pre>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<pre><code>http.formLogin()
  .usernameParameter(&quot;username&quot;)
  .passwordParameter(&quot;password&quot;)
  .loginPage(&quot;/toLogin&quot;)
  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求
</code></pre>
<p>5、在登录页增加记住我的多选框</p>
<pre><code>&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我
</code></pre>
<p>6、后端验证处理！</p>
<pre><code>//定制记住我的参数！
http.rememberMe().rememberMeParameter(&quot;remember&quot;);
</code></pre>
<p>7、测试，OK</p>
<h3 id="19-3、完整配置代码"><a href="#19-3、完整配置代码" class="headerlink" title="19.3、完整配置代码"></a>19.3、完整配置代码</h3><pre><code>package com.kuang.config;

import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;

   //定制请求的授权规则
   @Override
   protected void configure(HttpSecurity http) throws Exception &#123;

       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);


       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！
           // /login 请求来到登录页
           // /login?error 重定向到这里表示登录失败
       http.formLogin()
          .usernameParameter(&quot;username&quot;)
          .passwordParameter(&quot;password&quot;)
          .loginPage(&quot;/toLogin&quot;)
          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求

       //开启自动配置的注销的功能
           // /logout 注销请求
           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页

       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
       http.logout().logoutSuccessUrl(&quot;/&quot;);

       //记住我
       http.rememberMe().rememberMeParameter(&quot;remember&quot;);
  &#125;

   //定义认证规则
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
       //在内存中定义，也可以在jdbc中去拿....
       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
       //spring security 官方推荐的是使用bcrypt加密方式。

       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);
  &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" data-id="cl0utfle7001cugvs97ezhukj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/Spring/Spring中Bean的作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/">Spring中Bean作用域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><h2 id="一、Spring生命周期流程图"><a href="#一、Spring生命周期流程图" class="headerlink" title="一、Spring生命周期流程图"></a>一、Spring生命周期流程图</h2><p>下图描述的是从Spring容器初始化Bean开始直到Spring容器销毁Bean，所经历的关键节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20211208133748318.png" alt="file"></p>
<p>​        从上图可以看出，Spring Bean的生命周期管理的基本思路是：在Bean出现之前，先准备操作Bean的BeanFactory，然后操作完Bean，所有的Bean也还会交给BeanFactory进行管理。在所有Bean操作准备BeanPostProcessor作为回调。在Bean的完整生命周期管理过程中，经历了以下主要几个步骤：</p>
<h3 id="1-1-Bean创建前的准备阶段"><a href="#1-1-Bean创建前的准备阶段" class="headerlink" title="1.1 Bean创建前的准备阶段"></a>1.1 Bean创建前的准备阶段</h3><ul>
<li>步骤1： Bean容器在配置文件中找到Spring Bean的定义以及相关的配置，如init-method和destroy-method指定的方法。</li>
<li>步骤2： 实例化回调相关的后置处理器如BeanFactoryPostProcessor、BeanPostProcessor、InstantiationAwareBeanPostProcessor等</li>
</ul>
<h3 id="1-2-创建Bean的实例"><a href="#1-2-创建Bean的实例" class="headerlink" title="1.2 创建Bean的实例"></a>1.2 创建Bean的实例</h3><ul>
<li>步骤3： Srping 容器使用Java反射API创建Bean的实例。</li>
<li>步骤4：扫描Bean声明的属性并解析。</li>
</ul>
<h3 id="1-3-开始依赖注入"><a href="#1-3-开始依赖注入" class="headerlink" title="1.3 开始依赖注入"></a>1.3 开始依赖注入</h3><ul>
<li>步骤5：开始依赖注入，解析所有需要赋值的属性并赋值。</li>
<li>步骤6：如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。</li>
<li>步骤7：如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。</li>
<li>步骤8：如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。</li>
<li>步骤9：如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。</li>
</ul>
<h3 id="1-4-缓存到Spring容器"><a href="#1-4-缓存到Spring容器" class="headerlink" title="1.4 缓存到Spring容器"></a>1.4 缓存到Spring容器</h3><ul>
<li>步骤10： 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。</li>
<li>步骤11：如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。</li>
</ul>
<h3 id="1-5-销毁Bean的实例"><a href="#1-5-销毁Bean的实例" class="headerlink" title="1.5 销毁Bean的实例"></a>1.5 销毁Bean的实例</h3><ul>
<li>步骤12：如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。</li>
<li>步骤13：如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</li>
</ul>
<h2 id="二、Bean的作用域"><a href="#二、Bean的作用域" class="headerlink" title="二、Bean的作用域"></a>二、Bean的作用域</h2><p>​        创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方”。把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域，分别阐述如下表。</p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton">singleton</a></td>
<td>默认的。一个bean定义，在一个IoC容器内只会产生一个对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype">prototype</a></td>
<td>一个bean定义会产生多个对象实例</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-request">request</a></td>
<td>一个bean定义产生的bean生命周期为一个HTTP请求；也就是，每一个HTTP请求都会根据bean定义产生一个对象实例。该作用域只有在Spring web ApplicationContext 上下文环境中才有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-session">session</a></td>
<td>产生的bean生命周期在HTTP 会话期间。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-application">application</a></td>
<td>将单个bean定义范围限定为ServletContext的生命周期。 该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope">websocket</a></td>
<td>将单个bean定义范围限定为WebSocket的生命周期。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
</tbody></table>
<p>　    五种作用域中，request、session和global session三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<p>　　(1)当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>　　(2)当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
&lt;!--或者--&gt;
&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 
</code></pre>
<p>　　(3)当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>　　针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<p>　　(4)当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>　　针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<p>　　(5)当一个bean的作用域为Global Session，表示在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>　　global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p>
<h3 id="2-1-Spring中request请求作用域是什么？"><a href="#2-1-Spring中request请求作用域是什么？" class="headerlink" title="2.1 Spring中request请求作用域是什么？"></a>2.1 Spring中request请求作用域是什么？</h3><p>每个请求初始化具有此作用域的Bean注解。这听起来像是原型作用域的描述，但它们有一些差异。第一个区别是原型作用域在Spring的上下文中可用。而请求作用域仅适用于Web应用程序。第二个是原型bean根据需求进行初始化，而请求bean是在每个请求下构建的。需要说的是，request作用域bean在其作用域内有且仅有一个实例。而你可以拥有一个或多个原型作用域bean实例。</p>
<p>在以下代码中，你可以看到请求作用域bean的示例：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartRequest&quot; scope=&quot;request&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>当使用注解驱动组件或Java Config时，<code>@RequestScope</code>注解可以用于将一个组件分配给<code>request</code>作用域。</p>
<pre><code class="java">@RequestScope
@Component
public class ShoppingCartRequest &#123;
    // ...
&#125;
// request bean

// injection sample
@Controller
public class TestController &#123;
    @Autowired
    private ShoppingCartRequest shoppingCartRequest;

    @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)
    public String test(HttpServletRequest request) &#123;
        LOGGER.debug(&quot;shoppingCartRequest is :&quot;+shoppingCartRequest);
        // ...
    &#125;
&#125;
</code></pre>
<p>请注意<strong>定义内</strong>存在的**&lt;aop: scoped-proxy /&gt;**标签。这代表着使用代理对象。所以实际上，TestController持有的是代理对象的引用。我们所有的调用该对象都会转发到真正的<code>ShoppingCartRequest</code>对象。</p>
<p>有时我们需要使用<code>DispatcherServlet</code>的另一个<code>servlet</code>来处理请求。在这种情况下，我们必须确保Spring中所有请求都可用(否则可以抛出与下面类似的异常)。为此，我们需要在<code>web.xml</code>中定义一个监听器:</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>调用/测试URL后，你应该能在日志中的发现以下信息:</p>
<pre><code class="java">shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@2586b11c
shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@3bd5b945
</code></pre>
<p>如果我们尝试在单例bean中使用request作用域的bean，则会在应用程序上下文加载阶段抛出一个<code>BeanCreationException</code>:</p>
<pre><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;testController&#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:700)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:381)
    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293)
    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)
    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4701)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5204)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5199)
    at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source)
    at java.util.concurrent.FutureTask.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)
Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289)
    ... 21 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1014)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:957)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480)
    ... 23 more
Caused by: java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.web.context.request.RequestContextHolder.currentRequestAttributes(RequestContextHolder.java:131)
    at org.springframework.web.context.request.AbstractRequestAttributesScope.get(AbstractRequestAttributesScope.java:41)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338)
    ... 28 more
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="2-2-什么是Spring的Session作用域？"><a href="#2-2-什么是Spring的Session作用域？" class="headerlink" title="2.2 什么是Spring的Session作用域？"></a>2.2 什么是Spring的Session作用域？</h3><p>Session作用域的bean与request 作用域的bean没有太大的不同。它们也与纯Web应用程序上下文相关联。注解为Session作用域的Bean对于每个用户的会话仅创建一次。他们在会话结束时被破坏销毁掉。</p>
<p>由Session作用域限制的Bean可以被认为是面向Web的单例，因为给定环境(用户会话)仅存在一个实例。但请记住，你无法在Web应用程序上下文中使用它们(说个好理解点的，就是一个函数内部自定义变量所在的作用域，函数执行完就销毁了，没有什么逃逸，关于此处更深入的理解请看我的博文<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2016/11/08/%E7%94%B1%E5%9F%9F%E8%81%94%E7%B3%BB%E5%88%B0%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">由域联系到的逃逸分析</a>)。</p>
<p>想知道Session作用域bean在Spring中的操作，我们需要在配置文件中定义一个bean:</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartSession&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>通过<code>@Autowired</code>注解，查找这个bean的方式与request 作用域的bean相同。可以看到以下结果:</p>
<pre><code class="java">shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@2f87fafc
</code></pre>
<p>你可以看到，前5个打印输出代表相同的对象。最后一个是不同的。这是什么意思 ?简单来说，这代表 着一个新的用户使用自动注入的Session作用域访问该页面。我们可以通过打开两个浏览器的测试页(/test)来观察它。每个都将初始化一个新的会话Session，因此也就创建新的<code>ShoppingCartSession bean</code>实例。</p>
<p>关于全局会话作用域(Global session scope)属于4.3x的范畴了，Spring5已经没有了，Spring5文档是去掉了因为4的存在所以还是说两句，它保留给portlet应用程序。 是不是一脸懵逼，so，来解释一下portlet是什么。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与servlet不同，每个portlet都有不同的会话。在这种情况下，Spring提供了一个名为<code>global-session</code>的作用域。通过它，一个bean可以通过应用程序中的多个portlet共享。</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>至此，我们解释了请求和面向会话的作用域。第一个的作用是在每个request请求上创建新的bean。第二个在Session会话开始的时候初始化bean。</p>
<h2 id="三、Bean的生命周期"><a href="#三、Bean的生命周期" class="headerlink" title="三、Bean的生命周期"></a>三、Bean的生命周期</h2><p>　Spring中Bean的实例化过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210510144229675.png" alt="img"></p>
<p>Bean的生命周期：</p>
<p><img src="https://img-blog.csdnimg.cn/2021051014425161.png" alt="img"></p>
<p>Bean实例生命周期的执行过程如下：</p>
<ul>
<li>Spring对bean进行实例化，默认bean是单例；</li>
<li>Spring对bean进行依赖注入；</li>
<li>如果bean实现了BeanNameAware接口，Spring将bean的名称传给setBeanName()方法；</li>
<li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory实例传进来；</li>
<li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization()方法将被调用；</li>
<li>如果bean中有方法添加了@PostConstruct注解，那么该方法将被调用；</li>
<li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li>
<li>如果在xml文件中通过<bean>标签的init-method元素指定了初始化方法，那么该方法将被调用；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization()接口方法将被调用；</li>
<li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>
<li>如果bean中有方法添加了@PreDestroy注解，那么该方法将被调用；</li>
<li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ul>
<p>　　这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。</p>
<p>　　其实很多时候我们并不会真的去实现上面所描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<h3 id="3-1-单例管理的对象"><a href="#3-1-单例管理的对象" class="headerlink" title="3.1 单例管理的对象"></a>3.1 单例管理的对象</h3><p>　　当scope=”singleton”，即默认情况下，会在启动容器时（即实例化容器时）时实例化。但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。如下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;serviceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p>
<pre><code class="xml">&lt;beans default-lazy-init=&quot;true&quot;&gt;
</code></pre>
<p>　　默认情况下，Spring在读取xml文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用init-method属性值中所指定的方法。对象在被销毁的时候，会调用destroy-method属性值中所指定的方法（例如调用Container.destroy()方法的时候）。写一个测试类，代码如下：</p>
<pre><code class="java">public class LifeBean &#123;
    private String name;  
    
    public LifeBean()&#123;  
        System.out.println(&quot;LifeBean()构造函数&quot;);  
    &#125;  
    public String getName() &#123;  
        return name;  
    &#125;  
  
    public void setName(String name) &#123;  
        System.out.println(&quot;setName()&quot;);  
        this.name = name;  
    &#125;  

    public void init()&#123;  
        System.out.println(&quot;this is init of lifeBean&quot;);  
    &#125;  
      
    public void destory()&#123;  
        System.out.println(&quot;this is destory of lifeBean &quot; + this);  
    &#125;  
&#125;
</code></pre>
<p>　　life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_singleton&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;singleton&quot; 
            init-method=&quot;init&quot; destroy-method=&quot;destory&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　测试代码如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = 
        new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life&quot;);
        System.out.println(life1);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<h3 id="2-2-非单例管理的对象"><a href="#2-2-非单例管理的对象" class="headerlink" title="2.2 非单例管理的对象"></a>2.2 非单例管理的对象</h3><p>　　当scope=”prototype”时，容器也会延迟初始化bean，Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。在第一次请求每一个prototype的bean时，Spring容器都会调用其构造器创建这个对象，然后调用init-method属性值中所指定的方法。对象销毁的时候，Spring容器不会帮我们调用任何方法，因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<p>　　为了测试prototype bean的生命周期life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_prototype&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;
</code></pre>
<p>　　测试程序如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life_singleton&quot;);
        System.out.println(life1);
        
        LifeBean life3 = (LifeBean)container.getBean(&quot;life_prototype&quot;);
        System.out.println(life3);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：　</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@5ae9a829
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<p>　　可以发现，对于作用域为prototype的bean，其destroy方法并没有被调用。如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>　　Spring容器可以管理singleton作用域下bean的生命周期，在此作用域下，Spring能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的bean，Spring只负责创建，当容器创建了bean的实例后，bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<h3 id="2-3-引申"><a href="#2-3-引申" class="headerlink" title="2.3 引申"></a>2.3 引申</h3><p>　　在学习Spring IoC过程中发现，每次产生ApplicationContext工厂的方式是：</p>
<pre><code class="java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p>　　这样产生ApplicationContext就有一个弊端，每次访问加载bean的时候都会产生这个工厂，所以这里需要解决这个问题。</p>
<p>　　ApplicationContext是一个接口，它继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持。</p>
<p>　　解决问题的方法很简单，在web容器启动的时候将ApplicationContext转移到ServletContext中，因为在web应用中所有的Servlet都共享一个ServletContext对象。那么我们就可以利用ServletContextListener去监听ServletContext事件，当web应用启动的是时候，我们就将ApplicationContext装载到ServletContext中。 Spring容器底层已经为我们想到了这一点，在spring-web-xxx-release.jar包中有一个已经实现了ServletContextListener接口的类ContextLoader，其源码如下：</p>
<pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;
    private ContextLoader contextLoader;

    public ContextLoaderListener() &#123;

    &#125;

    public ContextLoaderListener(WebApplicationContext context) &#123;
        super(context);
    &#125;

    public void contextInitialized(ServletContextEvent event) &#123;
        this.contextLoader = createContextLoader();
        if (this.contextLoader == null) &#123;
            this.contextLoader = this;
        &#125;
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    &#125;

    @Deprecated
    protected ContextLoader createContextLoader() &#123;
        return null;
    &#125;

    @Deprecated
    public ContextLoader getContextLoader() &#123;
        return this.contextLoader;
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        if (this.contextLoader != null) &#123;
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
        &#125;
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    &#125;
&#125;
</code></pre>
<p>　　这里就监听到了servletContext的创建过程, 那么 这个类又是如何将applicationContext装入到serveletContext容器中的呢?</p>
<p>　　this.contextLoader.initWebApplicationContext(event.getServletContext())方法的具体实现中：</p>
<pre><code class="java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;
     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;
         throw new IllegalStateException(
                 &quot;Cannot initialize context because there is already a root application context present - &quot; +
                 &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
     &#125;

     Log logger = LogFactory.getLog(ContextLoader.class);
     servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
     if (logger.isInfoEnabled()) &#123;
         logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
     &#125;
     long startTime = System.currentTimeMillis();

     try &#123;
           // Store context in local instance variable, to guarantee that
          // it is available on ServletContext shutdown.
         if (this.context == null) &#123;
             this.context = createWebApplicationContext(servletContext);
         &#125;
         if (this.context instanceof ConfigurableWebApplicationContext) &#123;
             ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
             if (!cwac.isActive()) &#123;
                 // The context has not yet been refreshed -&gt; provide services such as
                 // setting the parent context, setting the application context id, etc
                 if (cwac.getParent() == null) &#123;
                     // The context instance was injected without an explicit parent -&gt;
                     // determine parent for root web application context, if any.
                     ApplicationContext parent = loadParentContext(servletContext);
                     cwac.setParent(parent);
                 &#125;
                 configureAndRefreshWebApplicationContext(cwac, servletContext);
             &#125;
         &#125;
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

         ClassLoader ccl = Thread.currentThread().getContextClassLoader();
         if (ccl == ContextLoader.class.getClassLoader()) &#123;
             currentContext = this.context;
         &#125;
         else if (ccl != null) &#123;
             currentContextPerThread.put(ccl, this.context);
         &#125;

         if (logger.isDebugEnabled()) &#123;
             logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
                     WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
         &#125;
         if (logger.isInfoEnabled()) &#123;
             long elapsedTime = System.currentTimeMillis() - startTime;
             logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
         &#125;

         return this.context;
     &#125;
     catch (RuntimeException ex) &#123;
         logger.error(&quot;Context initialization failed&quot;, ex);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
         throw ex;
     &#125;
     catch (Error err) &#123;
         logger.error(&quot;Context initialization failed&quot;, err);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
         throw err;
     &#125;
 &#125;
</code></pre>
<p>　　这里的重点是servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)，用key:WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE value: this.context的形式将applicationContext装载到servletContext中了。另外从上面的一些注释我们可以看出： WEB-INF/applicationContext.xml， 如果我们项目中的配置文件不是这么一个路径的话 那么我们使用ContextLoaderListener 就会出问题, 所以我们还需要在web.xml中配置我们的applicationContext.xml配置文件的路径。</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>　　剩下的就是在项目中开始使用 servletContext中装载的applicationContext对象了： 那么这里又有一个问题，装载时的key是 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们在代码中真的要使用这个吗? 其实Spring为我们提供了一个工具类WebApplicationContextUtils，接着我们先看下如何使用，然后再去看下这个工具类的源码：</p>
<pre><code class="java">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());
</code></pre>
<p>　　接着来看下这个工具类的源码：</p>
<pre><code class="java">public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;
    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
&#125;
</code></pre>
<p>　　这里就能很直观清晰地看到 通过key值直接获取到装载到servletContext中的 applicationContext对象了。</p>
<p>　　ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，整个加载配置过程由ContextLoader来完成。</p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>​        理解spring中bean的生命周期，对于学习和使用spring很有帮助。本文将从两个角度对spring中bean的生命周期进行介绍，一是bean定义生成；二是bean在初始化、使用、销毁的生命周期中经历的阶段。</p>
<h3 id="4-2-bean定义生成"><a href="#4-2-bean定义生成" class="headerlink" title="4.2 bean定义生成"></a>4.2 bean定义生成</h3><p>​        bean定义生成主要分为三个步骤，即bean定义的获取、bean定义的注册。<br><strong>1、bean定义的获取</strong><br>​        bean的定义来源各种各样，如xml定义、java注解定义等。<br>​        spring对各种来源提供了统一的接口org.springframework.core.io.Resource，<br>​        Resource接口即也是对spring内的所有底层资源进行了抽象（如file、url、classpath）。<br>​        Resource接口相关的类结构图如下：<br><img src="https://img-blog.csdnimg.cn/20181114231111589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5hYmVzdGNoaW5h,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​        各类bean定义的加载请参数相应spring源码。<br><strong>2、bean定义的解析</strong><br>​        由于来源的不同，bean的解析也是各种各样的（如xml内标签的解析）。<br>​        spring对bean的定义仍然有公共的接口org.springframework.beans.factory.config.BeanDefinition。<br>​        具体解析请查看spring源码。<br><strong>3、bean的注册</strong><br>​        解析得到的bean，最终会注册到容器中，其实也就是ConcurrentHashMap，<br>​        即org.springframework.beans.factory.support.DefaultListableBeanFactory类中的实例变量</p>
<pre><code class="java">/** Map of bean definition objects, keyed by bean name */
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<p>​        此bean的加载完成</p>
<h3 id="4-3-spring的生命周期"><a href="#4-3-spring的生命周期" class="headerlink" title="4.3 spring的生命周期"></a>4.3 spring的生命周期</h3><p>​        spring生命周期中的阶段，包括初始化、使用、销毁。<br><strong>1、初始化阶段</strong><br>​        1）调用bean的构造函数，创建实例；<br>​        2）进行参数依赖注入；<br>​        3）若实现org.springframework.beans.BeanNameAware接口，则调用BeanNameAware的setBeanName()方法;<br>​        4）若实现org.springframework.beans.factory.BeanClassLoaderAware接口，则调用BeanClassLoaderAware的setBeanClassLoader()方法;<br>​        5）若实现org.springframework.context.ApplicationContextAware接口，则调用ApplicationContextAware的setApplicationContext()方法;<br>​        6）若使用了注解@PostConstruct，则调相应方法；<br>​        7）若实现org.springframework.beans.factory.InitializingBean接口，则调用InitializingBean接口的afterPropertiesSet方法;<br>​        8）若bean定义的使用了initMethod，则调相应方法；<br>​        9）若实现org.springframework.beans.factory.config.BeanPostProcessor接口，则调用BeanPostProcessor的postProcessBeforeInitialization()方法和postProcessAfterInitialization方法;<br><strong>2、使用阶段</strong><br>​        1）bean在项目的使用；<br><strong>3、销毁阶段</strong><br>​        1）若使用注解@PreDestroy，则调用相应方法；<br>​        2）若bean定义中配置了destroyMethod，则调用相应方法；<br>​        3）若实现org.springframework.beans.factory.DisposableBean接口，则调用DisposableBean接口的destroy方法; </p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>综合前面的代码和分析，现在我们用大白话描述下：</p>
<ol>
<li>Bean容器找到Spring配置文件中Bean的定义；</li>
<li>Bean容器利用java 反射机制实例化Bean；</li>
<li>Bean容器为实例化的Bean设置属性值；</li>
<li>如果Bean实现了BeanNameAware接口，则执行setBeanName方法；</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则执行setBeanClassLoader方法；</li>
<li>如果Bean实现了BeanFactoryAware接口，则执行setBeanFactory方法；</li>
<li>如果 ……真的，到这我经常忘记，但前面三个Aware接口肯定能记住；</li>
<li>如果Bean实现了ApplicationContextAware接口，则执行setApplicationContext方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessBeforeInitialization方法；</li>
<li>如果Bean定义初始化方法（PostConstruct注解、配置init-method、实现了InitializingBean接口），则执行定义的初始化方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessAfterInitialization方法；</li>
<li>当要销毁这个Bean时，如果自定义了销毁方法（PreDestroy注解、配置destroy-method、实现了DisposableBean接口），则执行定义的销毁方法。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/" data-id="cl0utfle8001gugvsdmoc4ktp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA/Spring框架/Spring/Spring使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Spring使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring使用详解"><a href="#Spring使用详解" class="headerlink" title="Spring使用详解"></a>Spring使用详解</h1><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><h3 id="1-1、Spring组成"><a href="#1-1、Spring组成" class="headerlink" title="1.1、Spring组成"></a>1.1、Spring组成</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF6KnNia5YDhfatibrMvAUAhxgF27g4HdJsBGl6Fae9yQlUQJc9Bf8uftw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFetRkkw19r7H3mHDibgs4RpRNHdG6CcIMdnxRCu2yYXNiano7ESCCMF0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <strong>BeanFactory</strong>，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式<strong>将应用程序的配置和依赖性规范与实际的应用程序代码分开</strong>。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架<strong>提供上下文信息</strong>。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象<strong>提供事务管理服务</strong>。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来<strong>管理异常处理和不同数据库供应商抛出的错误消息</strong>。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h3 id="1-2、拓展"><a href="#1-2、拓展" class="headerlink" title="1.2、拓展"></a>1.2、拓展</h3><p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li>
<li>Spring Cloud是基于Spring Boot实现的；</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
<li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFH5GFXM4YPUGrmA2JdpPic3FwYaI1JZHBZxibaUJVXWzzTFeCayk4XAIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="二、IOC讲解"><a href="#二、IOC讲解" class="headerlink" title="二、IOC讲解"></a>二、IOC讲解</h2><h3 id="2-1、IOC基础"><a href="#2-1、IOC基础" class="headerlink" title="2.1、IOC基础"></a>2.1、IOC基础</h3><p>新建一个空白的maven项目</p>
<blockquote>
<p>分析实现</p>
</blockquote>
<p>我们先用我们原来的方式写一段代码。</p>
<p>1、UserDao接口</p>
<pre><code class="java">public interface UserDao &#123;
    public void getUser();
&#125;
</code></pre>
<p>2、Dao的实现类</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>3、UserService接口</p>
<pre><code class="java">public interface UserService &#123;
    public void getUser();
&#125;
</code></pre>
<p>4、Service实现类</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>5、测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
    UserService service = new UserServiceImpl();
    service.getUser();
&#125;
</code></pre>
<blockquote>
<p>=========================接下来做一下修改=================================</p>
</blockquote>
<p>增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoMySqlImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;MySql获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoMySqlImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>假设再增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoOracleImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;Oracle获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>​        那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现。假设我们的这种需求非常大 , 这种方式就根本不适用。这种设计的耦合性太高了, 牵一发而动全身。</p>
<p><strong>那我们如何去解决呢 ?</strong> </p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    
    // 利用set实现
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
&#125;
</code></pre>
<p>​        这两者有着本质区别：以前的思路都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者。程序不用去管怎么创建,怎么实现了。 它只负责提供一个接口。</p>
<p>​        这种思想 , 从本质上解决了问题 , 程序员不再去管理对象的创建 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="2-2、IOC本质"><a href="#2-2、IOC本质" class="headerlink" title="2.2、IOC本质"></a>2.2、IOC本质</h3><p>​        <strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFuYibmavlBHq9e4cDqiclpYSG8VT4EicVsnqKp65yJKQeNibsVdTiahQibJSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        <strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>​        <u>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</u></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p>​        <strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="三、HelloSpring"><a href="#三、HelloSpring" class="headerlink" title="三、HelloSpring"></a>三、HelloSpring</h2><h3 id="3-1、helloSpring的创建"><a href="#3-1、helloSpring的创建" class="headerlink" title="3.1、helloSpring的创建"></a>3.1、helloSpring的创建</h3><blockquote>
<p>导入jar包依赖</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 但是利用maven会自动下载对应的依赖项。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="java">@Data
public class Hello &#123;
   private String name;

   public void show()&#123;
       System.out.println(&quot;Hello,&quot;+ name );
  &#125;
&#125;
</code></pre>
<p>2、编写spring的文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>其中，bean标签各个参数解释如下：</p>
<ul>
<li><strong>id：</strong>JavaBean在BeanFactory中唯一标识，代码中通过BeanFactory获取JavaBean实例时需要此参数作为索引名称</li>
<li>name：可以为Bean指定多个名称（起别名）</li>
<li><strong>class：</strong>JavaBean 类名</li>
<li><strong>scope：</strong>设定Bean的作用域<ul>
<li><strong>singleton</strong>：指定此Java Bean是否使用单例模式，如果设为“True”，则在BeanFactory作用范围内只维护此Java Bean的一个实例，代码通BeanFactory获取此javaBean实例的引用;反这如果设为“False”，则通过BeanFactory获取javaBean实例时，BeanFactory每次都将创建一个新的实例返回。</li>
<li><strong>Prototype：</strong>原型：表示通过IoC容器获取的Bean是不同的</li>
<li><strong>request：</strong>请求：表示在一次HTTP请求内有效</li>
<li><strong>session：</strong>会话：表示在一个用户会话内有效</li>
</ul>
</li>
<li><strong>init-method：</strong>初始化方法，此方法将在BeanFactory创建JavaBean实例之后，在向应用层返回引用之前执行。一般用于一些资源的初始化工作。</li>
<li>销毁方法：此方法将在BeanFactory销毁的时候执行，一般用于资源释放。</li>
<li><strong>depends-on：</strong>Bean依赖关系。一般情况下无需设定。Spring会根据情况组织各个依赖关系的构建工作（这里<br>示例中的depends-on属性非必须）。只有某些特殊情况下，如JavaBean中的某些静态变量需要进行初始化（这是一种Bad Smell，应该在设计上应该避免）。通过depends-on指定其依赖关系可保证在此Bean加载之前，首先对depends-on所指定的资源进行加载。</li>
<li><strong>value：</strong>通过<value/>节点可指定属性值。BeanFactory将自动根据Java Bean对应的属性类型加以匹配。注意<value></value>代表一个空字符串，如果需要将属性值设定为null，必须使用<null/>节点。</li>
<li><strong>ref：</strong>指定了属性对BeanFactory中其他Bean的引用关系。</li>
<li><strong>property：</strong>Bean的子元素，用来指定需要赋值的属性</li>
<li><strong>constructor-arg：</strong>用于有参构造的注入<ul>
<li>index：指定下标</li>
<li>value：赋值</li>
<li>type：参数类型</li>
<li>ref：将注入别的Bean</li>
</ul>
</li>
<li><strong>import：</strong>用于导入别的XML文件</li>
</ul>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   // 解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   // getBean : 参数即为spring配置文件中bean的id .
   Hello hello = (Hello) context.getBean(&quot;hello&quot;);
   // 调用对象hello的show方法
   hello.show();
&#125;
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  <ul>
<li>hello 对象是由Spring创建的</li>
</ul>
</li>
<li>Hello 对象的属性是怎么设置的 ?  <ul>
<li>hello 对象的属性是由Spring容器设置的</li>
</ul>
</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p><strong>依赖注入 :</strong> 就是利用set方法来进行注入的.</p>
<p>​         IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>​        可以通过newClassPathXmlApplicationContext去浏览一下底层源码 。</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>新增一个Spring配置文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
&#125;
</code></pre>
<p>​        OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p>
<h3 id="3-2、IOC创建对象方式"><a href="#3-2、IOC创建对象方式" class="headerlink" title="3.2、IOC创建对象方式"></a>3.2、IOC创建对象方式</h3><h4 id="3-2-1、通过无参构造方法创建"><a href="#3-2-1、通过无参构造方法创建" class="headerlink" title="3.2.1、通过无参构造方法创建"></a>3.2.1、通过无参构造方法创建</h4><p>1、User.java</p>
<pre><code class="java">public class User &#123;

    private String name;

    public User() &#123;
        System.out.println(&quot;user无参构造方法&quot;);
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
&#125;
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h4 id="3-2-2、通过有参构造方法创建"><a href="#3-2-2、通过有参构造方法创建" class="headerlink" title="3.2.2、通过有参构造方法创建"></a>3.2.2、通过有参构造方法创建</h4><p>1、UserT . java</p>
<pre><code class="java">public class UserT &#123;

    private String name;

    public UserT(String name) &#123;
        this.name = name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- index指构造方法 , 下标从0开始 --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- name指参数名 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testT()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    UserT user = (UserT) context.getBean(&quot;userT&quot;);
    user.show();
&#125;
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h3 id="3-3、Spring配置"><a href="#3-3、Spring配置" class="headerlink" title="3.3、Spring配置"></a>3.3、Spring配置</h3><h4 id="3-3-1、别名"><a href="#3-3-1、别名" class="headerlink" title="3.3.1、别名"></a>3.3.1、别名</h4><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h4 id="3-3-2、Bean的配置"><a href="#3-3-2、Bean的配置" class="headerlink" title="3.3.2、Bean的配置"></a>3.3.2、Bean的配置</h4><pre><code class="xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3-3-3、import"><a href="#3-3-3、import" class="headerlink" title="3.3.3、import"></a>3.3.3、import</h4><p>团队的合作通过import来实现 .</p>
<pre><code class="xml">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;
</code></pre>
<h2 id="四、依赖注入（DI）"><a href="#四、依赖注入（DI）" class="headerlink" title="四、依赖注入（DI）"></a>四、依赖注入（DI）</h2><h3 id="4-1、依赖注入"><a href="#4-1、依赖注入" class="headerlink" title="4.1、依赖注入"></a>4.1、依赖注入</h3><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p><strong>Address.java</strong></p>
<pre><code class="java"> public class Address &#123;
 
     private String address;
 
     public String getAddress() &#123;
         return address;
    &#125;
 
     public void setAddress(String address) &#123;
         this.address = address;
    &#125;
 &#125;
</code></pre>
<p><strong>Student.java</strong></p>
<pre><code class="java">@Data
public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbys;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name
                           + &quot;,address=&quot;+ address.getAddress()
                           + &quot;,books=&quot;
                          );
        for (String book:books)&#123;
            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);
        &#125;
        System.out.println(&quot;\n爱好:&quot;+hobbys);

        System.out.println(&quot;card:&quot;+card);

        System.out.println(&quot;games:&quot;+games);

        System.out.println(&quot;wife:&quot;+wife);

        System.out.println(&quot;info:&quot;+info);

    &#125;
&#125;
</code></pre>
<h4 id="4-1-1、常量注入"><a href="#4-1-1、常量注入" class="headerlink" title="4.1.1、常量注入"></a>4.1.1、常量注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test01()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    Student student = (Student) context.getBean(&quot;student&quot;);

    System.out.println(student.getName());

&#125;
</code></pre>
<h4 id="4-1-2、Bean注入"><a href="#4-1-2、Bean注入" class="headerlink" title="4.1.2、Bean注入"></a>4.1.2、Bean注入</h4><p>注意点：这里的值是一个引用，ref</p>
<pre><code class="xml">&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-3、数组注入"><a href="#4-1-3、数组注入" class="headerlink" title="4.1.3、数组注入"></a>4.1.3、数组注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;西游记&lt;/value&gt;
            &lt;value&gt;红楼梦&lt;/value&gt;
            &lt;value&gt;水浒传&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-4、List注入"><a href="#4-1-4、List注入" class="headerlink" title="4.1.4、List注入"></a>4.1.4、List注入</h4><pre><code class="xml">&lt;property name=&quot;hobbys&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;听歌&lt;/value&gt;
        &lt;value&gt;看电影&lt;/value&gt;
        &lt;value&gt;爬山&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-5、Map注入"><a href="#4-1-5、Map注入" class="headerlink" title="4.1.5、Map注入"></a>4.1.5、Map注入</h4><pre><code class="xml">&lt;property name=&quot;card&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt;
        &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-6、set注入"><a href="#4-1-6、set注入" class="headerlink" title="4.1.6、set注入"></a>4.1.6、set注入</h4><pre><code class="xml">&lt;property name=&quot;games&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;LOL&lt;/value&gt;
        &lt;value&gt;BOB&lt;/value&gt;
        &lt;value&gt;COC&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-7、Null注入"><a href="#4-1-7、Null注入" class="headerlink" title="4.1.7、Null注入"></a>4.1.7、Null注入</h4><pre><code class="xml">&lt;property name=&quot;wife&quot;&gt;
    &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-9、Properties注入"><a href="#4-1-9、Properties注入" class="headerlink" title="4.1.9、Properties注入"></a>4.1.9、Properties注入</h4><pre><code class="xml">&lt;property name=&quot;info&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;
        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
<p>测试结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYGHEFnrCA8Jyr6ian5MWrUHtnKBpYYTTtysbp5UPYKQxSiaUHJibPKlicuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-1-10、p命名和c命名注入"><a href="#4-1-10、p命名和c命名注入" class="headerlink" title="4.1.10、p命名和c命名注入"></a>4.1.10、p命名和c命名注入</h4><p>User.java ：【注意：这里没有有参构造器！】</p>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>1、<strong>P命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;
</code></pre>
<p>2、<strong>c 命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;

&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;
</code></pre>
<p>​        发现问题：显示错误，代码标红</p>
<p>​        解决：把有参构造器加上，这里也能知道，c 就是所谓的<strong>构造器注入</strong>！</p>
<p>测试代码：</p>
<pre><code class="java">@Test
public void test02()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    System.out.println(user);
&#125;
</code></pre>
<h3 id="4-2、Bean的作用域"><a href="#4-2、Bean的作用域" class="headerlink" title="4.2、Bean的作用域"></a>4.2、Bean的作用域</h3><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYfmmAQF8hrnicY49FRXEkR5xkxD5A4H5pVUia3mFhrDdh4gBt183EiaFaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="4-2-1、Singleton"><a href="#4-2-1、Singleton" class="headerlink" title="4.2.1、Singleton"></a>4.2.1、Singleton</h4><p>​        <strong>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</strong>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test03()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    User user2 = (User) context.getBean(&quot;user&quot;);
    System.out.println(user==user2);
&#125;
</code></pre>
<h4 id="4-2-2、Prototype"><a href="#4-2-2、Prototype" class="headerlink" title="4.2.2、Prototype"></a>4.2.2、Prototype</h4><p>​        <strong>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。</strong>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml"> &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
 或者
 &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;
</code></pre>
<h4 id="4-2-3、Request"><a href="#4-2-3、Request" class="headerlink" title="4.2.3、Request"></a>4.2.3、Request</h4><p>​        <strong>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例</strong>；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>​        针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="4-2-4、Session"><a href="#4-2-4、Session" class="headerlink" title="4.2.4、Session"></a>4.2.4、Session</h4><p>​        <strong>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。</strong>该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>​        针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<h2 id="五、自动装配"><a href="#五、自动装配" class="headerlink" title="五、自动装配"></a>五、自动装配</h2><h3 id="5-1、自动装配"><a href="#5-1、自动装配" class="headerlink" title="5.1、自动装配"></a>5.1、自动装配</h3><blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ul>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ul>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ul>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ul>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h4 id="5-1-1、测试环境搭建"><a href="#5-1-1、测试环境搭建" class="headerlink" title="5.1.1、测试环境搭建"></a>5.1.1、测试环境搭建</h4><p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="java">public class Cat &#123;
   public void shout() &#123;
       System.out.println(&quot;miao~&quot;);
  &#125;
&#125;
    
public class Dog &#123;
   public void shout() &#123;
       System.out.println(&quot;wang~&quot;);
  &#125;
&#125;
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="java">public class User &#123;
   private Cat cat;
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void testMethodAutowire() &#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  &#125;
&#125;
</code></pre>
<p>结果正常输出。</p>
<h4 id="5-1-2、byName"><a href="#5-1-2、byName" class="headerlink" title="5.1.2、byName"></a>5.1.2、byName</h4><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=”byName”</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<h4 id="5-1-3、byType"><a href="#5-1-3、byType" class="headerlink" title="5.1.3、byType"></a>5.1.3、byType</h4><p>​        <strong>autowire byType (按类型自动装配)</strong></p>
<p>​        使用autowire byType首先需要保证：<strong>同一类型的对象，在spring容器中唯一</strong>。如果不唯一，会报不唯一的异常。</p>
<pre><code class="xml">NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="5-2、使用注解"><a href="#5-2、使用注解" class="headerlink" title="5.2、使用注解"></a>5.2、使用注解</h3><blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;
</code></pre>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="java">public class User &#123;
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String str;

   public Cat getCat() &#123;
       return cat;
  &#125;
   public Dog getDog() &#123;
       return dog;
  &#125;
   public String getStr() &#123;
       return str;
  &#125;
&#125;
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【小狂神科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code class="java">//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;

@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p><strong>实体类</strong>：</p>
<pre><code class="java">public class User &#123;
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="java">@Resource
private Cat cat;

@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<p><strong>小结</strong></p>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="六、使用注解开发"><a href="#六、使用注解开发" class="headerlink" title="六、使用注解开发"></a>六、使用注解开发</h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h3><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IzypAUHDfDEujP4ry6cHxWTvAS6qRS0qrmMCic3QqF9icGNcPj8IZwNo3R9VEgpAgWHrStBN1ya6Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="6-2、Bean的实现"><a href="#6-2、Bean的实现" class="headerlink" title="6.2、Bean的实现"></a>6.2、Bean的实现</h3><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   public String name = &quot;秦疆&quot;;
&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext applicationContext =
       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   User user = (User) applicationContext.getBean(&quot;user&quot;);
   System.out.println(user.name);
&#125;
</code></pre>
<h3 id="6-3、属性注入"><a href="#6-3、属性注入" class="headerlink" title="6.3、属性注入"></a>6.3、属性注入</h3><p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   @Value(&quot;秦疆&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   public String name;
&#125;
</code></pre>
<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<pre><code class="java">@Component(&quot;user&quot;)
public class User &#123;

   public String name;

   @Value(&quot;秦疆&quot;)
   public void setName(String name) &#123;
       this.name = name;
  &#125;
&#125;
</code></pre>
<h3 id="6-4、衍生注解"><a href="#6-4、衍生注解" class="headerlink" title="6.4、衍生注解"></a>6.4、衍生注解</h3><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User &#123;
   @Value(&quot;秦疆&quot;)
   public String name;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code>&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li><p>进行注解驱动注册，从而使注解生效</p>
</li>
<li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li><p>如果不扫描包，就需要手动配置bean</p>
</li>
<li><p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<h3 id="6-5、基于Java类进行配置"><a href="#6-5、基于Java类进行配置" class="headerlink" title="6.5、基于Java类进行配置"></a>6.5、基于Java类进行配置</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog &#123;
   public String name = &quot;dog&quot;;
&#125;
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig &#123;

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
&#125;
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig2 &#123;
&#125;
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="java">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig &#123;

   @Bean
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
<h2 id="七、静态-动态代理模式"><a href="#七、静态-动态代理模式" class="headerlink" title="七、静态/动态代理模式"></a>七、静态/动态代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p>
<p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>学习aop之前 , 我们要先了解一下代理模式！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLRnfS7LpO0Iic7fEEPFCgRs0ggNXCwf6IKo1tibjPmNSTEYeII5ro7YLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-1、静态代理"><a href="#7-1、静态代理" class="headerlink" title="7.1、静态代理"></a>7.1、静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li><p>抽象角色 : 一般使用接口或者抽象类来实现</p>
</li>
<li><p>真实角色 : 被代理的角色</p>
</li>
<li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p>
</li>
<li><p>客户  :  使用代理角色来进行一些操作 </p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>Proxy . java 即代理角色</p>
<pre><code class="java">//代理角色：中介
public class Proxy implements Rent &#123;

   private Host host;
   public Proxy() &#123; &#125;
   public Proxy(Host host) &#123;
       this.host = host;
  &#125;

   //租房
   public void rent()&#123;
       seeHouse();
       host.rent();
       fare();
  &#125;
   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;
&#125;
</code></pre>
<p>Client . java 即客户</p>
<pre><code class="java">//客户类，一般客户都会去找代理！
public class Client &#123;
   public static void main(String[] args) &#123;
       //房东要租房
       Host host = new Host();
       //中介帮助房东
       Proxy proxy = new Proxy(host);

       //你去找中介！
       proxy.rent();
  &#125;
&#125;
</code></pre>
<p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="7-2、静态代理再理解"><a href="#7-2、静态代理再理解" class="headerlink" title="7.2、静态代理再理解"></a>7.2、静态代理再理解</h3><p>练习步骤：</p>
<p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p>
<pre><code class="java">//抽象角色：增删改查业务
public interface UserService &#123;
   void add();
   void delete();
   void update();
   void query();
&#125;
</code></pre>
<p>2、我们需要一个真实对象来完成这些增删改查操作</p>
<pre><code class="java">//真实对象，完成增删改查操作的人
public class UserServiceImpl implements UserService &#123;

   public void add() &#123;
       System.out.println(&quot;增加了一个用户&quot;);
  &#125;

   public void delete() &#123;
       System.out.println(&quot;删除了一个用户&quot;);
  &#125;

   public void update() &#123;
       System.out.println(&quot;更新了一个用户&quot;);
  &#125;

   public void query() &#123;
       System.out.println(&quot;查询了一个用户&quot;);
  &#125;
&#125;
</code></pre>
<p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
<p>4、设置一个代理类来处理日志！代理角色</p>
<pre><code class="java">//代理角色，在这里面增加日志的实现
public class UserServiceProxy implements UserService &#123;
   private UserServiceImpl userService;

   public void setUserService(UserServiceImpl userService) &#123;
       this.userService = userService;
  &#125;

   public void add() &#123;
       log(&quot;add&quot;);
       userService.add();
  &#125;

   public void delete() &#123;
       log(&quot;delete&quot;);
       userService.delete();
  &#125;

   public void update() &#123;
       log(&quot;update&quot;);
       userService.update();
  &#125;

   public void query() &#123;
       log(&quot;query&quot;);
       userService.query();
  &#125;

   public void log(String msg)&#123;
       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>5、测试访问类：</p>
<pre><code class="java">public class Client &#123;
   public static void main(String[] args) &#123;
       //真实业务
       UserServiceImpl userService = new UserServiceImpl();
       //代理类
       UserServiceProxy proxy = new UserServiceProxy();
       //使用代理类实现日志功能！
       proxy.setUserService(userService);

       proxy.add();
  &#125;
&#125;
</code></pre>
<p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLJqcgicA5aEKtxYibgLPicNfDwicKIn9NlFl86rriaVRicKnEXlPNiacbHiaLibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、动态代理"><a href="#7-3、动态代理" class="headerlink" title="7.3、动态代理"></a>7.3、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLxvyvZMwn9gIEibuxjFwE3enJ4TgKO5PXxM5BPr6Bh7GQwExLvst4AsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>Object invoke(Object proxy, 方法 method, Object[] args)；
//参数
//proxy - 调用该方法的代理实例
//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。
</code></pre>
<p>【Proxy  : 代理】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="java">//生成代理类
public Object getProxy()&#123;
   return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                 rent.getClass().getInterfaces(),this);
&#125;
</code></pre>
<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>ProxyInvocationHandler. java 即代理角色</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Rent rent;

   public void setRent(Rent rent) &#123;
       this.rent = rent;
  &#125;

   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               rent.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.
   // 处理代理实例上的方法调用并返回结果
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       seeHouse();
       //核心：本质利用反射实现！
       Object result = method.invoke(rent, args);
       fare();
       return result;
  &#125;

   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;

&#125;
</code></pre>
<p>Client . java</p>
<pre><code class="java">//租客
public class Client &#123;

   public static void main(String[] args) &#123;
       //真实角色
       Host host = new Host();
       //代理实例的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setRent(host); //将真实角色放置进去！
       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！
       proxy.rent();
  &#125;

&#125;
</code></pre>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h3 id="7-4、深入理解"><a href="#7-4、深入理解" class="headerlink" title="7.4、深入理解"></a>7.4、深入理解</h3><p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Object target;

   public void setTarget(Object target) &#123;
       this.target = target;
  &#125;

   //生成代理类
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  &#125;

   public void log(String methodName)&#123;
       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>测试！</p>
<pre><code class="java">public class Test &#123;
   public static void main(String[] args) &#123;
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setTarget(userService); //设置要代理的对象
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       proxy.delete();
  &#125;
&#125;
</code></pre>
<p>测试，增删改查，查看结果！</p>
<blockquote>
<h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h2 id="八、AOP"><a href="#八、AOP" class="headerlink" title="八、AOP"></a>八、AOP</h2><h3 id="8-1、AOP简介"><a href="#8-1、AOP简介" class="headerlink" title="8.1、AOP简介"></a>8.1、AOP简介</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。<ul>
<li>前置通知：在某连接点之前执行的通知，这个通知不能组织连接点之前的执行流程</li>
<li>后置通知：在某连接点正常完成后执行的通知</li>
<li>异常通知：在方法抛出异常退出时执行的通知</li>
<li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li>
<li>环绕通知：保卫一个连接点的通知，如方法调用</li>
</ul>
</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="8-2、使用AOP"><a href="#8-2、使用AOP" class="headerlink" title="8.2、使用AOP"></a>8.2、使用AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="8-2-1、通过-Spring-API-实现"><a href="#8-2-1、通过-Spring-API-实现" class="headerlink" title="8.2.1、通过 Spring API 实现"></a>8.2.1、通过 Spring API 实现</h4><p>首先编写我们的业务接口和实现类</p>
<pre><code class="java">public interface UserService &#123;

   public void add();

   public void delete();

   public void update();

   public void search();

&#125;

public class UserServiceImpl implements UserService&#123;

   @Override
   public void add() &#123;
       System.out.println(&quot;增加用户&quot;);
  &#125;

   @Override
   public void delete() &#123;
       System.out.println(&quot;删除用户&quot;);
  &#125;

   @Override
   public void update() &#123;
       System.out.println(&quot;更新用户&quot;);
  &#125;

   @Override
   public void search() &#123;
       System.out.println(&quot;查询用户&quot;);
  &#125;
&#125;
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="java">public class Log implements MethodBeforeAdvice &#123;

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;
       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  &#125;
&#125;
public class AfterLog implements AfterReturningAdvice &#123;
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  &#125;
&#125;
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  &#125;
&#125;
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<h4 id="8-2-2、自定义类来实现Aop"><a href="#8-2-2、自定义类来实现Aop" class="headerlink" title="8.2.2、自定义类来实现Aop"></a>8.2.2、自定义类来实现Aop</h4><p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="java">public class DiyPointcut &#123;

   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;
   
&#125;
</code></pre>
<p>去spring中配置</p>
<pre><code class="xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  &#125;
&#125;
</code></pre>
<h4 id="8-2-3、使用注解实现"><a href="#8-2-3、使用注解实现" class="headerlink" title="8.2.3、使用注解实现"></a>8.2.3、使用注解实现</h4><p>第一步：编写一个注解实现的增强类</p>
<pre><code class="java">package com.kuang.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class AnnotationPointcut &#123;
   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;

   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;

   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable &#123;
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  &#125;
&#125;
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
<h2 id="九、声明式事务"><a href="#九、声明式事务" class="headerlink" title="九、声明式事务"></a>九、声明式事务</h2><h3 id="9-1、Spring的事务管理"><a href="#9-1、Spring的事务管理" class="headerlink" title="9.1、Spring的事务管理"></a>9.1、Spring的事务管理</h3><p>​        Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li><p>优点：将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p>
</li>
<li><p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li><p>一般情况下比编程式事务好用。</p>
</li>
<li><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p>
</li>
<li><p>将事务管理作为横切关注点，通过aop方法模块化。</p>
</li>
</ul>
<h3 id="9-2、通过Spring-AOP框架支持声明式事务管理"><a href="#9-2、通过Spring-AOP框架支持声明式事务管理" class="headerlink" title="9.2、通过Spring AOP框架支持声明式事务管理"></a>9.2、通过Spring AOP框架支持声明式事务管理</h3><p>​        使用Spring管理事务，注意<strong>头文件的约束导入 : tx</strong></p>
<pre><code class="xml">&lt;beans xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<h4 id="9-2-1、spring事务传播特性："><a href="#9-2-1、spring事务传播特性：" class="headerlink" title="9.2.1、spring事务传播特性："></a>9.2.1、spring事务传播特性：</h4><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<h4 id="9-2-2、配置AOP"><a href="#9-2-2、配置AOP" class="headerlink" title="9.2.2、配置AOP"></a>9.2.2、配置AOP</h4><p>导入aop的头文件！</p>
<pre><code class="xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" data-id="cl0utfler003zugvs6h3g2y8e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringMVC/">SpringMVC</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybaits/" rel="tag">Mybaits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">JVM使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">G1使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/JSP%E7%AE%80%E4%BB%8B/">JSP简介</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/helloservlet/">配置文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Shuyan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>