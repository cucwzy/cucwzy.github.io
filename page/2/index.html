
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Stay Hungry, Stay Foolish</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Shuyan</h1>
                <h3>Stay Hungry, Stay Foolish</h3>
                <h5>ShuyanCoding......</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/">
        <h2>
            Spring整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、Mybaits-Spring包"><a href="#一、Mybaits-Spring包" class="headerlink" title="一、Mybaits-Spring包"></a>一、Mybaits-Spring包</h2><p>MyBatis-Spring 会帮助我们将 MyBatis 代码无缝地整合到 Spring 中，MyBatis-Spring 需要以下版本：</p>
<pre><code class="java">| MyBatis-Spring | MyBatis | Spring 框架 | Spring Batch | Java   |
| -------------- | ------- | --------- | ------------ | ------- |
| 2.0            | 3.5+    | 5.0+      | 4.0+         | Java 8+ |
| 1.3            | 3.4+    | 3.2.2+    | 2.1+         | Java 6+ |
</code></pre>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        要和 Spring 一起使用 MyBatis，首先需要<code>SqlSessionFactory</code>，在MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>,配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>注</strong>：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 <code>DataSource</code>，只需要和配置其它 Spring 数据库连接一样配置它就可以了</p>
<p><strong><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。</strong></p>
<p>作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。<code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
<p>可以使用 <code>SqlSessionFactory</code> 作为构造方法的参数来创建 <code>SqlSessionTemplate</code> 对象。</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样:</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
  private SqlSession sqlSession;
  public void setSqlSession(SqlSession sqlSession) &#123;
    this.sqlSession = sqlSession;
  &#125;
  public User getUser(String userId) &#123;
    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);
  &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;
  &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="二、Spring整个Mybaits"><a href="#二、Spring整个Mybaits" class="headerlink" title="二、Spring整个Mybaits"></a>二、Spring整个Mybaits</h2><h3 id="2-1、user数据表："><a href="#2-1、user数据表：" class="headerlink" title="2.1、user数据表："></a>2.1、<strong>user数据表：</strong></h3><pre><code class="sql">CREATE TABLE user(
    id INT NOT NULL,
    &#39;name&#39; VARCHAR(20) NOT NULL,
    &#39;pwd&#39; VARCHAR(20) NOT NULL,
    PRIMARY KEY(id)
)ENGINE=InnoDB DEFAULT CHARSET=utf-8; 
</code></pre>
<h3 id="2-2、实体类"><a href="#2-2、实体类" class="headerlink" title="2.2、实体类"></a>2.2、<strong>实体类</strong></h3><pre><code class="java">@Data
@ALLArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
<h3 id="2-3、导包"><a href="#2-3、导包" class="headerlink" title="2.3、导包"></a>2.3、<strong>导包</strong></h3><ul>
<li>mybatis-spring整合包 【最重要】</li>
<li>mybaits</li>
<li>mysql驱动的</li>
<li>junit</li>
<li>spring-core</li>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-jdbc 【数据源】</li>
<li>spring-tx 【事务】</li>
<li>…</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--mybaits--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--mysql连接驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.9&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"><a href="#2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件" class="headerlink" title="2.4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"></a>2.4、<strong>配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.westos.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/westos/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="2-5、编写Spring配置文件"><a href="#2-5、编写Spring配置文件" class="headerlink" title="2.5、编写Spring配置文件"></a>2.5、<strong>编写Spring配置文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!--1.配置数据源,我们使用的是spring的数据源，还可以使用第三方的数据源
        dbcp,c3p0
        com.mchange.v2.c3p0.ComboPooledDataSource
        org.apache.commons.dbcp.BasicDataSource
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--2.配置SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--关联mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--3.创建selSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="2-6、接口实现类增加一个属性：sqlSession"><a href="#2-6、接口实现类增加一个属性：sqlSession" class="headerlink" title="2.6、接口实现类增加一个属性：sqlSession"></a>2.6、<strong>接口实现类增加一个属性：sqlSession</strong></h3><pre><code class="java">import org.apache.ibatis.session.SqlSession;
import org.westos.pojo.User;
import java.util.List;

public class UserMapperImpl implements UserMapper &#123;
    private SqlSession sqlSession;
    public void setSqlSession(SqlSession sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;
    public List&lt;User&gt; getUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
    &#125;
&#125;
</code></pre>
<h3 id="2-7、将接口的实现类交给spring来管理"><a href="#2-7、将接口的实现类交给spring来管理" class="headerlink" title="2.7、将接口的实现类交给spring来管理"></a>2.7、<strong>将接口的实现类交给spring来管理</strong></h3><pre><code class="xml">&lt;!--4.接口实现类注入sqlSession--&gt;
&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.westos.dao.UserMapperImpl&quot;&gt;
   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2-8、测试类"><a href="#2-8、测试类" class="headerlink" title="2.8、测试类"></a>2.8、<strong>测试类</strong></h3><pre><code class="java">import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.westos.pojo.User;
import java.util.List;

public class TestUserMapper &#123;
    
    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapperImpl userMapperImpl = (UserMapperImpl) context.getBean(&quot;UserMapperImpl&quot;);
        List&lt;User&gt; users = userMapperImpl.getUser();
        for (User user : users) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="三、整合Druid并开启监控"><a href="#三、整合Druid并开启监控" class="headerlink" title="三、整合Druid并开启监控"></a>三、整合Druid并开启监控</h2><h3 id="3-1、整合Druid"><a href="#3-1、整合Druid" class="headerlink" title="3.1、整合Druid"></a>3.1、整合Druid</h3><h4 id="3-1-1-导入starter"><a href="#3-1-1-导入starter" class="headerlink" title="3.1.1 导入starter"></a>3.1.1 导入starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.1.2、配置yaml</p>
<pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    type: com.alibaba.druid.pool.DruidDataSource
    
    #连接池配置(可选)
    # 连接池的配置信息初始化大小，最小，最大
    name: testDruidDataSource
    initial-size: 5    #初始化连接大小
    max-active: 20    #最大连接数
    min-idle: 5        #最小空闲连接数
    max-wait: 60000   # 配置获取连接等待超时的时间
    
    #######监控配置  说明请参考Druid Wiki
    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙
    filters: stat,wall
    #配置 Web Stat Filter
    web-stat-filter:
      enabled: true
      url-pattern: /*
      exclusions: /druid/*,*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico
      session-stat-enable: true
      session-stat-max-count: 10
      principal-session-name: session_name
      principal-cookie-name: cookie_name
      profile-enable:
      
    # Stat View Servlet 配置  配置默认false
    stat-view-servlet:
      enabled: true
      url-pattern: /druid/*
      reset-enable: false   #禁用HTML页面上的“Reset All”功能
      login-username: admin  #监控页面登录的用户名
      login-password: 123  #监控页面登录的密码
      #IP白名单(没有配置或者为空，则允许所有访问)
      allow:
      #IP黑名单 (存在共同时，deny优先于allow)
      deny:
</code></pre>
<p><strong>由于springboot默认的是hikari，号称最快的数据源，这里我们换成了阿里巴巴的数据源，druid最强大的则是监控功能</strong></p>
<pre><code class="java">class com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper
com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@3f866f50
</code></pre>
<h3 id="3-2、整合Mybaits"><a href="#3-2、整合Mybaits" class="headerlink" title="3.2、整合Mybaits"></a>3.2、整合Mybaits</h3><h4 id="3-2-1、导包"><a href="#3-2-1、导包" class="headerlink" title="3.2.1、导包"></a>3.2.1、导包</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="3-2-2、实体类"><a href="#3-2-2、实体类" class="headerlink" title="3.2.2、实体类"></a>3.2.2、实体类</h4><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student &#123;
    private int id;
    private String name;
    private int tid;
&#125;
</code></pre>
<h4 id="3-2-3、StudentMapper"><a href="#3-2-3、StudentMapper" class="headerlink" title="3.2.3、StudentMapper"></a>3.2.3、StudentMapper</h4><pre><code class="java">@Mapper
@Repository
public interface StudentMapper &#123;
     List&lt;Student&gt; selectAllStudent();
&#125;
</code></pre>
<h4 id="3-2-4、StudentMapper-xml"><a href="#3-2-4、StudentMapper-xml" class="headerlink" title="3.2.4、StudentMapper .xml"></a>3.2.4、StudentMapper .xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.kexing.mapper.StudentMapper&quot;&gt;
    &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt;
        select * from student
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="3-2-5、配置数据源、实体别名、mapper地址"><a href="#3-2-5、配置数据源、实体别名、mapper地址" class="headerlink" title="3.2.5、配置数据源、实体别名、mapper地址"></a>3.2.5、配置数据源、实体别名、mapper地址</h4><pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    
mybatis:
  type-aliases-package: site.kexing.pojo
  mapper-locations: classpath:mapper/*.xml
</code></pre>
<h4 id="3-2-6、测试输出"><a href="#3-2-6、测试输出" class="headerlink" title="3.2.6、测试输出"></a>3.2.6、测试输出</h4><pre><code class="java">@RestController
public class StudentController &#123;
    @Autowired
    StudentMapper studentMapper;
    @RequestMapping(&quot;/selectall&quot;)
    public List&lt;Student&gt; selectAllStudent()&#123;
        List&lt;Student&gt; students = studentMapper.selectAllStudent();
        return students;
    &#125;
&#125;
</code></pre>
<pre><code class="java">[&#123;
    &quot;id&quot;:1,&quot;name&quot;:&quot;小明&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:2,&quot;name&quot;:&quot;小红&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:3,&quot;name&quot;:&quot;小张&quot;,&quot;tid&quot;:2&#125;,&#123;
    &quot;id&quot;:4,&quot;name&quot;:&quot;小李&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:5,&quot;name&quot;:&quot;旺旺&quot;,&quot;tid&quot;:1&#125;]
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#879cff>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/">
        <h2>
            Mybaits知识点
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、概念、使用方法向的问题"><a href="#一、概念、使用方法向的问题" class="headerlink" title="一、概念、使用方法向的问题"></a>一、概念、使用方法向的问题</h2><h3 id="1-1、Mybaits介绍"><a href="#1-1、Mybaits介绍" class="headerlink" title="1.1、Mybaits介绍"></a>1.1、Mybaits介绍</h3><p>​        （1）Mybatis是一个<strong>半ORM框架</strong>，它<strong>内部封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>​        （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后<u>由mybatis框架执行sql并将结果映射为java对象并返回</u>。</p>
<h3 id="1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</h3><p>​        <strong>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。</strong>Hibernate是个完整的ORM框架，而MyBatis只完成了<strong>关系-&gt;对象</strong>，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>​        （1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>​        （2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询。</p>
<p>​        （3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3、-Mybaits的优点"><a href="#1-3、-Mybaits的优点" class="headerlink" title="1.3、 Mybaits的优点?"></a><strong>1.3、 Mybaits的优点?</strong></h3><p>​        （1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>​        （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>​        （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>​        （4）能够与Spring很好的集成；</p>
<p>​        （5）<strong>提供映射标签</strong>，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-、MyBatis框架的缺点"><a href="#1-4-、MyBatis框架的缺点" class="headerlink" title="1.4 、MyBatis框架的缺点?"></a>1.4 、MyBatis框架的缺点?</h3><p>​        （1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>​        （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5、-和-的区别"><a href="#1-5、-和-的区别" class="headerlink" title="1.5、 #{}和${}的区别?"></a>1.5、 #{}和${}的区别?</h3><p>​        （1）**${}<strong>是properties文件中的</strong>变量占位符**，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>​        （2）**#{}<strong>是sql的</strong>参数占位符<strong>，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。</strong>使用#{}可以有效的防止 SQL 注入**，提高系统安全性。</p>
<pre><code class="sql">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，
举例：
order by $&#123;param&#125;
则解析成的sql为：
order by id


#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，
举例：
select * from table where name = #&#123;param&#125;，
则解析成的sql为：
select * from table where name = &quot;id&quot;
</code></pre>
<h3 id="1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</h3><p>​        （1）通过在查询的sql语句中定义字段名的<strong>别名</strong>，使字段名的别名和实体类的属性名一致</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; parameterType=&quot;java.lang.Integer&quot; resultetype=&quot;com.en.entity.user&quot;&gt;
    select user_id as id, user_no as no from test where user_id = #&#123;id&#125;;
&lt;/select&gt;
</code></pre>
<p>​        （2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<pre><code class="xml">&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;
    &lt;!–用id标签来映射主键字段–&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&gt;
        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;
        &lt;result property=&quot;no&quot; column=&quot;user_no&quot;/&gt;
    &lt;/id&gt;
&lt;/reslutMap&gt;
</code></pre>
<h3 id="1-7、-如何在mapper中传递多个参数"><a href="#1-7、-如何在mapper中传递多个参数" class="headerlink" title="1.7、 如何在mapper中传递多个参数?"></a>1.7、 如何在mapper中传递多个参数?</h3><p>​        （1）使用 <a target="_blank" rel="noopener" href="https://github.com/param">@param</a> 注解：</p>
<pre><code class="java">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);
</code></pre>
<p>​        （2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap();
map.put(&quot;start&quot;, start);
map.put(&quot;end&quot;, end);
sqlSession.selectList(&quot;student.selectUser&quot;, map);
</code></pre>
<h3 id="1-8、-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8、-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8、 MyBatis的接口绑定有哪些实现方式？"></a>1.8、 MyBatis的接口绑定有哪些实现方式？</h3><p>​        <strong>接口绑定</strong>有两种实现方式：</p>
<p>​        （1）一种是<strong>通过注解绑定</strong>，就是在接口的方法上面加上<a target="_blank" rel="noopener" href="https://github.com/Select">@Select</a>、<a target="_blank" rel="noopener" href="https://github.com/Update">@Update</a>等注解里面包含Sql语句来绑定。</p>
<pre><code class="java">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)
@Results(
         id = &quot;distTypeMap&quot;,
         value =&#123;
            @Result(id =true,property=&quot;id&quot;,column=&quot;ID&quot;)，
            @Result(property=&quot;code&quot;,column=&quot;CODE&quot;)，
            @Result(property=&quot;name&quot;,column=&quot;NAME&quot;)，
            @Result(
                property = &quot;dictDtos&quot; ,
                column = &quot;ID&quot;,
                many = @Many(
                    select = &quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,
                    fetchType = FetchType.EAGER
                )
            )
        &#125;
)
List&lt;SysDictTypeDto&gt; getAllDist();
</code></pre>
<p>​        （2）另外一种就是<strong>通过xml里面写SQL来绑定</strong>，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<pre><code class="java">&lt;mapper namespace=&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;
&lt;select id=&quot;queryFileDisposeInfo&quot; parameterType=&quot;FileDisposeVo&quot; resultMap=&quot;illegalcollection-map&quot;&gt;
   SELECT 
        BATCH_NUMBER,
        FINISH_DATE,
        FILE_NAME,
        FILE_SIZE,
        DATA_SIZE,
        FILE_TYPE,
        ORG_CODE
   FROM 
        T_FILE_DISPOSE
&lt;/select&gt;
</code></pre>
<h3 id="1-9、-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9、-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9、 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9、 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>​        （1）Mapper接口<strong>方法名</strong>和mapper.xml中定义的每个<strong>sql的id</strong>相同；<br>​        （2）Mapper接口方法的<strong>输入参数类型</strong>和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>​        （3）Mapper接口方法的<strong>输出参数类型</strong>和mapper.xml中定义的每个sql的resultType的类型相同；<br>​        （4）Mapper.xml文件中的namespace即是mapper接口的<strong>类路径</strong>;</p>
<h2 id="二、源码向的问题"><a href="#二、源码向的问题" class="headerlink" title="二、源码向的问题"></a>二、源码向的问题</h2><h3 id="2-1、-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1、-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1、 解释下MyBatis面向Mapper编程工作原理？"></a>2.1、 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>​        Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的<strong>动态代理</strong>，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2、 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2、 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>​        在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了<strong>接口全限名+方法名</strong>的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<pre><code class="java">id = applyCurrentNamespace(id, false);
public String applyCurrentNamespace(String base, boolean isReference) &#123;
   ...
   // 返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)
   return currentNamespace + &quot;.&quot; + base;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200920171405540.png" alt="img"></p>
<h3 id="2-3、-Mybatis动态sql执行原理"><a href="#2-3、-Mybatis动态sql执行原理" class="headerlink" title="2.3、 Mybatis动态sql执行原理?"></a>2.3、 Mybatis动态sql执行原理?</h3><p>​        （1）<strong>初始化阶段：</strong>通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>​        （2）<strong>代理阶段：</strong>先从Configuration配置类的MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>​        （3）<strong>数据读写阶段：</strong>通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4、-Mybatis的一级、二级缓存实现原理"><a href="#2-4、-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4、 Mybatis的一级、二级缓存实现原理?"></a>2.4、 Mybatis的一级、二级缓存实现原理?</h3><p>​        （1）<strong>一级缓存：</strong> 基于 PerpetualCache 的 HashMap 本地缓存，<strong>其存储作用域为 Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092018550771.png" alt="img"></p>
<p>​        （2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于<strong>其存储作用域为 Mapper(Namespace)级别</strong>。</p>
<p>​        Mybatis默认不打开二级缓存，可以在config文件中xml<code> &lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920190114946.png" alt="img"></p>
<p>​        （3）对于<strong>缓存数据更新机制</strong>，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-、Mybatis是如何进行分页的？"><a href="#2-5-、Mybatis是如何进行分页的？" class="headerlink" title="2.5 、Mybatis是如何进行分页的？"></a>2.5 、Mybatis是如何进行分页的？</h3><p>​        （1）<strong>SQL分页</strong>(物理分页)：</p>
<pre><code class="xml">&lt;select id=&quot;queryStudentsBySql&quot; parameterType=&quot;map&quot; resultMap=&quot;studentmapper&quot;&gt; 
    select * from student limit #&#123;start&#125; , #&#123;end&#125;
&lt;/select&gt;
</code></pre>
<p>​        （2）使用<strong>RowBounds</strong>实现分页(逻辑分页)：</p>
<pre><code class="java">Service:
    publicList queryRolesByPage(String roleName,int start,int limit) &#123;
        returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));
    &#125;


Dao:
    public List queryUsersByPage(String userName, RowBounds rowBounds);
</code></pre>
<p>​        （3）使用<strong>分页插件PageHelper</strong>：</p>
<p>​        添加依赖：</p>
<pre><code class="xml">&lt;!--分页--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        在mybatis-config.xml中配置PageInterceptor拦截器:</p>
<pre><code class="xml">&lt;!--2.配置分页插件，此插件必须配置在typeAliases后面--&gt;
&lt;plugins&gt;
     &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
&lt;!--分页合理化参数，默认文false；pageNum&lt;=0，查询第一页；pageNum&gt;总页数，查询最后一页--&gt;
         &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<pre><code class="java">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;
    PageHelper.startPage(pageNum, pageSize);
    List&lt;User&gt; userList = userMapper.queryByPage(userParam);
    Json json = new Json();
    return json;
&#125;
</code></pre>
<h3 id="2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>Executor</strong>是mybatis中的<strong>执行器接口</strong>:</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>BaseExecutor（基础执行器）：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了<strong>缓存管理和事务管理</strong>的能力，使用了<strong>模板模式</strong>，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现。BaseExecutor的一级缓存是会话级别的，增、删、改都会清空一级缓存；而CachingExecutor的二级缓存是应用级的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>CachingExecutor（缓存执行器）：</strong>直接实现Executor接口，使用装饰器模式<strong>提供二级缓存能力</strong>。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200705191437604.png"></p>
<p>​        <strong>BatchExecutor（批处理执行器）：</strong>BaseExecutor具体子类实现，在doUpdate方法中，<strong>提供批量执行多条SQL语句的能力</strong>；</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>SimpleExecutor（简单执行器）：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor（可重用执行器）：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-7、-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7、-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7、 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7、 Mybatis中如何指定使用哪一种Executor执行器？</h3><p>​        在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920183713811.png" alt="img"></p>
<blockquote>
<p>&lt;class=”reference-link”&gt;</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200920183657317.png" alt="img"></p>
<h3 id="2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092018294130.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200920183022252.png" alt="img"></p>
<p>​        Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9、-Mybatis中用到了哪些设计模式？"><a href="#2-9、-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9、 Mybatis中用到了哪些设计模式？"></a>2.9、 Mybatis中用到了哪些设计模式？</h3><p>​        日志模块：代理模式、适配器模式</p>
<p>​        数据源模块：代理模式、工厂模式</p>
<p>​        缓存模块：装饰器模式</p>
<p>​        初始化阶段：建造者模式</p>
<p>​        代理阶段：策略模式</p>
<p>​        数据读写阶段：模板模式</p>
<p>​        插件化开发：责任链模式</p>
<h2 id="三、Mybaits源码结构"><a href="#三、Mybaits源码结构" class="headerlink" title="三、Mybaits源码结构"></a>三、Mybaits源码结构</h2><h3 id="3-1-、源码包功能模块图"><a href="#3-1-、源码包功能模块图" class="headerlink" title="3.1 、源码包功能模块图"></a>3.1 、源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png" alt="img"></p>
<h3 id="3-2-、各包详细功能解析"><a href="#3-2-、各包详细功能解析" class="headerlink" title="3.2 、各包详细功能解析"></a>3.2 、各包详细功能解析</h3><p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                包含所有mapper 接口中用到的注解</p>
<p>​        <strong>org.apache.ibatis.binding：</strong></p>
<p>​                生成mapper 接口的动态代理并进行管理</p>
<p>​        <strong>org.apache.ibatis.builder：</strong></p>
<p>​                1、包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</p>
<p>​                2、BaseBuilder 构建器基类</p>
<p>​                3、XMLConfigBuilder 解析configuration.xml配置文件</p>
<p>​                4、XMLMapperBuilder 解析Mapper.xml配置文件</p>
<p>​                5、XMLStatementBuilder 解析selectupdatedelete 标签MapperAnnotationBuilder 注解式Mapper</p>
<p>​        <strong>org.apache.ibatis.cache：</strong></p>
<p>​                1、缓存功能实现、包含各种缓存装饰器</p>
<p>​                2、TransactionalCache 二级缓存功能实现</p>
<p>​        <strong>org.apache.ibatis.cursor：</strong></p>
<p>​                实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p>​        <strong>org.apache.ibatis.datasource：</strong></p>
<p>​                数据源 包括jndi数据源、连接池功能</p>
<p>​        <strong>org.apache.ibatis.executor：</strong></p>
<p>​                1、包含SQL语句执行器，核心功能包</p>
<p>​                2、功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</p>
<p>​        <strong>org.apache.ibatis.exceptions：</strong></p>
<p>​                框架异常，常见异常：TooManyResultsException</p>
<p>​        <strong>org.apache.ibatis.io：</strong></p>
<p>​                资源文件读取</p>
<p>​        <strong>org.apache.ibatis.jdbc：</strong></p>
<p>​                1、JDBC一些操作</p>
<p>​                2、SqlRunner SQL执行</p>
<p>​                3、ScriptRunner 脚本执行，可以执行建库语句</p>
<p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                1、日志功能，实现多种日志框架的对接</p>
<p>​                2、org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</p>
<p>​        <strong>org.apache.ibatis.mapping：</strong></p>
<p>​                配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p>​        <strong>org.apache.ibatis.parsing：</strong></p>
<p>​                1、解析工具包</p>
<p>​                2、GenericTokenParser：解析#{} ${} 这种占位符</p>
<p>​                3、XPathParser：XPath形式解析XML</p>
<p>​                4、PropertyParser: properties解析器</p>
<p>​        <strong>org.apache.ibatis.scripting：</strong></p>
<p>​                动态SQL语言实现，配置文件中<code>&lt;if&gt; &lt;where&gt; &lt;set&gt; &lt;foreach&gt; &lt;choose&gt; </code>功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p>​        <strong>org.apache.ibatis.session：</strong></p>
<p>​                1、主要实现SqlSession功能，非常核心包</p>
<p>​                2、官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</p>
<p>​        <strong>org.apache.ibatis.transaction：</strong></p>
<p>​                事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p>​        <strong>org.apache.ibatis.type：</strong></p>
<p>​                类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="四、MyBatis初始化阶段"><a href="#四、MyBatis初始化阶段" class="headerlink" title="四、MyBatis初始化阶段"></a>四、MyBatis初始化阶段</h2><p>​        前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是<strong>将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级</strong>。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li>加载配置文件</li>
<li>解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li>根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="4-1、加载配置文件"><a href="#4-1、加载配置文件" class="headerlink" title="4.1、加载配置文件"></a>4.1、<strong>加载配置文件</strong></h3><p>​        下面我们来看一段经典查询操作：</p>
<pre><code class="java">String resouce = &quot;config/mybatis/mybatis-config.xml&quot;;
InputStream is = Resources.getResourceAsStream(resouce);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
SqlSession session = sqlSessionFactory.openSession();
user = session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);
</code></pre>
<p>​        以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="4-2、解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#4-2、解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="4.2、解析配置文件、将配置文件中的信息装载到Configuration中"></a>4.2、解析配置文件、将配置文件中的信息装载到Configuration中</h3><p>​        让我们来看一下梦开始的地方：</p>
<pre><code class="java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
</code></pre>
<p>​        跟进**build()**方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<pre><code class="java">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;
    try &#123;
      // 创建XMLConfigBuilder对象解析XML配置
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      // 将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory
      return build(parser.parse());
    &#125; 
    ....
&#125;
</code></pre>
<p>​        跟进<strong>parse()<strong>方法，我们可以看到parser.evalNode(“/configuration”)，</strong>evalNode</strong>为xml结点解析器，可以解析指定参数结点的信息，而”**/configuration**”则是mybatis.xml的根节点：</p>
<pre><code class="java">public Configuration parse() &#123;
    ...
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
&#125;
</code></pre>
<p>​        看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p>​        <strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p>​        <strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p>​        <strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200915222654319.png" alt="img"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p>​        Configuration类的源码实在太多，可以先了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p>​        <strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br>​        <strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br>​        <strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br>​        <strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>​        接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<pre><code class="java">parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
</code></pre>
<pre><code class="java">private void parseConfiguration(XNode root) &#123;
    try &#123;
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>​        点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915223612191.png" alt="img"></p>
<p>​        在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<pre><code class="java">XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>
<pre><code class="java">private void configurationElement(XNode context) &#123;
    try &#123;
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      ...
      builderAssistant.setCurrentNamespace(namespace);
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      cacheElement(context.evalNode(&quot;cache&quot;));
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>一一对应官网提供的节点信息进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915224121930.png" alt="img"></p>
<p>​        下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<pre><code class="java">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;
    for (XNode context : list) &#123;
      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
      try &#123;
        statementParser.parseStatementNode();
      &#125; catch (IncompleteElementException e) &#123;
        configuration.addIncompleteStatement(statementParser);
      &#125;
    &#125;
  &#125;
</code></pre>
<p>​        继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="4-3、根据Configuration创建SqlSessionFactory并返回"><a href="#4-3、根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="4.3、根据Configuration创建SqlSessionFactory并返回"></a>4.3、根据Configuration创建SqlSessionFactory并返回</h3><p>​        第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<pre><code class="java">public class SqlSessionFactoryBuilder &#123;
   ...
   public SqlSessionFactory build(Configuration config) &#123;
      return new DefaultSqlSessionFactory(config);
   &#125;
&#125;
</code></pre>
<p>​        此工厂内封装了Configuration对象：</p>
<pre><code class="java">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;
  private final Configuration configuration;
  public DefaultSqlSessionFactory(Configuration configuration) &#123;
    this.configuration = configuration;
  &#125;
  ...
&#125;
</code></pre>
<p>​        初始化阶段图解：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915225840294.png" alt="img"></p>
<p>​        至此，MyBatis初始化阶段完成。</p>
<h2 id="五、MyBatis代理阶段（binding模块分析）"><a href="#五、MyBatis代理阶段（binding模块分析）" class="headerlink" title="五、MyBatis代理阶段（binding模块分析）"></a>五、MyBatis代理阶段（binding模块分析）</h2><h3 id="5-1、MyBatis是如何做到面向Mapper接口编程？"><a href="#5-1、MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="5.1、MyBatis是如何做到面向Mapper接口编程？"></a>5.1、MyBatis是如何做到面向Mapper接口编程？</h3><p>​        只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User uer = userMapper.selectByPrimarKey(1);
</code></pre>
<p>​        MyBatis动态代理后执行的为下面这段代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
User uer = sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);
</code></pre>
<p>​        我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p>​        <strong>1、找到Session中对应的方法执行</strong></p>
<p>​        <strong>2、找到命名空间和方法名</strong></p>
<p>​        <strong>3、传递参数</strong></p>
<p>​        这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200916211402947.png" alt="img"></p>
<p>​        <strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<pre><code class="java">public class MapperRegistry &#123;
   private final Configuration config;
   //mapper接口和对应的代理对象工厂之间的关系
   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
   ...
&#125;
</code></pre>
<p>​        <strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<pre><code class="java">public class MapperProxyFactory&lt;T&gt; &#123;
  ...
  //key为mapper接口中的某个方法的method对象，value为对应的MapperMethod
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
  ...
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);
  &#125;
&#125;
</code></pre>
<p>​        <strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214700706.png" alt="img"></p>
<p>​        接着跟进**cachedInvoker(method).invoke(proxy, method, args, sqlSession)**方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200916213826490.png" alt="img"></p>
<p>​        我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214239389.png" alt="img"></p>
<p>​        那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214959863.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215029787.png" alt="img"></p>
<p>​        通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916215442588.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215556263.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215523383.png" alt="img"></p>
<h3 id="5-2、代理阶段流程梳理"><a href="#5-2、代理阶段流程梳理" class="headerlink" title="5.2、代理阶段流程梳理"></a>5.2、代理阶段流程梳理</h3><p>​        1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>​        2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>​        3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h2 id="六、MyBatis数据读写阶段"><a href="#六、MyBatis数据读写阶段" class="headerlink" title="六、MyBatis数据读写阶段"></a>六、MyBatis数据读写阶段</h2><h3 id="6-1、MyBatis是怎样的封装jdbc操作的"><a href="#6-1、MyBatis是怎样的封装jdbc操作的" class="headerlink" title="6.1、MyBatis是怎样的封装jdbc操作的"></a>6.1、MyBatis是怎样的封装jdbc操作的</h3><p>​        我们先来回忆一下jdbc代码：</p>
<pre><code class="java">//1.加载驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     
//2.获取连接conn
Connection con=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123&quot;);
//3.创建查询接口
Statement sta= con.createStatement();
//4.执行SQL，返回结果集
ResultSet rs= sta.executeQuery(&quot;SELECT * FROM `user`&quot;);
//5.对结果集数据进行操作
User user = new User();
user.setUserName(String.valueOf(rs.getObject(1)));
</code></pre>
<p>​        其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203050838.png" alt="img"></p>
<p>​        可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p>​        <strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p>​        <strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p>​        <strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>​        一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205236272.png" alt="img"></p>
<p>​        可以看到只有BaseExecutor和CachingExecutor两个类重写了**query()**方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<code>&lt;cache&gt;</code>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205454850.png" alt="img"></p>
<p>​        好的我们继续跟进BaseExecutor的**query()**方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210415293.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200917210606702.png" alt="img"></p>
<p>​        可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210831277.png" alt="img"></p>
<p>​        我们跟进默认实现SimpleExecutor的**doQuery()**方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211035123.png" alt="img"></p>
<p>​        这段代码有两点值得我们注意，一个是**prepareStatement(handler, ms.getStatementLog())**这个方法，我们跟进去会发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211124589.png" alt="img"></p>
<p>​        <strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919104808424.png" alt="img"></p>
<p>​        <strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p>​        <strong>CallableStatementHandler：</strong>调用存储过程</p>
<p>​        <strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p>​        <strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p>​        <strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>​        RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211725203.png" alt="img"></p>
<p>​        接上文调用SimpleStatementHandler的query方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211854628.png" alt="img"></p>
<p>​        <strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919110111271.png" alt="img"></p>
<p>​        处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li>创建multipleResults集合，保存最终返回的结果。</li>
<li>取出第一个结果集</li>
<li>获取对应的resultMap</li>
<li>根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</li>
<li>resultset.close()关闭结果集，将multipleResults集合返回</li>
</ol>
<h3 id="6-2、sqlSession查询流程图和Executor内部调用流程图"><a href="#6-2、sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="6.2、sqlSession查询流程图和Executor内部调用流程图"></a>6.2、sqlSession查询流程图和Executor内部调用流程图</h3><h4 id="6-2-1、sqlSession查询流程图："><a href="#6-2-1、sqlSession查询流程图：" class="headerlink" title="6.2.1、sqlSession查询流程图："></a>6.2.1、sqlSession查询流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911381497.png" alt="img"></p>
<h4 id="6-2-2、Executor内部调用流程图："><a href="#6-2-2、Executor内部调用流程图：" class="headerlink" title="6.2.2、Executor内部调用流程图："></a>6.2.2、Executor内部调用流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911204922.png" alt="img"></p>
<p>此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#ff7d73>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/">
        <h2>
            SSM整合
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SSM整合笔记"><a href="#SSM整合笔记" class="headerlink" title="SSM整合笔记"></a>SSM整合笔记</h1><h2 id="一、数据库环境"><a href="#一、数据库环境" class="headerlink" title="一、数据库环境"></a>一、数据库环境</h2><h3 id="1-1、创建数据库及数据表"><a href="#1-1、创建数据库及数据表" class="headerlink" title="1.1、创建数据库及数据表"></a>1.1、创建数据库及数据表</h3><pre><code class="sql">CREATE TABLE `books`(    
    `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,    
    `bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;, 
    `bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,    
    `detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,   
    KEY `bookId` (`bookId`)
) ENGINE=INNODB DEFAULT CHARSET=utf8; 

INSERT INTO books(`bookId`,`bookName`,`bookCounts`,`detail`) 
    VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;), (2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;), (3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);
</code></pre>
<h2 id="二、导入依赖"><a href="#二、导入依赖" class="headerlink" title="二、导入依赖"></a>二、导入依赖</h2><h3 id="2-1、导入jar包"><a href="#2-1、导入jar包" class="headerlink" title="2.1、导入jar包"></a>2.1、导入jar包</h3><p>​        创建一个maven工程，导入依赖和静态资源处理的配置。</p>
<pre><code class="xml">&lt;dependencies&gt;
    
    &lt;!--Junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--数据库驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.35&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--连接池--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--servlet--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jsp--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--JSTL--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--mybatis-spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jdbc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--静态资源导出问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="2-2、建包："><a href="#2-2、建包：" class="headerlink" title="2.2、建包："></a>2.2、建包：</h3><p>​        连接数据库；    </p>
<p>​        在src/main/java下创建pojo、service、controller、dao、util。</p>
<p>​        在resource文件夹下创建mybatis-config.xml、applicationContext.xml、database.properties。</p>
<h3 id="2-3、修改resource下的配置文件："><a href="#2-3、修改resource下的配置文件：" class="headerlink" title="2.3、修改resource下的配置文件："></a>2.3、修改resource下的配置文件：</h3><h4 id="2-3-1、mybatis-config-xml"><a href="#2-3-1、mybatis-config-xml" class="headerlink" title="2.3.1、mybatis-config.xml"></a>2.3.1、mybatis-config.xml</h4><p>​        关联数据库文件源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--
        数据源配置交给spring做
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.example.pojo&quot;/&gt;
        &lt;/typeAliases&gt;
    --&gt;
    
    &lt;!--写一些mapper配置文件的注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<p>​        编写pojo文件夹下的实体类：Books；</p>
<p>​        编写dao文件夹下的接口：BookMapper；</p>
<p>​        编写BookMapper.xml</p>
<h4 id="2-3-2、applicationContext-xml"><a href="#2-3-2、applicationContext-xml" class="headerlink" title="2.3.2、applicationContext.xml"></a>2.3.2、applicationContext.xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--将其他三层的spring配置文件合在一起即可--&gt;
    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="2-3-3、database-properties"><a href="#2-3-3、database-properties" class="headerlink" title="2.3.3、database.properties"></a>2.3.3、database.properties</h4><p>​        数据库的配置文件    </p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
# 如果使用MySQL8.0，还需要增加一个时区的配置 &amp;serverTimezone=Asia/Shanghai
jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=123456
</code></pre>
<h2 id="三、Mybatis层的配置："><a href="#三、Mybatis层的配置：" class="headerlink" title="三、Mybatis层的配置："></a>三、Mybatis层的配置：</h2><h3 id="3-1、创建pojo对象"><a href="#3-1、创建pojo对象" class="headerlink" title="3.1、创建pojo对象"></a>3.1、创建pojo对象</h3><p>​    采用lombok依赖对这个pojo生成get、set方法等一系列方法。</p>
<pre><code class="xml">&lt;!--lombok--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    
    &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@Data       //get、set等方法
@AllArgsConstructor     //有参构造
@NoArgsConstructor      //无参构造
public class Book &#123;
    private Integer bookId;
    private String bookName;
    private Integer bookCounts;
    private String detail;
&#125;
</code></pre>
<h3 id="3-2、创建dao接口。"><a href="#3-2、创建dao接口。" class="headerlink" title="3.2、创建dao接口。"></a>3.2、创建dao接口。</h3><pre><code class="java">public interface BookMapper &#123;
    int addBook(Book book);
    int deleteBookById(@Param(&quot;id&quot;) Integer id);
    int updateBook(Book book);
    Book queryBookById(@Param(&quot;id&quot;) Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<h3 id="3-3、创建mapper配置文件"><a href="#3-3、创建mapper配置文件" class="headerlink" title="3.3、创建mapper配置文件"></a>3.3、创建mapper配置文件</h3><p>​        并在全局配置中进行注册</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.example.pojo.Book&quot;&gt;
        insert into books(`bookName`,`bookCounts`,`detail`) values
        (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;details&#125;)
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot;&gt;
        delete from books where bookId = #&#123;id&#125;
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot;&gt;
        update books set `bookName` = #&#123;bookName&#125;,`bookCounts` = #&#123;bookCounts&#125;,
        `detail` = #&#123;detail&#125; where `bookId` = #&#123;bookId&#125;
    &lt;/update&gt;

    &lt;select id=&quot;queryBookById&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books where `bookId` = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBooks&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="3-4、创建service业务。"><a href="#3-4、创建service业务。" class="headerlink" title="3.4、创建service业务。"></a>3.4、创建service业务。</h3><pre><code class="java">public interface BookService &#123;
    int addBook(Book book);
    int deleteBookById(Integer id);
    int updateBook(Book book);
    Book queryBookById(Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<pre><code class="java">public class BookServiceImpl implements BookService&#123;
    // 之后用spring自动注入
    // service调dao层：组合Dao
    private BookMapper bookMapper;
    
    @Override
    public int addBook(Book book) &#123;
        return bookMapper.addBook(book);
    &#125;
    @Override
    public int deleteBookById(Integer id) &#123;
        return bookMapper.deleteBookById(id);
    &#125;
    @Override
    public int updateBook(Book book) &#123;
        return bookMapper.updateBook(book);
    &#125;
    @Override
    public Book queryBookById(Integer id) &#123;
        return bookMapper.queryBookById(id);
    &#125;
    @Override
    public List&lt;Book&gt; queryAllBooks() &#123;
        return bookMapper.queryAllBooks();
    &#125;
&#125;
</code></pre>
<h2 id="四、Spring层的配置："><a href="#四、Spring层的配置：" class="headerlink" title="四、Spring层的配置："></a>四、Spring层的配置：</h2><h3 id="4-1、创建一个新的spring配置文件去整合dao层"><a href="#4-1、创建一个新的spring配置文件去整合dao层" class="headerlink" title="4.1、创建一个新的spring配置文件去整合dao层"></a>4.1、创建一个新的spring配置文件去整合dao层</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--关联数据库配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
    
    &lt;!--连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--绑定数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--绑定mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--配置dao接口扫描包，可以将dao接口注入到spring的容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描dao包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.example.dao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="4-2、创建一个新的spring配置文件去整合service层。"><a href="#4-2、创建一个新的spring配置文件去整合service层。" class="headerlink" title="4.2、创建一个新的spring配置文件去整合service层。"></a>4.2、创建一个新的spring配置文件去整合service层。</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service包--&gt;
    &lt;context:component-scan base-package=&quot;com.example.service&quot;/&gt;

    &lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--aop事务支持--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.example.dao.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="五、springMVC层配置："><a href="#五、springMVC层配置：" class="headerlink" title="五、springMVC层配置："></a>五、springMVC层配置：</h2><h3 id="5-1、添加web支持，创建web-xml"><a href="#5-1、添加web支持，创建web-xml" class="headerlink" title="5.1、添加web支持，创建web.xml"></a>5.1、添加web支持，创建web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    
    &lt;!--配置前端处理器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--绑定的是spring的全局配置文件--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;!--
            /  :
            /* :会过滤到jsp等资源
        --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;!--配置乱码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!--配置session--&gt;
    &lt;session-config&gt;
        &lt;!--配置session超时时间--&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="5-2、创建spring的mvc配置文件"><a href="#5-2、创建spring的mvc配置文件" class="headerlink" title="5.2、创建spring的mvc配置文件"></a>5.2、创建spring的mvc配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--注解驱动--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--扫描controller--&gt;
    &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt;
    &lt;!--视图解析器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="5-3、在WEB-INF下创建jsp目录。"><a href="#5-3、在WEB-INF下创建jsp目录。" class="headerlink" title="5.3、在WEB-INF下创建jsp目录。"></a>5.3、在WEB-INF下创建jsp目录。</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/">
        <h2>
            Spring整合Log4j
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Sping整合Log4j"><a href="#Sping整合Log4j" class="headerlink" title="Sping整合Log4j"></a>Sping整合Log4j</h1><h2 id="一、log4j日志简介"><a href="#一、log4j日志简介" class="headerlink" title="一、log4j日志简介"></a>一、log4j日志简介</h2><p>​        Log4j是Apache的一个开放源代码项目，通过使用Log4j，控制日志信息输送的目的地可以为控制台、文件、数据库、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；可以控制每一条日志的信息内容和信息输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；甚至还可以在不需要修改业务逻辑代码、重启web服务，只需要通过一个修改配置文件就可以实现控制项目的日志动作。</p>
<p>​        Log4j由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p>
<h2 id="二、定义配置文件"><a href="#二、定义配置文件" class="headerlink" title="二、定义配置文件"></a>二、定义配置文件</h2><p>​        其实您也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件（键=值）。下面我们介绍使用Java特性文件做为配置文件的方法：</p>
<h3 id="2-1、配置根Logger"><a href="#2-1、配置根Logger" class="headerlink" title="2.1、配置根Logger"></a>2.1、配置根Logger</h3><pre><code class="java">log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre>
<p>​        其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p>
<p>eg：</p>
<pre><code class="properties">### set log levels ###  
log4j.rootLogger = debug,stdout,D,E  
 
log4j.appender.stdout = org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.Target = System.out  
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout  
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  
 
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.D.File = F://logs/log.log  
log4j.appender.D.Append = true  
log4j.appender.D.Threshold = DEBUG   
log4j.appender.D.layout = org.apache.log4j.PatternLayout  
log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n  
 
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.E.File =F://logs/error.log   
log4j.appender.E.Append = true  
log4j.appender.E.Threshold = ERROR   
log4j.appender.E.layout = org.apache.log4j.PatternLayout  
log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n
</code></pre>
<h3 id="2-2、配置日志信息输出目的地Appender"><a href="#2-2、配置日志信息输出目的地Appender" class="headerlink" title="2.2、配置日志信息输出目的地Appender"></a>2.2、配置日志信息输出目的地Appender</h3><pre><code class="properties">log4j.appender.appenderName = fully.qualified.name.of.appender.class
 
log4j.appender.appenderName.option1 = value1
 
…
 
log4j.appender.appenderName.option = valueN
</code></pre>
<p>​        其中，Log4j提供的appender有以下几种：</p>
<pre><code class="properties">org.apache.log4j.ConsoleAppender（控制台），
 
org.apache.log4j.FileAppender（文件），
 
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），
 
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
 
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre>
<h3 id="2-3、配置日志信息的格式（布局）"><a href="#2-3、配置日志信息的格式（布局）" class="headerlink" title="2.3、配置日志信息的格式（布局）"></a>2.3、配置日志信息的格式（布局）</h3><pre><code class="properties">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
 
log4j.appender.appenderName.layout.option1 = value1
 
…
 
log4j.appender.appenderName.layout.option = valueN
</code></pre>
<p>​        其中，Log4j提供的layout有以e几种：</p>
<pre><code class="css">org.apache.log4j.HTMLLayout（以HTML表格形式布局），
 
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
 
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
 
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre>
<p>​        Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息</p>
<pre><code class="properties">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  
%r 输出自应用启动到输出该log信息耗费的毫秒数  
%c 输出所属的类目，通常就是所在类的全名  
%t 输出产生该日志事件的线程名  
%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  
%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  
%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)
</code></pre>
<p>首先，日志的级别有：OFF 、FATAL 、ERROR、WARN、INFO、DEBUG、TRACE 、ALL 等等。</p>
<ul>
<li><p>OFF：关闭了日志信息  </p>
</li>
<li><p>FATAL：可能导致应用中止的严重事件错误  </p>
</li>
<li><p>ERROR：严重错误 主要是程序的错误  </p>
</li>
<li><p>WARN：一般警告，比如session丢失  </p>
</li>
<li><p>INFO：一般要显示的信息，比如登录登出  </p>
</li>
<li><p>DEBUG：程序的调试信息  </p>
</li>
<li><p>TRACE：比DEBUG更细粒度的事件信息  </p>
</li>
<li><p>ALL：打开所有级别的日志</p>
</li>
</ul>
<p>log4j提供了一系列的Appender，允许将日志输送到不同的地方，如控制台、文件、数据库等：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.jdbc.JDBCAppender（数据库）</li>
<li>org.apache.log4j.net.SMTPAppender（邮件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h2 id="三、Spring框架整合log4j"><a href="#三、Spring框架整合log4j" class="headerlink" title="三、Spring框架整合log4j"></a>三、Spring框架整合log4j</h2><h3 id="3-1、pom-xml-引入log4j组件依赖包："><a href="#3-1、pom-xml-引入log4j组件依赖包：" class="headerlink" title="3.1、pom.xml 引入log4j组件依赖包："></a>3.1、pom.xml 引入log4j组件依赖包：</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："><a href="#3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：" class="headerlink" title="3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："></a>3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：</h3><pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:conf/log4j.properties&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;!-- 5000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; 
&lt;context-param&gt;
      &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;
      &lt;param-value&gt;5000&lt;/param-value&gt;
&lt;/context-param&gt;
 
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>​        首先是这个关于JavaWeb的工程的总配置位置。我们要在里面声明要使用Spring与Log4j。值得注意的Log4j的配置必须在Spring配置之前，否则如果先启动Spring，那个必须整合Log4j才不吐警告的Spring，由于Log4j还没有启动，找不到Spring，又会在任性地吐警告。当然，你设置那些什么优先级也行，不过，先启动的直接放前面，这个文件不是更好看吗？</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
    version=&quot;3.0&quot;&gt;
    &lt;!-- Log4j配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!-- 指定Log4j的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
    
    &lt;!-- Spring配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    
&lt;/web-app&gt;  
</code></pre>
<p>​        这里，我将log4j.properties配置文件存放到classpath的conf目录下，并启动一个watchdog线程每5秒扫描配置文件的变化，重新调整日志的策略，实现在不调整逻辑代码即可实现日志的策略变更。通过log4j.properties详细配置了日志的策略，如下：</p>
<pre><code class="properties"># +======================================================================+#
log4j.rootLogger=$&#123;log4j.log.level&#125;,$&#123;log4j.log.target&#125;
log4j.addivity.org.apache=true
# +======================================================================+#
# | [target] - Console
# +----------------------------------------------------------------------+#
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.CONSOLE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.CONSOLE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - FILE
# +----------------------------------------------------------------------+#
log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.FILE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.FILE.File=$&#123;log4j.log.dir&#125;/runtime.log
log4j.appender.FILE.Append=true
log4j.appender.FILE.MaxFileSize=2048KB
log4j.appender.FILE.MaxBackupIndex=10
log4j.appender.FILE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.FILE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - DATABASE
# +----------------------------------------------------------------------+#
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.DATABASE.Threshold=ERROR
log4j.appender.DATABASE.URL=jdbc:mysql://127.0.0.1:3306/spring
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver
log4j.appender.DATABASE.user=root
log4j.appender.DATABASE.password=liuriqi
log4j.appender.DATABASE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.DATABASE.sql=INSERT INTO tv_log4j(message)VALUES(&#39;$&#123;log4j.log.layout.pattern&#125;&#39;)
# +======================================================================+#
# | [target] - EMAIL
# +----------------------------------------------------------------------+#
log4j.appender.EMAIL=org.apache.log4j.net.SMTPAppender
log4j.appender.EMAIL.Threshold=FATAL
log4j.appender.EMAIL.BufferSize=10
log4j.appender.EMAIL.From=fromuser@gmail.com
log4j.appender.EMAIL.SMTPHost=localhost
log4j.appender.EMAIL.Subject=Log4J Message
log4j.appender.EMAIL.To=touser@gmail.com
log4j.appender.EMAIL.layout=$&#123;log4j.log.layout&#125;
log4j.appender.EMAIL.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
上面配置相关的变量，我提取出来统一放到变量配置文件里边，如下：
 
# +======================================================================+#
# | log4j config
# +----------------------------------------------------------------------+#
log4j.log.dir=logs/
#log4j.log.level=ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF
log4j.log.level=DEBUG
#log4j.log.target=CONSOLE,FILE,DATABASE,EMAIL,SOCKET
log4j.log.target=CONSOLE,FILE
log4j.log.encoding=UTF-8
log4j.log.layout=org.apache.log4j.PatternLayout
log4j.log.layout.pattern=[%d %r] [%-5p] [%t] [%l] [%m]%n
# +======================================================================+#
</code></pre>
<p>​        通过以上配置，在项目启动的时候，会将DEBUG日志信息发送到控制台和文件日志中。</p>
<p>​        另一种配置方式：</p>
<pre><code class="properties">#log4j.rootLogger = [ level ] , appenderName, appenderName, ...
log4j.rootLogger = all, console, R

#Console
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] %m%n

#File
log4j.appender.R = org.apache.log4j.RollingFileAppender
log4j.appender.R.File = c:/log.txt
log4j.appender.R.MaxFileSize = 500KB
log4j.appender.R.MaxBackupIndex = 1
log4j.appender.R.layout = org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] - %m%n
</code></pre>
<p>​        首先第一部分是log4j的总配置部分，all代表debug,info,error,fatal四种类型的信息都会输出。一般不设置为all。因为那些debug,info信息对我们半点意义没有，还因为有很多系统内部的文件运行都会输出debug与info信息刷屏、刷版。关键是输出到磁盘的日志文件会极速递增，浪费磁盘空间。玩SQL Server的时候大家又不知道那个.ldb是多么恐怖？</p>
<p>​        因此第一部分，一般写成：</p>
<pre><code class="properties">log4j.rootLogger = ERROR, console, R
</code></pre>
<p>​        代表仅输出error与fatal错误。<br>​        之后的console，R分别代表在控制台与文件输出。同时在之后的代码必须配置好这个两输出。</p>
<p>​        第二部分控制台#Console<br>​        首先要使用log4j特定的包，这个没有什么好说，最后一句指明输出格式。一会儿大招对照输出结果就明白怎么回事了。</p>
<p>​        第三部分文件#File</p>
<p>​        log4j.appender.R.File=c:/log.txt是指这个Web工程错误日志皆输出到c:/log.txt。不要像网上那些大神输出一个什么.log后缀，关键是能够直接打开。</p>
<p>​        之后log4j.appender.R.MaxFileSize = 500KB指明这个log.txt文件大小最多为500KB，如果超过这个大小，自动开一个新文件，而log4j.appender.R.MaxBackupIndex=1指明此工程顶多只能有1个这个的日志文件。注：新内容覆盖旧内容。</p>
<p>​        最后，可以在应用程序中采用log4j自带的debug()、info()、warn()、error()方法来记录你想要记录的操作，至于如何存储日志及日志的目的地发送的工作就交给log4j好了。</p>
<p>​        最后一点说明的问题：配置较低级别的错误日志策略会记录高级的错误信息，配置高级的错误日志策略会忽略低级错误信息。如将错误日志的level配置为debug，则log4j组件会记录包含debug以上所有的级别日志如debug、info、warn、error、fatal等。加入你配置的为error级别，则不会记录error以下级别的日志信息如debug、info、warn等等。</p>
<pre><code class="java">import org.apache.log4j.Logger;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
public class Log4jTest &#123;
     private static Logger logger =Logger.getLogger(Log4jTest.class);
     
     @RequestMapping(&quot;/log&quot;)
     public void writeLog() &#123;
            // 记录debug级别的信息    
            logger.debug(&quot;This is debug message.&quot;);    
            // 记录info级别的信息    
            logger.info(&quot;This is info message.&quot;);    
            // 记录error级别的信息    
            logger.error(&quot;This is error message.&quot;); 
     &#125;
     
&#125;
</code></pre>
<h2 id="四、Spring整合log4j2"><a href="#四、Spring整合log4j2" class="headerlink" title="四、Spring整合log4j2"></a>四、Spring整合log4j2</h2><p>4.1、pom.xml文件</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;!-- something --&gt;
 
        &lt;!-- log配置 --&gt;
        &lt;!-- 排除springboot原有的log依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 添加log4j2依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>4.2、log4j2.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 
&lt;!-- 日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL --&gt;
&lt;!-- status：设置log4j2本身的日志信息打印级别，可以不设置。当设置为info及以下级别时，在更改当前log4j2.xml文件后，自动检测功能发现xml文件有更改，将会打印更改日志，可以在console中看到。因此该status是log4j2.xml文件的日志设置。 --&gt;
&lt;!-- monitorInterval：设置间隔时间，单位为秒。Log4j2能够自动检测修改，并在monitorInterval设定的时间周期重新加载配置，无需重启应用 --&gt;
&lt;configuration status=&quot;info&quot; monitorInterval=&quot;5&quot;&gt;
    &lt;!-- 自定义属性 --&gt;
    &lt;Properties&gt;
        &lt;!-- 缺省配置（用于开发环境），配置日志文件输出目录和动态参数。其他环境需要在VM参数中指定； --&gt;
        &lt;!-- “sys:”表示：如果VM参数中没指定这个变量值，则使用本文件中定义的缺省全局变量值 --&gt;
        &lt;Property name=&quot;instance&quot;&gt;spring-boot-demo-log4j2&lt;/Property&gt;
        &lt;Property name=&quot;log.dir&quot;&gt;D:\log4j2&lt;/Property&gt;
    &lt;/Properties&gt;
    
    &lt;!-- 定义所有的appender --&gt;
    &lt;Appenders&gt;
        &lt;!--这个是输出控制台的配置--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT --&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!--输出日志的格式--&gt;
            &lt;!-- PatternLayout:输出格式，不设置默认为:%m%n --&gt;
            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%level] [%l] - %message%n&quot;/&gt;
            
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;accept&quot; onMismatch=&quot;deny&quot;/&gt;
            &lt;/Filters&gt;
        &lt;/Console&gt;
        
        &lt;!-- info及以上级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- fileName:指定输出日志的目的文件带全路径的文件名 --&gt;
        &lt;!-- filePattern:指定新建日志文件的名称格式 --&gt;
        &lt;RollingRandomAccessFile name=&quot;infoLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-info.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            
            &lt;!-- PatternLayout:日志输出格式，不设置默认为:%m%n --&gt;
            &lt;!-- &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%level][%class][%line]:%message%n&quot;/&gt; --&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;!-- 过滤器 --&gt;
            &lt;!-- 注意，这里要做一些特点说明： --&gt;
            &lt;!-- 等级大小关系为：OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL。 --&gt;
            &lt;!-- 在ThresholdFilter配置中，level属性是用来标识“匹配范围”的，且“被匹配（onMatch）范围”为该level及其以上的等级（例如level=&quot;WARN&quot;，那么onMatch范围为“OFF,FATAL,ERROR,WARN”），而“未匹配（onMismatch）范围”为所匹配途中剩下未被匹配的范围（例如level=&quot;WARN&quot;，那么onMismatch范围为“INFO,DEBUG,TRACE,ALL”）。 --&gt;
            &lt;!-- 需要注意，如果在一个&lt;Filters&gt;里面有多个&lt;ThresholdFilter&gt;，那么这些&lt;ThresholdFilter&gt;的书写是有上下关系的。 --&gt;
            &lt;!-- 写在上面的&lt;ThresholdFilter&gt;将通过level属性确定了已经匹配过的范围，那么，写在下面的&lt;ThresholdFilter&gt;的level必须在未被匹配的范围内选择，否则将无法生效（例如第一个&lt;ThresholdFilter&gt;中的level=&quot;WARN&quot;，那么第二个&lt;ThresholdFilter&gt;中的level属性值只能在“INFO、DEBUG、TRACE、ALL”里面选择）。 --&gt;
            &lt;!-- 因此，我们做一个规定： --&gt;
            &lt;!-- 在一个含有多个&lt;ThresholdFilter&gt;的&lt;Filters&gt;里面，在从上到下的&lt;ThresholdFilter&gt;列表顺序中，每一个&lt;ThresholdFilter&gt;中的level属性值我们规定必须由高等级至低等级填写。 --&gt;
            &lt;!-- 例如： --&gt;
            &lt;!-- 
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;XXX&quot;/&gt;
            --&gt;
            &lt;Filters&gt;
                &lt;!-- onMatch=&quot;ACCEPT&quot; 表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;DENY&quot; 表示拒绝该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;NEUTRAL&quot; 表示中立，该级别及以上的日志的onMatch通过性，将由下一个ThresholdFilter的onMatch属性处理，如果当前ThresholdFilter是最后一个，则表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMismatch=&quot;ACCEPT&quot; 表示允许该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;DENY&quot; 表示拒绝该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;NEUTRAL&quot; 表示中立，该级别以下的日志的onMismatch通过性，将由下一个ThresholdFilter的onMismatch属性处理，如果当前是最后一个，则允许该级别以下的日志--&gt;
                &lt;!-- level属性缺省，默认为level=&quot;ERROR&quot;，注意：缺省意思是没有该属性，而非level=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMatch属性缺省，默认为onMatch=&quot;accept&quot;，注意：缺省意思是没有该属性，而非onMatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMismatch属性缺省，默认为onMismatch=&quot;deny&quot;，注意：缺省意思是没有该属性，而非onMismatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;!-- Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 --&gt;
            &lt;Policies&gt;
                &lt;!-- 基于时间的滚动策略 --&gt;
                &lt;!-- interval：表示历史日志封存间隔时间，单位为hour，默认是1 --&gt;
                &lt;!-- modulate：表示是否历史日志生成时间纠偏，纠偏以零点为基准进行。比如：17:30生成了$&#123;instance&#125;-info-2019032817.log.gz文件，那么纠偏后会在18:00生成$&#123;instance&#125;-info-2019032818.log.gz --&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;!-- 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小 --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
            
            &lt;!-- DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个(通过max属性定义)日志文件时开始删除最旧的，创建新的 --&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot;&gt;
                &lt;Delete basePath=&quot;$&#123;log.dir&#125;&quot; maxDepth=&quot;1&quot;&gt;
                    &lt;IfFileName glob=&quot;*.log.gz&quot; /&gt;
                    &lt;!-- 小时：H，天：d --&gt;
                    &lt;IfLastModified age=&quot;5d&quot; /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
 
        &lt;!-- warn级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;warnLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-warn.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- error级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;errorLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-error.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- 测试日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;testLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-test.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-test-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;deny&quot; onMismatch=&quot;accept&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
    &lt;/Appenders&gt;
    
    &lt;!-- 用来配置Logger，包含一个root和若干个logger --&gt;
    &lt;!-- additivity指定是否同时输出当前logger的父类的日志，缺省为true --&gt;
    &lt;!-- 一个logger可以绑定多个不同的Appender。只有定义了logger并通过AppenderRef引入appender，该appender才会生效 --&gt;
    &lt;!-- &lt;logger&gt;可以不配置&lt;AppenderRef&gt;，这样可以控制指定的包在控制台的日志打印，而无需考虑日志文件的存储问题 --&gt;
    &lt;!--     （等效于在application.properties文件配置logging.level.xxx=LEVEL，xxx代指包名，如org.apache.kafka，LEVEL代指日志基本，如error等） --&gt;
    &lt;!--     （例如要屏蔽org.apache.kafka包下的所用日志打印，则可以这样写logging.level.org.apache.kafka=off） --&gt;
    &lt;Loggers&gt;
        &lt;!-- Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 --&gt;
        &lt;!-- additivity：这个属性的意思是需不需要打印此logger继承的父logger，默认为true，如果是false则只打印当前logger；如果是true则继续打印上一层的logger，直到root --&gt;
        &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- 屏蔽kafka的日志打印 --&gt;
        &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;off&quot;&gt;&lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.config&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.web&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;testLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- Root节点用来指定项目的根日志，如果没有类似上面所配置的单独指定的logger，那么就会默认使用该Root日志输出 --&gt;
        &lt;!-- &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt; --&gt;
        &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt;
            &lt;!-- 用来指定该日志输出到哪个Appender --&gt;
            &lt;AppenderRef ref=&quot;Console&quot;/&gt;
        &lt;/Root&gt;
 
        &lt;!-- AsyncRoot - 异步记录日志 - 需要LMAXDisruptor的支持 --&gt;
        &lt;!--
        &lt;AsyncRoot level=&quot;info&quot; additivity=&quot;false&quot;&gt;
          &lt;AppenderRef ref=&quot;Console&quot;/&gt;
          &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
          &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/AsyncRoot&gt;
        --&gt;
    &lt;/Loggers&gt;
 
&lt;/configuration&gt;
</code></pre>
<p>参数说明</p>
<pre><code>    ********************************************************************************************************************
    参数        说明                                         举例                    输出显示媒介
    ********************************************************************************************************************
    %c          列出logger名字空间的全称，如果加上&#123;&lt;层数&gt;&#125;，   假设当前logger的命名空间是&quot;a.b.c&quot;
                则表示列出从最内层算起的指定层数的名字空间
                                                            %c                  a.b.c
                                                            %c&#123;2&#125;               b.c
                                                            %20c                （若名字空间长度小于20，则左边用空格填充）
                                                            %-20c               （若名字空间长度小于20，则右边用空格填充）
                                                            %.30c               （若名字空间长度超过30，截去多余字符）
                                                            %20.30c             （若名字空间长度小于20，则左边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
                                                            %-20.30c            （若名字空间长度小于20，则右边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
    ********************************************************************************************************************
    %C          列出调用logger的类的全名（包含包路径）         假设当前类是&quot;org.apache.xyz.SomeClass&quot;
                                                            %C                  org.apache.xyz.SomeClass
                                                            %C&#123;1&#125;               SomeClass
    %class
    ********************************************************************************************************************
    %d          显示日志记录时间，&#123;&lt;日期格式&gt;&#125;使用ISO8601定义的日期格式
                                                            %d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;     2005/10/12 22:23:30,117
                                                            %d&#123;ABSOLUTE&#125;        22:23:30,117
                                                            %d&#123;DATE&#125;            12 Oct 2005 22:23:30,117
                                                            %d&#123;ISO8601&#125;         2005-10-12 22:23:30,117
    ********************************************************************************************************************
    %F          显示调用logger的源文件名                     %F                   MyClass.java
    ********************************************************************************************************************
    %l          显示日志事件的发生位置，包含包路径、方法名、
                源文件名，以及在代码中的行数                  %l                   com.a.b.MyClass.main(MyClass.java:168)
    ********************************************************************************************************************
    %L          显示调用logger的代码行                       %L                   129
    %line                                                  %line                129
    ********************************************************************************************************************
    %level      显示该条日志的优先级                         %level               INFO
    %p                                                     %p                   INFO
    ********************************************************************************************************************
    %m          显示输出消息                                 %m                  This is a message for debug.
    %message                                                %message            This is a message for debug.
    ********************************************************************************************************************
    %M          显示调用logger的方法名                       %M                   main
    ********************************************************************************************************************
    %n          当前平台下的换行符                           %n                   Windows平台下表示rn，UNIX平台下表示n
    ********************************************************************************************************************
    %p          显示该条日志的优先级                         %p                   INFO
    %level                                                 %level               INFO
    ********************************************************************************************************************
    %r          显示从程序启动时到记录该条日志时已经经过的毫秒数  %r                 1215
    ********************************************************************************************************************
    %t          输出产生该日志事件的线程名                    %t                   http-nio-8080-exec-10
    %thread                                                 %thread              http-nio-8080-exec-10
    ********************************************************************************************************************
    %x          按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志           假设某程序调用顺序是MyApp调用com.foo.Bar
                                                            %c %x - %m%n        MyApp - Call com.foo.Bar.
                                                                                com.foo.Bar - Log in Bar
                                                                                MyApp - Return to MyApp.
    ********************************************************************************************************************
    %X          按MDC（Mapped Diagnostic Context，线程映射表）
                输出日志。通常用于多个客户端连接同一台服务器，
                方便服务器区分是那个客户端访问留下来的日志。     %X&#123;5&#125;             （记录代号为5的客户端的日志）
    ********************************************************************************************************************
    %%          显示一个百分号                               %%                  %
    ********************************************************************************************************************
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#00bcd4>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/">
        <h2>
            Spring中Bean作用域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><h2 id="一、Spring生命周期流程图"><a href="#一、Spring生命周期流程图" class="headerlink" title="一、Spring生命周期流程图"></a>一、Spring生命周期流程图</h2><p>下图描述的是从Spring容器初始化Bean开始直到Spring容器销毁Bean，所经历的关键节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20211208133748318.png" alt="file"></p>
<p>​        从上图可以看出，Spring Bean的生命周期管理的基本思路是：在Bean出现之前，先准备操作Bean的BeanFactory，然后操作完Bean，所有的Bean也还会交给BeanFactory进行管理。在所有Bean操作准备BeanPostProcessor作为回调。在Bean的完整生命周期管理过程中，经历了以下主要几个步骤：</p>
<h3 id="1-1-Bean创建前的准备阶段"><a href="#1-1-Bean创建前的准备阶段" class="headerlink" title="1.1 Bean创建前的准备阶段"></a>1.1 Bean创建前的准备阶段</h3><ul>
<li>步骤1： Bean容器在配置文件中找到Spring Bean的定义以及相关的配置，如init-method和destroy-method指定的方法。</li>
<li>步骤2： 实例化回调相关的后置处理器如BeanFactoryPostProcessor、BeanPostProcessor、InstantiationAwareBeanPostProcessor等</li>
</ul>
<h3 id="1-2-创建Bean的实例"><a href="#1-2-创建Bean的实例" class="headerlink" title="1.2 创建Bean的实例"></a>1.2 创建Bean的实例</h3><ul>
<li>步骤3： Srping 容器使用Java反射API创建Bean的实例。</li>
<li>步骤4：扫描Bean声明的属性并解析。</li>
</ul>
<h3 id="1-3-开始依赖注入"><a href="#1-3-开始依赖注入" class="headerlink" title="1.3 开始依赖注入"></a>1.3 开始依赖注入</h3><ul>
<li>步骤5：开始依赖注入，解析所有需要赋值的属性并赋值。</li>
<li>步骤6：如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。</li>
<li>步骤7：如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。</li>
<li>步骤8：如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。</li>
<li>步骤9：如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。</li>
</ul>
<h3 id="1-4-缓存到Spring容器"><a href="#1-4-缓存到Spring容器" class="headerlink" title="1.4 缓存到Spring容器"></a>1.4 缓存到Spring容器</h3><ul>
<li>步骤10： 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。</li>
<li>步骤11：如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。</li>
</ul>
<h3 id="1-5-销毁Bean的实例"><a href="#1-5-销毁Bean的实例" class="headerlink" title="1.5 销毁Bean的实例"></a>1.5 销毁Bean的实例</h3><ul>
<li>步骤12：如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。</li>
<li>步骤13：如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</li>
</ul>
<h2 id="二、Bean的作用域"><a href="#二、Bean的作用域" class="headerlink" title="二、Bean的作用域"></a>二、Bean的作用域</h2><p>​        创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方”。把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域，分别阐述如下表。</p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton">singleton</a></td>
<td>默认的。一个bean定义，在一个IoC容器内只会产生一个对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype">prototype</a></td>
<td>一个bean定义会产生多个对象实例</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-request">request</a></td>
<td>一个bean定义产生的bean生命周期为一个HTTP请求；也就是，每一个HTTP请求都会根据bean定义产生一个对象实例。该作用域只有在Spring web ApplicationContext 上下文环境中才有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-session">session</a></td>
<td>产生的bean生命周期在HTTP 会话期间。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-application">application</a></td>
<td>将单个bean定义范围限定为ServletContext的生命周期。 该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope">websocket</a></td>
<td>将单个bean定义范围限定为WebSocket的生命周期。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
</tbody></table>
<p>　    五种作用域中，request、session和global session三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<p>　　(1)当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>　　(2)当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
&lt;!--或者--&gt;
&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 
</code></pre>
<p>　　(3)当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>　　针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<p>　　(4)当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>　　针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<p>　　(5)当一个bean的作用域为Global Session，表示在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>　　global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p>
<h3 id="2-1-Spring中request请求作用域是什么？"><a href="#2-1-Spring中request请求作用域是什么？" class="headerlink" title="2.1 Spring中request请求作用域是什么？"></a>2.1 Spring中request请求作用域是什么？</h3><p>每个请求初始化具有此作用域的Bean注解。这听起来像是原型作用域的描述，但它们有一些差异。第一个区别是原型作用域在Spring的上下文中可用。而请求作用域仅适用于Web应用程序。第二个是原型bean根据需求进行初始化，而请求bean是在每个请求下构建的。需要说的是，request作用域bean在其作用域内有且仅有一个实例。而你可以拥有一个或多个原型作用域bean实例。</p>
<p>在以下代码中，你可以看到请求作用域bean的示例：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartRequest&quot; scope=&quot;request&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>当使用注解驱动组件或Java Config时，<code>@RequestScope</code>注解可以用于将一个组件分配给<code>request</code>作用域。</p>
<pre><code class="java">@RequestScope
@Component
public class ShoppingCartRequest &#123;
    // ...
&#125;
// request bean

// injection sample
@Controller
public class TestController &#123;
    @Autowired
    private ShoppingCartRequest shoppingCartRequest;

    @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)
    public String test(HttpServletRequest request) &#123;
        LOGGER.debug(&quot;shoppingCartRequest is :&quot;+shoppingCartRequest);
        // ...
    &#125;
&#125;
</code></pre>
<p>请注意<strong>定义内</strong>存在的**&lt;aop: scoped-proxy /&gt;**标签。这代表着使用代理对象。所以实际上，TestController持有的是代理对象的引用。我们所有的调用该对象都会转发到真正的<code>ShoppingCartRequest</code>对象。</p>
<p>有时我们需要使用<code>DispatcherServlet</code>的另一个<code>servlet</code>来处理请求。在这种情况下，我们必须确保Spring中所有请求都可用(否则可以抛出与下面类似的异常)。为此，我们需要在<code>web.xml</code>中定义一个监听器:</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>调用/测试URL后，你应该能在日志中的发现以下信息:</p>
<pre><code class="java">shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@2586b11c
shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@3bd5b945
</code></pre>
<p>如果我们尝试在单例bean中使用request作用域的bean，则会在应用程序上下文加载阶段抛出一个<code>BeanCreationException</code>:</p>
<pre><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;testController&#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:700)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:381)
    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293)
    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)
    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4701)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5204)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5199)
    at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source)
    at java.util.concurrent.FutureTask.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)
Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289)
    ... 21 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1014)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:957)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480)
    ... 23 more
Caused by: java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.web.context.request.RequestContextHolder.currentRequestAttributes(RequestContextHolder.java:131)
    at org.springframework.web.context.request.AbstractRequestAttributesScope.get(AbstractRequestAttributesScope.java:41)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338)
    ... 28 more
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="2-2-什么是Spring的Session作用域？"><a href="#2-2-什么是Spring的Session作用域？" class="headerlink" title="2.2 什么是Spring的Session作用域？"></a>2.2 什么是Spring的Session作用域？</h3><p>Session作用域的bean与request 作用域的bean没有太大的不同。它们也与纯Web应用程序上下文相关联。注解为Session作用域的Bean对于每个用户的会话仅创建一次。他们在会话结束时被破坏销毁掉。</p>
<p>由Session作用域限制的Bean可以被认为是面向Web的单例，因为给定环境(用户会话)仅存在一个实例。但请记住，你无法在Web应用程序上下文中使用它们(说个好理解点的，就是一个函数内部自定义变量所在的作用域，函数执行完就销毁了，没有什么逃逸，关于此处更深入的理解请看我的博文<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2016/11/08/%E7%94%B1%E5%9F%9F%E8%81%94%E7%B3%BB%E5%88%B0%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">由域联系到的逃逸分析</a>)。</p>
<p>想知道Session作用域bean在Spring中的操作，我们需要在配置文件中定义一个bean:</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartSession&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>通过<code>@Autowired</code>注解，查找这个bean的方式与request 作用域的bean相同。可以看到以下结果:</p>
<pre><code class="java">shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@2f87fafc
</code></pre>
<p>你可以看到，前5个打印输出代表相同的对象。最后一个是不同的。这是什么意思 ?简单来说，这代表 着一个新的用户使用自动注入的Session作用域访问该页面。我们可以通过打开两个浏览器的测试页(/test)来观察它。每个都将初始化一个新的会话Session，因此也就创建新的<code>ShoppingCartSession bean</code>实例。</p>
<p>关于全局会话作用域(Global session scope)属于4.3x的范畴了，Spring5已经没有了，Spring5文档是去掉了因为4的存在所以还是说两句，它保留给portlet应用程序。 是不是一脸懵逼，so，来解释一下portlet是什么。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与servlet不同，每个portlet都有不同的会话。在这种情况下，Spring提供了一个名为<code>global-session</code>的作用域。通过它，一个bean可以通过应用程序中的多个portlet共享。</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>至此，我们解释了请求和面向会话的作用域。第一个的作用是在每个request请求上创建新的bean。第二个在Session会话开始的时候初始化bean。</p>
<h2 id="三、Bean的生命周期"><a href="#三、Bean的生命周期" class="headerlink" title="三、Bean的生命周期"></a>三、Bean的生命周期</h2><p>　Spring中Bean的实例化过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210510144229675.png" alt="img"></p>
<p>Bean的生命周期：</p>
<p><img src="https://img-blog.csdnimg.cn/2021051014425161.png" alt="img"></p>
<p>Bean实例生命周期的执行过程如下：</p>
<ul>
<li>Spring对bean进行实例化，默认bean是单例；</li>
<li>Spring对bean进行依赖注入；</li>
<li>如果bean实现了BeanNameAware接口，Spring将bean的名称传给setBeanName()方法；</li>
<li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory实例传进来；</li>
<li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization()方法将被调用；</li>
<li>如果bean中有方法添加了@PostConstruct注解，那么该方法将被调用；</li>
<li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li>
<li>如果在xml文件中通过<bean>标签的init-method元素指定了初始化方法，那么该方法将被调用；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization()接口方法将被调用；</li>
<li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>
<li>如果bean中有方法添加了@PreDestroy注解，那么该方法将被调用；</li>
<li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ul>
<p>　　这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。</p>
<p>　　其实很多时候我们并不会真的去实现上面所描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<h3 id="3-1-单例管理的对象"><a href="#3-1-单例管理的对象" class="headerlink" title="3.1 单例管理的对象"></a>3.1 单例管理的对象</h3><p>　　当scope=”singleton”，即默认情况下，会在启动容器时（即实例化容器时）时实例化。但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。如下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;serviceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p>
<pre><code class="xml">&lt;beans default-lazy-init=&quot;true&quot;&gt;
</code></pre>
<p>　　默认情况下，Spring在读取xml文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用init-method属性值中所指定的方法。对象在被销毁的时候，会调用destroy-method属性值中所指定的方法（例如调用Container.destroy()方法的时候）。写一个测试类，代码如下：</p>
<pre><code class="java">public class LifeBean &#123;
    private String name;  
    
    public LifeBean()&#123;  
        System.out.println(&quot;LifeBean()构造函数&quot;);  
    &#125;  
    public String getName() &#123;  
        return name;  
    &#125;  
  
    public void setName(String name) &#123;  
        System.out.println(&quot;setName()&quot;);  
        this.name = name;  
    &#125;  

    public void init()&#123;  
        System.out.println(&quot;this is init of lifeBean&quot;);  
    &#125;  
      
    public void destory()&#123;  
        System.out.println(&quot;this is destory of lifeBean &quot; + this);  
    &#125;  
&#125;
</code></pre>
<p>　　life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_singleton&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;singleton&quot; 
            init-method=&quot;init&quot; destroy-method=&quot;destory&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　测试代码如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = 
        new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life&quot;);
        System.out.println(life1);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<h3 id="2-2-非单例管理的对象"><a href="#2-2-非单例管理的对象" class="headerlink" title="2.2 非单例管理的对象"></a>2.2 非单例管理的对象</h3><p>　　当scope=”prototype”时，容器也会延迟初始化bean，Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。在第一次请求每一个prototype的bean时，Spring容器都会调用其构造器创建这个对象，然后调用init-method属性值中所指定的方法。对象销毁的时候，Spring容器不会帮我们调用任何方法，因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<p>　　为了测试prototype bean的生命周期life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_prototype&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;
</code></pre>
<p>　　测试程序如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life_singleton&quot;);
        System.out.println(life1);
        
        LifeBean life3 = (LifeBean)container.getBean(&quot;life_prototype&quot;);
        System.out.println(life3);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：　</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@5ae9a829
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<p>　　可以发现，对于作用域为prototype的bean，其destroy方法并没有被调用。如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>　　Spring容器可以管理singleton作用域下bean的生命周期，在此作用域下，Spring能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的bean，Spring只负责创建，当容器创建了bean的实例后，bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<h3 id="2-3-引申"><a href="#2-3-引申" class="headerlink" title="2.3 引申"></a>2.3 引申</h3><p>　　在学习Spring IoC过程中发现，每次产生ApplicationContext工厂的方式是：</p>
<pre><code class="java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p>　　这样产生ApplicationContext就有一个弊端，每次访问加载bean的时候都会产生这个工厂，所以这里需要解决这个问题。</p>
<p>　　ApplicationContext是一个接口，它继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持。</p>
<p>　　解决问题的方法很简单，在web容器启动的时候将ApplicationContext转移到ServletContext中，因为在web应用中所有的Servlet都共享一个ServletContext对象。那么我们就可以利用ServletContextListener去监听ServletContext事件，当web应用启动的是时候，我们就将ApplicationContext装载到ServletContext中。 Spring容器底层已经为我们想到了这一点，在spring-web-xxx-release.jar包中有一个已经实现了ServletContextListener接口的类ContextLoader，其源码如下：</p>
<pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;
    private ContextLoader contextLoader;

    public ContextLoaderListener() &#123;

    &#125;

    public ContextLoaderListener(WebApplicationContext context) &#123;
        super(context);
    &#125;

    public void contextInitialized(ServletContextEvent event) &#123;
        this.contextLoader = createContextLoader();
        if (this.contextLoader == null) &#123;
            this.contextLoader = this;
        &#125;
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    &#125;

    @Deprecated
    protected ContextLoader createContextLoader() &#123;
        return null;
    &#125;

    @Deprecated
    public ContextLoader getContextLoader() &#123;
        return this.contextLoader;
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        if (this.contextLoader != null) &#123;
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
        &#125;
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    &#125;
&#125;
</code></pre>
<p>　　这里就监听到了servletContext的创建过程, 那么 这个类又是如何将applicationContext装入到serveletContext容器中的呢?</p>
<p>　　this.contextLoader.initWebApplicationContext(event.getServletContext())方法的具体实现中：</p>
<pre><code class="java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;
     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;
         throw new IllegalStateException(
                 &quot;Cannot initialize context because there is already a root application context present - &quot; +
                 &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
     &#125;

     Log logger = LogFactory.getLog(ContextLoader.class);
     servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
     if (logger.isInfoEnabled()) &#123;
         logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
     &#125;
     long startTime = System.currentTimeMillis();

     try &#123;
           // Store context in local instance variable, to guarantee that
          // it is available on ServletContext shutdown.
         if (this.context == null) &#123;
             this.context = createWebApplicationContext(servletContext);
         &#125;
         if (this.context instanceof ConfigurableWebApplicationContext) &#123;
             ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
             if (!cwac.isActive()) &#123;
                 // The context has not yet been refreshed -&gt; provide services such as
                 // setting the parent context, setting the application context id, etc
                 if (cwac.getParent() == null) &#123;
                     // The context instance was injected without an explicit parent -&gt;
                     // determine parent for root web application context, if any.
                     ApplicationContext parent = loadParentContext(servletContext);
                     cwac.setParent(parent);
                 &#125;
                 configureAndRefreshWebApplicationContext(cwac, servletContext);
             &#125;
         &#125;
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

         ClassLoader ccl = Thread.currentThread().getContextClassLoader();
         if (ccl == ContextLoader.class.getClassLoader()) &#123;
             currentContext = this.context;
         &#125;
         else if (ccl != null) &#123;
             currentContextPerThread.put(ccl, this.context);
         &#125;

         if (logger.isDebugEnabled()) &#123;
             logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
                     WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
         &#125;
         if (logger.isInfoEnabled()) &#123;
             long elapsedTime = System.currentTimeMillis() - startTime;
             logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
         &#125;

         return this.context;
     &#125;
     catch (RuntimeException ex) &#123;
         logger.error(&quot;Context initialization failed&quot;, ex);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
         throw ex;
     &#125;
     catch (Error err) &#123;
         logger.error(&quot;Context initialization failed&quot;, err);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
         throw err;
     &#125;
 &#125;
</code></pre>
<p>　　这里的重点是servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)，用key:WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE value: this.context的形式将applicationContext装载到servletContext中了。另外从上面的一些注释我们可以看出： WEB-INF/applicationContext.xml， 如果我们项目中的配置文件不是这么一个路径的话 那么我们使用ContextLoaderListener 就会出问题, 所以我们还需要在web.xml中配置我们的applicationContext.xml配置文件的路径。</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>　　剩下的就是在项目中开始使用 servletContext中装载的applicationContext对象了： 那么这里又有一个问题，装载时的key是 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们在代码中真的要使用这个吗? 其实Spring为我们提供了一个工具类WebApplicationContextUtils，接着我们先看下如何使用，然后再去看下这个工具类的源码：</p>
<pre><code class="java">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());
</code></pre>
<p>　　接着来看下这个工具类的源码：</p>
<pre><code class="java">public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;
    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
&#125;
</code></pre>
<p>　　这里就能很直观清晰地看到 通过key值直接获取到装载到servletContext中的 applicationContext对象了。</p>
<p>　　ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，整个加载配置过程由ContextLoader来完成。</p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>​        理解spring中bean的生命周期，对于学习和使用spring很有帮助。本文将从两个角度对spring中bean的生命周期进行介绍，一是bean定义生成；二是bean在初始化、使用、销毁的生命周期中经历的阶段。</p>
<h3 id="4-2-bean定义生成"><a href="#4-2-bean定义生成" class="headerlink" title="4.2 bean定义生成"></a>4.2 bean定义生成</h3><p>​        bean定义生成主要分为三个步骤，即bean定义的获取、bean定义的注册。<br><strong>1、bean定义的获取</strong><br>​        bean的定义来源各种各样，如xml定义、java注解定义等。<br>​        spring对各种来源提供了统一的接口org.springframework.core.io.Resource，<br>​        Resource接口即也是对spring内的所有底层资源进行了抽象（如file、url、classpath）。<br>​        Resource接口相关的类结构图如下：<br><img src="https://img-blog.csdnimg.cn/20181114231111589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5hYmVzdGNoaW5h,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​        各类bean定义的加载请参数相应spring源码。<br><strong>2、bean定义的解析</strong><br>​        由于来源的不同，bean的解析也是各种各样的（如xml内标签的解析）。<br>​        spring对bean的定义仍然有公共的接口org.springframework.beans.factory.config.BeanDefinition。<br>​        具体解析请查看spring源码。<br><strong>3、bean的注册</strong><br>​        解析得到的bean，最终会注册到容器中，其实也就是ConcurrentHashMap，<br>​        即org.springframework.beans.factory.support.DefaultListableBeanFactory类中的实例变量</p>
<pre><code class="java">/** Map of bean definition objects, keyed by bean name */
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<p>​        此bean的加载完成</p>
<h3 id="4-3-spring的生命周期"><a href="#4-3-spring的生命周期" class="headerlink" title="4.3 spring的生命周期"></a>4.3 spring的生命周期</h3><p>​        spring生命周期中的阶段，包括初始化、使用、销毁。<br><strong>1、初始化阶段</strong><br>​        1）调用bean的构造函数，创建实例；<br>​        2）进行参数依赖注入；<br>​        3）若实现org.springframework.beans.BeanNameAware接口，则调用BeanNameAware的setBeanName()方法;<br>​        4）若实现org.springframework.beans.factory.BeanClassLoaderAware接口，则调用BeanClassLoaderAware的setBeanClassLoader()方法;<br>​        5）若实现org.springframework.context.ApplicationContextAware接口，则调用ApplicationContextAware的setApplicationContext()方法;<br>​        6）若使用了注解@PostConstruct，则调相应方法；<br>​        7）若实现org.springframework.beans.factory.InitializingBean接口，则调用InitializingBean接口的afterPropertiesSet方法;<br>​        8）若bean定义的使用了initMethod，则调相应方法；<br>​        9）若实现org.springframework.beans.factory.config.BeanPostProcessor接口，则调用BeanPostProcessor的postProcessBeforeInitialization()方法和postProcessAfterInitialization方法;<br><strong>2、使用阶段</strong><br>​        1）bean在项目的使用；<br><strong>3、销毁阶段</strong><br>​        1）若使用注解@PreDestroy，则调用相应方法；<br>​        2）若bean定义中配置了destroyMethod，则调用相应方法；<br>​        3）若实现org.springframework.beans.factory.DisposableBean接口，则调用DisposableBean接口的destroy方法; </p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>综合前面的代码和分析，现在我们用大白话描述下：</p>
<ol>
<li>Bean容器找到Spring配置文件中Bean的定义；</li>
<li>Bean容器利用java 反射机制实例化Bean；</li>
<li>Bean容器为实例化的Bean设置属性值；</li>
<li>如果Bean实现了BeanNameAware接口，则执行setBeanName方法；</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则执行setBeanClassLoader方法；</li>
<li>如果Bean实现了BeanFactoryAware接口，则执行setBeanFactory方法；</li>
<li>如果 ……真的，到这我经常忘记，但前面三个Aware接口肯定能记住；</li>
<li>如果Bean实现了ApplicationContextAware接口，则执行setApplicationContext方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessBeforeInitialization方法；</li>
<li>如果Bean定义初始化方法（PostConstruct注解、配置init-method、实现了InitializingBean接口），则执行定义的初始化方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessAfterInitialization方法；</li>
<li>当要销毁这个Bean时，如果自定义了销毁方法（PreDestroy注解、配置destroy-method、实现了DisposableBean接口），则执行定义的销毁方法。</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/">
        <h2>
            Mybaits使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="MyBaits使用详解"><a href="#MyBaits使用详解" class="headerlink" title="MyBaits使用详解"></a>MyBaits使用详解</h1><blockquote>
<p> 环境说明：</p>
</blockquote>
<ul>
<li>jdk 8 +</li>
<li>MySQL 5.7.19</li>
<li>maven-3.6.1</li>
<li>IDEA</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1、Mybaits简介"><a href="#1-1、Mybaits简介" class="headerlink" title="1.1、Mybaits简介"></a>1.1、Mybaits简介</h3><ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</li>
<li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到<strong>Github</strong> .</li>
<li>Mybatis官方文档 : <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li>
<li>GitHub : <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li>
</ul>
<h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p>
<ul>
<li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
<li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li>
</ul>
<p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p>
<ul>
<li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li>
<li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p><strong>什么是持久层？</strong></p>
<ul>
<li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li>
<li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li>
<li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li>
<li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li>
</ul>
<h3 id="1-4、Mybaits功能"><a href="#1-4、Mybaits功能" class="headerlink" title="1.4、Mybaits功能"></a>1.4、Mybaits功能</h3><ul>
<li><p>Mybatis就是帮助程序员将数据存入数据库中 , 和从数据库中取数据 .</p>
</li>
<li><p>传统的jdbc操作 , 有很多重复代码块 。比如：数据取出时的封装 , 数据库的建立连接等等，通过框架可以减少重复代码，提高开发效率 。</p>
</li>
<li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p>
</li>
<li><p>MyBatis的优点</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
</ul>
<ul>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<h3 id="1-5、Mybaits程序"><a href="#1-5、Mybaits程序" class="headerlink" title="1.5、Mybaits程序"></a>1.5、Mybaits程序</h3><h4 id="1-5-1、数据库搭建"><a href="#1-5-1、数据库搭建" class="headerlink" title="1.5.1、数据库搭建"></a>1.5.1、数据库搭建</h4><pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
`id` int(20) NOT NULL,
`name` varchar(30) DEFAULT NULL,
`pwd` varchar(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) 
values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);
</code></pre>
<h4 id="1-5-2、导入依赖"><a href="#1-5-2、导入依赖" class="headerlink" title="1.5.2、导入依赖"></a>1.5.2、导入依赖</h4><pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1-5-3、核心配置文件"><a href="#1-5-3、核心配置文件" class="headerlink" title="1.5.3、核心配置文件"></a>1.5.3、核心配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
   &lt;!-- 配置环境 --&gt;
   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
               &lt;property name=&quot;url&quot; 
                         value=&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;amp;
                                useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
    
   &lt;!-- 加载映射地址 --&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="1-5-4、Mybaits工具类"><a href="#1-5-4、Mybaits工具类" class="headerlink" title="1.5.4、Mybaits工具类"></a>1.5.4、Mybaits工具类</h4><pre><code class="java">import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils &#123;

    /**
     * 禁止外界通过new方法创建
         private MybatisUtil()&#123;&#125;
     */
    
   private static SqlSessionFactory sqlSessionFactory;

   static &#123;
       try &#123;
           String resource = &quot;mybatis-config.xml&quot;;
           // 加载核心配置文件
           InputStream inputStream = Resources.getResourceAsStream(resource);
           // 创建sqlsession工厂 --&gt;相当于connection
           sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
      &#125; catch (IOException e) &#123;
           e.printStackTrace();
      &#125;
  &#125;

   //获取SqlSession连接 --&gt;相当于执行sql语句对象
   public static SqlSession getSession()&#123;
       
       /*       
           //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象为空
            if(sqlSession == null)&#123;
                //在SqlSessionFactory非空的情况下，获取SqlSession对象
                sqlSession = sqlSessionFactory.openSession();
                //将SqlSession对象与当前线程绑定在一起
                threadLocal.set(sqlSession);
            &#125;       
       */
       
       return sqlSessionFactory.openSession();
  &#125;
    
   /**
     * 
          关闭SqlSession与当前线程分开
           public static void closeSqlSession()&#123;
            //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象非空
            if(sqlSession != null)&#123;
                //关闭SqlSession对象
                sqlSession.close();
                //分开当前线程与SqlSession对象的关系，目的是让GC尽早回收
                threadLocal.remove();
            &#125;
        &#125;
     
     */
  

&#125;
</code></pre>
<p><strong>MybatisUtil工具类的作用</strong>:</p>
<ul>
<li>在静态初始化块中加载mybatis配置文件和StudentMapper.xml文件一次</li>
<li>使用ThreadLocal对象让当前线程与SqlSession对象绑定在一起</li>
<li>获取当前线程中的SqlSession对象，如果没有的话，从SqlSessionFactory对象中获取SqlSession对象</li>
<li>获取当前线程中的SqlSession对象，再将其关闭，释放其占用的资源</li>
</ul>
<h4 id="1-5-5、实体类"><a href="#1-5-5、实体类" class="headerlink" title="1.5.5、实体类"></a>1.5.5、实体类</h4><pre><code class="java">@Data
public class User &#123;
   
   private int id;  //id
   private String name;   //姓名
   private String pwd;   //密码
   
&#125;
</code></pre>
<h4 id="1-5-6、Mapper接口类"><a href="#1-5-6、Mapper接口类" class="headerlink" title="1.5.6、Mapper接口类"></a>1.5.6、Mapper接口类</h4><pre><code class="java">import com.kuang.pojo.User;
import java.util.List;

public interface UserMapper &#123;
   List&lt;User&gt; selectUser();
&#125;
</code></pre>
<h4 id="1-5-7、Mapper-xml配置文件"><a href="#1-5-7、Mapper-xml配置文件" class="headerlink" title="1.5.7、Mapper.xml配置文件"></a>1.5.7、Mapper.xml配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;
 &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
  select * from user
 &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="1-5-8、测试类"><a href="#1-5-8、测试类" class="headerlink" title="1.5.8、测试类"></a>1.5.8、测试类</h4><pre><code class="java">public class MyTest &#123;
   @Test
   public void selectUser() &#123;
       SqlSession session = MybatisUtils.getSession();
       //方法一:
       List&lt;User&gt; users1 = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);
       
       for (User user: users1)&#123;
           System.out.println(user);
      &#125;    
       
       
       //方法二:
       UserMapper mapper = session.getMapper(UserMapper.class);
       List&lt;User&gt; users2 = mapper.selectUser();
   
       for (User user: users2)&#123;
           System.out.println(user);
      &#125;
       session.close();
  &#125;
&#125;
</code></pre>
<h3 id="1-6、问题说明"><a href="#1-6、问题说明" class="headerlink" title="1.6、问题说明"></a>1.6、问题说明</h3><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/resources&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="二、CUDR操作及配置解析"><a href="#二、CUDR操作及配置解析" class="headerlink" title="二、CUDR操作及配置解析"></a>二、CUDR操作及配置解析</h2><h3 id="2-1、namespace"><a href="#2-1、namespace" class="headerlink" title="2.1、namespace"></a>2.1、namespace</h3><ol>
<li>将上面案例中的UserMapper接口改名为 UserDao；</li>
<li>将UserMapper.xml中的namespace改为为UserDao的路径 ；</li>
<li>再次测试</li>
</ol>
<p><strong>结论：</strong></p>
<p>​        <strong>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名，必须一致！</strong></p>
<h3 id="2-2、CUDR操作"><a href="#2-2、CUDR操作" class="headerlink" title="2.2、CUDR操作"></a>2.2、CUDR操作</h3><h4 id="2-2-1、select操作"><a href="#2-2-1、select操作" class="headerlink" title="2.2.1、select操作"></a>2.2.1、select操作</h4><ul>
<li><p>select标签是mybatis中最常用的标签之一</p>
</li>
<li><p>select语句有很多属性可以详细配置每一条SQL语句</p>
</li>
<li><ul>
<li>SQL语句返回值类型。【完整的类名或者别名】</li>
<li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li>
<li>命名空间中唯一的标识符</li>
<li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li>
<li>id</li>
<li>parameterType</li>
<li>resultType</li>
</ul>
</li>
</ul>
<p><strong>需求一：根据id查询用户</strong></p>
<p>1、在UserMapper中添加对应方法</p>
<pre><code class="java">public interface UserMapper &#123;
   //查询全部用户
   List&lt;User&gt; selectUser();
   //根据id查询用户
   User selectUserById(int id);
&#125;
</code></pre>
<p>2、在UserMapper.xml中添加Select语句</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>select参数：</p>
<p>1). id：</p>
<p>2). <strong>parametweType：</strong>传递的参数</p>
<p>3). <strong>resultType：</strong>是SQL映射文件中定义返回值类型，返回值有基本类型，对象类型，List类型，Map类型等。</p>
<ul>
<li>基本类型：resultType=基本类型</li>
<li>List类型：resultType=<strong>List中元素的类型</strong></li>
<li>Map类型  <ul>
<li>单条记录：resultType=map</li>
<li>多条记录：resultType =Map中value的类型</li>
</ul>
</li>
</ul>
<p><strong>注：</strong>为什么是使用map而不是Map呢？</p>
<p>刚刚配置中的**resultType=”map”**，为什么是map，不是Map呢？</p>
<p>如果想写Map，需要写成全限定类名，即：<strong>resultType = “java.util.Map”</strong> map是java.util.Map的一个简写，还有其他的简写可以参考下方表格：</p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M1.png"></p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M2.png"></p>
<p>3、测试类中测试</p>
<pre><code class="java">@Test
public void tsetSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   System.out.println(user);
   
   session.close();
&#125;
</code></pre>
<p><strong>需求二：根据密码和名字查询用户</strong></p>
<p><strong>思路一：直接在方法中传递参数</strong></p>
<p>1、在接口方法的参数前加 @Param属性</p>
<p>2、Sql语句编写的时候，直接取**@Param中设置的值**即可，不需要单独设置参数类型</p>
<pre><code class="java">//通过密码和名字查询用户
User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);
</code></pre>
<p>3、Mapper.xml配置文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p><strong>思路二：使用Map</strong></p>
<p>1、在接口方法中，参数直接传递Map；</p>
<pre><code class="java">User selectUserByNP2(Map&lt;String,Object&gt; map);
</code></pre>
<p>2、编写sql语句的时候，需要传递参数类型，参数类型为map</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p>3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put(&quot;username&quot;,&quot;小明&quot;);
map.put(&quot;pwd&quot;,&quot;123456&quot;);
User user = mapper.selectUserByNP2(map);
</code></pre>
<p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可.</p>
<h4 id="2-2-2、insert操作"><a href="#2-2-2、insert操作" class="headerlink" title="2.2.2、insert操作"></a>2.2.2、insert操作</h4><p><strong>需求：给数据库增加一个用户</strong></p>
<p>1、在UserMapper接口中添加对应的方法</p>
<pre><code class="java">//添加一个用户
int addUser(User user);
</code></pre>
<p>2、在UserMapper.xml中添加insert语句</p>
<pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
&lt;/insert&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);
   int i = mapper.addUser(user);
   System.out.println(i);
   
   // 提交事务，将事务提交到数据库
   session.commit(); 
   session.close();
&#125;
</code></pre>
<p>​    <strong>注：</strong>增、删、改操作需要提交事务！</p>
<h4 id="2-2-3、update操作"><a href="#2-2-3、update操作" class="headerlink" title="2.2.3、update操作"></a>2.2.3、update操作</h4><p><strong>需求：修改用户的信息</strong></p>
<p>1、同理，编写接口方法</p>
<pre><code class="java">//修改一个用户
int updateUser(User user);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   user.setPwd(&quot;asdfgh&quot;);
   int i = mapper.updateUser(user);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-4、delete操作"><a href="#2-2-4、delete操作" class="headerlink" title="2.2.4、delete操作"></a>2.2.4、delete操作</h4><p><strong>需求：根据id删除一个用户</strong></p>
<p>1、编写接口方法</p>
<pre><code class="java">//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from user where id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   int i = mapper.deleteUser(5);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-5、模糊查询like语句"><a href="#2-2-5、模糊查询like语句" class="headerlink" title="2.2.5、模糊查询like语句"></a>2.2.5、模糊查询like语句</h4><p>方法一：在Java代码中添加sql通配符。</p>
<pre><code class="java">string wildcardname = “%smi%”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like #&#123;value&#125;
&lt;/select&gt;
</code></pre>
<p>方法二：在sql语句中拼接通配符，会引起sql注入</p>
<pre><code class="java">string wildcardname = “smi”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
&lt;/select&gt;
</code></pre>
<h4 id="2-4-6、小结"><a href="#2-4-6、小结" class="headerlink" title="2.4.6、小结"></a>2.4.6、小结</h4><ul>
<li>所有的增删改操作都需要提交事务！</li>
<li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li>
<li>有时候根据业务的需求，可以考虑使用map传递参数！</li>
<li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li>
</ul>
<h3 id="2-3、配置解析"><a href="#2-3、配置解析" class="headerlink" title="2.3、配置解析"></a>2.3、配置解析</h3><h4 id="2-3-1、核心配置文件"><a href="#2-3-1、核心配置文件" class="headerlink" title="2.3.1、核心配置文件"></a>2.3.1、核心配置文件</h4><ul>
<li>mybatis-config.xml 系统核心配置文件</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
<li>能配置的内容如下：</li>
</ul>
<pre><code class="xml">configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;
</code></pre>
<p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p>
<h4 id="2-3-2、environments元素"><a href="#2-3-2、environments元素" class="headerlink" title="2.3.2、environments元素"></a>2.3.2、environments元素</h4><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;

        &lt;!-- 事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<ul>
<li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p>
</li>
<li><p>子元素节点：<strong>environment</strong></p>
<ul>
<li>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</li>
</ul>
<ul>
<li><p>数据源是必须配置的。</p>
</li>
<li><p>有三种内建的数据源类型</p>
</li>
</ul>
</li>
</ul>
<pre><code class="xml">type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）
</code></pre>
<ul>
<li><p><strong>unpooled：</strong>这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
</li>
<li><p><strong>JNDI：</strong>这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
<li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p>
</li>
<li><p>详情：点击查看官方文档</p>
</li>
<li><p>这两种事务管理器类型都不需要设置任何属性。</p>
</li>
<li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p>
</li>
<li><p>子元素节点：transactionManager - [ 事务管理器 ]</p>
</li>
</ul>
<pre><code class="xml">&lt;!-- 语法 --&gt;
&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;
</code></pre>
<ul>
<li>子元素节点：<strong>数据源（dataSource）</strong></li>
</ul>
<h4 id="2-3-3、mappers元素"><a href="#2-3-3、mappers元素" class="headerlink" title="2.3.3、mappers元素"></a>2.3.3、mappers元素</h4><p><strong>mappers</strong></p>
<ul>
<li><strong>映射器 :</strong> 定义映射SQL语句文件</li>
<li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用<strong>相对于类路径的资源引用</strong>， 或<strong>完全限定资源定位符</strong>（包括 <code>file:///</code> 的 URL），或类名和包名等。</li>
<li>映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li>
</ul>
<p><strong>引入资源方式</strong></p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
    使用映射器接口实现类的完全限定类名
    需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Mapper文件</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
   
&lt;/mapper&gt;
</code></pre>
<ul>
<li><p>namespace中文意思：命名空间，作用如下：</p>
<ul>
<li>namespace的命名必须跟某个接口同名</li>
</ul>
<ul>
<li>接口中的方法与映射文件中sql语句id应该一一对应<ul>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p>
<h4 id="2-3-4、Properties优化"><a href="#2-3-4、Properties优化" class="headerlink" title="2.3.4、Properties优化"></a>2.3.4、Properties优化</h4><p>​        数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<p>​        第一步 ; 在资源目录下新建一个<strong>db.properties</strong></p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
username=root
password=123456
</code></pre>
<p>​        第二步 : 将文件导入properties 配置文件</p>
<pre><code class="xml">&lt;configuration&gt;
   &lt;!--导入properties文件--&gt;
   &lt;properties resource=&quot;db.properties&quot;/&gt;

   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
               &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>更多操作，可以查看官方文档！【演示带领学习】</p>
<ul>
<li>配置文件优先级问题</li>
<li>新特性：使用占位符</li>
</ul>
<h4 id="2-4-5、typeAliases优化"><a href="#2-4-5、typeAliases优化" class="headerlink" title="2.4.5、typeAliases优化"></a>2.4.5、typeAliases优化</h4><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<pre><code class="xml">&lt;!--配置别名,注意顺序--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p>
<pre><code class="xml">&lt;typeAliases&gt;
   &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p>
<p>若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class User &#123;
  ...
&#125;
</code></pre>
<p>去官网查看一下Mybatis默认的一些类型别名！</p>
<h4 id="2-4-6、其他浏览设置"><a href="#2-4-6、其他浏览设置" class="headerlink" title="2.4.6、其他浏览设置"></a>2.4.6、其他浏览设置</h4><ul>
<li><p>设置（settings）相关 =&gt; 查看帮助文档</p>
<ul>
<li>懒加载</li>
</ul>
<ul>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li><p>一个配置完整的 settings 元素的示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;!--该配置影响的所有映射器中配置的缓存的全局开关--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态--&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--是否允许单一语句返回多结果集（需要兼容驱动）。--&gt;
    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。--&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。--&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。--&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
   
    &lt;!----&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    
    &lt;!--配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。--&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
   
    &lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。--&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
   
    &lt;!--Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.--&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    
    &lt;!--允许在嵌套语句中使用分页（RowBounds）。--&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
   
    &lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。--&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。--&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    
    &lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。--&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    
    &lt;!--指定哪个对象的方法触发一次延迟加载。--&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;

    &lt;!--指定动态 SQL 生成的默认语言。--&gt;
    &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver&quot;/&gt;

    &lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。--&gt;
    &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;

    &lt;!--定 MyBatis 增加到日志名称的前缀。--&gt;
    &lt;setting name=&quot;logPrefix&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 MyBatis 所用日志的具体实现，未指定时将自动查找。--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。--&gt;
    &lt;setting name=&quot;proxyFactory&quot; value=&quot;JAVASSIST&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
</ul>
<p><strong>类型处理器</strong></p>
<ul>
<li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li>
<li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li>
</ul>
<p><strong>对象工厂</strong></p>
<ul>
<li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li>
<li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li>
<li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li>
</ul>
<h4 id="2-4-7、生命周期和作用域"><a href="#2-4-7、生命周期和作用域" class="headerlink" title="2.4.7、生命周期和作用域"></a>2.4.7、生命周期和作用域</h4><p>​        理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>作用域理解</strong></p>
<ul>
<li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li>
<li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li>
<li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li>
<li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li>
<li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li>
<li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、ResultMap以及分页"><a href="#三、ResultMap以及分页" class="headerlink" title="三、ResultMap以及分页"></a>三、ResultMap以及分页</h2><h3 id="3-1、查询为null"><a href="#3-1、查询为null" class="headerlink" title="3.1、查询为null"></a>3.1、查询为null</h3><h4 id="3-1-1、属性名和字段名不一致问题"><a href="#3-1-1、属性名和字段名不一致问题" class="headerlink" title="3.1.1、属性名和字段名不一致问题"></a>3.1.1、属性名和字段名不一致问题</h4><p>环境：新建一个项目，将之前的项目拷贝过来</p>
<p>1、查看之前的数据库的字段名</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KdXPq6whFkfHe43CtgZMJrr62lCnbfxl25aQ4ZDwlU4JiaMZHs3nqAoNxFsJYZRC4Cm11uSH0USNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、Java中的实体类设计</p>
<pre><code class="java">@Data
public class User &#123;

   private int id;  //id
   private String name;   //姓名
   private String password;   //密码和数据库不一样！
   
&#125;
</code></pre>
<p>3、接口</p>
<pre><code class="java">//根据id查询用户
User selectUserById(int id);
</code></pre>
<p>4、mapper映射文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   System.out.println(user);
   session.close();
&#125;
</code></pre>
<p><strong>结果:</strong></p>
<ul>
<li>User{id=1, name=’狂神’, password=’null’}</li>
<li>查询出来发现 password 为空 . 说明出现了问题！</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li><p>select * from user where id = #{id} 可以看做</p>
<p>select  id,name,pwd  from user where id = #{id}</p>
</li>
<li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p>
</li>
</ul>
<h4 id="3-1-2、解决方案"><a href="#3-1-2、解决方案" class="headerlink" title="3.1.2、解决方案"></a>3.1.2、解决方案</h4><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;
    select id , name , pwd as password 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>方案二：使用结果集映射——-&gt;ResultMap</strong> 【推荐】</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
    select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;

&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!-- id为主键 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="3-2、ResultMap"><a href="#3-2、ResultMap" class="headerlink" title="3.2、ResultMap"></a>3.2、ResultMap</h3><p><strong>自动映射</strong></p>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li>
<li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li>
<li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li>
</ul>
<p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;
    select id , name , pwd
    from user
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p>
<p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p>
<p><strong>手动映射</strong></p>
<p>1、返回值类型为resultMap</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
  select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>2、编写resultMap，实现手动映射！</p>
<pre><code class="xml">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
   &lt;!-- id为主键 --&gt;
   &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
   &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
   &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<p>​        数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p>
<h3 id="3-3、分页"><a href="#3-3、分页" class="headerlink" title="3.3、分页"></a>3.3、分页</h3><h4 id="3-3-1、日志工厂"><a href="#3-3-1、日志工厂" class="headerlink" title="3.3.1、日志工厂"></a>3.3.1、日志工厂</h4><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p>
<p>​        如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p>
<p>​        对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p>
<p>​        Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>​        具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p>
<p><strong>标准日志实现</strong></p>
<p>​        指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p>
<pre><code class="xml">&lt;settings&gt;
       &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>​        测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p>
<h4 id="3-3-2、Log4j简介："><a href="#3-3-2、Log4j简介：" class="headerlink" title="3.3.2、Log4j简介："></a>3.3.2、Log4j<strong>简介：</strong></h4><ul>
<li>Log4j是Apache的一个开源项目</li>
<li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p><strong>使用步骤：</strong></p>
<p>1、导入log4j的包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置文件编写</p>
<pre><code class="properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
<p>3、setting设置日志实现</p>
<pre><code class="xml">&lt;settings&gt;
   &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>4、在程序中使用Log4j进行输出！</p>
<pre><code class="java">//注意导包：org.apache.log4j.Logger
static Logger logger = Logger.getLogger(MyTest.class);

@Test
public void selectUser() &#123;
   logger.info(&quot;info：进入selectUser方法&quot;);
   logger.debug(&quot;debug：进入selectUser方法&quot;);
   logger.error(&quot;error: 进入selectUser方法&quot;);
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   List&lt;User&gt; users = mapper.selectUser();
   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<p>5、测试，看控制台输出！</p>
<ul>
<li>使用Log4j 输出日志</li>
<li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</li>
</ul>
<h4 id="3-3-3、limit实现分页"><a href="#3-3-3、limit实现分页" class="headerlink" title="3.3.3、limit实现分页"></a>3.3.3、limit实现分页</h4><p><strong>思考：为什么需要分页？</strong></p>
<p>​        在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p>
<p><strong>使用Limit实现分页</strong></p>
<pre><code class="sql">#语法
SELECT * FROM table LIMIT stratIndex，pageSize

SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  

#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   
SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  

#如果只给定一个参数，它表示返回最大的记录行数目：   
SELECT * FROM table LIMIT 5; //检索前 5 个记录行  

#换句话说，LIMIT n 等价于 LIMIT 0,n。 
</code></pre>
<p><strong>步骤：</strong></p>
<p>1、修改Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;
    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>
<p>2、Mapper接口，参数为map</p>
<pre><code class="java">//选择全部用户实现分页
List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);
</code></pre>
<p>3、在测试类中传入参数测试</p>
<ul>
<li>推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li>
</ul>
<pre><code class="java">//分页查询 , 两个参数startIndex , pageSize
@Test
public void testSelectUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   int currentPage = 1;  //第几页
   int pageSize = 2;  //每页显示几个
   Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();
   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);
   map.put(&quot;pageSize&quot;,pageSize);

   List&lt;User&gt; users = mapper.selectUser(map);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<blockquote>
<p>RowBounds分页</p>
</blockquote>
<p>​        我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p>
<p><strong>步骤：</strong></p>
<p>1、mapper接口</p>
<pre><code class="java">//选择全部用户RowBounds实现分页
List&lt;User&gt; getUserByRowBounds();
</code></pre>
<p>2、mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<p>在这里，我们需要使用RowBounds类</p>
<pre><code class="java">@Test
public void testUserByRowBounds() &#123;
   SqlSession session = MybatisUtils.getSession();

   int currentPage = 2;  //第几页
   int pageSize = 2;  //每页显示几个
   RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);

   //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]
   List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<h4 id="3-3-4、PageHelper"><a href="#3-3-4、PageHelper" class="headerlink" title="3.3.4、PageHelper"></a>3.3.4、PageHelper</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<h2 id="四、注解开发"><a href="#四、注解开发" class="headerlink" title="四、注解开发"></a>四、注解开发</h2><h3 id="4-1、面向接口编程"><a href="#4-1、面向接口编程" class="headerlink" title="4.1、面向接口编程"></a>4.1、面向接口编程</h3><ul>
<li><strong>根本原因 :  解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<h4 id="4-1-1、关于接口的理解"><a href="#4-1-1、关于接口的理解" class="headerlink" title="4.1.1、关于接口的理解"></a>4.1.1、关于接口的理解</h4><ul>
<li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p>
</li>
<li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p>
</li>
<li><p>接口应有两类：</p>
<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； </li>
</ul>
<ul>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li>
</ul>
</li>
<li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p>
</li>
</ul>
<h4 id="4-1-2、三个面向区别"><a href="#4-1-2、三个面向区别" class="headerlink" title="4.1.2、三个面向区别"></a>4.1.2、三个面向区别</h4><ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</li>
</ul>
<h3 id="4-2、利用注解开发"><a href="#4-2、利用注解开发" class="headerlink" title="4.2、利用注解开发"></a>4.2、利用注解开发</h3><ul>
<li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p>
</li>
<li><p>sql 类型主要分成 :</p>
<ul>
<li>@select () </li>
</ul>
<ul>
<li>@update ()</li>
<li>@Insert ()</li>
<li>@delete ()</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>利用注解开发就不需要mapper.xml映射文件了 .</p>
<p>1、我们在我们的接口中添加注解</p>
<pre><code class="java">//查询全部用户
@Select(&quot;select id,name,pwd password from user&quot;)
public List&lt;User&gt; getAllUser();
</code></pre>
<p>2、在mybatis的核心配置文件中注入</p>
<pre><code class="xml">&lt;!--使用class绑定接口--&gt;
&lt;mappers&gt;
   &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>3、我们去进行测试</p>
<pre><code class="java">@Test
public void testGetAllUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   //本质上利用了jvm的动态代理机制
   UserMapper mapper = session.getMapper(UserMapper.class);

   List&lt;User&gt; users = mapper.getAllUser();
   for (User user : users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<p>4、利用Debug查看本质</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNnMiahVkdvictXZkDDWHQCwob9rMlKtxnhiaQee5Kxa6K0BCbHH2ibRERibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、本质上利用了jvm的动态代理机制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNeukjWMleICg2Jsm8hTI63hvVLiarGmD7zT1CmgXlUXSUbmdhialeIjpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>6、Mybatis详细的执行流程</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="4-3、注解增删改"><a href="#4-3、注解增删改" class="headerlink" title="4.3、注解增删改"></a>4.3、注解增删改</h3><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。</p>
<pre><code class="java">//获取SqlSession连接
public static SqlSession getSession()&#123;
    return getSession(true); //事务自动提交
&#125;

public static SqlSession getSession(boolean flag)&#123;
    return sqlSessionFactory.openSession(flag);
&#125;
</code></pre>
<p>【注意】确保实体类和数据库字段对应</p>
<p><strong>查询：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id查询用户
@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
User selectUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.selectUserById(1);
   System.out.println(user);

   session.close();
&#125;
</code></pre>
<p><strong>新增：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//添加一个用户
@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)
int addUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;);
   mapper.addUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>修改：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//修改一个用户
@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)
int updateUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);
   mapper.updateUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>删除：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id删除用
@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
int deleteUser(@Param(&quot;id&quot;)int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   mapper.deleteUser(6);
   
   session.close();
&#125;
</code></pre>
<p>【注意点：增删改一定记得对事务的处理】</p>
<h3 id="4-4、关于-Param"><a href="#4-4、关于-Param" class="headerlink" title="4.4、关于@Param"></a>4.4、关于@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p>
<ul>
<li>在方法只接受一个参数的情况下，可以不使用@Param。</li>
<li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li>
<li>如果参数是 JavaBean ， 则不能使用@Param。</li>
<li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li>
</ul>
<h3 id="4-5、-与-的区别"><a href="#4-5、-与-的区别" class="headerlink" title="4.5、#与$的区别"></a>4.5、#与$的区别</h3><ul>
<li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (#&#123;name&#125;);
INSERT INTO user (name) VALUES (?);
</code></pre>
</li>
<li><p>${} 的作用是直接进行字符串替换</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);
INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);
</code></pre>
</li>
</ul>
<h2 id="五、一对多处理与多对一处理"><a href="#五、一对多处理与多对一处理" class="headerlink" title="五、一对多处理与多对一处理"></a>五、一对多处理与多对一处理</h2><h3 id="5-1、多对一处理"><a href="#5-1、多对一处理" class="headerlink" title="5.1、多对一处理"></a>5.1、多对一处理</h3><h4 id="5-1-1、数据库设计"><a href="#5-1-1、数据库设计" class="headerlink" title="5.1.1、数据库设计"></a>5.1.1、数据库设计</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LPbib5To6slfFhMArq5QvCjofjccx37cuQgKsWEHibax0bDiaicU6ojNfEzWrj3TibFsX3MJju4sAp5Pg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="sql">CREATE TABLE `teacher` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);

CREATE TABLE `student` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
`tid` INT(10) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `fktid` (`tid`),
CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
</code></pre>
<h4 id="5-1-2、搭建测试环境"><a href="#5-1-2、搭建测试环境" class="headerlink" title="5.1.2、搭建测试环境"></a>5.1.2、搭建测试环境</h4><p>1、IDEA安装Lombok插件</p>
<p>2、引入Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.16.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、在代码中增加注解</p>
<pre><code class="java">@Data //GET,SET,ToString，有参，无参构造
public class Teacher &#123;
   private int id;
   private String name;
&#125;
@Data
public class Student &#123;
   private int id;
   private String name;
   //多个学生可以是同一个老师，即多对一
   private Teacher teacher;
&#125;
</code></pre>
<p>4、编写实体类对应的Mapper接口 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="java">public interface StudentMapper &#123;
&#125;
public interface TeacherMapper &#123;
&#125;
</code></pre>
<p>5、编写Mapper接口对应的 mapper.xml配置文件 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

&lt;/mapper&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="5-1-3、按查询嵌套处理"><a href="#5-1-3、按查询嵌套处理" class="headerlink" title="5.1.3、按查询嵌套处理"></a>5.1.3、按查询嵌套处理</h4><p>1、给StudentMapper接口增加方法</p>
<pre><code class="java">//获取所有学生及对应老师的信息
public List&lt;Student&gt; getStudents();
</code></pre>
<p>2、编写对应的Mapper文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

   &lt;!--
   需求：获取所有学生及对应老师的信息
   思路：
       1. 获取所有学生的信息
       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息
       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？
           1. 做一个结果集映射：StudentTeacher
           2. StudentTeacher结果集的类型为 Student
           3. 学生中老师的属性为teacher，对应数据库中为tid。
              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多
           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询
   --&gt;
   &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
   &lt;/select&gt;
   &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
       &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
       &lt;association property=&quot;teacher&quot;  column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
   &lt;/resultMap&gt;
   &lt;!--
   这里传递过来的id，只有一个属性的时候，下面可以写任何值
   association中column多参数配置：
       column=&quot;&#123;key=value,key=value&#125;&quot;
       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
      select * from teacher where id = #&#123;id&#125;
   &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p>
<p>4、注意点说明：</p>
<pre><code class="xml">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
   &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
   &lt;association property=&quot;teacher&quot;  column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
这里传递过来的id，只有一个属性的时候，下面可以写任何值
association中column多参数配置：
   column=&quot;&#123;key=value,key=value&#125;&quot;
   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
--&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testGetStudents()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<h4 id="5-1-4、按结果嵌套处理"><a href="#5-1-4、按结果嵌套处理" class="headerlink" title="5.1.4、按结果嵌套处理"></a>5.1.4、按结果嵌套处理</h4><p>我们还可以按照结果进行嵌套处理；</p>
<p>1、接口方法编写</p>
<pre><code class="java">public List&lt;Student&gt; getStudents2();
</code></pre>
<p>2、编写对应的mapper文件</p>
<pre><code class="xml">&lt;!--
按查询结果嵌套处理
思路：
   1. 直接查询出结果，进行结果集的映射
--&gt;
&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;
  select s.id sid, s.name sname , t.name tname
  from student s,teacher t
  where s.tid = t.id
&lt;/select&gt;

&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
   &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
   &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
   &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;
   &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
       &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
   &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<p>3、去mybatis-config文件中注入【此处应该处理过了】</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetStudents2()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents2();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>按照查询进行嵌套处理就像SQL中的子查询</p>
<p>按照结果进行嵌套处理就像SQL中的联表查询</p>
<h3 id="5-2、一对多处理"><a href="#5-2、一对多处理" class="headerlink" title="5.2、一对多处理"></a>5.2、一对多处理</h3><h4 id="5-2-1、实体类编写"><a href="#5-2-1、实体类编写" class="headerlink" title="5.2.1、实体类编写"></a>5.2.1、实体类编写</h4><pre><code class="java">@Data
public class Student &#123;
   private int id;
   private String name;
   private int tid;
&#125;

@Data
public class Teacher &#123;
   private int id;
   private String name;
   //一个老师多个学生
   private List&lt;Student&gt; students;
&#125;
</code></pre>
<h4 id="5-2-2、按结果嵌套"><a href="#5-2-2、按结果嵌套" class="headerlink" title="5.2.2、按结果嵌套"></a>5.2.2、按结果嵌套</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">//获取指定老师，及老师下的所有学生
public Teacher getTeacher(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

   &lt;!--
   思路:
       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名
       2. 对查询出来的操作做结果集映射
           1. 集合的话，使用collection！
               JavaType和ofType都是用来指定对象类型的
               JavaType是用来指定pojo中属性的类型
               ofType指定的是映射到list集合属性中pojo的类型。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
      select s.id sid, s.name sname , t.name tname, t.id tid
      from student s,teacher t
      where s.tid = t.id and t.id=#&#123;id&#125;
   &lt;/select&gt;

   &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
       &lt;result  property=&quot;name&quot; column=&quot;tname&quot;/&gt;
       &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
           &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;
           &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;
           &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;
       &lt;/collection&gt;
   &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<pre><code class="xml">&lt;mappers&gt;
   &lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<h4 id="5-2-3、按查询嵌套处理"><a href="#5-2-3、按查询嵌套处理" class="headerlink" title="5.2.3、按查询嵌套处理"></a>5.2.3、按查询嵌套处理</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">public Teacher getTeacher2(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;
    select * from teacher where id = #&#123;id&#125;
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher2()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher2(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、关联-association</p>
<p>2、集合-collection</p>
<p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p>
<p>4、JavaType和ofType都是用来指定对象类型的</p>
<ul>
<li>JavaType是用来指定pojo中属性的类型</li>
<li>ofType指定的是映射到list集合属性中pojo的类型。</li>
</ul>
<p><strong>注意说明：</strong></p>
<p>1、保证SQL的可读性，尽量通俗易懂</p>
<p>2、根据实际要求，尽量编写性能更高的SQL语句</p>
<p>3、注意属性名和字段不一致的问题</p>
<p>4、注意一对多和多对一 中：字段和属性对应的问题</p>
<p>5、尽量使用Log4j，通过日志来查看自己的错误</p>
<h2 id="六、动态SQL"><a href="#六、动态SQL" class="headerlink" title="六、动态SQL"></a>六、动态SQL</h2><h3 id="6-1、动态SQL简介"><a href="#6-1、动态SQL简介" class="headerlink" title="6.1、动态SQL简介"></a>6.1、动态SQL简介</h3><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p>
<pre><code>官网描述：
MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。
虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。
动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

  -------------------------------
  - if
  - choose (when, otherwise)
  - trim (where, set)
  - foreach
  -------------------------------
</code></pre>
<p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p>
<p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p>
<h3 id="6-2、搭建环境"><a href="#6-2、搭建环境" class="headerlink" title="6.2、搭建环境"></a>6.2、搭建环境</h3><h4 id="6-2-1、数据库"><a href="#6-2-1、数据库" class="headerlink" title="6.2.1、数据库"></a>6.2.1、数据库</h4><pre><code class="sql">CREATE TABLE `blog` (
`id` varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,
`author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
`create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
`views` int(30) NOT NULL COMMENT &#39;浏览量&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<h4 id="6-2-2、创建Mybaits基础工程"><a href="#6-2-2、创建Mybaits基础工程" class="headerlink" title="6.2.2、创建Mybaits基础工程"></a>6.2.2、创建Mybaits基础工程</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JISvrLfLvE3e9Wv1kpFL9qzPPOq4EuoibKKLvGve4vEicLpXeEHfz1flqX3ribyzpbjDlOGzziapTsIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、IDutil工具类</p>
<pre><code class="java">public class IDUtil &#123;

   public static String genId()&#123;
       return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);
  &#125;

&#125;
</code></pre>
<p>3、实体类编写  【注意set方法作用】</p>
<pre><code class="java">import java.util.Date;

public class Blog &#123;

   private String id;
   private String title;
   private String author;
   private Date createTime;
   private int views;
   //set，get....
&#125;
</code></pre>
<p>4、编写Mapper接口及xml文件</p>
<pre><code class="java">public interface BlogMapper &#123;
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<p>5、mybatis核心配置文件，下划线驼峰自动转换</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
&lt;!--注册Mapper.xml--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>6、插入初始数据</p>
<p>编写接口</p>
<pre><code class="java">//新增一个博客
int addBlog(Blog blog);
</code></pre>
<p>sql配置文件</p>
<pre><code class="xml">&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;
  insert into blog (id, title, author, create_time, views)
  values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);
&lt;/insert&gt;
</code></pre>
<p>初始化博客方法</p>
<pre><code class="java">@Test
public void addInitBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   Blog blog = new Blog();
   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Mybatis如此简单&quot;);
   blog.setAuthor(&quot;狂神说&quot;);
   blog.setCreateTime(new Date());
   blog.setViews(9999);

   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Java如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Spring如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;微服务如此简单&quot;);
   mapper.addBlog(blog);

   session.close();
&#125;
</code></pre>
<p>初始化数据完毕！</p>
<h3 id="6-3、if语句"><a href="#6-3、if语句" class="headerlink" title="6.3、if语句"></a>6.3、if语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p>
<p>1、编写接口类</p>
<pre><code class="java">//需求1
List&lt;Blog&gt; queryBlogIf(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询
select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;
--&gt;
&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog where
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogIf()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！</p>
<h3 id="6-4、Where语句"><a href="#6-4、Where语句" class="headerlink" title="6.4、Where语句"></a>6.4、Where语句</h3><p>修改上面的SQL语句；</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;if test=&quot;title != null&quot;&gt;
          title = #&#123;title&#125;
       &lt;/if&gt;
       &lt;if test=&quot;author != null&quot;&gt;
          and author = #&#123;author&#125;
       &lt;/if&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p>
<h3 id="6-5、Set语句"><a href="#6-5、Set语句" class="headerlink" title="6.5、Set语句"></a>6.5、Set语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p>
<p>1、编写接口方法</p>
<pre><code class="java">int updateBlog(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;!--注意set是用的逗号隔开--&gt;
&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;
  update blog
     &lt;set&gt;
         &lt;if test=&quot;title != null&quot;&gt;
            title = #&#123;title&#125;,
         &lt;/if&gt;
         &lt;if test=&quot;author != null&quot;&gt;
            author = #&#123;author&#125;
         &lt;/if&gt;
     &lt;/set&gt;
  where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;动态SQL&quot;);
   map.put(&quot;author&quot;,&quot;秦疆&quot;);
   map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);

   mapper.updateBlog(map);


   session.close();
&#125;
</code></pre>
<h3 id="6-6、choose语句"><a href="#6-6、choose语句" class="headerlink" title="6.6、choose语句"></a>6.6、choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>1、编写接口方法</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogChoose(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;choose&gt;
           &lt;when test=&quot;title != null&quot;&gt;
                title = #&#123;title&#125;
           &lt;/when&gt;
           &lt;when test=&quot;author != null&quot;&gt;
              and author = #&#123;author&#125;
           &lt;/when&gt;
           &lt;otherwise&gt;
              and views = #&#123;views&#125;
           &lt;/otherwise&gt;
       &lt;/choose&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void testQueryBlogChoose()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   map.put(&quot;views&quot;,9999);
   List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<h3 id="6-7、SQL片段"><a href="#6-7、SQL片段" class="headerlink" title="6.7、SQL片段"></a>6.7、SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p>
<p><strong>提取SQL片段：</strong></p>
<pre><code class="xml">&lt;sql id=&quot;if-title-author&quot;&gt;
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<p><strong>引用SQL片段：</strong></p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;
       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>注意：</p>
<p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p>
<p>②、在 sql 片段中不要包括 where</p>
<h3 id="6-8、Foreach"><a href="#6-8、Foreach" class="headerlink" title="6.8、Foreach"></a>6.8、Foreach</h3><p>将数据库中前三个数据的id修改为1,2,3；</p>
<p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p>
<p>1、编写接口</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogForeach(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!--
       collection:指定输入对象中的集合属性
       item:每次遍历生成的对象
       open:开始遍历时的拼接字符串
       close:结束时拼接的字符串
       separator:遍历对象之间需要拼接的字符串
       select * from blog where 1=1 and (id=1 or id=2 or id=3)
     --&gt;
       &lt;foreach collection=&quot;ids&quot;  item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
          id=#&#123;id&#125;
       &lt;/foreach&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogForeach()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap map = new HashMap();
   List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
   ids.add(1);
   ids.add(2);
   ids.add(3);
   map.put(&quot;ids&quot;,ids);

   List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。</p>
<h2 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h2><h3 id="7-1、缓存简介"><a href="#7-1、缓存简介" class="headerlink" title="7.1、缓存简介"></a>7.1、缓存简介</h3><h4 id="7-1-1、缓存"><a href="#7-1-1、缓存" class="headerlink" title="7.1.1、缓存"></a>7.1.1、缓存</h4><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
<h4 id="7-1-2、Mybaits缓存"><a href="#7-1-2、Mybaits缓存" class="headerlink" title="7.1.2、Mybaits缓存"></a>7.1.2、Mybaits缓存</h4><ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p>
</li>
<li><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="7-2、一级缓存"><a href="#7-2、一级缓存" class="headerlink" title="7.2、一级缓存"></a>7.2、一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<h4 id="7-2-1、测试"><a href="#7-2-1、测试" class="headerlink" title="7.2.1、测试"></a>7.2.1、测试</h4><p>1、在mybatis中加入日志，方便测试结果</p>
<p>2、编写接口方法</p>
<pre><code class="java">//根据id查询用户
User queryUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>3、接口对应的Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
  select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>5、结果分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="7-2-2、一级缓存失效情况"><a href="#7-2-2、一级缓存失效情况" class="headerlink" title="7.2.2、一级缓存失效情况"></a>7.2.2、一级缓存失效情况</h4><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
   session2.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！</p>
<p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(2);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！很正常的理解</p>
<p>结论：<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<pre><code class="java">//修改用户
int updateUser(Map map);
</code></pre>
<p>编写SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;
  update user set name = #&#123;name&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   HashMap map = new HashMap();
   map.put(&quot;name&quot;,&quot;kuangshen&quot;);
   map.put(&quot;id&quot;,4);
   mapper.updateUser(map);

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：查询在中间执行了增删改操作后，重新执行了</p>
<p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   session.clearCache();//手动清除缓存

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>一级缓存就是一个map</p>
<h3 id="7-3、二级缓存"><a href="#7-3、二级缓存" class="headerlink" title="7.3、二级缓存"></a>7.3、二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、开启全局缓存 【mybatis-config.xml】</p>
<pre><code class="xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<pre><code class="xml">&lt;cache/&gt;

官方示例=====&gt;查看官方文档
&lt;cache
 eviction=&quot;FIFO&quot;
 flushInterval=&quot;60000&quot;
 size=&quot;512&quot;
 readOnly=&quot;true&quot;/&gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
</code></pre>
<p>3、代码测试</p>
<ul>
<li>所有的实体类先实现序列化接口</li>
<li>测试代码</li>
</ul>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();

   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   session.close();

   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session2.close();
&#125;
</code></pre>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<h3 id="7-4、缓存原理图"><a href="#7-4、缓存原理图" class="headerlink" title="7.4、缓存原理图"></a>7.4、缓存原理图</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-5、EhCache"><a href="#7-5、EhCache" class="headerlink" title="7.5、EhCache"></a>7.5、EhCache</h3><p>第三方缓存实现–EhCache: 查看百度百科</p>
<p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p>
<p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
   &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在mapper.xml中使用对应的缓存即可</p>
<pre><code class="xml">&lt;mapper namespace = “org.acme.FooMapper” &gt;
   &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;
&lt;/mapper&gt;
</code></pre>
<p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&gt;
   &lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      user.home – 用户主目录
      user.dir – 用户当前工作目录
      java.io.tmpdir – 默认临时文件路径
    --&gt;
   &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
   
   &lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

   &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
   &lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
   &lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&gt;

&lt;/ehcache&gt;
</code></pre>
<p>合理的使用缓存，可以让我们程序的性能大大提升！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#ffa2c4>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/">
        <h2>
            Spring使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring使用详解"><a href="#Spring使用详解" class="headerlink" title="Spring使用详解"></a>Spring使用详解</h1><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><h3 id="1-1、Spring组成"><a href="#1-1、Spring组成" class="headerlink" title="1.1、Spring组成"></a>1.1、Spring组成</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF6KnNia5YDhfatibrMvAUAhxgF27g4HdJsBGl6Fae9yQlUQJc9Bf8uftw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFetRkkw19r7H3mHDibgs4RpRNHdG6CcIMdnxRCu2yYXNiano7ESCCMF0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <strong>BeanFactory</strong>，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式<strong>将应用程序的配置和依赖性规范与实际的应用程序代码分开</strong>。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架<strong>提供上下文信息</strong>。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象<strong>提供事务管理服务</strong>。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来<strong>管理异常处理和不同数据库供应商抛出的错误消息</strong>。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h3 id="1-2、拓展"><a href="#1-2、拓展" class="headerlink" title="1.2、拓展"></a>1.2、拓展</h3><p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li>
<li>Spring Cloud是基于Spring Boot实现的；</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
<li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFH5GFXM4YPUGrmA2JdpPic3FwYaI1JZHBZxibaUJVXWzzTFeCayk4XAIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="二、IOC讲解"><a href="#二、IOC讲解" class="headerlink" title="二、IOC讲解"></a>二、IOC讲解</h2><h3 id="2-1、IOC基础"><a href="#2-1、IOC基础" class="headerlink" title="2.1、IOC基础"></a>2.1、IOC基础</h3><p>新建一个空白的maven项目</p>
<blockquote>
<p>分析实现</p>
</blockquote>
<p>我们先用我们原来的方式写一段代码。</p>
<p>1、UserDao接口</p>
<pre><code class="java">public interface UserDao &#123;
    public void getUser();
&#125;
</code></pre>
<p>2、Dao的实现类</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>3、UserService接口</p>
<pre><code class="java">public interface UserService &#123;
    public void getUser();
&#125;
</code></pre>
<p>4、Service实现类</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>5、测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
    UserService service = new UserServiceImpl();
    service.getUser();
&#125;
</code></pre>
<blockquote>
<p>=========================接下来做一下修改=================================</p>
</blockquote>
<p>增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoMySqlImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;MySql获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoMySqlImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>假设再增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoOracleImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;Oracle获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>​        那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现。假设我们的这种需求非常大 , 这种方式就根本不适用。这种设计的耦合性太高了, 牵一发而动全身。</p>
<p><strong>那我们如何去解决呢 ?</strong> </p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    
    // 利用set实现
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
&#125;
</code></pre>
<p>​        这两者有着本质区别：以前的思路都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者。程序不用去管怎么创建,怎么实现了。 它只负责提供一个接口。</p>
<p>​        这种思想 , 从本质上解决了问题 , 程序员不再去管理对象的创建 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="2-2、IOC本质"><a href="#2-2、IOC本质" class="headerlink" title="2.2、IOC本质"></a>2.2、IOC本质</h3><p>​        <strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFuYibmavlBHq9e4cDqiclpYSG8VT4EicVsnqKp65yJKQeNibsVdTiahQibJSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        <strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>​        <u>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</u></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p>​        <strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="三、HelloSpring"><a href="#三、HelloSpring" class="headerlink" title="三、HelloSpring"></a>三、HelloSpring</h2><h3 id="3-1、helloSpring的创建"><a href="#3-1、helloSpring的创建" class="headerlink" title="3.1、helloSpring的创建"></a>3.1、helloSpring的创建</h3><blockquote>
<p>导入jar包依赖</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 但是利用maven会自动下载对应的依赖项。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="java">@Data
public class Hello &#123;
   private String name;

   public void show()&#123;
       System.out.println(&quot;Hello,&quot;+ name );
  &#125;
&#125;
</code></pre>
<p>2、编写spring的文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>其中，bean标签各个参数解释如下：</p>
<ul>
<li><strong>id：</strong>JavaBean在BeanFactory中唯一标识，代码中通过BeanFactory获取JavaBean实例时需要此参数作为索引名称</li>
<li>name：可以为Bean指定多个名称（起别名）</li>
<li><strong>class：</strong>JavaBean 类名</li>
<li><strong>scope：</strong>设定Bean的作用域<ul>
<li><strong>singleton</strong>：指定此Java Bean是否使用单例模式，如果设为“True”，则在BeanFactory作用范围内只维护此Java Bean的一个实例，代码通BeanFactory获取此javaBean实例的引用;反这如果设为“False”，则通过BeanFactory获取javaBean实例时，BeanFactory每次都将创建一个新的实例返回。</li>
<li><strong>Prototype：</strong>原型：表示通过IoC容器获取的Bean是不同的</li>
<li><strong>request：</strong>请求：表示在一次HTTP请求内有效</li>
<li><strong>session：</strong>会话：表示在一个用户会话内有效</li>
</ul>
</li>
<li><strong>init-method：</strong>初始化方法，此方法将在BeanFactory创建JavaBean实例之后，在向应用层返回引用之前执行。一般用于一些资源的初始化工作。</li>
<li>销毁方法：此方法将在BeanFactory销毁的时候执行，一般用于资源释放。</li>
<li><strong>depends-on：</strong>Bean依赖关系。一般情况下无需设定。Spring会根据情况组织各个依赖关系的构建工作（这里<br>示例中的depends-on属性非必须）。只有某些特殊情况下，如JavaBean中的某些静态变量需要进行初始化（这是一种Bad Smell，应该在设计上应该避免）。通过depends-on指定其依赖关系可保证在此Bean加载之前，首先对depends-on所指定的资源进行加载。</li>
<li><strong>value：</strong>通过<value/>节点可指定属性值。BeanFactory将自动根据Java Bean对应的属性类型加以匹配。注意<value></value>代表一个空字符串，如果需要将属性值设定为null，必须使用<null/>节点。</li>
<li><strong>ref：</strong>指定了属性对BeanFactory中其他Bean的引用关系。</li>
<li><strong>property：</strong>Bean的子元素，用来指定需要赋值的属性</li>
<li><strong>constructor-arg：</strong>用于有参构造的注入<ul>
<li>index：指定下标</li>
<li>value：赋值</li>
<li>type：参数类型</li>
<li>ref：将注入别的Bean</li>
</ul>
</li>
<li><strong>import：</strong>用于导入别的XML文件</li>
</ul>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   // 解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   // getBean : 参数即为spring配置文件中bean的id .
   Hello hello = (Hello) context.getBean(&quot;hello&quot;);
   // 调用对象hello的show方法
   hello.show();
&#125;
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  <ul>
<li>hello 对象是由Spring创建的</li>
</ul>
</li>
<li>Hello 对象的属性是怎么设置的 ?  <ul>
<li>hello 对象的属性是由Spring容器设置的</li>
</ul>
</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p><strong>依赖注入 :</strong> 就是利用set方法来进行注入的.</p>
<p>​         IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>​        可以通过newClassPathXmlApplicationContext去浏览一下底层源码 。</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>新增一个Spring配置文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
&#125;
</code></pre>
<p>​        OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p>
<h3 id="3-2、IOC创建对象方式"><a href="#3-2、IOC创建对象方式" class="headerlink" title="3.2、IOC创建对象方式"></a>3.2、IOC创建对象方式</h3><h4 id="3-2-1、通过无参构造方法创建"><a href="#3-2-1、通过无参构造方法创建" class="headerlink" title="3.2.1、通过无参构造方法创建"></a>3.2.1、通过无参构造方法创建</h4><p>1、User.java</p>
<pre><code class="java">public class User &#123;

    private String name;

    public User() &#123;
        System.out.println(&quot;user无参构造方法&quot;);
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
&#125;
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h4 id="3-2-2、通过有参构造方法创建"><a href="#3-2-2、通过有参构造方法创建" class="headerlink" title="3.2.2、通过有参构造方法创建"></a>3.2.2、通过有参构造方法创建</h4><p>1、UserT . java</p>
<pre><code class="java">public class UserT &#123;

    private String name;

    public UserT(String name) &#123;
        this.name = name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- index指构造方法 , 下标从0开始 --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- name指参数名 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testT()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    UserT user = (UserT) context.getBean(&quot;userT&quot;);
    user.show();
&#125;
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h3 id="3-3、Spring配置"><a href="#3-3、Spring配置" class="headerlink" title="3.3、Spring配置"></a>3.3、Spring配置</h3><h4 id="3-3-1、别名"><a href="#3-3-1、别名" class="headerlink" title="3.3.1、别名"></a>3.3.1、别名</h4><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h4 id="3-3-2、Bean的配置"><a href="#3-3-2、Bean的配置" class="headerlink" title="3.3.2、Bean的配置"></a>3.3.2、Bean的配置</h4><pre><code class="xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3-3-3、import"><a href="#3-3-3、import" class="headerlink" title="3.3.3、import"></a>3.3.3、import</h4><p>团队的合作通过import来实现 .</p>
<pre><code class="xml">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;
</code></pre>
<h2 id="四、依赖注入（DI）"><a href="#四、依赖注入（DI）" class="headerlink" title="四、依赖注入（DI）"></a>四、依赖注入（DI）</h2><h3 id="4-1、依赖注入"><a href="#4-1、依赖注入" class="headerlink" title="4.1、依赖注入"></a>4.1、依赖注入</h3><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p><strong>Address.java</strong></p>
<pre><code class="java"> public class Address &#123;
 
     private String address;
 
     public String getAddress() &#123;
         return address;
    &#125;
 
     public void setAddress(String address) &#123;
         this.address = address;
    &#125;
 &#125;
</code></pre>
<p><strong>Student.java</strong></p>
<pre><code class="java">@Data
public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbys;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name
                           + &quot;,address=&quot;+ address.getAddress()
                           + &quot;,books=&quot;
                          );
        for (String book:books)&#123;
            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);
        &#125;
        System.out.println(&quot;\n爱好:&quot;+hobbys);

        System.out.println(&quot;card:&quot;+card);

        System.out.println(&quot;games:&quot;+games);

        System.out.println(&quot;wife:&quot;+wife);

        System.out.println(&quot;info:&quot;+info);

    &#125;
&#125;
</code></pre>
<h4 id="4-1-1、常量注入"><a href="#4-1-1、常量注入" class="headerlink" title="4.1.1、常量注入"></a>4.1.1、常量注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test01()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    Student student = (Student) context.getBean(&quot;student&quot;);

    System.out.println(student.getName());

&#125;
</code></pre>
<h4 id="4-1-2、Bean注入"><a href="#4-1-2、Bean注入" class="headerlink" title="4.1.2、Bean注入"></a>4.1.2、Bean注入</h4><p>注意点：这里的值是一个引用，ref</p>
<pre><code class="xml">&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-3、数组注入"><a href="#4-1-3、数组注入" class="headerlink" title="4.1.3、数组注入"></a>4.1.3、数组注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;西游记&lt;/value&gt;
            &lt;value&gt;红楼梦&lt;/value&gt;
            &lt;value&gt;水浒传&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-4、List注入"><a href="#4-1-4、List注入" class="headerlink" title="4.1.4、List注入"></a>4.1.4、List注入</h4><pre><code class="xml">&lt;property name=&quot;hobbys&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;听歌&lt;/value&gt;
        &lt;value&gt;看电影&lt;/value&gt;
        &lt;value&gt;爬山&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-5、Map注入"><a href="#4-1-5、Map注入" class="headerlink" title="4.1.5、Map注入"></a>4.1.5、Map注入</h4><pre><code class="xml">&lt;property name=&quot;card&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt;
        &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-6、set注入"><a href="#4-1-6、set注入" class="headerlink" title="4.1.6、set注入"></a>4.1.6、set注入</h4><pre><code class="xml">&lt;property name=&quot;games&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;LOL&lt;/value&gt;
        &lt;value&gt;BOB&lt;/value&gt;
        &lt;value&gt;COC&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-7、Null注入"><a href="#4-1-7、Null注入" class="headerlink" title="4.1.7、Null注入"></a>4.1.7、Null注入</h4><pre><code class="xml">&lt;property name=&quot;wife&quot;&gt;
    &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-9、Properties注入"><a href="#4-1-9、Properties注入" class="headerlink" title="4.1.9、Properties注入"></a>4.1.9、Properties注入</h4><pre><code class="xml">&lt;property name=&quot;info&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;
        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
<p>测试结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYGHEFnrCA8Jyr6ian5MWrUHtnKBpYYTTtysbp5UPYKQxSiaUHJibPKlicuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-1-10、p命名和c命名注入"><a href="#4-1-10、p命名和c命名注入" class="headerlink" title="4.1.10、p命名和c命名注入"></a>4.1.10、p命名和c命名注入</h4><p>User.java ：【注意：这里没有有参构造器！】</p>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>1、<strong>P命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;
</code></pre>
<p>2、<strong>c 命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;

&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;
</code></pre>
<p>​        发现问题：显示错误，代码标红</p>
<p>​        解决：把有参构造器加上，这里也能知道，c 就是所谓的<strong>构造器注入</strong>！</p>
<p>测试代码：</p>
<pre><code class="java">@Test
public void test02()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    System.out.println(user);
&#125;
</code></pre>
<h3 id="4-2、Bean的作用域"><a href="#4-2、Bean的作用域" class="headerlink" title="4.2、Bean的作用域"></a>4.2、Bean的作用域</h3><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYfmmAQF8hrnicY49FRXEkR5xkxD5A4H5pVUia3mFhrDdh4gBt183EiaFaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="4-2-1、Singleton"><a href="#4-2-1、Singleton" class="headerlink" title="4.2.1、Singleton"></a>4.2.1、Singleton</h4><p>​        <strong>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</strong>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test03()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    User user2 = (User) context.getBean(&quot;user&quot;);
    System.out.println(user==user2);
&#125;
</code></pre>
<h4 id="4-2-2、Prototype"><a href="#4-2-2、Prototype" class="headerlink" title="4.2.2、Prototype"></a>4.2.2、Prototype</h4><p>​        <strong>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。</strong>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml"> &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
 或者
 &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;
</code></pre>
<h4 id="4-2-3、Request"><a href="#4-2-3、Request" class="headerlink" title="4.2.3、Request"></a>4.2.3、Request</h4><p>​        <strong>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例</strong>；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>​        针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="4-2-4、Session"><a href="#4-2-4、Session" class="headerlink" title="4.2.4、Session"></a>4.2.4、Session</h4><p>​        <strong>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。</strong>该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>​        针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<h2 id="五、自动装配"><a href="#五、自动装配" class="headerlink" title="五、自动装配"></a>五、自动装配</h2><h3 id="5-1、自动装配"><a href="#5-1、自动装配" class="headerlink" title="5.1、自动装配"></a>5.1、自动装配</h3><blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ul>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ul>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ul>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ul>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h4 id="5-1-1、测试环境搭建"><a href="#5-1-1、测试环境搭建" class="headerlink" title="5.1.1、测试环境搭建"></a>5.1.1、测试环境搭建</h4><p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="java">public class Cat &#123;
   public void shout() &#123;
       System.out.println(&quot;miao~&quot;);
  &#125;
&#125;
    
public class Dog &#123;
   public void shout() &#123;
       System.out.println(&quot;wang~&quot;);
  &#125;
&#125;
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="java">public class User &#123;
   private Cat cat;
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void testMethodAutowire() &#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  &#125;
&#125;
</code></pre>
<p>结果正常输出。</p>
<h4 id="5-1-2、byName"><a href="#5-1-2、byName" class="headerlink" title="5.1.2、byName"></a>5.1.2、byName</h4><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=”byName”</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<h4 id="5-1-3、byType"><a href="#5-1-3、byType" class="headerlink" title="5.1.3、byType"></a>5.1.3、byType</h4><p>​        <strong>autowire byType (按类型自动装配)</strong></p>
<p>​        使用autowire byType首先需要保证：<strong>同一类型的对象，在spring容器中唯一</strong>。如果不唯一，会报不唯一的异常。</p>
<pre><code class="xml">NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="5-2、使用注解"><a href="#5-2、使用注解" class="headerlink" title="5.2、使用注解"></a>5.2、使用注解</h3><blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;
</code></pre>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="java">public class User &#123;
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String str;

   public Cat getCat() &#123;
       return cat;
  &#125;
   public Dog getDog() &#123;
       return dog;
  &#125;
   public String getStr() &#123;
       return str;
  &#125;
&#125;
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【小狂神科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code class="java">//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;

@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p><strong>实体类</strong>：</p>
<pre><code class="java">public class User &#123;
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="java">@Resource
private Cat cat;

@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<p><strong>小结</strong></p>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="六、使用注解开发"><a href="#六、使用注解开发" class="headerlink" title="六、使用注解开发"></a>六、使用注解开发</h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h3><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IzypAUHDfDEujP4ry6cHxWTvAS6qRS0qrmMCic3QqF9icGNcPj8IZwNo3R9VEgpAgWHrStBN1ya6Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="6-2、Bean的实现"><a href="#6-2、Bean的实现" class="headerlink" title="6.2、Bean的实现"></a>6.2、Bean的实现</h3><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   public String name = &quot;秦疆&quot;;
&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext applicationContext =
       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   User user = (User) applicationContext.getBean(&quot;user&quot;);
   System.out.println(user.name);
&#125;
</code></pre>
<h3 id="6-3、属性注入"><a href="#6-3、属性注入" class="headerlink" title="6.3、属性注入"></a>6.3、属性注入</h3><p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   @Value(&quot;秦疆&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   public String name;
&#125;
</code></pre>
<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<pre><code class="java">@Component(&quot;user&quot;)
public class User &#123;

   public String name;

   @Value(&quot;秦疆&quot;)
   public void setName(String name) &#123;
       this.name = name;
  &#125;
&#125;
</code></pre>
<h3 id="6-4、衍生注解"><a href="#6-4、衍生注解" class="headerlink" title="6.4、衍生注解"></a>6.4、衍生注解</h3><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User &#123;
   @Value(&quot;秦疆&quot;)
   public String name;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code>&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li><p>进行注解驱动注册，从而使注解生效</p>
</li>
<li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li><p>如果不扫描包，就需要手动配置bean</p>
</li>
<li><p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<h3 id="6-5、基于Java类进行配置"><a href="#6-5、基于Java类进行配置" class="headerlink" title="6.5、基于Java类进行配置"></a>6.5、基于Java类进行配置</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog &#123;
   public String name = &quot;dog&quot;;
&#125;
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig &#123;

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
&#125;
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig2 &#123;
&#125;
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="java">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig &#123;

   @Bean
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
<h2 id="七、静态-动态代理模式"><a href="#七、静态-动态代理模式" class="headerlink" title="七、静态/动态代理模式"></a>七、静态/动态代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p>
<p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>学习aop之前 , 我们要先了解一下代理模式！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLRnfS7LpO0Iic7fEEPFCgRs0ggNXCwf6IKo1tibjPmNSTEYeII5ro7YLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-1、静态代理"><a href="#7-1、静态代理" class="headerlink" title="7.1、静态代理"></a>7.1、静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li><p>抽象角色 : 一般使用接口或者抽象类来实现</p>
</li>
<li><p>真实角色 : 被代理的角色</p>
</li>
<li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p>
</li>
<li><p>客户  :  使用代理角色来进行一些操作 </p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>Proxy . java 即代理角色</p>
<pre><code class="java">//代理角色：中介
public class Proxy implements Rent &#123;

   private Host host;
   public Proxy() &#123; &#125;
   public Proxy(Host host) &#123;
       this.host = host;
  &#125;

   //租房
   public void rent()&#123;
       seeHouse();
       host.rent();
       fare();
  &#125;
   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;
&#125;
</code></pre>
<p>Client . java 即客户</p>
<pre><code class="java">//客户类，一般客户都会去找代理！
public class Client &#123;
   public static void main(String[] args) &#123;
       //房东要租房
       Host host = new Host();
       //中介帮助房东
       Proxy proxy = new Proxy(host);

       //你去找中介！
       proxy.rent();
  &#125;
&#125;
</code></pre>
<p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="7-2、静态代理再理解"><a href="#7-2、静态代理再理解" class="headerlink" title="7.2、静态代理再理解"></a>7.2、静态代理再理解</h3><p>练习步骤：</p>
<p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p>
<pre><code class="java">//抽象角色：增删改查业务
public interface UserService &#123;
   void add();
   void delete();
   void update();
   void query();
&#125;
</code></pre>
<p>2、我们需要一个真实对象来完成这些增删改查操作</p>
<pre><code class="java">//真实对象，完成增删改查操作的人
public class UserServiceImpl implements UserService &#123;

   public void add() &#123;
       System.out.println(&quot;增加了一个用户&quot;);
  &#125;

   public void delete() &#123;
       System.out.println(&quot;删除了一个用户&quot;);
  &#125;

   public void update() &#123;
       System.out.println(&quot;更新了一个用户&quot;);
  &#125;

   public void query() &#123;
       System.out.println(&quot;查询了一个用户&quot;);
  &#125;
&#125;
</code></pre>
<p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
<p>4、设置一个代理类来处理日志！代理角色</p>
<pre><code class="java">//代理角色，在这里面增加日志的实现
public class UserServiceProxy implements UserService &#123;
   private UserServiceImpl userService;

   public void setUserService(UserServiceImpl userService) &#123;
       this.userService = userService;
  &#125;

   public void add() &#123;
       log(&quot;add&quot;);
       userService.add();
  &#125;

   public void delete() &#123;
       log(&quot;delete&quot;);
       userService.delete();
  &#125;

   public void update() &#123;
       log(&quot;update&quot;);
       userService.update();
  &#125;

   public void query() &#123;
       log(&quot;query&quot;);
       userService.query();
  &#125;

   public void log(String msg)&#123;
       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>5、测试访问类：</p>
<pre><code class="java">public class Client &#123;
   public static void main(String[] args) &#123;
       //真实业务
       UserServiceImpl userService = new UserServiceImpl();
       //代理类
       UserServiceProxy proxy = new UserServiceProxy();
       //使用代理类实现日志功能！
       proxy.setUserService(userService);

       proxy.add();
  &#125;
&#125;
</code></pre>
<p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLJqcgicA5aEKtxYibgLPicNfDwicKIn9NlFl86rriaVRicKnEXlPNiacbHiaLibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、动态代理"><a href="#7-3、动态代理" class="headerlink" title="7.3、动态代理"></a>7.3、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLxvyvZMwn9gIEibuxjFwE3enJ4TgKO5PXxM5BPr6Bh7GQwExLvst4AsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>Object invoke(Object proxy, 方法 method, Object[] args)；
//参数
//proxy - 调用该方法的代理实例
//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。
</code></pre>
<p>【Proxy  : 代理】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="java">//生成代理类
public Object getProxy()&#123;
   return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                 rent.getClass().getInterfaces(),this);
&#125;
</code></pre>
<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>ProxyInvocationHandler. java 即代理角色</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Rent rent;

   public void setRent(Rent rent) &#123;
       this.rent = rent;
  &#125;

   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               rent.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.
   // 处理代理实例上的方法调用并返回结果
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       seeHouse();
       //核心：本质利用反射实现！
       Object result = method.invoke(rent, args);
       fare();
       return result;
  &#125;

   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;

&#125;
</code></pre>
<p>Client . java</p>
<pre><code class="java">//租客
public class Client &#123;

   public static void main(String[] args) &#123;
       //真实角色
       Host host = new Host();
       //代理实例的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setRent(host); //将真实角色放置进去！
       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！
       proxy.rent();
  &#125;

&#125;
</code></pre>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h3 id="7-4、深入理解"><a href="#7-4、深入理解" class="headerlink" title="7.4、深入理解"></a>7.4、深入理解</h3><p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Object target;

   public void setTarget(Object target) &#123;
       this.target = target;
  &#125;

   //生成代理类
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  &#125;

   public void log(String methodName)&#123;
       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>测试！</p>
<pre><code class="java">public class Test &#123;
   public static void main(String[] args) &#123;
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setTarget(userService); //设置要代理的对象
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       proxy.delete();
  &#125;
&#125;
</code></pre>
<p>测试，增删改查，查看结果！</p>
<blockquote>
<h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h2 id="八、AOP"><a href="#八、AOP" class="headerlink" title="八、AOP"></a>八、AOP</h2><h3 id="8-1、AOP简介"><a href="#8-1、AOP简介" class="headerlink" title="8.1、AOP简介"></a>8.1、AOP简介</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。<ul>
<li>前置通知：在某连接点之前执行的通知，这个通知不能组织连接点之前的执行流程</li>
<li>后置通知：在某连接点正常完成后执行的通知</li>
<li>异常通知：在方法抛出异常退出时执行的通知</li>
<li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li>
<li>环绕通知：保卫一个连接点的通知，如方法调用</li>
</ul>
</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="8-2、使用AOP"><a href="#8-2、使用AOP" class="headerlink" title="8.2、使用AOP"></a>8.2、使用AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="8-2-1、通过-Spring-API-实现"><a href="#8-2-1、通过-Spring-API-实现" class="headerlink" title="8.2.1、通过 Spring API 实现"></a>8.2.1、通过 Spring API 实现</h4><p>首先编写我们的业务接口和实现类</p>
<pre><code class="java">public interface UserService &#123;

   public void add();

   public void delete();

   public void update();

   public void search();

&#125;

public class UserServiceImpl implements UserService&#123;

   @Override
   public void add() &#123;
       System.out.println(&quot;增加用户&quot;);
  &#125;

   @Override
   public void delete() &#123;
       System.out.println(&quot;删除用户&quot;);
  &#125;

   @Override
   public void update() &#123;
       System.out.println(&quot;更新用户&quot;);
  &#125;

   @Override
   public void search() &#123;
       System.out.println(&quot;查询用户&quot;);
  &#125;
&#125;
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="java">public class Log implements MethodBeforeAdvice &#123;

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;
       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  &#125;
&#125;
public class AfterLog implements AfterReturningAdvice &#123;
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  &#125;
&#125;
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  &#125;
&#125;
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<h4 id="8-2-2、自定义类来实现Aop"><a href="#8-2-2、自定义类来实现Aop" class="headerlink" title="8.2.2、自定义类来实现Aop"></a>8.2.2、自定义类来实现Aop</h4><p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="java">public class DiyPointcut &#123;

   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;
   
&#125;
</code></pre>
<p>去spring中配置</p>
<pre><code class="xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  &#125;
&#125;
</code></pre>
<h4 id="8-2-3、使用注解实现"><a href="#8-2-3、使用注解实现" class="headerlink" title="8.2.3、使用注解实现"></a>8.2.3、使用注解实现</h4><p>第一步：编写一个注解实现的增强类</p>
<pre><code class="java">package com.kuang.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class AnnotationPointcut &#123;
   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;

   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;

   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable &#123;
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  &#125;
&#125;
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
<h2 id="九、声明式事务"><a href="#九、声明式事务" class="headerlink" title="九、声明式事务"></a>九、声明式事务</h2><h3 id="9-1、Spring的事务管理"><a href="#9-1、Spring的事务管理" class="headerlink" title="9.1、Spring的事务管理"></a>9.1、Spring的事务管理</h3><p>​        Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li><p>优点：将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p>
</li>
<li><p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li><p>一般情况下比编程式事务好用。</p>
</li>
<li><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p>
</li>
<li><p>将事务管理作为横切关注点，通过aop方法模块化。</p>
</li>
</ul>
<h3 id="9-2、通过Spring-AOP框架支持声明式事务管理"><a href="#9-2、通过Spring-AOP框架支持声明式事务管理" class="headerlink" title="9.2、通过Spring AOP框架支持声明式事务管理"></a>9.2、通过Spring AOP框架支持声明式事务管理</h3><p>​        使用Spring管理事务，注意<strong>头文件的约束导入 : tx</strong></p>
<pre><code class="xml">&lt;beans xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<h4 id="9-2-1、spring事务传播特性："><a href="#9-2-1、spring事务传播特性：" class="headerlink" title="9.2.1、spring事务传播特性："></a>9.2.1、spring事务传播特性：</h4><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<h4 id="9-2-2、配置AOP"><a href="#9-2-2、配置AOP" class="headerlink" title="9.2.2、配置AOP"></a>9.2.2、配置AOP</h4><p>导入aop的头文件！</p>
<pre><code class="xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/">
        <h2>
            Spring设计模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><h2 id="一、解释器设计模式"><a href="#一、解释器设计模式" class="headerlink" title="一、解释器设计模式"></a>一、解释器设计模式</h2><p>​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用<strong>解释器设计模式</strong>来做。</p>
<p>​        此模式基于<strong>表达式和评估器</strong>部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个上下文中进行的。</p>
<p>​        Spring主要以<strong>Spring Expression Language</strong>（Spel）为例。</p>
<p>​        这里提个醒，SpEL是一种由Spring的<strong>org.springframework.expression.ExpressionParser</strong>实现分析和执行的语言。</p>
<p>​        这些实现使用作为字符串给出的Spel表达式，并将它们转换为<strong>org.springframework.expression.Expression的</strong>实例。上</p>
<p>​        下文组件由<strong>org.springframework.expression.EvaluationContext</strong>实现表示，例如：StandardEvaluationContext。</p>
<p>举个Spel的一个例子：</p>
<pre><code class="Java">Writer writer = new Writer();
writer.setName(&quot;Writer&#39;s name&quot;);
StandardEvaluationContext modifierContext = new StandardEvaluationContext(subscriberContext);
modifierContext.setVariable(&quot;name&quot;, &quot;Overriden writer&#39;s name&quot;);
parser.parseExpression(&quot;name = #name&quot;).getValue(modifierContext);
System.out.println(&quot;writer&#39;s name is : &quot; + writer.getName());
</code></pre>
<p>​        输出应打印“Overriden writer’s name”。如你所见，一个对象的属性是通过一个表达式<code>name = #name</code>进行修改的，这个表达式只有在<code>ExpressionParser</code>才能理解，因为提供了<code>context</code>（前面的样例中的<code>modifierContext</code>实例）。</p>
<h2 id="二、建设者模式"><a href="#二、建设者模式" class="headerlink" title="二、建设者模式"></a>二、建设者模式</h2><p>​        <strong>建设者设计模式</strong>是属于创建对象模式三剑客的第一种模式。<strong>该模式用于简化复杂对象的构造</strong>。要理解这个概念，想象一个说明程序员简历的对象。在这个对象中，我们想存储个人信息（名字，地址等）以及技术信息（知识语言，已实现的项目等）。该对象的构造可能如下所示：</p>
<pre><code class="Java">// with constructor
Programmer programmer = new Programmer(&quot;first name&quot;, &quot;last name&quot;, &quot;address Street 39&quot;, &quot;ZIP code&quot;, &quot;City&quot;, &quot;Country&quot;, birthDateObject, new String[] &#123;&quot;Java&quot;, &quot;PHP&quot;, &quot;Perl&quot;, &quot;SQL&quot;&#125;, new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);

// or with setters
Programmer programmer = new Programmer();
programmer.setName(&quot;first name&quot;);
programmer.setLastName(&quot;last name&quot;);
// ... multiple lines after
programmer.setProjects(new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);
</code></pre>
<p>​        Builder允许我们通过使用将值传递给父类的内部构建器对象来清楚地分解对象构造。所以对于我们这个程序员简历的对象的创建，构建器可以看起来像：</p>
<pre><code class="Java">public class BuilderTest &#123;

  @Test
  public void test() &#123;
    Programmer programmer = new Programmer.ProgrammerBuilder()
            .setFirstName(&quot;F&quot;)
            .setLastName(&quot;L&quot;)
            .setCity(&quot;City&quot;)
            .setZipCode(&quot;0000A&quot;)
            .setAddress(&quot;Street 39&quot;)
            .setLanguages(new String[] &#123;&quot;bash&quot;, &quot;Perl&quot;&#125;)
            .setProjects(new String[] &#123;&quot;Linux kernel&quot;&#125;).build();
    assertTrue(&quot;Programmer should be &#39;F L&#39; but was &#39;&quot;+ programmer+&quot;&#39;&quot;, programmer.toString().equals(&quot;F L&quot;));
  &#125;

&#125;

class Programmer &#123;
  private String firstName;
  private String lastName;
  private String address;
  private String zipCode;
  private String city;
  private String[] languages;
  private String[] projects;

  private Programmer(String fName, String lName, String addr, String zip, String city, String[] langs, String[] projects) &#123;
    this.firstName = fName;
    this.lastName = lName;
    this.address = addr;
    this.zipCode = zip;
    this.city = city;
    this.languages = langs;
    this.projects = projects;
  &#125;

  public static class ProgrammerBuilder &#123;
    private String firstName;
    private String lastName;
    private String address;
    private String zipCode;
    private String city;
    private String[] languages;
    private String[] projects;

    public ProgrammerBuilder setFirstName(String firstName) &#123;
      this.firstName = firstName;
      return this;
    &#125;

    public ProgrammerBuilder setLastName(String lastName) &#123;
      this.lastName = lastName;
      return this;
    &#125;

    public ProgrammerBuilder setAddress(String address) &#123;
      this.address = address;
      return this;
    &#125;

    public ProgrammerBuilder setZipCode(String zipCode) &#123;
      this.zipCode = zipCode;
      return this;
    &#125;

    public ProgrammerBuilder setCity(String city) &#123;
      this.city = city;
      return this;
    &#125;

    public ProgrammerBuilder setLanguages(String[] languages) &#123;
      this.languages = languages;
      return this;
    &#125;
    public ProgrammerBuilder setProjects(String[] projects) &#123;
      this.projects = projects;
      return this;
    &#125;

    public Programmer build() &#123;
      return new Programmer(firstName, lastName, address, zipCode, city, languages, projects);
    &#125;
  &#125;

  @Override
  public String toString() &#123;
    return this.firstName + &quot; &quot;+this.lastName;
  &#125;

&#125;
</code></pre>
<p>​        可以看出，构建器后面隐藏了对象构造的复杂性，内部静态类接受链接方法的调用。</p>
<p>​        在Spring中，我们可以在<strong>org.springframework.beans.factory.support.BeanDefinitionBuilder</strong>类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。我们可以在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/09/16/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84bean%E5%B7%A5%E5%8E%82%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">bean工厂后处理器的</a>文章中看到它，<code>BeanDefinitionBuilder</code>包含几个方法，它们为<strong>AbstractBeanDefinition</strong>抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：</p>
<pre><code class="java">public class BeanDefinitionBuilder &#123;
    /**
        * The &#123;@code BeanDefinition&#125; instance we are creating.
    */
    private AbstractBeanDefinition beanDefinition;

    // ... some not important methods for this article

    // Some of building methods
    /**
    * Set the name of the parent definition of this bean definition.
    */
    public BeanDefinitionBuilder setParentName(String parentName) &#123;
        this.beanDefinition.setParentName(parentName);
        return this;
    &#125;

    /**
    * Set the name of the factory method to use for this definition.
    */
    public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) &#123;
        this.beanDefinition.setFactoryMethodName(factoryMethod);
        return this;
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    * @deprecated since Spring 2.5, in favor of &#123;@link #addConstructorArgValue&#125;
    */
    @Deprecated
    public BeanDefinitionBuilder addConstructorArg(Object value) &#123;
        return addConstructorArgValue(value);
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    */
    public BeanDefinitionBuilder addConstructorArgValue(Object value) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
        this.constructorArgIndex++, value);
        return this;
    &#125;

    /**
    * Add a reference to a named bean as a constructor arg.
    * @see #addConstructorArgValue(Object)
    */
    public BeanDefinitionBuilder addConstructorArgReference(String beanName) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
            this.constructorArgIndex++, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Add the supplied property value under the given name.
    */
    public BeanDefinitionBuilder addPropertyValue(String name, Object value) &#123;
        this.beanDefinition.getPropertyValues().add(name, value);
        return this;
    &#125;

    /**
    * Add a reference to the specified bean name under the property specified.
    * @param name the name of the property to add the reference to
    * @param beanName the name of the bean being referenced
    */
    public BeanDefinitionBuilder addPropertyReference(String name, String beanName) &#123;
        this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Set the init method for this definition.
    */
    public BeanDefinitionBuilder setInitMethodName(String methodName) &#123;
        this.beanDefinition.setInitMethodName(methodName);
        return this;
    &#125;

    // Methods that can be used to construct BeanDefinition
    /**
    * Return the current BeanDefinition object in its raw (unvalidated) form.
    * @see #getBeanDefinition()
    */
    public AbstractBeanDefinition getRawBeanDefinition() &#123;
        return this.beanDefinition;
    &#125;

    /**
    * Validate and return the created BeanDefinition object.
    */
    public AbstractBeanDefinition getBeanDefinition() &#123;
        this.beanDefinition.validate();
        return this.beanDefinition;
    &#125;
&#125;
</code></pre>
<h2 id="三、工厂模式"><a href="#三、工厂模式" class="headerlink" title="三、工厂模式"></a>三、工厂模式</h2><p>​        创建对象模式三剑客的第二个成员是<strong>工厂方法设计模式</strong>。它完全适于使用<strong>动态环境</strong>作为Spring框架。实际上，<strong>这种模式允许通过公共静态方法对象进行初始化，称为工厂方法</strong>。在这个概念中，我们需要定义一个接口来创建对象。但是创建是由使用相关对象的类创建的。</p>
<p>​        但是在跳到Spring世界之前，让我们用Java代码做一个例子：</p>
<pre><code class="Java">public class FactoryMethodTest &#123;

    @Test
    public void test() &#123;
        Meal fruit = Meal.valueOf(&quot;banana&quot;);
        Meal vegetable = Meal.valueOf(&quot;carrot&quot;);
        assertTrue(&quot;Banana should be a fruit but is &quot;+fruit.getType(), fruit.getType().equals(&quot;fruit&quot;));
        assertTrue(&quot;Carrot should be a vegetable but is &quot;+vegetable.getType(),                                                     vegetable.getType().equals(&quot;vegetable&quot;));
    &#125;

&#125;

class Meal &#123;

    private String type;

    public Meal(String type) &#123;
        this.type = type;
    &#125;

    public String getType() &#123;
        return this.type;
    &#125;

    // Example of factory method - different object is created depending on current context
    public static Meal valueOf(String ingredient) &#123;
        if (ingredient.equals(&quot;banana&quot;)) &#123;
            return new Meal(&quot;fruit&quot;);
        &#125;
        return new Meal(&quot;vegetable&quot;);
    &#125;
&#125;
</code></pre>
<p>​        在Spring中，我们可以通过指定的工厂方法创建bean。该方法与以前代码示例中看到的valueOf方法完全相同。它是静态的，可以采取没有或多个参数。为了更好地了解案例，让我们来看一下实例。首先搞定下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;welcomerBean&quot; class=&quot;com.mysite.Welcomer&quot; factory-method=&quot;createWelcomer&quot;&gt;
    &lt;constructor-arg ref=&quot;messagesLocator&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messagesLocator&quot; class=&quot;com.mysite.MessageLocator&quot;&gt;
    &lt;property name=&quot;messages&quot; value=&quot;messages_file.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>​        现在请关注这个bean的初始化：</p>
<pre><code class="java">public class Welcomer &#123;
    private String message;

    public Welcomer(String message) &#123;
        this.message = message;
    &#125;

    public static Welcomer createWelcomer(MessageLocator messagesLocator) &#123;
        Calendar cal = Calendar.getInstance();
        String msgKey = &quot;welcome.pm&quot;;
        if (cal.get(Calendar.AM_PM) == Calendar.AM) &#123;
            msgKey = &quot;welcome.am&quot;;
        &#125;
        return new Welcomer(messagesLocator.getMessageByKey(msgKey));
    &#125;
&#125;
</code></pre>
<p>​        当Spring将构造welcomerBean时，它不会通过传统的构造函数，而是通过定义的静态工厂方法createWelcomer来实现。还要注意，这个方法接受一些参数（MessageLocator bean的实例包含所有可用的消息） 标签，通常保留给传统的构造函数。</p>
<h2 id="四、抽象工厂"><a href="#四、抽象工厂" class="headerlink" title="四、抽象工厂"></a>四、抽象工厂</h2><p>​        <strong>抽象的工厂设计模式</strong>，看起来类似于工厂方法。不同之处在于，我们可以将抽象工厂视为这个词的工业意义上的工厂，即。作为提供所需对象的东西。工厂部件有：抽象工厂，抽象产品，产品和客户。更准确地说，<strong>抽象工厂定义了构建对象的方法</strong>。抽象产品是这种结构的结果。产品是具有同样结构的具体结果。客户是要求创造产品来抽象工厂的人。</p>
<p>​        同样的，在进入Spring的细节之前，我们将首先通过示例Java代码说明这个概念：</p>
<pre><code class="java">public class FactoryTest &#123;

    // Test method which is the client
    @Test
    public void test() &#123;
        Kitchen factory = new KitchenFactory();
        KitchenMeal meal = factory.getMeal(&quot;P.1&quot;);
        KitchenMeal dessert = factory.getDessert(&quot;I.1&quot;);
        assertTrue(&quot;Meal&#39;s name should be &#39;protein meal&#39; and was &#39;&quot;+meal.getName()+&quot;&#39;&quot;, meal.getName().equals(&quot;protein meal&quot;));
        assertTrue(&quot;Dessert&#39;s name should be &#39;ice-cream&#39; and was &#39;&quot;+dessert.getName()+&quot;&#39;&quot;, dessert.getName().equals(&quot;ice-cream&quot;));
    &#125;

&#125;

// abstract factory
abstract class Kitchen &#123;
    public abstract KitchenMeal getMeal(String preferency);
    public abstract KitchenMeal getDessert(String preferency);
&#125;

// concrete factory
class KitchenFactory extends Kitchen &#123;
    @Override
    public KitchenMeal getMeal(String preferency) &#123;
        if (preferency.equals(&quot;F.1&quot;)) &#123;
            return new FastFoodMeal();
        &#125; else if (preferency.equals(&quot;P.1&quot;)) &#123;
            return new ProteinMeal();
        &#125;
        return new VegetarianMeal();
    &#125;

    @Override
    public KitchenMeal getDessert(String preferency) &#123;
        if (preferency.equals(&quot;I.1&quot;)) &#123;
            return new IceCreamMeal();
        &#125;
        return null;
    &#125;
&#125;

// abstract product
abstract class KitchenMeal &#123;
    public abstract String getName();
&#125;

// concrete products
class ProteinMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;protein meal&quot;;
    &#125;
&#125;

class VegetarianMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;vegetarian meal&quot;;
    &#125;
&#125;

class FastFoodMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;fast-food meal&quot;;
    &#125;
&#125;

class IceCreamMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;ice-cream&quot;;
    &#125;
&#125;
</code></pre>
<p>​        我们可以在这个例子中看到，<strong>抽象工厂封装了对象的创建</strong>。对象创建可以使用与经典构造函数一样使用的工厂方法模式。在Spring中，工厂的例子是<strong>org.springframework.beans.factory.BeanFactory</strong>。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，<strong>getBean</strong>方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。</p>
<p>​        在<code>BeanFactory</code>的实现中，我们可以区分：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>；</li>
<li><code>XmlWebApplicationContext</code>；</li>
<li><code>StaticWebApplicationContext</code>；</li>
<li><code>StaticPortletApplicationContext</code>；</li>
<li><code>GenericApplicationContext</code>；</li>
<li><code>StaticApplicationContext</code>。</li>
</ul>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;file:test-context.xml&quot;&#125;)
public class TestProduct &#123;

    @Autowired
    private BeanFactory factory;

    @Test
    public void test() &#123;
        System.out.println(&quot;Concrete factory is: &quot;+factory.getClass());
        assertTrue(&quot;Factory can&#39;t be null&quot;, factory != null);
        ShoppingCart cart = (ShoppingCart) factory.getBean(&quot;shoppingCart&quot;);
        assertTrue(&quot;Shopping cart object can&#39;t be null&quot;, cart != null);
        System.out.println(&quot;Found shopping cart bean:&quot;+cart.getClass());
    &#125;
&#125;
</code></pre>
<p>​        在这种情况下，抽象工厂由BeanFactory接口表示。</p>
<p>​        具体工厂是在第一个System.out中打印的，是<strong>org.springframework.beans.factory.support.DefaultListableBeanFactory</strong>的实例。它的抽象产物是一个对象。在我们的例子中，具体的产品就是被强转为ShoppingCart实例的抽象产品（Object）。</p>
<h2 id="五、代理模式"><a href="#五、代理模式" class="headerlink" title="五、代理模式"></a>五、代理模式</h2><p>​        面向对象编程（OOP）可能是编程中最流行的概念。然而，Spring引入了另一种编码规范，<strong>面向切面编程</strong>（AOP）。为了简化定义，AOP是面向系统特定点的一种编程，如：异常抛出，特定类别方法的执行等。AOP允许在执行这些特定点之前或之后执行补充动作。如何实现这种操作？它可以**通过监听器(listeners)**进行。但在这种情况下，我们应该在只要可能存在调用的地方都需要定义监听器来进行监听（比如在一个方法的开始的地方）。这就是为什么Spring不采用这个idea。相反，Spring实现了一种能够通过额外的方法调用完成任务的设计模式 - <strong>代理设计模式</strong>。</p>
<p>​        代理就像对象的镜像一样。也正因为如此，代理对象不仅可以覆盖真实对象，还可以扩展其功能。因此，对于只能在屏幕上打印一些文本的对象，我们可以添加另一个对象来过滤显示单词。可以通过代理来定义第二个对象的调用。代理是封装真实对象的对象。例如，如果您尝试调用Waiter bean，那么您将调用该Bean的代理，其行为方式完全相同。</p>
<p>​        代理设计模式的一个很好的例子是<strong>org.springframework.aop.framework.ProxyFactoryBean</strong>。该工厂根据Spring bean构建AOP代理。该类实现了定义**getObject()**方法的<code>FactoryBean</code>接口。此方法用于将需求<code>Bean</code>的实例返回给<code>bean factory</code>。在这种情况下，它不是返回的实例，而是<code>AOP代理</code>。在执行代理对象的方法之前，可以通过调用补充方法来进一步“修饰”代理对象(其实所谓的静态代理不过是在装饰模式上加了个要不要你来干动作行为而已，而不是装饰模式什么也不做就加了件衣服，其他还得由你来全权完成)。</p>
<p><code>ProxyFactory</code>的一个例子是：</p>
<pre><code class="java">public class TestProxyAop &#123;

    @Test
    public void test() &#123;
        ProxyFactory factory = new ProxyFactory(new House());
        factory.addInterface(Construction.class);
        factory.addAdvice(new BeforeConstructAdvice());
        factory.setExposeProxy(true);

        Construction construction = (Construction) factory.getProxy();
        construction.construct();
        assertTrue(&quot;Construction is illegal. &quot;
                   + &quot;Supervisor didn&#39;t give a permission to build &quot;
                   + &quot;the house&quot;, construction.isPermitted());
    &#125;

&#125;

interface Construction &#123;
    public void construct();
    public void givePermission();
    public boolean isPermitted();
&#125;

class House implements Construction&#123;

    private boolean permitted = false;

    @Override
    public boolean isPermitted() &#123;
        return this.permitted;
    &#125;

    @Override
    public void construct() &#123;
        System.out.println(&quot;I&#39;m constructing a house&quot;);
    &#125;

    @Override
    public void givePermission() &#123;
        System.out.println(&quot;Permission is given to construct a simple house&quot;);
        this.permitted = true;
    &#125;
&#125;

class BeforeConstructAdvice implements MethodBeforeAdvice &#123;

    @Override
    public void before(Method method, Object[] arguments, Object target) throws Throwable &#123;
        if (method.getName().equals(&quot;construct&quot;)) &#123;
            ((Construction) target).givePermission();
        &#125;
    &#125;

&#125;
</code></pre>
<p>​        这个测试应该通过，因为我们不直接在House实例上操作，而是代理它。代理调用第一个<code>BeforeConstructAdvice</code>的<code>before</code>方法（指向在执行目标方法之前执行，在我们的例子中为<code>construct()</code>）通过它，给出了一个“权限”来构造对象的字段（house）。代理层提供了一个额外新功能，因为它可以简单地分配给另一个对象。要做到这一点，我们只能在before方法之前修改过滤器。</p>
<h2 id="六、复合模式"><a href="#六、复合模式" class="headerlink" title="六、复合模式"></a>六、复合模式</h2><p>​        另一种结构模式是<strong>复合模式</strong>。在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/07/20/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)">Spring中设计模式</a>的第一篇文章中，我们使用构建器来构造复杂对象。另一种实现方法是使用复合模式。这种模式是<strong>基于具有共同行为的多个对象的存在</strong>，用于构建更大的对象。较大的对象仍然具有与最小对象相同的特征。那么用它来定义相同的行为。</p>
<p>​        复合对象的非Spring示例可以是一个写入HTML的文本对象，由包含span或em标签的段落组成：</p>
<pre><code class="java">public class CompositeTest &#123;

    @Test
    public void test() &#123;
        TextTagComposite composite = new PTag();
        composite.addTag(new SpanTag());
        composite.addTag(new EmTag());

        // sample client code
        composite.startWrite();
        for (TextTag leaf : composite.getTags()) &#123;
            leaf.startWrite();
            leaf.endWrite();
        &#125;
        composite.endWrite();
        assertTrue(&quot;Composite should contain 2 tags but it contains &quot;+composite.getTags().size(), composite.getTags().size() == 2);
    &#125;

&#125;

interface TextTag &#123;
    public void startWrite();
    public void endWrite();
&#125;

interface TextTagComposite extends TextTag &#123;
    public List&lt;TextTag&gt; getTags();
    public void addTag(TextTag tag);
&#125;

class PTag implements TextTagComposite &#123;
    private List&lt;TextTag&gt; tags = new ArrayList&lt;TextTag&gt;();

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;p&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/p&gt;&quot;);
    &#125;

    @Override
    public List&lt;TextTag&gt; getTags() &#123;
        return tags;
    &#125;

    @Override
    public void addTag(TextTag tag) &#123;
        tags.add(tag);
    &#125;
&#125;

class SpanTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;span&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/span&gt;&quot;);
    &#125;

&#125;

class EmTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;em&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/em&gt;&quot;);
    &#125;

&#125;
</code></pre>
<p>​        在这种情况下，可以看到一个复合对象。我们可以区分复合与非复合对象，因为第一个可以容纳一个或多个非复合对象（<code>PTag</code>类中的<code>private List tags</code>字段）。非复合对象称为<strong>叶子</strong>。<code>TextTag</code>接口被称为<strong>组件</strong>，因为它为两个对象类型提供了共同的行为规范(有点像<code>Linux</code>文件管理系统的有共同点的文件放在一个文件夹下进行管理，其实就是节点管理)。</p>
<p>​        在<code>Spring</code>世界中，我们检索复合对象的概念是<strong>org.springframework.beans.BeanMetadataElement</strong>接口，用于配置<code>bean</code>对象。它是所有继承对象的基本界面。</p>
<p>​        现在，在一方面，我们有一个叶子，由<strong>org.springframework.beans.factory.parsing.BeanComponentDefinition</strong>表示，另一边是复合<strong>org.springframework.beans.factory.parsing.CompositeComponentDefinition</strong>。</p>
<p>​        <code>CompositeComponentDefinition</code>类似于组件，因为它包含<strong>addNestedComponent（ComponentDefinition component）</strong>方法，它允许将叶子添加到私有final列表中<code>nestedComponents</code>。您可以看到，由于此列表，<code>BeanComponentDefinition</code>和<code>CompositeComponentDefinition</code>的组件是<strong>org.springframework.beans.factory.parsing.ComponentDefinition</strong>。</p>
<p><img src="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg" alt="img"></p>
<h2 id="七、策略模式"><a href="#七、策略模式" class="headerlink" title="七、策略模式"></a>七、策略模式</h2><p>​        <strong>策略设计模式</strong>。<strong>策略定义了通过不同方式完成相同事情的几个对象</strong>。完成任务的方式取决于采用的策略。举个例子说明，我们可以去一个国家。我们可以乘公共汽车，飞机，船甚至汽车去那里。所有这些方法将把我们运送到目的地国家。但是，我们将通过检查我们的银行帐户来选择最适应的方式。如果我们有很多钱，我们将采取最快的方式（可能是私人飞行）。如果我们没有足够的话，我们会采取最慢的（公车，汽车）。该银行账户作为确定适应策略的因素。</p>
<p>​        Spring在<strong>org.springframework.web.servlet.mvc.multiaction.MethodNameResolver</strong>类(过时，但不影响拿来研究)中使用策略设计模式。它是<code>MultiActionController</code>(同样过时)的参数化实现。在开始解释策略之前，我们需要了解MultiActionController的实用性。这个类允许同一个类处理几种类型的请求。</p>
<p>​        作为Spring中的每个控制器，MultiActionController执行方法来响应提供的请求。策略用于检测应使用哪种方法。解析过程在MethodNameResolver实现中实现，例如在同一个包中的<strong>ParameterMethodNameResolver中</strong>。方法可以通过多个条件解决：属性映射，HTTP请求参数或URL路径。</p>
<pre><code class="java">@Override
public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException &#123;
    String methodName = null;

    // Check parameter names where the very existence of each parameter
    // means that a method of the same name should be invoked, if any.
    if (this.methodParamNames != null) &#123;
        for (String candidate : this.methodParamNames) &#123;
            if (WebUtils.hasSubmitParameter(request, candidate)) &#123;
                methodName = candidate;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                                 &quot;&#39; based on existence of explicit request parameter of same name&quot;);
                &#125;
                break;
            &#125;
        &#125;
    &#125;

    // Check parameter whose value identifies the method to invoke, if any.
    if (methodName == null &amp;&amp; this.paramName != null) &#123;
        methodName = request.getParameter(this.paramName);
        if (methodName != null) &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                             &quot;&#39; based on value of request parameter &#39;&quot; + this.paramName + &quot;&#39;&quot;);
            &#125;
        &#125;
    &#125;

    if (methodName != null &amp;&amp; this.logicalMappings != null) &#123;
        // Resolve logical name into real method name, if appropriate.
        String originalName = methodName;
        methodName = this.logicalMappings.getProperty(methodName, methodName);
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Resolved method name &#39;&quot; + originalName + &quot;&#39; to handler method &#39;&quot; + methodName + &quot;&#39;&quot;);
        &#125;
    &#125;

    if (methodName != null &amp;&amp; !StringUtils.hasText(methodName)) &#123;
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Method name &#39;&quot; + methodName + &quot;&#39; is empty: treating it as no method name found&quot;);
        &#125;
        methodName = null;
    &#125;

    if (methodName == null) &#123;
        if (this.defaultMethodName != null) &#123;
            // No specific method resolved: use default method.
            methodName = this.defaultMethodName;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Falling back to default handler method &#39;&quot; + this.defaultMethodName + &quot;&#39;&quot;);
            &#125;
        &#125;
        else &#123;
            // If resolution failed completely, throw an exception.
            throw new NoSuchRequestHandlingMethodException(request);
        &#125;
    &#125;

    return methodName;
&#125;
</code></pre>
<p>​        正如我们在前面的代码中可以看到的，方法的名称通过提供的参数映射，URL中的预定义属性或参数存在来解决（默认情况下，该参数的名称是action）。</p>
<h2 id="八、模板模式"><a href="#八、模板模式" class="headerlink" title="八、模板模式"></a>八、模板模式</h2><p>​        <strong>模板方法</strong>。此模式定义了类行为的骨架，并将子步骤的某些步骤的延迟执行(具体就是下面例子中一个方法放在另一个方法中，只有调用另一方方法的时候这个方法才会执行,而且还可能会在其他行为方法之后按顺序执行)。其中写了一种方法(下面例子中的construct())，注意定义为final，起着同步器的角色。它以给定的顺序执行由子类定义的方法。在现实世界中，我们可以将模板方法与房屋建设进行比较。独立于建造房屋的公司，我们需要从建立基础开始，只有在我们完成之后才能做其他的工作。这个执行逻辑将被保存在一个我们不能改变的方法中。例如基础建设或刷墙会被作为一个模板方法中的方法，具体到建筑房屋的公司。我们可以在给定的例子中看到它：</p>
<pre><code class="java">public class TemplateMethod &#123;

  public static void main(String[] args) &#123;
    HouseAbstract house = new SeaHouse();
    house.construct();
  &#125;

&#125;

abstract class HouseAbstract &#123;
  protected abstract void constructFoundations();
  protected abstract void constructWall();

  // template method
  public final void construct() &#123;
    constructFoundations();
    constructWall();
  &#125;
&#125;

class EcologicalHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Making foundations with wood&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Making wall with wood&quot;);
  &#125;

&#125;

class SeaHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Constructing very strong foundations&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Constructing very strong wall&quot;);
  &#125;

&#125;
</code></pre>
<p>​        该代码应该输出：</p>
<pre><code class="java">Constructing very strong foundations
Constructing very strong wall
</code></pre>
<p>​        Spring在<strong>org.springframework.context.support.AbstractApplicationContext</strong>类中使用模板方法。他们不是一个模板方法（在我们的例子中是construct ），而是多个。例如，<strong>getsFreshBeanFactory</strong>返回内部<code>bean工厂</code>的新版本，调用两个抽象方法：<code>refreshBeanFactory</code>（刷新工厂bean）和<code>getBeanFactory</code>（以获取更新的工厂bean）。这个方法和其他一些方法一样，用在<strong>public void refresh()<strong>中，抛出</strong>构造应用程序上下文的BeansException，IllegalStateException</strong>方法(这里会在后面Spring中与应用程序上下文分析中再次提到)。</p>
<p>​        我们可以从同一个包中的GenericApplicationContext找到一些通过模板方法所实现的抽象方法的实现的例子(说的有点拗口，多读几遍就好):</p>
<pre><code class="java">/**
  * Do nothing: We hold a single internal BeanFactory and rely on callers
  * to register beans through our public methods (or the BeanFactory&#39;s).
  * @see #registerBeanDefinition
  */
@Override
protected final void refreshBeanFactory() throws IllegalStateException &#123;
  if (this.refreshed) &#123;
    throw new IllegalStateException(
      &quot;GenericApplicationContext does not support multiple refresh attempts: just call &#39;refresh&#39; once&quot;);
  &#125;
  this.beanFactory.setSerializationId(getId());
  this.refreshed = true;
&#125;

@Override
protected void cancelRefresh(BeansException ex) &#123;
  this.beanFactory.setSerializationId(null);
  super.cancelRefresh(ex);
&#125;

/**
  * Not much to do: We hold a single internal BeanFactory that will never
  * get released.
  */
@Override
protected final void closeBeanFactory() &#123;
  this.beanFactory.setSerializationId(null);
&#125;

/**
  * Return the single internal BeanFactory held by this context
  * (as ConfigurableListableBeanFactory).
  */
@Override
public final ConfigurableListableBeanFactory getBeanFactory() &#123;
  return this.beanFactory;
&#125;

/**
  * Return the underlying bean factory of this context,
  * available for registering bean definitions.
  * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; You need to call &#123;@link #refresh()&#125; to initialize the
  * bean factory and its contained beans with application context semantics
  * (autodetecting BeanFactoryPostProcessors, etc).
  * @return the internal bean factory (as DefaultListableBeanFactory)
  */
public final DefaultListableBeanFactory getDefaultListableBeanFactory() &#123;
  return this.beanFactory;
&#125;
</code></pre>
<p>​        经过上面这些可以让我们发现Spring如何通过使用行为和结构设计模式来更好地组织上下文（<strong>模板方法</strong>），并通过相应<strong>策略</strong>来解决执行方法。它使用两种结构设计模式，通过<strong>代理模式</strong>来简化AOP部分并通过<strong>复合模式</strong>来构造复杂对象。</p>
<h2 id="九、原型模式"><a href="#九、原型模式" class="headerlink" title="九、原型模式"></a>九、原型模式</h2><p>​        可以通过官方文档查找有关Spring作用域中的bean作用域的文章中介绍了类似的概念(<strong>prototype</strong>)。原型设计模式与有用相同名称的(<strong>prototype</strong>)作用域有点相似。此设计模式允许通过复制已存在的对象来创建一个对象的实例。副本应该是<strong>真正的副本</strong>。这意味着新对象的所有属性应与复制对象的属性相同。如果不清楚，比一个简单的<code>JUnit</code>案例更好的说明：</p>
<pre><code class="java">public class PrototypeTest &#123;

  @Test
  public void test() &#123;
    Robot firstRobot = new Robot(&quot;Droid#1&quot;);
    Robot secondRobot = (Robot) firstRobot.clone();
    assertTrue(&quot;Cloned robot&#39;s instance can&#39;t be the same as the&quot;
      +&quot; source robot instance&quot;,
      firstRobot != secondRobot);
    assertTrue(&quot;Cloned robot&#39;s name should be &#39;&quot;+firstRobot.getName()+&quot;&#39;&quot;
      +&quot; but was &#39;&quot;+secondRobot.getName()+&quot;&#39;&quot;,
      secondRobot.getName().equals(firstRobot.getName()));
  &#125;

&#125;


class Robot implements Cloneable &#123;
  private String name;

  public Robot(String name) &#123;
    this.name = name;
  &#125;

  public String getName() &#123;
    return this.name;
  &#125;

  protected Object clone() throws CloneNotSupportedException &#123;
    return super.clone();
  &#125;
&#125;
</code></pre>
<p>​        在<code>Spring</code>中，在<strong>org.springframework.beans.factory.support.AbstractBeanFactory</strong>中使用一种特定的原型设计模式，它将初始化<code>bean原型作用域</code>。新对象基于配置文件中的bean定义。我们可以看到，在给定的例子中：</p>
<pre><code class="java">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; scope=&quot;prototype&quot;&gt;
  &lt;property name=&quot;id&quot; value=&quot;9&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;applicationContext-test.xml&quot;&#125;)
public class SpringPrototypeTest &#123;

  @Autowired
  private BeanFactory beanFactory;

  @Test
  public void test() &#123;
    ShoppingCart cart1 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart1 should be 9 but was &quot;+cart1.getId(),
      cart1.getId() == 9);
    cart1.setId(100);
    ShoppingCart cart2 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart2 should be 9 but was &quot;+cart2.getId(),
      cart2.getId() == 9);
    assertTrue(&quot;Id of second cart (&quot;+cart2.getId()+&quot;) shouldn&#39;t be the same as the first one: &quot;+cart1.getId(),
      cart1.getId() != cart2.getId());
    cart2.setId(cart1.getId());
    assertTrue(&quot;Now (after cart2.setId(cart1.getId())), the id of second cart (&quot;+cart2.getId()+&quot;) should be the same as the first one: &quot;
      +cart1.getId(), cart1.getId() == cart2.getId());
    assertTrue(&quot;Both instance shouldn&#39;t be the same&quot;, cart1 != cart2);
  &#125;

&#125;
</code></pre>
<p>​        从前面的例子可以看出，<code>ShoppingCart</code>实例是直接从bean定义创建的。最初，<code>cart1</code>和<code>cart2</code>对象的<code>id</code>值为<code>9</code>.它在测试结束时被修改，以证明两个引用都属于两个不同的对象。</p>
<h2 id="十、对象池"><a href="#十、对象池" class="headerlink" title="十、对象池"></a>十、对象池</h2><p>​        <code>Spring</code>中使用的另一个模型是<strong>对象池设计模式</strong>。其主要目的在于在一个池中保存特定数量的对象，并根据需要重新使用。通过它，我们可以改善我们想要使用<code>巨型对象</code>的响应时间。<code>巨型</code>意味着这些对象的构造需要很多时间（例如：持有数据库连接的对象），最好重用已经存在的和未获取的对象，而不是创建新对象。</p>
<p>​        Spring还使用线程池来管理其调度部分。一些示例位于<strong>org.springframework.scheduling.concurrent中</strong>。我们检索数据库（<code>Spring JDBC</code>）项目中的对象池的想法。数据库连接池不是由<code>Spring</code>直接实现的，而是适用于<code>Spring</code>工作方式的项目，如<code>C3P0</code>或<code>Jakarta Commons DBCP</code>连接池。</p>
<h2 id="十一、观察者"><a href="#十一、观察者" class="headerlink" title="十一、观察者"></a>十一、观察者</h2><p>​        当一个或几个课程正在等待具体事件时可以使用它。观察者模式由一个科目和观察员名单组成。一个很好的例子就是<code>GUI界面</code>，其中点击按钮（按钮是主题）会引起听众（观察者）启动的一些操作(再说的直白点就是电影院一场电影这个<code>subject</code>,需要<code>观众</code>(也就是观察者咯),电影产生的一些画面产生的事件，比如恐怖 电影给男人女人带来的不同的感官的感受，传播到观察者也就是观众的眼里所带来的不一样的反应，这个中间一般会添加一个<code>事件传播者</code>，在后面解释<code>Spring</code>的例子的时候会说到)，例如：打开一个新页面这个动作。可以参考下面的例子：</p>
<pre><code class="java">public class ObserverTest &#123;

  @Test
  public void test() &#123;
    Observer pageOpener = new PageOpener();
    Observer register = new Register();
    Button btn = new Button();
    btn.addListener(pageOpener);
    btn.addListener(register);
    btn.clickOn();
    assertTrue(&quot;Button should be clicked but it wasn&#39;t&quot;,
      btn.wasClicked());
    assertTrue(&quot;Page opener should be informed about click but it wasn&#39;t&quot;,
      pageOpener.wasInformed());
    assertTrue(&quot;Register should be informed about click but it wasn&#39;t&quot;,
      register.wasInformed());
  &#125;

&#125;

class Button &#123;

  private boolean clicked;
  private List&lt;observer&gt; listeners;

  public List&lt;observer&gt; getListeners() &#123;
    if (this.listeners == null) &#123;
      this.listeners = new ArrayList&lt;observer&gt;();
    &#125;
    return this.listeners;
  &#125;

  public void addListener(Observer observer) &#123;
    getListeners().add(observer);
  &#125;

  public boolean wasClicked() &#123;
    return this.clicked;
  &#125;

  public void clickOn() &#123;
    this.clicked = true;
    informAll();
  &#125;

  private void informAll() &#123;
    for (Observer observer : getListeners()) &#123;
      observer.informAboutEvent();
    &#125;
  &#125;

&#125;

abstract class Observer &#123;
  protected boolean informed;

  public void informAboutEvent() &#123;
    this.informed = true;
  &#125;

  public boolean wasInformed() &#123;
    return this.informed;
  &#125;
&#125;

class PageOpener extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Preparing download of new page&quot;);
    super.informAboutEvent();
  &#125;

&#125;

class Register extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Adding the action to register&quot;);
    super.informAboutEvent();
  &#125;
&#125;
</code></pre>
<p>​        可以看到，关于我们的<code>Button</code>实例点击的事件被发送到所有的观察者对象。从这些对象开始下载页面内容，第二个将在事件的信息保存在注册表中。在<code>Spring</code>中，观察者设计模式用于将与应用程序上下文相关的事件传输到<strong>org.springframework.context.ApplicationListener的实现</strong>。要了解它们的实现方法，我们来看一下<code>AbstractApplicationContext</code>类(老版本的代码，新版本的请自行对照)：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader
  implements ConfigurableApplicationContext, DisposableBean &#123;
  /** Statically specified listeners */
  private Set&lt;applicationlistener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;applicationlistener&lt;?&gt;&gt;();

  // some other fields and methods
  @Override
  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;
    if (this.applicationEventMulticaster != null) &#123;
      this.applicationEventMulticaster.addApplicationListener(listener);
    &#125;
    else &#123;//新版本这里直接咔嚓掉，上面的applicationEventMulticaster一旦为空，就会报错的
      this.applicationListeners.add(listener);
    &#125;
  &#125;

  /**
    * Return the list of statically specified ApplicationListeners.
    */
  public Collection&lt;applicationlistener&lt;?&gt;&gt; getApplicationListeners() &#123;
    return this.applicationListeners;
  &#125;

  /**
    * Add beans that implement ApplicationListener as listeners.
    * Doesn&#39;t affect other listeners, which can be added without being beans.
    */
  protected void registerListeners() &#123;
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;
      getApplicationEventMulticaster().addApplicationListener(listener);
    &#125;
    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String lisName : listenerBeanNames) &#123;
      getApplicationEventMulticaster().addApplicationListenerBean(lisName);
    &#125;
  &#125;
&#125;java
</code></pre>
<p>​        在提供的代码中，监听器在内部添加到应用程序上下文类中，并且在<code>registerListeners()</code>方法之后，它们被注册到由接口<strong>org.springframework.context.event.ApplicationEventMulticaster</strong>表示的适当的事件多路广播器(因为有很多listeners)。<code>EventMulticaster</code>负责管理不同的<code>listener</code>和向他们发布事件。</p>
<pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;
    private Executor taskExecutor;
    private ErrorHandler errorHandler;

    public SimpleApplicationEventMulticaster() &#123;
    &#125;

    public SimpleApplicationEventMulticaster(BeanFactory beanFactory) &#123;
        this.setBeanFactory(beanFactory);
    &#125;

    public void setTaskExecutor(Executor taskExecutor) &#123;
        this.taskExecutor = taskExecutor;
    &#125;

    protected Executor getTaskExecutor() &#123;
        return this.taskExecutor;
    &#125;

    public void setErrorHandler(ErrorHandler errorHandler) &#123;
        this.errorHandler = errorHandler;
    &#125;

    protected ErrorHandler getErrorHandler() &#123;
        return this.errorHandler;
    &#125;

    public void multicastEvent(ApplicationEvent event) &#123;
        this.multicastEvent(event, this.resolveDefaultEventType(event));
    &#125;
    //发布事件:通过池执行任务的方式来做并发处理，这样就把之前的对象池模式给利用上了
    public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123;
        ResolvableType type = eventType != null?eventType:this.resolveDefaultEventType(event);
        Iterator var4 = this.getApplicationListeners(event, type).iterator();

        while(var4.hasNext()) &#123;
            final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();
            Executor executor = this.getTaskExecutor();
            if(executor != null) &#123;
                executor.execute(new Runnable() &#123;
                    public void run() &#123;
                        SimpleApplicationEventMulticaster.this.invokeListener(listener, event);
                    &#125;
                &#125;);
            &#125; else &#123;
                this.invokeListener(listener, event);
            &#125;
        &#125;

    &#125;
...
&#125;
</code></pre>
<p>​        这次我们讲3种设计模式:用于在同一个调用作用域内创建<code>bean的原型</code>，避免重新创建巨型对象的对象池，以及将应用程序的上下文事件分派给适当的监听器的观察者。</p>
<h2 id="十二、适配器"><a href="#十二、适配器" class="headerlink" title="十二、适配器"></a>十二、适配器</h2><p>​        当我们需要在给定场景下(也就是给定接口)想要不改变自身行为而又想做到一些事情的情况下(就是我给电也就是接口了，你来做事也就是各种电器)，使用<strong>适配器设计模式</strong>(这里再说一点，就相当于我们再一个规章制度的环境下，如何去适应并达到我们期待的效果，放在架构设计这里，可以拿一个php系统和一个Java系统来说，假如两者要互相调用对方的功能，我们可以设计一套对外的api来适配)。这意味着在调用此对象之前，我们将更改使用对象而不改变机制。拿一个现实中的例子进行说明，想象一下你想要用电钻来钻一个洞。要钻一个小洞，你会使用小钻头，钻一个大的需要用大钻头。可以看下面的代码：</p>
<pre><code class="java">public class AdapterTest &#123;

  public static void main(String[] args) &#123;
    HoleMaker maker = new HoleMakerImpl();
    maker.makeHole(1);
    maker.makeHole(2);
    maker.makeHole(30);
    maker.makeHole(40);
  &#125;
&#125;

interface HoleMaker &#123;
  public void makeHole(int diameter);
&#125;

interface DrillBit &#123;
  public void makeSmallHole();
  public void makeBigHole();
&#125;

// Two adaptee objects
class BigDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    // do nothing
  &#125;

  @Override
  public void makeBigHole() &#123;
    System.out.println(&quot;Big hole is made byt WallBigHoleMaker&quot;);
  &#125;
&#125;

class SmallDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    System.out.println(&quot;Small hole is made byt WallSmallHoleMaker&quot;);
  &#125;

  @Override
  public void makeBigHole() &#123;
    // do nothing
  &#125;
&#125;

// Adapter class
class Drill implements HoleMaker &#123;

  private DrillBit drillBit;

  public Drill(int diameter) &#123;
    drillBit = getMakerByDiameter(diameter);
  &#125;

  @Override
  public void makeHole(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            drillBit.makeSmallHole();
    &#125; else &#123;
            drillBit.makeBigHole();
    &#125;
  &#125;

  private DrillBit getMakerByDiameter(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            return new SmallDrillBit();
    &#125;
    return new BigDrillBit();
  &#125;

  private boolean isSmallDiameter(int diameter) &#123;
    return diameter &lt; 10;
  &#125;
&#125;

// Client class
class HoleMakerImpl implements HoleMaker &#123;

  @Override
  public void makeHole(int diameter) &#123;
    HoleMaker maker = new Drill(diameter);
    maker.makeHole(diameter);
  &#125;
&#125;
</code></pre>
<p>以上代码的结果如下:</p>
<pre><code class="java">Small hole is made byt SmallDrillBit
Small hole is made byt SmallDrillBit
Big hole is made byt BigDrillBit
Big hole is made byt BigDrillBit
</code></pre>
<p>​        可以看到，hole 是由所匹配的DrillBit对象制成的。如果孔的直径小于10，则使用SmallDrillBit。如果它更大，我们使用BigDrillBit。</p>
<p>​        思路就是，要打洞，那就要有打洞的工具，这里提供一个电钻接口和钻头。电钻就是用来打洞的，所以，它就一个接口方法即可，接下来定义钻头的接口，无非就是钻头的尺寸标准，然后搞出两个钻头实现类出来，接下来就是把钻头和电钻主机组装起来咯，也就是<code>Drill</code>类，里面有电钻接口+钻头(根据要钻的孔大小来确定用哪个钻头)，其实也就是把几个单一的东西组合起来拥有丰富的功能，最后我们进行封装下:<code>HoleMakerImpl</code>，这样只需要根据尺寸就可以打相应的孔了，对外暴露的接口极为简单，无须管内部逻辑是多么复杂</p>
<p>​        Spring使用适配器设计模式来处理不同servlet容器中的<strong>加载时编织</strong>(<strong>load-time-weaving</strong>)。在面向切面编程（AOP）中使用<strong>load-time-weaving</strong>，一种方式是在类加载期间将AspectJ的方面注入字节码。另一种方式是对类进行编译时注入或对已编译的类进行静态注入。</p>
<p>​        我们可以从关于Spring和JBoss的处理接口这里找到一个很好的例子，它包含在<strong>org.springframework.instrument.classloading.jboss</strong>包中。我们检索<code>JBossLoadTimeWeaver类</code>负责<code>JBoss容器</code>的编织管理。然而，类加载器对于<code>JBoss 6</code>（使用<code>JBossMCAdapter</code>实例）和<code>JBoss 7/8</code>（使用<code>JBossModulesAdapter</code>实例）是不同的。根据<code>JBoss</code>版本，我们在<code>JBossLoadTimeWeaver</code>构造函数中初始化相应的适配器（与我们示例中的<code>Drill</code>的构造函数完全相同）：</p>
<pre><code class="java">public JBossLoadTimeWeaver(ClassLoader classLoader) &#123;
  private final JBossClassLoaderAdapter adapter;

  Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
  if (classLoader.getClass().getName().startsWith(&quot;org.jboss.modules&quot;)) &#123;
    // JBoss AS 7 or WildFly 8
    this.adapter = new JBossModulesAdapter(classLoader);
  &#125;
  else &#123;
    // JBoss AS 6
    this.adapter = new JBossMCAdapter(classLoader);
  &#125;
&#125;
</code></pre>
<p>​        而且，此适配器所创建的实例用于根据运行的servlet容器版本进行编织操作：</p>
<pre><code class="java">@Override
public void addTransformer(ClassFileTransformer transformer) &#123;
  this.adapter.addTransformer(transformer);
&#125;

@Override
public ClassLoader getInstrumentableClassLoader() &#123;
  return this.adapter.getInstrumentableClassLoader();
&#125;
</code></pre>
<blockquote>
<p>总结：适配器模式，其实就是我们用第一人称的视角去看世界，我想拓展我自己的技能的时候，就实行拿来主义，就好比这里的我是电钻的视角，那么我想拥有钻大孔或者小孔的功能，那就把钻头拿到手组合起来就好。</p>
<p>和装饰模式的区别：装饰模式属于第三人称的视角，也就是上帝视角！我只需要把几个功能性的组件给拿到手，进行组合一下，实现一个更加<code>niubility</code>的功能这里提前说下，这样看下面的内容能好理解些。下面解释装饰模式</p>
</blockquote>
<h2 id="十三、装饰"><a href="#十三、装饰" class="headerlink" title="十三、装饰"></a>十三、装饰</h2><p>​        这里描述的第二种设计模式看起来类似于适配器。它是<strong>装饰模式</strong>。这种设计模式的主要作用是为给定的对象添加补充角色。举个现实的例子，就拿咖啡来讲。通常越黑越苦，你可以添加（<code>装饰</code>）糖和牛奶，使咖啡不那么苦。咖啡在这里被装饰的对象，糖与牛奶是用来装饰的。可以参考下面的例子：</p>
<pre><code class="java">public class DecoratorSample &#123;

  @Test
  public void test() &#123;
    Coffee sugarMilkCoffee=new MilkDecorator(new SugarDecorator(new BlackCoffee()));
    assertEquals(sugarMilkCoffee.getPrice(), 6d, 0d);
  &#125;
&#125;

// decorated
abstract class Coffee&#123;
  protected int candied=0;
  protected double price=2d;
  public abstract int makeMoreCandied();
  public double getPrice()&#123;
    return this.price;
  &#125;
  public void setPrice(double price)&#123;
    this.price+=price;
  &#125;
&#125;
class BlackCoffee extends Coffee&#123;
  @Override
  public int makeMoreCandied()&#123;
    return 0;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.price;
  &#125;
&#125;

// abstract decorator
abstract class CoffeeDecorator extends Coffee&#123;
  protected Coffee coffee;
  public CoffeeDecorator(Coffee coffee)&#123;
    this.coffee=coffee;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.coffee.getPrice();
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return this.coffee.makeMoreCandied();
  &#125;
&#125;

// concrete decorators
class MilkDecorator extends CoffeeDecorator&#123;
  public MilkDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+1d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
class SugarDecorator extends CoffeeDecorator&#123;
  public SugarDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+3d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
</code></pre>
<p>​        上面这个简单的装饰器的小例子是基于对父方法的调用，从而改变最后的属性（我们这里是指价格和加糖多少）。在Spring中，我们在处理与Spring管理缓存同步事务的相关类中可以 发现装饰器设计模式的例子。这个类是<strong>org.springframework.cache.transaction.TransactionAwareCacheDecorator</strong>。</p>
<p>​        这个类的哪些特性证明它是<strong>org.springframework.cache.Cache</strong>对象的装饰器？首先，与我们的咖啡示例一样，<code>TransactionAwareCacheDecorator</code>的构造函数接收参数装饰对象（Cache）：</p>
<pre><code class="java">private final Cache targetCache;
/**
 * Create a new TransactionAwareCache for the given target Cache.
 * @param targetCache the target Cache to decorate
 */
public TransactionAwareCacheDecorator(Cache targetCache) &#123;
  Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
  this.targetCache = targetCache;
&#125;
</code></pre>
<p>​        其次，通过这个对象，我们可以得到一个新的行为:为给定的目标缓存创建一个新的TransactionAwareCache。这个我们可以在<code>TransactionAwareCacheDecorator</code>的注释中可以阅读到，其主要目的是提供缓存和Spring事务之间的同步级别。这是通过<strong>org.springframework.transaction.support.TransactionSynchronizationManager</strong>中的两种缓存方法实现的：<code>put</code> 和 <code>evict</code>(其实最终不还是通过<code>targetCache</code>来实现的么)：</p>
<pre><code class="java">@Override
public void put(final Object key, final Object value) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
    TransactionSynchronizationManager.registerSynchronization(
      new TransactionSynchronizationAdapter() &#123;
        @Override
        public void afterCommit() &#123;
          targetCache.put(key, value);
        &#125;
    &#125;);
  &#125;
  else &#123;
    this.targetCache.put(key, value);
  &#125;
&#125;

@Override
public void evict(final Object key) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
          TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronizationAdapter() &#123;
              @Override
              public void afterCommit() &#123;
                targetCache.evict(key);
              &#125;
          &#125;);
  &#125;
  else &#123;
    this.targetCache.evict(key);
  &#125;
&#125;
</code></pre>
<p>​        这种模式看起来类似于适配器，对吧？但是，它们还是有区别的。我们可以看到，适配器将对象适配到运行时环境，即。如果我们在JBoss 6中运行，我们使用与JBoss 7不同的类加载器。Decorator每次使用相同的主对象（Cache）工作，并且仅向其添加新行为（与本例中的Spring事务同步），另外，可以通过我在解读这个设计模式之前的说法来区分二者。</p>
<p>​        我们再以springboot的初始化来举个例子的，这块后面会进行仔细的源码分析的，这里就仅仅用设计模式来说下的:</p>
<pre><code class="java">/**
 * Event published as early as conceivably possible as soon as a &#123;@link SpringApplication&#125;
 * has been started - before the &#123;@link Environment&#125; or &#123;@link ApplicationContext&#125; is
 * available, but after the &#123;@link ApplicationListener&#125;s have been registered. The source
 * of the event is the &#123;@link SpringApplication&#125; itself, but beware of using its internal
 * state too much at this early stage since it might be modified later in the lifecycle.
 *
 * @author Dave Syer
 */
@SuppressWarnings(&quot;serial&quot;)
public class ApplicationStartedEvent extends SpringApplicationEvent &#123;

    /**
     * Create a new &#123;@link ApplicationStartedEvent&#125; instance.
     * @param application the current application
     * @param args the arguments the application is running with
     */
    public ApplicationStartedEvent(SpringApplication application, String[] args) &#123;
        super(application, args);
    &#125;

&#125;
</code></pre>
<p>​        从注释可以看出 <code>ApplicationListener</code>要先行到位的，然后就是started的时候<code>Event published</code>走起，接着就是<code>Environment</code>配置好，<code>ApplicationContext</code>进行初始化完毕，那我们去看<code>ApplicationListener</code>的源码:</p>
<pre><code class="java">/**
 * Listener for the &#123;@link SpringApplication&#125; &#123;@code run&#125; method.
 * &#123;@link SpringApplicationRunListener&#125;s are loaded via the &#123;@link SpringFactoriesLoader&#125;
 * and should declare a public constructor that accepts a &#123;@link SpringApplication&#125;
 * instance and a &#123;@code String[]&#125; of arguments. A new
 * &#123;@link SpringApplicationRunListener&#125; instance will be created for each run.
 *
 * @author Phillip Webb
 * @author Dave Syer
 */
public interface SpringApplicationRunListener &#123;

    /**
     * Called immediately when the run method has first started. Can be used for very
     * early initialization.
     */
    void started();

    /**
     * Called once the environment has been prepared, but before the
     * &#123;@link ApplicationContext&#125; has been created.
     * @param environment the environment
     */
    void environmentPrepared(ConfigurableEnvironment environment);

    /**
     * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but
     * before sources have been loaded.
     * @param context the application context
     */
    void contextPrepared(ConfigurableApplicationContext context);

    /**
     * Called once the application context has been loaded but before it has been
     * refreshed.
     * @param context the application context
     */
    void contextLoaded(ConfigurableApplicationContext context);

    /**
     * Called immediately before the run method finishes.
     * @param context the application context or null if a failure occurred before the
     * context was created
     * @param exception any run exception or null if run completed successfully.
     */
    void finished(ConfigurableApplicationContext context, Throwable exception);

&#125;
</code></pre>
<p>​        看类注释我们可以知道，需要实现此接口内所定义的这几个方法，ok，来看个实现类:</p>
<pre><code class="java">/**
 * &#123;@link SpringApplicationRunListener&#125; to publish &#123;@link SpringApplicationEvent&#125;s.
 * &lt;p&gt;
 * Uses an internal &#123;@link ApplicationEventMulticaster&#125; for the events that are fired
 * before the context is actually refreshed.
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 */
public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;

    private final SpringApplication application;

    private final String[] args;

    private final ApplicationEventMulticaster initialMulticaster;

    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;
        this.application = application;
        this.args = args;
        this.initialMulticaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;
            this.initialMulticaster.addApplicationListener(listener);
        &#125;
    &#125;

    @Override
    public int getOrder() &#123;
        return 0;
    &#125;

    @Override
    public void started() &#123;
        this.initialMulticaster
                .multicastEvent(new ApplicationStartedEvent(this.application, this.args));
    &#125;

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) &#123;
        this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(
                this.application, this.args, environment));
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;

    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        for (ApplicationListener&lt;?&gt; listener : this.application.getListeners()) &#123;
            if (listener instanceof ApplicationContextAware) &#123;
                ((ApplicationContextAware) listener).setApplicationContext(context);
            &#125;
            context.addApplicationListener(listener);
        &#125;
        this.initialMulticaster.multicastEvent(
                new ApplicationPreparedEvent(this.application, this.args, context));
    &#125;

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;
        // Listeners have been registered to the application context so we should
        // use it at this point
        context.publishEvent(getFinishedEvent(context, exception));
    &#125;

    private SpringApplicationEvent getFinishedEvent(
            ConfigurableApplicationContext context, Throwable exception) &#123;
        if (exception != null) &#123;
            return new ApplicationFailedEvent(this.application, this.args, context,
                    exception);
        &#125;
        return new ApplicationReadyEvent(this.application, this.args, context);
    &#125;

&#125;
</code></pre>
<p>​        从上可以看出，<code>EventPublishingRunListener</code>里对接口功能的实现，主要是通过<code>SpringApplication</code> <code>ApplicationEventMulticaster</code> 来实现的，自己不干活，挂个虚名，从上帝模式的角度来看，这不就是应用了装饰模式来实现的么</p>
<h2 id="十四、单例模式"><a href="#十四、单例模式" class="headerlink" title="十四、单例模式"></a>十四、单例模式</h2><p>​        <strong>单例</strong>，我们最常用的设计模式。正如我们在很多Spring Framework中关于单例和原型bean的文章(网上太多了)中已经看到过的，单例是几个bean作用域中的中的一个。此作用域在每个应用程序上下文中仅创建一个给定bean的实例。与signleton设计模式有所区别的是，Spring将实例的数量限制的作用域在整个应用程序的上下文。而Singleton设计模式在Java应用程序中是将这些实例的数量限制在给定类加载器管理的整个空间中。这意味着我们可以为两个Spring的上下文(同一份配置文件起两个容器，也就是不同端口的容器实例)使用相同的类加载器，并检索两个单例作用域的bean。</p>
<p>​        在看Spring单例应用之前，让我们来看一个Java的单例例子：</p>
<pre><code class="java">public class SingletonTest &#123;

  @Test
  public void test() &#123;
    President president1 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    President president2 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    assertTrue(&quot;Both references of President should point to the same object&quot;, president1 == president2);
    System.out.println(&quot;president1 = &quot;+president1+&quot; and president2 = &quot;+president2);
    // sample output
    // president1 = com.migo.test.President@17414c8 and president2 = com.migo.test.President@17414c8

  &#125;

&#125;

enum SingletonsHolder &#123;

  PRESIDENT(new President());

  private Object holdedObject;

  private SingletonsHolder(Object o) &#123;
          this.holdedObject = o;
  &#125;

  public Object getHoldedObject() &#123;
          return this.holdedObject;
  &#125;

&#125;

class President &#123;
&#125;
</code></pre>
<p>​        这个测试例子证明，只有一个由SingletonsHolder所持有的President实例。在Spring中，我们可以在bean工厂中找到单例应用的影子（例如在<strong>org.springframework.beans.factory.config.AbstractFactoryBean中</strong>）：</p>
<pre><code class="java">/**
 * Expose the singleton instance or create a new prototype instance.
 * @see #createInstance()
 * @see #getEarlySingletonInterfaces()
 */
@Override
public final T getObject() throws Exception &#123;
  if (isSingleton()) &#123;
    return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());
  &#125;
  else &#123;
    return createInstance();
  &#125;
&#125;
</code></pre>
<p>​        我们看到，当需求对象被视为单例时，它只被初始化一次，并且在每次使用同一个bean类的实例后返回。我们可以在给定的例子中看到，类似于我们以前看到的President情况。将测试bean定义为：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; /&gt;
</code></pre>
<p>测试用例如下所示：</p>
<pre><code class="java">public class SingletonSpringTest &#123;

  @Test
  public void test() &#123;
    // retreive two different contexts
    ApplicationContext firstContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);
    ApplicationContext secondContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);

    // prove that both contexts are loaded by the same class loader
    assertTrue(&quot;Class loaders for both contexts should be the same&quot;,
      firstContext.getClassLoader() == secondContext.getClassLoader());
    // compare the objects from different contexts
    ShoppingCart firstShoppingCart = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    ShoppingCart secondShoppingCart = (ShoppingCart) secondContext.getBean(&quot;shoppingCart&quot;);
    assertFalse(&quot;ShoppingCart instances got from different application context shouldn&#39;t be the same&quot;,
      firstShoppingCart == secondShoppingCart);

    // compare the objects from the same context
    ShoppingCart firstShoppingCartBis = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;ShoppingCart instances got from the same application context should be the same&quot;,
      firstShoppingCart == firstShoppingCartBis);
  &#125;
&#125;
</code></pre>
<p>​        这个测试案例显示了Spring单例模式与纯粹的单例设计模式的主要区别。尽管使用相同的类加载器来加载两个应用程序上下文，但是ShoppingCart的实例是不一样的。但是，当我们比较两次创建并属于相同上下文的实例时，我们认为它们是相等的。</p>
<p>​        也正因为有了单例，Spring可以控制在每个应用程序上下文中只有一个这样指定的bean的实例可用。因为适配器，Spring可以决定使用由谁来处理<code>JBoss servlet</code>容器中的加载时编织,也可以实现<code>ConfigurableListableBeanFactory</code>的相应实例。第三种设计模式，装饰器，用于向Cache对象添加同步功能，还有Springboot的容器初始化。</p>
<p>​        其实对于适配器和装饰者确实有太多的相似的地方，一个是运行时选择，一个是加料组合产生新的化学效应，还有从看待事物的角度不同得到不同的行为，适配适配，更注重面向接口的实现，而内部又根据不同情况调用面向一套接口的多套实现的实例的相应方法来实现所要实现的具体功能，装饰者更注重添油加醋，通过组合一些其他对象实例来让自己的功能实现的更加华丽一些(达到1+1&gt;2的这种效果)。</p>
<h2 id="十五、命令模式"><a href="#十五、命令模式" class="headerlink" title="十五、命令模式"></a>十五、命令模式</h2><p>​        这篇文章描述的第一个行为设计模式是<strong>命令</strong>。它允许将请求封装在一个对象内并附加一个回调动作(每次遇到所所谓的回调大家就只需要理解为一个函数方法就好，省的去浪费那么多脑子)。请求被封装在命令对象之下，而请求的结果被发送到接收者。命令本身不是由调用者执行。为了直白了解其中的主要思想，想象一下管理服务器的情况(远程通过<code>ssh</code>操作<code>Linux</code>服务器)。管理员（<code>invoker</code>）在命令行（<code>commands</code>）中启动一些操作，将结果发送到服务器（接收器）。在这里,所有这一切都是由客户端的终端(也就是我们用的<code>xshell</code>)来完成的。搞个<code>Demo</code>来说明一下(对于命令，它的动作就是执行，对于管理员来讲，我们的动作其实就是一个回车，执不执行当然是管理员说的算了，执行交给命令对象了，服务器最后就是一个展示结果)：</p>
<pre><code class="java">public class CommandTest &#123;

  // This test method is a client
  @Test
  public void test() &#123;
    Administrator admin = new Administrator();
    Server server = new Server();

    // start Apache
    admin.setCommand(new StartApache(server));
    admin.typeEnter();

    // start Tomcat
    admin.setCommand(new StartTomcat(server));
    admin.typeEnter();

    // check executed commands
    int executed = server.getExecutedCommands().size();
    assertTrue(&quot;Two commands should be executed but only &quot;+
      executed+ &quot; were&quot;, executed == 2);
  &#125;

&#125;

// commands
abstract class ServerCommand &#123;

  protected Server server;

  public ServerCommand(Server server) &#123;
    this.server = server;
  &#125;

  public abstract void execute();
&#125;

class StartTomcat extends ServerCommand &#123;

  public StartTomcat(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service tomcat7 start&quot;);
  &#125;
&#125;

class StartApache extends ServerCommand &#123;

  public StartApache(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service apache2 start&quot;);
  &#125;
&#125;

// invoker
class Administrator &#123;

  private ServerCommand command;

  public void setCommand(ServerCommand command) &#123;
    this.command = command;
  &#125;

  public void typeEnter() &#123;
    this.command.execute();
  &#125;

&#125;

// receiver
class Server &#123;

  // as in common terminals, we store executed commands in history
  private List&lt;String&gt; executedCommands = new ArrayList&lt;String&gt;();

  public void launchCommand(String command) &#123;
    System.out.println(&quot;Executing: &quot;+command+&quot; on server&quot;);
    this.executedCommands.add(command);
  &#125;

  public List&lt;String&gt; getExecutedCommands() &#123;
    return this.executedCommands;
  &#125;

&#125;
</code></pre>
<p>测试应通过并打印两个命令：</p>
<pre><code class="java">Executing: sudo service apache2 start on server
Executing: sudo service tomcat7 start on server
</code></pre>
<p>​        命令模式不仅允许封装请求（ServerCommand）并将其传输到接收器（Server），而且还可以更好地处理给定的请求。在这里，这种更好的处理是通过存储命令的执行历史。在Spring中，我们在beanFactory后置处理器的特性中来找到指令设计模式的原理。要通过快速对它们进行定义，应用程序上下文会启动后置处理器，并可以用来对创建的bean进行一些操作（这里不打算细说了，具体的我后面会专门写一篇这方面的文章，来分析其中的源码细节）。</p>
<p>​        当我们将先前Demo里呈现的命令逻辑转换并对比到<code>Spring bean工厂后处理器</code>时，我们可以区分以下<code>actors</code>：<strong>后置处理器bean</strong>(是指实现<code>BeanFactoryPostProcessor</code>接口)是命令，<strong>org.springframework.context.support.PostProcessorRegistrationDelegate</strong>是调用者(它执行<code>postProcessBeanFactory</code>方法注册所有的后置处理器bean，此处看下面第二段代码)和接收器<strong>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</strong>可以在元素（bean）构造初始化之前修改它们（例如：在初始化bean之前可以更改属性）。</p>
<p>​        另外，回顾下上面的那个Demo，和我们的Demo中的命令历史管理一样。<code>PostProcessorRegistrationDelegate</code>包含一个内部类<code>BeanPostProcessorChecker</code>，它可以记录当一个bean不符合处理条件的情况。</p>
<p>​        可以观察<code>PostProcessorRegistrationDelegate</code>中的两段代码:</p>
<pre><code class="java">/**
     * BeanPostProcessor that logs an info message when a bean is created during
     * BeanPostProcessor instantiation, i.e. when a bean is not eligible for
     * getting processed by all BeanPostProcessors.
     */
    private static class BeanPostProcessorChecker implements BeanPostProcessor &#123;

        private static final Log logger = LogFactory.getLog(BeanPostProcessorChecker.class);

        private final ConfigurableListableBeanFactory beanFactory;

        private final int beanPostProcessorTargetCount;

        public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) &#123;
            this.beanFactory = beanFactory;
            this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
        &#125;

        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;
            return bean;
        &#125;

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) &#123;
            if (bean != null &amp;&amp; !(bean instanceof BeanPostProcessor) &amp;&amp; !isInfrastructureBean(beanName) &amp;&amp;
                    this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount) &#123;
                if (logger.isInfoEnabled()) &#123;
                    logger.info(&quot;Bean &#39;&quot; + beanName + &quot;&#39; of type [&quot; + bean.getClass() +
                            &quot;] is not eligible for getting processed by all BeanPostProcessors &quot; +
                            &quot;(for example: not eligible for auto-proxying)&quot;);
                &#125;
            &#125;
            return bean;
        &#125;

        private boolean isInfrastructureBean(String beanName) &#123;
            if (beanName != null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName)) &#123;
                BeanDefinition bd = this.beanFactory.getBeanDefinition(beanName);
                return RootBeanDefinition.ROLE_INFRASTRUCTURE == bd.getRole();
            &#125;
            return false;
        &#125;
    &#125;
</code></pre>
<p>​        定义后的调用,用的就是<code>ConfigurableListableBeanFactory</code>的实例(看<code>BeanPostProcessorChecker</code>注释):</p>
<pre><code class="java">public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  //BeanPostProcessorChecker
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                    internalPostProcessors.add(pp);
                &#125;
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        sortPostProcessors(beanFactory, orderedPostProcessors);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(beanFactory, internalPostProcessors);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    &#125;
</code></pre>
<blockquote>
<p>总结一个过程就是，我要BeanFactory里面得到对象(也就是为了得到一个命令的执行结果)，那么，想要在得到对象的时候就已经实现了一些对其修改的想法，那么就通过后置处理器，也是就实现了后置处理器接口的beans(命令里可以通过传入不同的参数来得到不同结果，或者对命令的脚本进行修改)，然后还需要一个执行者(我们在做自动化运维的时候，不止操作一个脚本，这里的<code>PostProcessorRegistrationDelegate</code>就是集中来管理这些的)，最后得到的结果就由<code>BeanFactory</code>来展示咯。</p>
</blockquote>
<h2 id="十六、访问者模式"><a href="#十六、访问者模式" class="headerlink" title="十六、访问者模式"></a>十六、访问者模式</h2><p>​        接下来要介绍的一个行为设计模式是<strong>Visitor</strong>:抽象一点就是通过另一种类型的对象来使一个对象访问。在这个简短定义中，使用这个设计模式中的对象将被视为访问者或对象可被访问。第一个访问者要有可访问支持。这个模式的一个现实的例子可以是一个汽车质检员，他们检查一些汽车零件，比如轮子，制动器和发动机，以判断汽车质量是否合格。我们来做个JUnit测试用例：</p>
<pre><code class="java">public class VisitorTest &#123;

  @Test
  public void test() &#123;
    CarComponent car = new Car();
    Mechanic mechanic = new QualifiedMechanic();
    car.accept(mechanic);
    assertTrue(&quot;After qualified mechanics visit, the car should be broken&quot;,
      car.isBroken());
    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();
    car.accept(nonqualifiedMechanic);
    assertFalse(&quot;Car shouldn&#39;t be broken becase non qualified mechanic &quot; +
      &quot; can&#39;t see breakdowns&quot;, car.isBroken());
  &#125;

&#125;

// visitor
interface Mechanic &#123;
  public void visit(CarComponent element);
  public String getName();
&#125;

class QualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;qualified&quot;;
  &#125;
&#125;

class NonQualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;unqualified&quot;;
  &#125;
&#125;

// visitable
abstract class CarComponent &#123;
  protected boolean broken;

  public abstract void accept(Mechanic mechanic);

  public void setBroken(boolean broken) &#123;
    this.broken = broken;
  &#125;

  public boolean isBroken() &#123;
    return this.broken;
  &#125;
&#125;

class Car extends CarComponent &#123;

  private boolean broken = false;
  private CarComponent[] components;

  public Car() &#123;
    components = new CarComponent[] &#123;
      new Wheels(), new Engine(), new Brake()
    &#125;;
  &#125;

  @Override
  public void accept(Mechanic mechanic) &#123;
    this.broken = false;
    if (mechanic.getName().equals(&quot;qualified&quot;)) &#123;
      int i = 0;
      while (i &lt; components.length &amp;&amp; this.broken == false) &#123;
        CarComponent component = components[i];
        mechanic.visit(component);
        this.broken = component.isBroken();
        i++;
      &#125;
    &#125;
    // if mechanic isn&#39;t qualified, we suppose that
    // he isn&#39;t able to see breakdowns and so
    // he considers the car as no broken
    // (even if the car is broken)
  &#125;

  @Override
  public boolean isBroken() &#123;
          return this.broken;
  &#125;
&#125;

class Wheels extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Engine extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Brake extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;
</code></pre>
<p>​        在这个例子中，我们可以看到他们有两个机制(访问者,其实就是免检和不免检)：合格和不合格。暴露于他们的可见对象是汽车。通过其接受方式，决定哪个角色应该适用于被访问者(通过代码<code>mechanic.getName().equals(&quot;qualified&quot;)</code>来判断)。当访问者合格时，Car让他分析所有组件。如果访问者不合格，Car认为其干预是无用的，并且在方法<code>isBroken()</code>中直接返回<code>false</code>(其实就是为了达到一个免检的效果)。<code>Spring在beans配置中实现了访问者设计模式</code>。为了观察，我们可以看看<strong>org.springframework.beans.factory.config.BeanDefinitionVisitor</strong>对象，该对象用于<code>解析bean元数据</code>并将其解析为<code>String</code>（例如：具有作用域或工厂方法名称的XML属性）或<code>Object</code>（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的<code>BeanDefinition</code>实例中进行判断设置。具体的源码请看<code>BeanDefinitionVisitor</code>的代码片段：</p>
<pre><code class="java">/**
 * Traverse the given BeanDefinition object and the MutablePropertyValues
 * and ConstructorArgumentValues contained in them.
 * @param beanDefinition the BeanDefinition object to traverse
 * @see #resolveStringValue(String)
 */
public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;
  visitParentName(beanDefinition);
  visitBeanClassName(beanDefinition);
  visitFactoryBeanName(beanDefinition);
  visitFactoryMethodName(beanDefinition);
  visitScope(beanDefinition);
  visitPropertyValues(beanDefinition.getPropertyValues());
  ConstructorArgumentValues cas = beanDefinition.
    getConstructorArgumentValues();
  visitIndexedArgumentValues(cas.
    getIndexedArgumentValues());
  visitGenericArgumentValues(cas.
    getGenericArgumentValues());
&#125;

protected void visitParentName(BeanDefinition beanDefinition) &#123;
  String parentName = beanDefinition.getParentName();
  if (parentName != null) &#123;
    String resolvedName = resolveStringValue(parentName);
    if (!parentName.equals(resolvedName)) &#123;
      beanDefinition.setParentName(resolvedName);
    &#125;
  &#125;
&#125;
</code></pre>
<p>​        在这种情况下，他们只是访问方式，没有对访问者做任何补充的控制(在Demo里对car的质检员做了控制)。这里访问包括分析给定<code>BeanDefinition</code>的参数，并将其替换为已解析对象。</p>
<p>在这篇关于Spring中设计模式的文章中，我们发现了2种行为模式：<code>用于处理bean工厂的后置处理的命令模式</code>和<code>用于将定义的bean参数转换为面向对象（String或Object的实例）参数的访问者模式</code>。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/">
        <h2>
            SpringBoot整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h1><h2 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h2><h3 id="1-1、选择项目所需要的依赖"><a href="#1-1、选择项目所需要的依赖" class="headerlink" title="1.1、选择项目所需要的依赖"></a>1.1、选择项目所需要的依赖</h3><p><img src="https://img-blog.csdn.net/20180926174507971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="1-2、pom-xml"><a href="#1-2、pom-xml" class="headerlink" title="1.2、pom.xml"></a>1.2、pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;demo&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
 
    &lt;name&gt;demo&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
 
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
 
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
 
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
 
 
&lt;/project&gt;
</code></pre>
<h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>​        本文不使用application.properties文件 而使用更加简洁的application.yml文件。将resource文件夹下原有的application.properties文件删除，创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties），本文创建了两个yml文件（application.yml和application-dev.yml），分别来看一下内容</p>
<ul>
<li>application.yml</li>
</ul>
<pre><code class="yml">spring:
  profiles:
    active: dev
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8080
 
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
</code></pre>
<p>​        两个文件的意思是：</p>
<blockquote>
<p>在项目中配置多套环境的配置方法。<br>因为现在一个项目有好多环境，开发环境，测试环境，准生产环境，生产环境，每个环境的参数不同，所以我们就可以把每个环境的参数配置到yml文件中，这样在想用哪个环境的时候只需要在主配置文件中将用的配置文件写上就行如application.yml</p>
<p>笔记：在Spring Boot中多环境配置文件名需要满足application-{profile}.yml的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.yml：开发环境<br>application-test.yml：测试环境<br>application-prod.yml：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.yml文件中通过<strong>spring.profiles.active属性</strong>来设置，其值对应{profile}值。</p>
</blockquote>
<p>​        还有配置文件中最好不要有中文注释，会报错。</p>
<p>​        接下来把启动文件移到com.example下，而且springboot的启动类不能放在java目录下！！！必须要个包将它包进去</p>
<p>​        否则会报错误：</p>
<pre><code class="java">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.
</code></pre>
<p>​        这个原因值得注意就是因为有时候很难在IDEA中的项目目录认出来这个错误并且还容易扫描不到一些类</p>
<h2 id="二、创建类"><a href="#二、创建类" class="headerlink" title="二、创建类"></a>二、创建类</h2><p>​        创建包controller、entity、mapper、service。resources下创建mapping文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。下面直接贴代码</p>
<h3 id="2-1、创建实体类"><a href="#2-1、创建实体类" class="headerlink" title="2.1、创建实体类"></a>2.1、创建实体类</h3><h4 id="2-1-1、数据库表结构"><a href="#2-1-1、数据库表结构" class="headerlink" title="2.1.1、数据库表结构"></a>2.1.1、数据库表结构</h4><pre><code class="sql">CREATE TABLE `user` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `userName` varchar(32) NOT NULL,
  `passWord` varchar(50) NOT NULL,
  `realName` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre>
<p><img src="https://img-blog.csdn.net/20180927092715962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>entity.java</li>
</ul>
<pre><code class="java">package com.example.entity;
 
@Data
public class User &#123;
    private Integer id;
    private String userName;
    private String passWord;
    private String realName;
&#125;
</code></pre>
<ul>
<li>UserController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
@RequestMapping(&quot;/testBoot&quot;)
public class UserController &#123;
 
    @Autowired
    private UserService userService;
 
    @RequestMapping(&quot;getUser/&#123;id&#125;&quot;)
    public String GetUser(@PathVariable int id)&#123;
        return userService.Sel(id).toString();
    &#125;
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
&#125;
</code></pre>
<ul>
<li>UserMappering.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;com.example.entity.User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
&lt;/mapper&gt;
</code></pre>
<p>最终框架结构</p>
<p><img src="https://img-blog.csdn.net/20180927095234881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>启动类</li>
</ul>
<pre><code class="java">package com.example;
 
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
 
@MapperScan(&quot;com.example.mapper&quot;) //扫描的mapper
@SpringBootApplication
public class DemoApplication &#123;
 
    public static void main(String[] args) &#123;
        SpringApplication.run(DemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="三、注册、登录以及拦截器配置"><a href="#三、注册、登录以及拦截器配置" class="headerlink" title="三、注册、登录以及拦截器配置"></a>三、注册、登录以及拦截器配置</h2><ul>
<li>添加依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8888
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    prefix: classpath:/templates/
    suffix: .html
    encoding: utf-8
    mode: html5
    servlet:
      content-type: text/html
</code></pre>
<ul>
<li>register.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;form action=&quot;/user/register&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Register&quot;/&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot; type=&quot;text/css&quot; /&gt;--&gt;
&lt;form action=&quot;/user/loginUser&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;
    &lt;a href=&quot;/user/toRegister&quot;&gt;--注册--&lt;/a&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>welcome.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
注册或登录后才能看到的界面
 
&lt;a href=&quot;/user/outUser&quot;&gt;退出登录&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>LoginController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController &#123;
    @Autowired
    private UserService userService;
 
    //跳转首页（登录页）
    @RequestMapping(&quot;/toIndex&quot;)
    public String show()&#123;
        return &quot;index&quot;;
    &#125;
 
    //登录操作
    @ResponseBody
    @RequestMapping(&quot;/loginUser&quot;)
    public String login(User user, HttpServletRequest request)&#123;
        String userName = user.getUserName();
        String passWord = user.getPassWord();
        User u1 =userService.login(userName,passWord);
        if (u1==null)&#123;
            return &quot;用户名或密码错误&quot;;
        &#125;else&#123;
            request.getSession().setAttribute(&quot;session_user&quot;,user);//登录成功后将用户放入session中，用于拦截
            return &quot;登录成功&quot;;
        &#125;
    &#125;
 
    //跳转注册页
    @RequestMapping(&quot;/toRegister&quot;)
    public String toRegister()&#123;
        return &quot;register&quot;;
    &#125;
 
    //注册操作
    @RequestMapping(&quot;/register&quot;)
    public String register(User user)&#123;
        int su = userService.register(user);
        if(su==0)&#123;
            System.out.println(&quot;----&quot;);
        &#125;
        return &quot;welcome&quot;;
    &#125;
 
    //测试未登陆拦截页面
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome()&#123;
        return &quot;welcome&quot;;
    &#125;
 
    //退出登录
    @RequestMapping(&quot;/outUser&quot;)
    public void outUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        request.getSession().removeAttribute(&quot;session_user&quot;);
        response.sendRedirect(&quot;/user/toIndex&quot;);
    &#125;
 
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
 
    public User login(String userName, String passWord) &#123;
        return userMapper.login(userName,passWord);
    &#125;
 
    public int register(User user) &#123;
        return userMapper.register(user);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
 
    User login(String userName,String passWord);
 
    int register(User user);
&#125;
</code></pre>
<ul>
<li>UserMapping.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
    &lt;select id=&quot;login&quot; resultType=&quot;User&quot;&gt;
        SELECT * FROM user where userName = #&#123;param1&#125; and passWord = #&#123;param2&#125;
    &lt;/select&gt;
 
    &lt;insert id=&quot;register&quot; parameterType=&quot;User&quot;&gt;
        INSERT INTO user (userName, passWord) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>其实注册登录也诶逻辑也很简单，就不多赘述了，接下来讲讲实现拦截器功能（敲黑板，本章的重点）</p>
<p>首先在com.example下新建intercetor包，然后新建UserIntercetor.java实现HandlerInterceptor接口并重写方法，更多介绍都写在里面注释了</p>
<ul>
<li>UserIntercetor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import com.example.entity.User;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Component
public class UserInterceptor implements HandlerInterceptor &#123;
 
    /*
     * 进入controller层之前拦截请求
     * 返回值：表示是否将当前的请求拦截下来  false：拦截请求，请求别终止。true：请求不被拦截，继续执行
     * Object obj:表示被拦的请求的目标对象（controller中方法）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;
        System.out.println(&quot;执行到了preHandle方法&quot;);
        System.out.println(handler);
        User user = (User) request.getSession().getAttribute(&quot;session_user&quot;);
        if (user==null)&#123;
            response.sendRedirect(request.getContextPath()+&quot;/user/toIndex&quot;);//拦截后跳转的方法
            System.out.println(&quot;已成功拦截并转发跳转&quot;);
            return false;
        &#125;
        System.out.println(&quot;合格不需要拦截，放行&quot;);
        return true;
    &#125;
 
    /*
     * 处理请求完成后视图渲染之前的处理操作
     * 通过ModelAndView参数改变显示的视图，或发往视图的方法
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;
        System.out.println(&quot;执行了postHandle方法&quot;);
    &#125;
 
    /*
     * 视图渲染之后的操作
     */
    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;
        System.out.println(&quot;执行到了afterCompletion方法&quot;);
    &#125;
 
&#125;
</code></pre>
<p>新建类SessionInterceptor实现WebMvcConfigurer接口来注册拦截器</p>
<ul>
<li>SessionInterceptor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
import java.util.ArrayList;
import java.util.List;

@Configuration
public class SessionInterceptor implements WebMvcConfigurer &#123;
 
    /**
     * 自定义拦截器，添加拦截路径和排除拦截路径
     * addPathPatterns():添加需要拦截的路径
     * excludePathPatterns():添加不需要拦截的路径
     */
    //注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        List list = new ArrayList();
        list.add(&quot;/user/toIndex&quot;);
        list.add(&quot;/user/loginUser&quot;);
        list.add(&quot;/user/toRegister&quot;);
        list.add(&quot;/user/register&quot;);
        registry.addInterceptor(new UserInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(list);
 
    &#125;
&#125;
</code></pre>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>4.1、application.yml文件中文注释乱码</p>
<pre><code class="yml">server:
  port: 8080
  servlet:
    jsp:
      init-parameters:
        # jsp修改之后立即生效
        development: true
</code></pre>
<p><img src="https://img-blog.csdn.net/20180908114638271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4ODcwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot" style=color:#ff7d73>
                SpringBoot
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/">
        <h2>
            SpringMVC使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringMVC使用详解"><a href="#SpringMVC使用详解" class="headerlink" title="SpringMVC使用详解"></a>SpringMVC使用详解</h1><h2 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h2><h3 id="1-1、什么是-SpringMVC"><a href="#1-1、什么是-SpringMVC" class="headerlink" title="1.1、什么是 SpringMVC"></a>1.1、什么是 SpringMVC</h3><p>​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架</p>
<h3 id="1-2、为什么学习-SpringMVC"><a href="#1-2、为什么学习-SpringMVC" class="headerlink" title="1.2、为什么学习 SpringMVC"></a>1.2、为什么学习 SpringMVC</h3><p>​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定大于配置，能够进行简单的 junit 测试，支持 Restful 风格，异常处理，本地化，国际化，数据验证，类型转换，拦截器，等等</p>
<h3 id="1-3、SpringMVC-的特点"><a href="#1-3、SpringMVC-的特点" class="headerlink" title="1.3、SpringMVC 的特点"></a>1.3、SpringMVC 的特点</h3><ul>
<li>简单好学</li>
<li>高效（基于请求相应的 MVC 框架）</li>
<li>与 Spring 无缝集成，兼容性好</li>
<li>约定大于配置</li>
<li>功能强大（Restful、数据验证、格式化、本地化、类型转换、等等）</li>
<li>简洁灵活</li>
</ul>
<h2 id="二、中心控制器"><a href="#二、中心控制器" class="headerlink" title="二、中心控制器"></a>二、中心控制器</h2><p>​        Spring 的 web 框架围绕 DispatcherServlet 设计。<strong>DispatcherServlet 的作用是将请求分发到不同的处理器</strong>。从 Spring 2.5 开始，使用 Java 5 或者以上版本的用户可以采用基于注解的 controller 声明方式。</p>
<p>​        Spring MVC 框架像许多其他 MVC 框架一样, 以请求为驱动 , 围绕一个中心 Servlet 分派请求及提供其他功能，DispatcherServlet 是一个实际的 Servlet (它继承自 HttpServlet 基类)。</p>
<p><img src="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        SpringMVC的原理如下图所示：</p>
<ul>
<li>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</li>
</ul>
<h2 id="三、SpringMVC原理"><a href="#三、SpringMVC原理" class="headerlink" title="三、SpringMVC原理"></a>三、SpringMVC原理</h2><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringMVC执行原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet 表示前置控制器，是整个 SpringMVC 的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。</p>
<p>​        我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p>​        如上 url 拆分成三部分：</p>
<ul>
<li><p> <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 服务器域名</p>
</li>
<li><p> SpringMVC 部署在服务器上的 web 站点</p>
</li>
<li><p>hello 表示控制器</p>
</li>
</ul>
<p> 通过分析，如上 url 表示为：请求位于服务器 localhost:8080上的Spring MVC站点的 hello 控制器。</p>
</li>
<li><p>HandlerMapping 为处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</p>
</li>
<li><p>HandlerExecution 表示具体的Handler，其主要作用是根据 url 查找控制器，如上 url 被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution 将解析后的信息传递给 DispatcherServlet，如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行 Handler。</p>
</li>
<li><p>Handler 让具体的 Controller 执行。</p>
</li>
<li><p>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</p>
</li>
<li><p>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="四、HelloSpringMVC"><a href="#四、HelloSpringMVC" class="headerlink" title="四、HelloSpringMVC"></a>四、HelloSpringMVC</h2><h3 id="4-1、配置版"><a href="#4-1、配置版" class="headerlink" title="4.1、配置版"></a>4.1、配置版</h3><p><strong>步骤：</strong></p>
<ol>
<li>新建一个 项目，添加 web 支持</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件（springmvc-service.xml）</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
</ol>
<pre><code class="xml">&lt;!--配置DispatchServlet：这个是SpringMVC的核心：请求分发器，前端控制器--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--DispatchServlet要绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-service.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--
    在Spring中，/ 与 /* 的区别
    /:只匹配所有的请求，不会去匹配jsp
    /*：匹配所有请求，包括jsp页面
--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>继续配置 SpringMVC 的配置文件（springmvc-servlet.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>添加 <strong>处理映射器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>处理器适配器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>视图解析器</strong></li>
</ul>
<pre><code class="xml">&lt;!--视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="6">
<li>编写操作业务的 Controller</li>
</ol>
<ul>
<li>要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图</li>
</ul>
<pre><code class="java">public class HelloController implements Controller &#123;
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //业务代码
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC！&quot;);
        
        //视图解释
        mv.setViewName(&quot;hello&quot;);//需要拼接的视图名称，参考视图解析器的代码实际地址就是（/WEB-INF/jsp/hello.jsp）
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>注册 bean（将 HelloController 这个类交给 Spring 容器【IOC】）</li>
</ol>
<pre><code class="xml">&lt;!--BeanNameUrlHandlerMapping:匹配的id(Handler)--&gt;
&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.aze.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="8">
<li>编写跳转页面，显示 ModelandView 存放的数据，以及我们编写的页面</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><strong>大多数都会遇到的问题！</strong></p>
<p>即使你的代码正确，但是却一直报出 404 错误！</p>
<ul>
<li><p>问题原因可能就在于 IDEA 项目发布中，缺少了 springMVC 相关的 jar 包</p>
</li>
<li><p>解决办法：</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>在 WEB-INF 下创建一个 lib 目录，在这个目录下存放 相关的 jar 包</p>
<p><img src="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将所有的<strong>包</strong>导入，点击 ok</p>
</li>
</ul>
</li>
</ul>
<p>​                </p>
<p><img src="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2、注解版（-）"><a href="#4-2、注解版（-）" class="headerlink" title="4.2、注解版（*）"></a>4.2、注解版（*）</h3><p>步骤：</p>
<ol>
<li>新建一个项目，添加 web 支持</li>
<li>解决 Maven 可能存在资源过滤的问题</li>
</ol>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ol start="3">
<li><p>在 pom.xml 文件引入相关的依赖：主要有 Spring 框架核心库、Spring MVC、servlet , JSTL 等</p>
</li>
<li><p>配置 web.xml</p>
</li>
</ol>
<pre><code class="xml">&lt;!--这是使用注解开发时固定的配置--&gt;
&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--初始化Spring配置文件的位置--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动顺序，数字越小，启动越早--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--所有的请求都会被SpringMVC拦截--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>编写 springmvc-servlet.xml 配置文件</li>
</ol>
<ul>
<li>配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能</li>
<li>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问<ul>
<li>让IOC的注解生效（context:component-scan base-package=””）</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …（mvc:default-servlet-handler）</li>
<li>MVC的注解驱动（mvc:annotation-driven）</li>
<li>配置视图解析器（开发中，程序员只需要配置这一步，其他的都是死的，CV 就可以）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
    &lt;!--这也是固定配置，需要修改的只有需要注入IOC的包--&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="6">
<li>编写一个 Java 控制类 HelloController.java</li>
</ol>
<ul>
<li>@Controller 是为了让 Spring IOC 容器初始化时自动扫描到；</li>
<li>@RequestMapping 是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是 /hello/hi；</li>
<li>方法中声明 Model 类型的参数是为了把 Action 中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称 hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</li>
</ul>
<pre><code class="java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    //类上注册了@RequestMapping方法就自动下移，实际地址：项目名/hello/hi
    @RequestMapping(&quot;/hi&quot;)
    public String sayHello(Model model)&#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVCAnnotatiom!&quot;);
        //web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>编写视图层 hello.jsp</li>
</ol>
<ul>
<li>视图可以直接取出并展示从 Controller 带回的信息；</li>
<li>可以通过 EL 表示取出 Model 中存放的值，或者对象</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h3 id="4-3、结论"><a href="#4-3、结论" class="headerlink" title="4.3、结论"></a>4.3、结论</h3><p>实现步骤：</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
<li><p>编写 web.xml , 注册 DispatcherServlet</p>
</li>
<li><p>编写 springmvc 配置文件</p>
</li>
<li><p>接下来就是去创建对应的控制类 , controller</p>
</li>
<li><p>最后完善前端视图和 controller 之间的对应</p>
</li>
<li><p>测试运行调试.</p>
</li>
</ol>
<p><strong>使用springMVC必须配置的三大件：</strong></p>
<ul>
<li><p>处理器映射器</p>
</li>
<li><p>处理器适配器</p>
</li>
<li><p>视图解析器</p>
</li>
</ul>
<p>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。</p>
<h2 id="五、注解"><a href="#五、注解" class="headerlink" title="五、注解"></a>五、注解</h2><h3 id="5-1、Controller"><a href="#5-1、Controller" class="headerlink" title="5.1、Controller"></a>5.1、Controller</h3><p>Controller 控制器</p>
<p>负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
<p>负责解析用户的请求并将其转换为一个模型。</p>
<p>在 Spring MVC 中一个控制器类可以包含多个方法</p>
<p>在 Spring MVC 中，对于 Controller 的配置方式有很多种</p>
<h4 id="5-1-1、实现-Controller-接口"><a href="#5-1-1、实现-Controller-接口" class="headerlink" title="5.1.1、实现 Controller 接口"></a>5.1.1、实现 Controller 接口</h4><p>Controller是一个接口</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p>步骤：（上面 HelloSpringMVC 的配置版就是 实现 Controller 接口）</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入 SpringMVC 的依赖</p>
</li>
<li><p>创建 SpringMVC 的配置文件（springmvc-service.xml）</p>
<ul>
<li>删掉 HelloController</li>
<li>只留下 视图解析器！</li>
</ul>
</li>
<li><p>配置 web.xml，注册 DispatcherServlet</p>
</li>
<li><p>编写一个 Controller 类</p>
</li>
<li><p>编写完毕后，去 Spring 配置文件中注册请求的 bean</p>
<ul>
<li>name 对应请求路径</li>
<li>class 对应处理请求的类</li>
</ul>
</li>
<li><p>编写前端 hello.jsp</p>
<ul>
<li>注意：在 WEB-INF/jsp 目录下编写，对应我们的视图解析器</li>
</ul>
</li>
<li><p>配置 Tomcat 运行测试<br>注意：实现接口 Controller 定义控制器是较老的办法<br>缺点：</p>
<ul>
<li>一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</li>
<li>定义的方式比较麻烦；</li>
</ul>
</li>
</ol>
<h4 id="5-1-2、注解-Controller"><a href="#5-1-2、注解-Controller" class="headerlink" title="5.1.2、注解 @Controller"></a>5.1.2、注解 @Controller</h4><ul>
<li>@Controller 注解类型用于声明 Spring 类的实例是一个控制器（<ul>
<li><strong>@Controller：</strong>用于controller</li>
<li><strong>@Component：</strong>用于组件</li>
<li><strong>@Repository：</strong>用于 dao</li>
<li><strong>@Service：</strong>用于 service</li>
</ul>
</li>
<li>Spring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证 Spring 能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<p>步骤：（4.2 注解版就是用注解 @Controller）</p>
<ol>
<li>新建一个 web 项目</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
<li>编写一个 Controller 类</li>
<li>使用注解（）</li>
<li>编写前端 hello.jsp</li>
<li>配置 Tomcat 运行测试</li>
</ol>
<h3 id="5-2、RequestMapping"><a href="#5-2、RequestMapping" class="headerlink" title="5.2、RequestMapping"></a>5.2、RequestMapping</h3><ul>
<li>@RequestMapping<pre><code>+ @RequestMapping 注解用于映射 url 到控制器类或一个特定的处理程序方法。
</code></pre>
可用于类或方法上<ul>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<ul>
<li>用于方法上，方法的响应请求是该地址</li>
</ul>
</li>
</ul>
<strong>建议：</strong>类上不要使用此注解</li>
</ul>
<h2 id="六、RestFul风格"><a href="#六、RestFul风格" class="headerlink" title="六、RestFul风格"></a>六、RestFul风格</h2><h3 id="6-1、什么是-RestFul"><a href="#6-1、什么是-RestFul" class="headerlink" title="6.1、什么是 RestFul"></a>6.1、什么是 RestFul</h3><p>Restful 就是一个资源定位及资源操作的风格。</p>
<ul>
<li>不是标准也不是协议，只是一种风格</li>
<li>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
</ul>
<h3 id="6-2、RestFul-功能"><a href="#6-2、RestFul-功能" class="headerlink" title="6.2、RestFul 功能"></a>6.2、RestFul 功能</h3><p>资源：互联网所有的事物都可以被抽象为资源</p>
<ul>
<li><p>资源操作：使用 POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
</li>
<li><p>分别对应 添加、 删除、修改、查询。</p>
</li>
</ul>
<p><strong>传统方式操作资源 ：</strong>通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源 ：</strong>可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<h3 id="6-3、测试-RestFul-风格"><a href="#6-3、测试-RestFul-风格" class="headerlink" title="6.3、测试 RestFul 风格"></a>6.3、测试 RestFul 风格</h3><h4 id="6-3-1、使用-RequestMapping"><a href="#6-3-1、使用-RequestMapping" class="headerlink" title="6.3.1、使用 @RequestMapping"></a>6.3.1、使用 @RequestMapping</h4><p>步骤：</p>
<ol>
<li><p>新建一个 Controller 类，用于测试 RestFul 风格</p>
</li>
<li><p>在 Spring MVC 中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
</li>
</ol>
<pre><code class="java">@Controller
public class RestFulTest &#123;

    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;
        int result = a + b;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;hello&quot;;
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>修改下对应的参数类型，再次测试</li>
</ol>
<pre><code class="java">// 将 int b，改为 String b
@PathVariable int a, @PathVariable String b
    
// 对应的 result 也需要改为 String
String result = a+b;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="6-3-2、使用注解变体"><a href="#6-3-2、使用注解变体" class="headerlink" title="6.3.2、使用注解变体"></a>6.3.2、使用注解变体</h4><p>使用method属性指定请求类型：</p>
<ul>
<li>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE 等</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<p>问题？</p>
<p>​        这样写，代码量就会变多，这时候，注解变体他来了！<br>注解变体：（方法级别）</p>
<ul>
<li>@GetMapping：GET 类型</li>
<li>@PostMapping：POST 类型</li>
<li>@PutMapping：PUT 类型</li>
<li>@DeleteMapping：DELETE 类型</li>
<li>@PatchMapping：PATCH 类型</li>
</ul>
<pre><code class="java">// 使用注解变体
@GetMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
// 等价于 @RequestMapping(value = &quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<h3 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h3><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。（注意！！！）</p>
<p><strong>@GetMapping 是一个组合注解</strong>，平时使用的会比较多！</p>
<p>使用浏览器地址栏进行访问默认是 Get 请求，会报错 405</p>
<p>解决办法：将 POST 修改为 GET 就好了</p>
<h2 id="七、转发与重定向"><a href="#七、转发与重定向" class="headerlink" title="七、转发与重定向"></a>七、转发与重定向</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置 ModelAndView 对象 , 根据 view 的名称 , 和视图解析器跳到指定的页面 .</p>
<ul>
<li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li>
</ul>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>controller 类</li>
</ul>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>这是 JavaWeb 中学习到的用法：</p>
<ul>
<li>通过设置 ServletAPI，不需要视图解析器 .<ol>
<li>通过 HttpServletResponse 进行输出</li>
</ol>
</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/test1&quot;)
public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
&#125;
</code></pre>
<p>​        2. 通过 HttpServletResponse 实现重定向（重定向）</p>
<pre><code class="java">@RequestMapping(&quot;test2&quot;)
public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.sendRedirect(&quot;/index.jsp&quot;);
&#125;
</code></pre>
<ol start="3">
<li>通过 HttpServletResponse 实现转发（请求转发）</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/test3&quot;)
public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
    // 转发
    req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
    req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
&#125;
</code></pre>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><h4 id="7-3-1、无视图解析器"><a href="#7-3-1、无视图解析器" class="headerlink" title="7.3.1、无视图解析器"></a>7.3.1、无视图解析器</h4><pre><code class="java">@RequestMapping(&quot;/rsm/t1&quot;)
public String test1()&#123;
    // 默认就是转发
    return &quot;/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t2&quot;)
public String test2()&#123;
    // 也可以显示定义转发
    return &quot;forward:/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t3&quot;)
public String test3()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
<h4 id="7-3-2、有视图解析器"><a href="#7-3-2、有视图解析器" class="headerlink" title="7.3.2、有视图解析器"></a>7.3.2、有视图解析器</h4><p>​        重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方 , 所以注意路径问题.</p>
<pre><code class="java">@RequestMapping(&quot;/rsm2/t1&quot;)
public String test1()&#123;
    // 转发：默认就是转发
    return &quot;test&quot;;
&#125;

@RequestMapping(&quot;/rsm2/t2&quot;)
public String test2()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
    // return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
&#125;
</code></pre>
<h2 id="八、数据处理"><a href="#八、数据处理" class="headerlink" title="八、数据处理"></a>八、数据处理</h2><h3 id="8-1、处理提交数据"><a href="#8-1、处理提交数据" class="headerlink" title="8.1、处理提交数据"></a>8.1、处理提交数据</h3><ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数名不一致，就需要使用注解 @RequestParam 来解决</li>
</ol>
<pre><code class="java">// @RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<ul>
<li>实体类</li>
</ul>
<pre><code class="java">// 这里使用的是 Lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private int age;
&#125;
</code></pre>
<ul>
<li>Controller 类</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<h3 id="8-2、数据显示到前端"><a href="#8-2、数据显示到前端" class="headerlink" title="8.2、数据显示到前端"></a>8.2、数据显示到前端</h3><ol>
<li>通过 ModelAndView</li>
</ol>
<pre><code class="java">public class ControllerTest implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>通过ModelMap</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>通过 Model</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<p>区别：</p>
<ul>
<li><p>Model：只有寥寥几个方法只适合用于储存数据，简化了新手对于 Model 对象的操作和理解</p>
</li>
<li><p>ModelMap：继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView：可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<h2 id="九、中文乱码问题"><a href="#九、中文乱码问题" class="headerlink" title="九、中文乱码问题"></a>九、中文乱码问题</h2><p>解决办法：</p>
<ol>
<li>自我编写一个过滤器，再注册到 web.xml 文件中</li>
</ol>
<pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;

    // 初始化：web 服务器启动，就已经初始化了，随时等待过滤对象的出现
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    // 销毁：web 服务器关闭时，过滤器会销毁
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用 SpringMVC 自带的过滤器</li>
</ol>
<ul>
<li>导入相关依赖后，直接配置 web.xml 即可</li>
</ul>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="3">
<li>使用大佬配置的过滤器</li>
</ol>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                                       .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
<p>​        以上都不行可能是你的 Tomcat 没有配置好！去修改 tomcat 配置文件 ：设置编码</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<h2 id="十、Json"><a href="#十、Json" class="headerlink" title="十、Json"></a>十、Json</h2><ul>
<li>JSON（JavaScript Object Notation, JS 对象标记） 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。（前后端分离）</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<h3 id="10-1、JSON-与-JavaScript"><a href="#10-1、JSON-与-JavaScript" class="headerlink" title="10.1、JSON 与 JavaScript"></a>10.1、JSON 与 JavaScript</h3><p>在 JavaScript 语言中，一切都是对象。因此，任何 JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li><p>对象表示为键值对，数据由逗号分隔</p>
</li>
<li><p>花括号保存对象</p>
</li>
<li><p>方括号保存数组</p>
</li>
</ul>
<p>​        <strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值（ {“键” : “值”} ）。</p>
<p>​        JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br><strong>JSON 和 JavaScript 对象互转：</strong></p>
<ul>
<li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法</li>
</ul>
<pre><code class="java">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);
</code></pre>
<ul>
<li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法</li>
</ul>
<pre><code class="java">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
<h3 id="10-2、Controller-返回-JSON-数据"><a href="#10-2、Controller-返回-JSON-数据" class="headerlink" title="10.2、Controller 返回 JSON 数据"></a>10.2、Controller 返回 JSON 数据</h3><ul>
<li>Jackson 应该是目前比较好的 json 解析工具了</li>
<li>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</li>
<li>这里使用的是 Jackson，使用它需要导入它的 jar 包；</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>web.xml 配置 SpringMVC 需要的配置<ul>
<li>servlet 注册 SpringMVC</li>
<li>filter 注册字符过滤器</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ul>
<li>编写 springmvc-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>编写一个实体类 User，去测试<ul>
<li>需要导入 lombok 的 jar 包</li>
</ul>
</li>
</ul>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<ul>
<li>编写 UserController<ul>
<li>@ResponseBody：将 java 对象转化为 json</li>
<li>ObjectMapper：创建一个 jackson 的对象映射器，用来解析数据</li>
</ul>
</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置 Tomcat</li>
<li>配置 Artifacts</li>
</ul>
<p>问题：乱码问题</p>
<p><img src="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center" alt="在这里插入图片描述"></p>
<p>解决办法：通过 @RequestMaping 的 produces 属性来实现</p>
<pre><code class="java">// produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
<h3 id="10-3、Controller-返回-JSON-数据代码优化"><a href="#10-3、Controller-返回-JSON-数据代码优化" class="headerlink" title="10.3、Controller 返回 JSON 数据代码优化"></a>10.3、Controller 返回 JSON 数据代码优化</h3><h4 id="10-3-1、将乱码问题统一解决"><a href="#10-3-1、将乱码问题统一解决" class="headerlink" title="10.3.1、将乱码问题统一解决"></a>10.3.1、将乱码问题统一解决</h4><p>上面解决乱码的方法在项目请求多的情况下就不适用了</p>
<p>就可以使用 Spring 配置统一指定返回类型和编码，等等</p>
<ul>
<li>在 spring-mvc 的配置文件上添加一段消息<ul>
<li>StringHttpMessageConverter 转换配置</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<h4 id="10-3-2、统一解决返回为-json-字符串问题"><a href="#10-3-2、统一解决返回为-json-字符串问题" class="headerlink" title="10.3.2、统一解决返回为 json 字符串问题"></a>10.3.2、统一解决返回为 json 字符串问题</h4><p>如果类中有所有的方法都需要返回 json 字符串，那么所有的方法都需要标识注释 @ResponseBody，这将会特别麻烦</p>
<ul>
<li>所以直接在类上使用 @RestController 来标注这个类的所有方法返回的都是 json 字符串<ul>
<li>这样就不用再每个方法上写 @ResponseBody</li>
<li>前后端分离开发中，一般都会使用 @RestController ，十分便捷</li>
</ul>
</li>
</ul>
<h3 id="10-4、测试集合的输出"><a href="#10-4、测试集合的输出" class="headerlink" title="10.4、测试集合的输出"></a>10.4、测试集合的输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
public String json2() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();

    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛逼1&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼2&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼3&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼4&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼5&quot;,18,&quot;男&quot;));

    return mapper.writeValueAsString(userList);
&#125;
</code></pre>
<h3 id="10-5、测试时间对象输出"><a href="#10-5、测试时间对象输出" class="headerlink" title="10.5、测试时间对象输出"></a>10.5、测试时间对象输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();
    Date date = new Date();
    // 默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式
    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<p>默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式：</p>
<ul>
<li>取消 timestamps（时间戳）形式，自定义时间格式</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();

    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<h3 id="10-6、将重复代码抽取为工具类"><a href="#10-6、将重复代码抽取为工具类" class="headerlink" title="10.6、将重复代码抽取为工具类"></a>10.6、将重复代码抽取为工具类</h3><p>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中</p>
<pre><code class="java">public class JsonUtils &#123;
    public static String getJson(Object object)&#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat)&#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>使用工具类后的代码量</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    return JsonUtils.getJson(new Date());
&#125;
</code></pre>
<h3 id="10-7、FastJson"><a href="#10-7、FastJson" class="headerlink" title="10.7、FastJson"></a>10.7、FastJson</h3><p>fastjson.jar 是阿里开发的一款专门用于 Java 开发的包，可以方便的实现多种转换，最后的实现结果都是一样的。</p>
<ul>
<li><p>实现 json 对象与 JavaBean 对象的转换</p>
</li>
<li><p>实现 JavaBean 对象与 json 字符串的转换</p>
</li>
<li><p>实现 json 对象与 json 字符串的转换。实现 son的 转换方法很多</p>
</li>
</ul>
<p><strong>fastjson 的 pom 依赖：</strong></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.78&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject 实现了 Map 接口, 猜想 JSONObject 底层操作是由 Map 实现的。</li>
<li>JSONObject 对应 json对 象，通过各种形式的 get() 方法可以获取 json 对象中的数据，也可利用诸如 size()，isEmpty() 等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有 List 接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON 代表 JSONObject 和 JSONArray 的转化</strong></p>
<ul>
<li>JSON 类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现 json 对象，json 对象数组，javabean 对象，json 字符串之间的相互转化。</li>
</ul>
<p>代码测试：</p>
<pre><code class="java">@RequestMapping(&quot;/json6&quot;)
public String json6()&#123;
    //创建一个对象
    User user1 = new User(&quot;1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    userList.add(user4);

    System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
    String str1 = JSON.toJSONString(userList);
    System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
    String str2 = JSON.toJSONString(user1);
    System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

    System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
    User jp_user1=JSON.parseObject(str2,User.class);
    System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

    System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
    JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
    System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

    System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
    User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
    System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    
    return JSON.toJSONString(userList);
&#125;
</code></pre>
<h2 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h2><h3 id="11-1、什么是-Ajax"><a href="#11-1、什么是-Ajax" class="headerlink" title="11.1、什么是 Ajax"></a>11.1、什么是 Ajax</h3><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML。</li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
<li>传统的网页（即不用 ajax 技术的网页），想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</li>
</ul>
<h3 id="11-2、Ajax-原理"><a href="#11-2、Ajax-原理" class="headerlink" title="11.2、Ajax 原理"></a>11.2、Ajax 原理</h3><p><img src="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="11-3、伪造-Ajax"><a href="#11-3、伪造-Ajax" class="headerlink" title="11.3、伪造 Ajax"></a>11.3、伪造 Ajax</h3><ol>
<li>新建一个项目，导入 web 支持</li>
<li>编写一个 前端页面，使用 iframe 进行测试</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function x() &#123;
            var url =  document.getElementById(&#39;url&#39;).value;
            document.getElementById(&#39;iframePosition&#39;).src = url;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;p&gt;请输入地址：&lt;/p&gt;
    &lt;p&gt;
        &lt;input id=&quot;url&quot; type=&quot;text&quot; placeholder=&quot;网页地址&quot;/&gt;
        &lt;input type=&quot;button&quot; value=&quot;前往&quot; onclick=&quot;x()&quot;&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 666px&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-4、jQuery-操作-ajax"><a href="#11-4、jQuery-操作-ajax" class="headerlink" title="11.4、jQuery 操作 ajax"></a>11.4、jQuery 操作 ajax</h3><ul>
<li>使用jquery提供的，方便，有兴趣的可以自己去了解下 JS 原生 XMLHttpRequest ！<ul>
<li>Ajax 的核心是 XMLHttpRequest 对象（XHR）。XHR 为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
</ul>
</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="js">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<h3 id="11-5、原始的-HttpServletResponse-实现"><a href="#11-5、原始的-HttpServletResponse-实现" class="headerlink" title="11.5、原始的 HttpServletResponse 实现"></a>11.5、原始的 HttpServletResponse 实现</h3><ol>
<li>配置 web.xml</li>
</ol>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="2">
<li>springmvc 配置文件（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li><p>静态资源过滤和注解驱动配置（我的父工程已经配置了，所以这就不配了）</p>
</li>
<li><p>编写 Controller 类</p>
</li>
</ol>
<pre><code class="java">@RestController
public class UserController &#123;

    @RequestMapping(&quot;/a&quot;)
    public void ajax(String name, HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().write(&quot;true&quot;);
        &#125;else &#123;
            response.getWriter().write(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>导入 jQuery</p>
</li>
<li><p>编写前端页面</p>
</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ajaxTest&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function a1()&#123;
        $.post(&#123;
          url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
          data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
          success:function (data,status) &#123;
            alert(data);
            alert(status);
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; οnblur=&quot;a1()&quot;/&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="11-6、SpringMVC-实现异步加载数据"><a href="#11-6、SpringMVC-实现异步加载数据" class="headerlink" title="11.6、SpringMVC 实现异步加载数据"></a>11.6、SpringMVC 实现异步加载数据</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛&quot;,10,&quot;男&quot;));
    userList.add(new User(&quot;中牛&quot;,11,&quot;女&quot;));
    userList.add(new User(&quot;小牛&quot;,12,&quot;男&quot;));
    return userList;
&#125;
</code></pre>
<ol start="2">
<li>在 index 中增加内容</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;取得信息&quot;&gt;
  &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">$(function () &#123;
    $(&quot;#btn&quot;).click(function () &#123;
        $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
            console.log(data)
            var html=&quot;&quot;;
            for (let i = 0; i &lt; data.length ; i++) &#123;
                html+= &quot;&lt;tr&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;/tr&gt;&quot;
            &#125;
            $(&quot;#content&quot;).html(html);
        &#125;);
    &#125;)
&#125;)
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-7、注册提示效果"><a href="#11-7、注册提示效果" class="headerlink" title="11.7、注册提示效果"></a>11.7、注册提示效果</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String oldPwd,String newPwd, String newPwd2)&#123;
    String msg = &quot;&quot;;
    if (name != null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;用户名不存在&quot;;
        &#125;
    &#125;
    if (oldPwd != null)&#123;
        if (&quot;123456&quot;.equals(oldPwd))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;旧密码有误&quot;;
        &#125;
    &#125;
    return msg;
&#125;
</code></pre>
<ol start="2">
<li>编写前端</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;name&quot; οnblur=&quot;a3_1()&quot;&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
    旧密码：&lt;input type=&quot;password&quot; id=&quot;oldPwd&quot; οnblur=&quot;a3_2()&quot;&gt;
    &lt;span id=&quot;oldPwdInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function a3_1() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;name&quot;:$(&#39;#name&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#userInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
function a3_2() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;oldPwd&quot;:$(&#39;#oldPwd&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#oldPwdInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
</code></pre>
<ol start="3">
<li>解决乱码问题（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<h2 id="十二、拦截器"><a href="#十二、拦截器" class="headerlink" title="十二、拦截器"></a>十二、拦截器</h2><h3 id="12-1、什么是拦截器"><a href="#12-1、什么是拦截器" class="headerlink" title="12.1、什么是拦截器"></a>12.1、什么是拦截器</h3><p>​        SpringMVC 的处理器、拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<ul>
<li><p>过滤器</p>
<ul>
<li>servlet 规范中的一部分，任何 java web工程都可以使用</li>
<li>在 url-pattern 中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是 jsp、html、css、image、js 是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="12-2、自定义拦截器"><a href="#12-2、自定义拦截器" class="headerlink" title="12.2、自定义拦截器"></a>12.2、自定义拦截器</h3><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>配置 web.xml 和 applicationContext.xml</p>
</li>
<li><p>编写一个拦截器</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在 springmvc 配置文件中配置拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class TestController &#123;

    @RequestMapping(&quot;/t1&quot;)
    public String test()&#123;
        System.out.println(&quot;控制器方法执行！&quot;);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="12-3、验证用户是否登录（认证用户）"><a href="#12-3、验证用户是否登录（认证用户）" class="headerlink" title="12.3、验证用户是否登录（认证用户）"></a>12.3、验证用户是否登录（认证用户）</h3><p><strong>测试思路：</strong></p>
<ul>
<li>有一个登陆页面，需要写一个 controller 访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在 controller 中处理。判断用户名密码是否正确。如果正确，向 session 中写入用户信息。返回登陆成功。</li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>编写登录页面（login.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;

    &lt;h1&gt;登录页面&lt;/h1&gt;
    &lt;hr&gt;

    &lt;body&gt;
        &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt;
            用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;br&gt;
            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; required&gt; &lt;br&gt;
            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>编写 Controller 类处理请求</li>
</ol>
<pre><code class="java">package com.aze.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>编写登录成功页面（success.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;登录成功页面&lt;/h1&gt;
        &lt;hr&gt;

        $&#123;user&#125;
        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>编写首页，来测试页面跳转（index.jsp）</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 16:29
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
  &lt;/div&gt;

  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;hr&gt;
    &lt;%--登录--%&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>编写用户登录拦截器</li>
</ol>
<pre><code class="java">package com.aze.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;url: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>在 springmvc 配置文件中注册拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.aze.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="7">
<li><p>配置 Tomcat</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="13、文件上传和下载"><a href="#13、文件上传和下载" class="headerlink" title="13、文件上传和下载"></a>13、文件上传和下载</h2><h3 id="13-1、准备测试"><a href="#13-1、准备测试" class="headerlink" title="13.1、准备测试"></a>13.1、准备测试</h3><p>​        文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是 SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用 Spring 的文件上传功能，则需要在上下文中配置 MultipartResolver。</p>
<p>​        前端表单要求：为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p>对表单中的 enctype 属性做个详细的说明：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>​        一旦设置了 enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的 HTTP 响应。在2003年，Apache Software Foundation 发布了开源的 Commons FileUpload 组件，其很快成为 Servlet/JSP 程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0 规范已经提供方法来处理文件上传，但这种上传需要在 Servlet中完成。</li>
<li>而 Spring MVC 则提供了更简单的封装。</li>
<li>Spring MVC 为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver 实现的。</li>
<li>Spring MVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。</li>
<li>因此，SpringMVC 的文件上传还需要依赖 Apache Commons FileUpload 的组件。</li>
</ul>
<h3 id="13-2、文件上传"><a href="#13-2、文件上传" class="headerlink" title="13.2、文件上传"></a>13.2、文件上传</h3><ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
</ol>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--文件上传--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet-api导入高版本的--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--统一的解决乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>在 applicationContext.xml 中添加 bean 配置</li>
</ol>
<ul>
<li><strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong></li>
</ul>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 17:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;form action=&quot;/upload2&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class FileController &#123;
    
&#125;
</code></pre>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="java">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
//批量上传CommonsMultipartFile则为数组即可
@RequestMapping(&quot;/upload&quot;)
public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

    //获取文件名 : file.getOriginalFilename();
    String uploadFileName = file.getOriginalFilename();

    //如果文件名为空，直接回到首页！
    if (&quot;&quot;.equals(uploadFileName))&#123;
        return &quot;redirect:/index.jsp&quot;;
    &#125;
    System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    //如果路径不存在，创建一个
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    InputStream is = file.getInputStream(); //文件输入流
    OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

    //读取写出
    int len=0;
    byte[] buffer = new byte[1024];
    while ((len=is.read(buffer))!=-1)&#123;
        os.write(buffer,0,len);
        os.flush();
    &#125;
    os.close();
    is.close();
    return &quot;success&quot;;
&#125;
</code></pre>
<ul>
<li>方式二：采用 file.Transto 来保存上传的文件</li>
</ul>
<pre><code class="java">/*
    * 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;success&quot;;
&#125;
</code></pre>
<p>7.配置 Tomcat</p>
<ol start="8">
<li>测试</li>
</ol>
<h3 id="13-3、文件下载"><a href="#13-3、文件下载" class="headerlink" title="13.3、文件下载"></a>13.3、文件下载</h3><p>步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>Controller 类添加</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;baidu.png&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端添加</p>
<pre><code class="html">&lt;div&gt;
  &lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
&lt;/div&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringMVC" style=color:#879cff>
                SpringMVC
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            Shuyan
        </div>
        <div class="descriptions">
            
            <div class="description">
                正しさなんてもの
            </div>
            
            <div class="description">
                人のモノサシによって変わる
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://en.korilin.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://jp.korilin.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>