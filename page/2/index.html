
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Stay Hungry, Stay Foolish</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Shuyan</h1>
                <h3>Stay Hungry, Stay Foolish</h3>
                <h5>ShuyanCoding......</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/17/JAVA/JVM/JVM虚拟机/">
        <h2>
            JVM虚拟机
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、类加载器子系统、运算时数据区、内存分布、执行引擎"><a href="#一、类加载器子系统、运算时数据区、内存分布、执行引擎" class="headerlink" title="一、类加载器子系统、运算时数据区、内存分布、执行引擎"></a>一、类加载器子系统、运算时数据区、内存分布、执行引擎</h2><h3 id="1-JDK中包含了哪些内容"><a href="#1-JDK中包含了哪些内容" class="headerlink" title="1  JDK中包含了哪些内容?"></a>1  JDK中包含了哪些内容?</h3><ul>
<li>①. JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等</li>
<li>②. JRE(Java Runtime Environment Java运行环境)：包括Java虚拟机(Java Virtual Machine，JVM)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可</li>
</ul>
<h3 id="2-三大商业虚拟机"><a href="#2-三大商业虚拟机" class="headerlink" title="2  三大商业虚拟机"></a>2  三大商业虚拟机</h3><ul>
<li>①. sun公司的HotSpot VM(后来被Oracle收购)</li>
<li>②. BEA JRocket VM(后来被Oracle收购)，JRocket虚拟机中没有解释器，全部代码都靠即时编译器编译后执行</li>
<li>③. iBM J9</li>
</ul>
<h3 id="3-谈谈你对JVM整体的理解"><a href="#3-谈谈你对JVM整体的理解" class="headerlink" title="3 谈谈你对JVM整体的理解"></a>3 谈谈你对JVM整体的理解</h3><ul>
<li>①. 类加载器子系统</li>
<li>②. 运行时数据区[我们核心关注这里 的栈、堆、方法区]</li>
<li>③. 执行引擎(解释器和JIT编译器共存)<br><img src="https://img-blog.csdnimg.cn/2021060411352293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-简述Java类加载机制-Java类加载过程"><a href="#4-简述Java类加载机制-Java类加载过程" class="headerlink" title="4 简述Java类加载机制(Java类加载过程)"></a>4 简述Java类加载机制(Java类加载过程)</h3><ul>
<li><strong>加载机制是指类的加载、链接、初始化的过程</strong><br><img src="https://img-blog.csdnimg.cn/20210504185259863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="5-什么是类的加载、链接、初始化"><a href="#5-什么是类的加载、链接、初始化" class="headerlink" title="5  什么是类的加载、链接、初始化"></a>5  什么是类的加载、链接、初始化</h3><ul>
<li><p>①. <strong>加载：</strong>将字节码文件中的.class文件，通过类加载器，加载进运行时数据区的<strong>方法区</strong>内，并创建一个大的<strong>Class对象</strong></p>
</li>
<li><p>②. <strong>链接：</strong>(验证、准备、解析)</p>
<ul>
<li>验证，比如说验证字节码文件开头是CAFFBABA，版本号等</li>
</ul>
<ul>
<li><p>准备，为类变量赋予默认的初始化值，使用static+final修饰，且显示赋值不涉及到方法或者构造器调用的基本数据类型或者String类型的显示赋值都在准备阶段</p>
</li>
<li><p>解析，将类中的符号引用变成直接引用(符号引号在字节码文件的常量池中)</p>
</li>
</ul>
</li>
<li><p>③. <strong>初始化：</strong>为类变量赋予正确的初始化值，执行Clinit方法(静态代码块或使用static修饰的变量)<br>注意：一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
</li>
</ul>
<h3 id="6-类的主动使用和被动使用"><a href="#6-类的主动使用和被动使用" class="headerlink" title="6 类的主动使用和被动使用"></a>6 类的主动使用和被动使用</h3><ul>
<li>①. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li>
<li>②. 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>③. 调用类的静态方法</li>
<li>④. 反射(比如：Class.forName(“com.xiaozhi.Test”))</li>
<li>⑤. 初始化一个子类(当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化)</li>
<li>⑥. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类</li>
<li>⑦. JDK7开始提供的动态语言支持 (涉及解析REF_getStatic、REF_putStatic、REF_invokeSt atic方法句柄对应的类)</li>
</ul>
<h3 id="7-forName-“Java-lang-String”-和loadClass-“Java-lang-String”-有什么区别"><a href="#7-forName-“Java-lang-String”-和loadClass-“Java-lang-String”-有什么区别" class="headerlink" title="7 forName(“Java.lang.String”)和loadClass(“Java.lang.String”)有什么区别?"></a>7 forName(“Java.lang.String”)和loadClass(“Java.lang.String”)有什么区别?</h3><ul>
<li>①. forName()会导致类的<strong>主动加载</strong>，而getClassLoader()不会导致类的主动加载，Class.forName()：是一个静态方法，最常用的是Class.forName(String className)；根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化</li>
<li>②. ClassLoader.loadClass()：这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。(该方法因为需要得到一个ClassLoader 对象，所以可以根据需要指定使用哪个类加载器)</li>
</ul>
<h3 id="8-判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件"><a href="#8-判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件" class="headerlink" title="8 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件"></a>8 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件</h3><ul>
<li>①. 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li>②. 加载该类的类加载器已经被回收。这个条件除非是精心设计的可替换类加载器的场景。如JSP重加载等。否则通常是很难达成的</li>
<li>③. 该类对应的Java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="9-说说类的加载器分类？"><a href="#9-说说类的加载器分类？" class="headerlink" title="9  说说类的加载器分类？"></a>9  说说类的加载器分类？</h3><ul>
<li>①. JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>(Bootstrap ClassLoader)和<strong>自定义类加载器</strong>(User-Defined ClassLoader)</li>
<li>②. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范并没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器<br><img src="https://img-blog.csdnimg.cn/20210426223104306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="10-说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解"><a href="#10-说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解" class="headerlink" title="10  说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解"></a>10  说说你对引导类加载器、扩展类加载器和应用程序类加载器的理解</h3><ul>
<li><p>①. <strong>引导类加载器</strong></p>
<ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
</ul>
<ul>
<li><p>它用来加载Java的核心类库(JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容)，用于提供JVM自身需要的类(String类就是使用的这个类加载器)</p>
</li>
<li><p>由于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>不继承自java.lang.ClassLoader，没有父加载器</p>
</li>
</ul>
</li>
<li><p>②. <strong>扩展类加载器 Extension</strong></p>
<ul>
<li>Java语言编写，由sum.music.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类，父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
<li><p>③. <strong>系统类加载器(Application)</strong></p>
<ul>
<li>Java语言编写，由sum.music.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类，父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
</ul>
<ul>
<li>调用System.getSystemClassLoader() | Thread.currentThread().getContextClassLoader()获取到的是系统类加载器</li>
</ul>
</li>
</ul>
<h3 id="11-谈谈你对双亲委派机制的理解"><a href="#11-谈谈你对双亲委派机制的理解" class="headerlink" title="11  谈谈你对双亲委派机制的理解"></a>11  谈谈你对双亲委派机制的理解</h3><ul>
<li>①. 如果一个类加载收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行</li>
<li>②. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>
<li>③. 如果父类的加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ul>
<h3 id="12-双亲委派机制的优势"><a href="#12-双亲委派机制的优势" class="headerlink" title="12  双亲委派机制的优势"></a>12  双亲委派机制的优势</h3><ul>
<li>①. <strong>避免类的重复加载</strong>，确保一个类的全局唯一性(当父ClassLoader已经加载了该类的时候，就没有必要子ClassLoader再加载一次)<br>比如：我们如果是引导类加载器加载了，就没必要再一次使用扩展类加载器进行加载</li>
<li>②. <strong>保护程序安全</strong>，防止核心API被随意篡改<br><img src="https://img-blog.csdnimg.cn/20210426224243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="13-双亲委托模式的弊端"><a href="#13-双亲委托模式的弊端" class="headerlink" title="13  双亲委托模式的弊端"></a>13  双亲委托模式的弊端</h3><ul>
<li>检查类是否加载的委托过程是<strong>单向</strong>的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类</li>
</ul>
<h3 id="14-双亲委派机制可以打破吗？为什么"><a href="#14-双亲委派机制可以打破吗？为什么" class="headerlink" title="14  双亲委派机制可以打破吗？为什么"></a>14  双亲委派机制可以打破吗？为什么</h3><ul>
<li>①. 双亲委派模型的第一次”被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的”远古”时代</li>
<li>②. 第二次破坏双亲委派机制：线程上下文类加载器(ClassLoader.getSystemClassLoader( ))</li>
<li>③. 双亲委派模型的第三次”被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换(Hot Swap)、模块热部署(Hot Deployment)</li>
</ul>
<h3 id="15-沙箱安全机制谈谈你的认识"><a href="#15-沙箱安全机制谈谈你的认识" class="headerlink" title="15  沙箱安全机制谈谈你的认识"></a>15  沙箱安全机制谈谈你的认识</h3><ul>
<li>①. <strong>自定义String类</strong>，但是在加载String类的时候会使用引导类加载器进行加载，而引导类加载器在加载过程中会先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。在一定程度上可以保护程序安全，保护原生的JDK代码</li>
</ul>
<h3 id="16-谈谈你对ClassLaoder中的loadClass的理解"><a href="#16-谈谈你对ClassLaoder中的loadClass的理解" class="headerlink" title="16  谈谈你对ClassLaoder中的loadClass的理解"></a>16  谈谈你对ClassLaoder中的loadClass的理解</h3><ul>
<li>①. 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>②. 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name， false)接口进行加载</li>
<li>③. 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载</li>
<li>④. 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lan g.ClassLoader接口的defineClass系列的native接口加载目标Java类</li>
</ul>
<h3 id="17-Java中基本数据类型存储在JVM中的存储位置"><a href="#17-Java中基本数据类型存储在JVM中的存储位置" class="headerlink" title="17  Java中基本数据类型存储在JVM中的存储位置"></a>17  Java中基本数据类型存储在JVM中的存储位置</h3><ul>
<li><strong>局部变量存储在栈中，实例变量和静态变量存储在堆中</strong></li>
</ul>
<h3 id="18-字节码文件中都有什么"><a href="#18-字节码文件中都有什么" class="headerlink" title="18  字节码文件中都有什么?"></a>18  字节码文件中都有什么?</h3><ul>
<li>魔术</li>
<li>版本(副版本、主版本)</li>
<li>常量池(字节码文件的基石)</li>
<li>访问标识</li>
<li>类索引|父类索引|接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<h3 id="19-常量池中都有什么？"><a href="#19-常量池中都有什么？" class="headerlink" title="19  常量池中都有什么？"></a>19  常量池中都有什么？</h3><ul>
<li>①. 字面量和符号引号</li>
<li>②. 字面量：Java中的常量和字符串</li>
<li>③. 符号引号：<ul>
<li>类和接口的全限定名</li>
<li>属性的名称和修饰符</li>
<li>方法的名称和修饰符</li>
</ul>
</li>
</ul>
<h3 id="20-JVM的永久代中会发生垃圾回收么"><a href="#20-JVM的永久代中会发生垃圾回收么" class="headerlink" title="20 JVM的永久代中会发生垃圾回收么?"></a>20 JVM的永久代中会发生垃圾回收么?</h3><ul>
<li>①. 方法区中的垃圾回收主要是：废弃的常量和不再使用的类型</li>
<li>②. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li>
<li>③. 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:<ul>
<li>该类<strong>所有的实例</strong>都已经被回收。也就是Java堆中不存在类以及任何派生子类的实例</li>
<li>加载该类的<strong>加载器</strong>已经被回收。这个条件除非是经过设计的可替换类加载器的场景，入OSGI、JSP的重加载等，否则通常是很难达成的</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ul>
<h3 id="21-JVM在加载类的时候，是否按照类的加载、链接-验证、准备、解析-和初始化的顺序执行的？"><a href="#21-JVM在加载类的时候，是否按照类的加载、链接-验证、准备、解析-和初始化的顺序执行的？" class="headerlink" title="21  JVM在加载类的时候，是否按照类的加载、链接(验证、准备、解析)和初始化的顺序执行的？"></a>21  JVM在加载类的时候，是否按照类的加载、链接(验证、准备、解析)和初始化的顺序执行的？</h3><ul>
<li>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
</ul>
<h3 id="22-“父加载器”和”子加载器”之间的关系是继承的吗"><a href="#22-“父加载器”和”子加载器”之间的关系是继承的吗" class="headerlink" title="22 “父加载器”和”子加载器”之间的关系是继承的吗?"></a>22 “父加载器”和”子加载器”之间的关系是继承的吗?</h3><ul>
<li>不是继承的关系，是<strong>包含</strong>的关系</li>
</ul>
<h3 id="23-如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？"><a href="#23-如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？" class="headerlink" title="23  如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？"></a>23  如果我们自定义加载器，没有使用双亲委派机制，那么Java中的核心类库是不是还是会进行加载？</h3><ul>
<li>会由引导类加载器进行加载，这是因为不管是自定义加载器还是系统类加载器或者扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass (String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineC lass()接口，该接口中提供给了对JDK核心类库的保护</li>
</ul>
<h3 id="24-为什么JDBC需要打破双亲委派机制-tomcat也打破了"><a href="#24-为什么JDBC需要打破双亲委派机制-tomcat也打破了" class="headerlink" title="24  为什么JDBC需要打破双亲委派机制?(tomcat也打破了)"></a>24  为什么JDBC需要打破双亲委派机制?(tomcat也打破了)</h3><ul>
<li>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包，DriverManager类中要加载各个实现了Driver接口的类，然后进行管理，也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类，这就打破了双亲委派机制</li>
</ul>
<h3 id="25-既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢"><a href="#25-既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢" class="headerlink" title="25  既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢"></a>25  既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢</h3><ul>
<li>显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？<strong>tomcat不遵循双亲委派机制</strong>，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader</li>
</ul>
<h3 id="26-我们思考一下-Tomcat是个web容器，那么它要解决什么问题？"><a href="#26-我们思考一下-Tomcat是个web容器，那么它要解决什么问题？" class="headerlink" title="26  我们思考一下:Tomcat是个web容器，那么它要解决什么问题？"></a>26  我们思考一下:Tomcat是个web容器，那么它要解决什么问题？</h3><ul>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离</li>
<li>①. 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份</li>
<li>②. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。<br>默认的类加载器是能够实现的，因为他的职责就是保证唯一性。</li>
<li>③. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来第三个问题和第一个问题一样</li>
<li>④. web容器要支持jsp的修改，我们知道，jsp文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？所以，web容器需要支持jsp修改后不用重启<br>我们想我们要怎么实现jsp文件的热替换，jsp文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件</li>
</ul>
<h3 id="27-如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？"><a href="#27-如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？" class="headerlink" title="27  如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？"></a>27  如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？</h3><ul>
<li>可以使用<strong>线程上下文类加载器</strong>实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作</li>
</ul>
<h3 id="28-为什么java文件放在Eclipse-IDEA中的src文件夹下会优先jar包中的class"><a href="#28-为什么java文件放在Eclipse-IDEA中的src文件夹下会优先jar包中的class" class="headerlink" title="28 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class"></a>28 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class</h3><ul>
<li>Tomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在WEB-INF/class中。</li>
<li>而Eclipse/IDEA外部引用的jar包，则相当于放在WEB-INF/lib中。</li>
<li>因此肯定是java文件或者JSP文件编译出的class优先加载。</li>
</ul>
<h3 id="29-谈谈你对程序计数器的理解"><a href="#29-谈谈你对程序计数器的理解" class="headerlink" title="29 谈谈你对程序计数器的理解"></a>29 谈谈你对程序计数器的理解</h3><ul>
<li>①. 作用:是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</li>
<li>②. 是线程私有的 、不会存在内存溢出(唯一一个运行时数据区没有OOM的区域</li>
<li>③. 如果执行的是一个Native方法，那这个计数器是<strong>undefined</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200220202701869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="30-为什么使用PC寄存器记录当前线程的执行地址呢"><a href="#30-为什么使用PC寄存器记录当前线程的执行地址呢" class="headerlink" title="30  为什么使用PC寄存器记录当前线程的执行地址呢?"></a>30  为什么使用PC寄存器记录当前线程的执行地址呢?</h3><ul>
<li>①. 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li>
<li>②. JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令<br><img src="https://img-blog.csdnimg.cn/20210427211423937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="31-PC寄存器为什么设定为线程私有"><a href="#31-PC寄存器为什么设定为线程私有" class="headerlink" title="31 PC寄存器为什么设定为线程私有?"></a>31 PC寄存器为什么设定为线程私有?</h3><ul>
<li>为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</li>
</ul>
<h3 id="32-说说你对本地方法栈的理解"><a href="#32-说说你对本地方法栈的理解" class="headerlink" title="32 说说你对本地方法栈的理解"></a>32 说说你对本地方法栈的理解</h3><ul>
<li>①.本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须由调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies</li>
<li>②. native方法的举例：Object类中的clone wait notify hashCode等Unsafe类都是native方法<br><img src="https://img-blog.csdnimg.cn/20200505095206157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="33-什么虚拟机栈？"><a href="#33-什么虚拟机栈？" class="headerlink" title="33  什么虚拟机栈？"></a>33  什么虚拟机栈？</h3><ul>
<li>①.虚拟机栈(Java Virtual Machine Stacks)线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈， 所以Java栈也是”线程私有”的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程 [先进后出]<br><img src="https://img-blog.csdnimg.cn/20200228105322185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="34-栈里面存在GC吗？"><a href="#34-栈里面存在GC吗？" class="headerlink" title="34  栈里面存在GC吗？"></a>34  栈里面存在GC吗？</h3><ul>
<li>栈中是<strong>不存在GC</strong>的，存在OOM和StackOverflowError</li>
</ul>
<h3 id="35-静态变量和局部变量的对比？"><a href="#35-静态变量和局部变量的对比？" class="headerlink" title="35  静态变量和局部变量的对比？"></a>35  静态变量和局部变量的对比？</h3><ul>
<li>①. 我们知道类变量表有两次初始化的机会，第一次是在”准备阶段”，执行系统初始化，对类变量设置为零值，另一次则是在”初始化”阶段，赋予程序员在代码中定义的初始值</li>
<li>②. 和类变量初始化不同的是，局部变量表不存在初始化的过程，这意味着一旦定义了局部变量则必须认为初始化</li>
</ul>
<h3 id="36-虚拟机栈中都有什么"><a href="#36-虚拟机栈中都有什么" class="headerlink" title="36 虚拟机栈中都有什么?"></a>36 虚拟机栈中都有什么?</h3><ul>
<li>局部变量表、操作数栈、动态链接、方法的返回地址、附件信息</li>
</ul>
<h3 id="37-谈谈你对局部变量表的理解"><a href="#37-谈谈你对局部变量表的理解" class="headerlink" title="37 谈谈你对局部变量表的理解?"></a>37 谈谈你对局部变量表的理解?</h3><ul>
<li>①. 定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各种基本数据类型、对象引用(reference)以及return Address类型)</li>
<li>②. 由于局部变量是建立在线程的栈上，是<strong>线程私有数据</strong>，因此不存在数据安全问题</li>
<li>③. 局部变量表所需容量大小是在编译期确定下来的。(并保存在方法Code属性的maximum local variables数据项中，在方法运行期间不会改变局部变量表的大小的)</li>
<li>④. 局部变量表，其<strong>基本的存储单元是slot(变量槽)</strong></li>
<li>⑤. 在局部变量表中，32位以内的类型只占有一个slot(包括引用数据类型)，64位的类型(long和double)占有两个slot、byte、short、char在存储前被转换为int，boolean也被转换为int(0表示fasle，非0表示true)long和double则占据两个slot</li>
<li>⑥. Jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>⑦. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可(比如:访问long或double类型变量)</li>
<li>⑧. 如果当前帧是由构造方法或者实例方法创建，那么该对象引用this将会放在index为0的slot处</li>
<li>⑨. 栈帧中的局部变量表中的槽位是可以复用的，如果一个局部变量过了其作用域，那么在其作用域之后申请的新的局部变量就很可能会复用过期局部变量的槽位，从而节省资源的目的</li>
<li>⑩. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li>
</ul>
<h3 id="38-谈谈你对操作数栈的理解"><a href="#38-谈谈你对操作数栈的理解" class="headerlink" title="38 谈谈你对操作数栈的理解?"></a>38 谈谈你对操作数栈的理解?</h3><ul>
<li>①. 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li>
<li>②. 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为<strong>表达式栈</strong></li>
<li>③. 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>④. 栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>⑤. 操作数栈，主要用于保存计算机过程的中间结果，同时作为计算过程中变量临时的存储空间</li>
</ul>
<h3 id="39-说说你对动态链接的理解"><a href="#39-说说你对动态链接的理解" class="headerlink" title="39 说说你对动态链接的理解?"></a>39 说说你对动态链接的理解?</h3><ul>
<li><strong>动态链接就是将字节码文件中的符号引号(字符串常量池中)变成直接引用的过程</strong></li>
</ul>
<h3 id="40-方法返回地址？"><a href="#40-方法返回地址？" class="headerlink" title="40 方法返回地址？"></a>40 方法返回地址？</h3><ul>
<li>①. 存放调用该方法的PC寄存器的值</li>
<li>②. 一个方法的结束，有两种方式:<br>正常执行完成<br>出现未处理的异常，非正常退出</li>
<li>③. 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li>
<li>④. 而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<h3 id="41-附加信息-了解"><a href="#41-附加信息-了解" class="headerlink" title="41 附加信息(了解)"></a>41 附加信息(了解)</h3><ul>
<li>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</li>
</ul>
<h3 id="42-调整栈大小，就能保证不出现溢出吗"><a href="#42-调整栈大小，就能保证不出现溢出吗" class="headerlink" title="42 调整栈大小，就能保证不出现溢出吗?"></a>42 调整栈大小，就能保证不出现溢出吗?</h3><ul>
<li>不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出</li>
</ul>
<h3 id="43-分配的栈内存越大越好吗"><a href="#43-分配的栈内存越大越好吗" class="headerlink" title="43 分配的栈内存越大越好吗?"></a>43 分配的栈内存越大越好吗?</h3><ul>
<li>不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小</li>
</ul>
<h3 id="44-垃圾回收是否会涉及到虚拟机栈"><a href="#44-垃圾回收是否会涉及到虚拟机栈" class="headerlink" title="44 垃圾回收是否会涉及到虚拟机栈?"></a>44 垃圾回收是否会涉及到虚拟机栈?</h3><ul>
<li>①. 不会。<strong>垃圾回收只会涉及到方法区和堆中</strong>，方法区和堆也会存在溢出的可能</li>
<li>②. 程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收</li>
<li>③. 虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收</li>
</ul>
<h3 id="45-方法中定义的局部变量是否线程安全"><a href="#45-方法中定义的局部变量是否线程安全" class="headerlink" title="45 方法中定义的局部变量是否线程安全?"></a>45 方法中定义的局部变量是否线程安全?</h3><ul>
<li>如果局部变量在内部产生并在内部消亡的，那就是线程安全的</li>
</ul>
<h3 id="46-什么情况下会发生栈内存溢出"><a href="#46-什么情况下会发生栈内存溢出" class="headerlink" title="46 什么情况下会发生栈内存溢出?"></a>46 什么情况下会发生栈内存溢出?</h3><ul>
<li>①. 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出</li>
<li>②. 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出</li>
</ul>
<h3 id="47-说说堆和栈的区别"><a href="#47-说说堆和栈的区别" class="headerlink" title="47 说说堆和栈的区别?"></a>47 说说堆和栈的区别?</h3><ul>
<li>①.从GC、OOM、StackOverflowError的角度<br>[栈中不存在GC，当固定大小的栈会发生StackOverflowError，动态的会发生OOM。堆中GC、OOM、StackOverflowError都存在]</li>
<li>②. 从堆栈的执行效率[栈的效率高于堆]</li>
<li>③. 内存大小，数据结构<br>[堆的空间比栈的大一般，栈是一种FIFO先进后出的模型。堆中结构复杂，可以有链表、数组等]</li>
<li>④. 栈管运行，堆管存储</li>
</ul>
<h3 id="48-简单谈谈你对堆的理解-共享-垃圾回收"><a href="#48-简单谈谈你对堆的理解-共享-垃圾回收" class="headerlink" title="48 简单谈谈你对堆的理解?(共享|垃圾回收)"></a>48 简单谈谈你对堆的理解?(共享|垃圾回收)</h3><ul>
<li>①. Java堆区在JVM启动的时候即被创建，其空间大小也是确定的。是Jvm管理最大的一块内存空间</li>
<li>②. <strong>所有的线程共享Java堆</strong>，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer，TLAB)</li>
<li>③. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才有被移除<br>(注意:一个进程就是一个JVM实例，一个进程中包含多个线程)</li>
<li>④. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer， TLAB)</li>
</ul>
<h3 id="49-堆里面的分区-Eden，survival-from-to-，老年代，各自的特点"><a href="#49-堆里面的分区-Eden，survival-from-to-，老年代，各自的特点" class="headerlink" title="49 堆里面的分区:Eden，survival(from+to)，老年代，各自的特点"></a>49 堆里面的分区:Eden，survival(from+to)，老年代，各自的特点</h3><ul>
<li>①. 在JDK1.7中分为: 新生代+老年代+永久代 | 在JDK1.8中分为: 新生代+老年代+元空间</li>
<li>②. 新生代:伊甸园区、幸存者S0、S1(8:1:1)，几乎所有的Java对象都是在Eden区被new出来的，绝大部分的Java对象的销毁都在新生代进行了;</li>
<li>IBM公司的专门研究表明，新生代中 80% 的对象都是”朝生夕死”的老年代:另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致新生代:老年代=1:2</li>
</ul>
<h3 id="50-堆大小通过什么参数设置？"><a href="#50-堆大小通过什么参数设置？" class="headerlink" title="50 堆大小通过什么参数设置？"></a>50 堆大小通过什么参数设置？</h3><ul>
<li>①. -Xms:初始内存(默认为物理内存的1/64)</li>
<li>②. -Xmx:最大内存(默认为物理内存的1/4)</li>
<li>③. -XX:NewRatio=2<br>-XX:SurvivorRatio<br>-XX:HandlePromotionFailure:空间分配担保<br>-Xmn:设置新生代最大内存大小，一般使用默认值就可以了</li>
</ul>
<h3 id="51-初始堆大小和最大堆大小一样，问这样有什么好处"><a href="#51-初始堆大小和最大堆大小一样，问这样有什么好处" class="headerlink" title="51 初始堆大小和最大堆大小一样，问这样有什么好处?"></a>51 初始堆大小和最大堆大小一样，问这样有什么好处?</h3><ul>
<li>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能</li>
</ul>
<h3 id="52-对象在堆中的分配规则"><a href="#52-对象在堆中的分配规则" class="headerlink" title="52 对象在堆中的分配规则?"></a>52 对象在堆中的分配规则?</h3><ul>
<li>①. 优先分配到Eden</li>
<li>②. 大对象直接分配到老年(尽量避免程序中出现过多的大对象)</li>
<li>③. 长期存活的对象分配到老年代</li>
<li>④. 动态对象年龄判断(如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄对象可以直接进入老年代，无须等到MaxTenurningThreshold中要求的年龄</li>
<li>⑤. 空间分配担保 -XX:HandlePromotionFailure<br>(JDK6 Update24之后规则变为只有老年代的连续空间大于新生代对象总大小或者历次晋身的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<h3 id="53-Minor-GC-Major-GC-Full-GC"><a href="#53-Minor-GC-Major-GC-Full-GC" class="headerlink" title="53 Minor GC | Major GC | Full GC"></a>53 Minor GC | Major GC | Full GC</h3><ul>
<li>①. Minor GC 在Eden伊甸园区满的时候会触发，发生在新生代中</li>
<li>②. Major GC 在老年代中满了会进行触发，发生在老年代，major gc的时间比minor gc时间长</li>
<li>③. Full GC 发生在整个堆中</li>
</ul>
<h3 id="54-什么时候会触发minor-gc？"><a href="#54-什么时候会触发minor-gc？" class="headerlink" title="54  什么时候会触发minor gc？"></a>54  什么时候会触发minor gc？</h3><ul>
<li>在Eden伊甸园区满的时候会触发</li>
</ul>
<h3 id="55-是不是所有对象都分配在堆中"><a href="#55-是不是所有对象都分配在堆中" class="headerlink" title="55 是不是所有对象都分配在堆中?"></a>55 是不是所有对象都分配在堆中?</h3><ul>
<li>几乎所有对象是分配在堆中，如果一个对象在方法中没有进行逃逸，也可以分配在栈中进行分配</li>
</ul>
<h3 id="56-方法区中都存放什么东西"><a href="#56-方法区中都存放什么东西" class="headerlink" title="56 方法区中都存放什么东西?"></a>56 方法区中都存放什么东西?</h3><ul>
<li>类型信息、常量、静态变量、即时编译器编译后的代码缓存</li>
</ul>
<h3 id="57-方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误"><a href="#57-方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误" class="headerlink" title="57 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误?"></a>57 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误?</h3><ul>
<li>①. 加载大量的第三方的jar包</li>
<li>②. tomcat部署的工程过多(30-50个)</li>
<li>③. 大量动态的生成反射类</li>
</ul>
<h3 id="58-谈谈你对方法区中字符串常量池、静态变量的变化？"><a href="#58-谈谈你对方法区中字符串常量池、静态变量的变化？" class="headerlink" title="58 谈谈你对方法区中字符串常量池、静态变量的变化？"></a>58 谈谈你对方法区中字符串常量池、静态变量的变化？</h3><ul>
<li>①. Jdk 1.6 及之前：有永久代，静态变量、字符串常量池1.6在方法区</li>
<li>②. Jdk 1.7：有永久代，但已经逐步 “ 去永久代 “，字符串常量池、静态变量移除，保存在堆中</li>
<li>③. jdk 1.8 及之后：无永久代，常量池1.8在元空间。但静态变量、字符串常量池仍在堆中</li>
</ul>
<h3 id="59-为什么要用元空间取代永久代"><a href="#59-为什么要用元空间取代永久代" class="headerlink" title="59 为什么要用元空间取代永久代"></a>59 为什么要用元空间取代永久代</h3><ul>
<li>①.永久代参数设置过小，在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM，比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误</li>
<li>②.永久代参数设置过大，导致空间浪费</li>
<li>③. 默认情况下，元空间的大小受本地内存限制)</li>
<li>④. 对永久代进行调优是很困难的<br>[方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型，而不再使用的类或类的加载器回收比较复杂，full gc 的时间长]</li>
</ul>
<h3 id="60-StringTable为什么要调整"><a href="#60-StringTable为什么要调整" class="headerlink" title="60 StringTable为什么要调整?"></a>60 StringTable为什么要调整?</h3><ul>
<li>①.jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才能触发。而full gc是老年代的空间不足、永久代不足才会触发</li>
<li>②. 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存</li>
</ul>
<h3 id="61-new对象流程？对象的内存分配"><a href="#61-new对象流程？对象的内存分配" class="headerlink" title="61 new对象流程？对象的内存分配?"></a>61 new对象流程？对象的内存分配?</h3><ul>
<li>①. 判断对象对应的类是否加载、链接、初始化</li>
<li>②. 为对象分配内存</li>
<li>③. 处理并发安全问题</li>
<li>④. 初始化分配到的空间</li>
<li>⑤. 设置对象的对象头</li>
<li>⑥. 执行init方法进行初始化</li>
</ul>
<h3 id="62-对象内部结构都有什么"><a href="#62-对象内部结构都有什么" class="headerlink" title="62 对象内部结构都有什么?"></a>62 对象内部结构都有什么?</h3><ul>
<li>对象头、实例数据、对齐填充(保证8个字节的倍数)<br><img src="https://img-blog.csdnimg.cn/20210406193020801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="63-Java对象头里有什么"><a href="#63-Java对象头里有什么" class="headerlink" title="63  Java对象头里有什么?"></a>63  Java对象头里有什么?</h3><ul>
<li>①. 对象标记Mark Word(哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)</li>
<li>②. 类元信息</li>
</ul>
<h3 id="64-谈谈你对执行引擎的理解"><a href="#64-谈谈你对执行引擎的理解" class="headerlink" title="64  谈谈你对执行引擎的理解?"></a>64  谈谈你对执行引擎的理解?</h3><ul>
<li>①. 执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以</li>
<li>②. 解释器(负责响应时间)：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
<li>③. JIT(负责性能) (Just In Time Compiler)编译器(即时编译器)：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言<br>JLT是基于计数器的热点探测技术将热点代码进行缓存，主要分为基于：方法调用计数器用于统计方法的调用次数;回边计数器则用于统计循环体执行的循环次数<br><img src="https://img-blog.csdnimg.cn/20210609154505805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="65-你是怎么指定JVM启动模式？"><a href="#65-你是怎么指定JVM启动模式？" class="headerlink" title="65 你是怎么指定JVM启动模式？"></a>65 你是怎么指定JVM启动模式？</h3><ul>
<li>java -version</li>
</ul>
<h3 id="66-那你知道-server-c2-和-client-c1-的区别吗？"><a href="#66-那你知道-server-c2-和-client-c1-的区别吗？" class="headerlink" title="66 那你知道-server(c2)和-client(c1)的区别吗？"></a>66 那你知道-server(c2)和-client(c1)的区别吗？</h3><ul>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h3 id="67-为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？"><a href="#67-为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？" class="headerlink" title="67  为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？"></a>67  为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？</h3><ul>
<li>①. 使用JLT编译器，针对的是字节码文件，可以跨平台</li>
<li>②. 可以在动态期间对齐进行优化，比如:逃逸分析优化(逃逸分析优化可以有如下几种:栈上分配、标量替换、同步消除)</li>
</ul>
<h3 id="68-什么是垃圾？"><a href="#68-什么是垃圾？" class="headerlink" title="68 什么是垃圾？"></a>68 什么是垃圾？</h3><ul>
<li>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li>
</ul>
<h3 id="69-Java中垃圾回收的重点区域是？"><a href="#69-Java中垃圾回收的重点区域是？" class="headerlink" title="69  Java中垃圾回收的重点区域是？"></a>69  Java中垃圾回收的重点区域是？</h3><ul>
<li>①. 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收</li>
<li>②. 从次数上讲:<br>频繁收集Young区<br>较少收集Old区<br>基本不动Perm区(或元空间)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210614131601172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="70-谈谈你对垃圾判别阶段算法都有哪些"><a href="#70-谈谈你对垃圾判别阶段算法都有哪些" class="headerlink" title="70  谈谈你对垃圾判别阶段算法都有哪些?"></a>70  谈谈你对垃圾判别阶段算法都有哪些?</h3><ul>
<li>①. 引用计数算法</li>
<li>②. 可达性分析算法</li>
</ul>
<h3 id="71-引用计数算法"><a href="#71-引用计数算法" class="headerlink" title="71 引用计数算法"></a>71 引用计数算法</h3><ul>
<li>①. 原理:假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收</li>
<li>②. 最大的缺陷:无法解决循环引用的问题，gc永远都清除不了(这也是引用计数法被淘汰的原因)</li>
<li>③. Java使用的不是引用计数法(Java之所以没有使用引用计数法，是由于不能解决循环引用问题) | (Python使用了是引用计数法)</li>
<li>④. Python如何解决循环引用( 扩展了解 )</li>
</ul>
<ol>
<li>手动解决:很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用(只要发生了回收，弱引用都会被回收)</li>
</ol>
<h3 id="72-你对枚举根节点做可达性分析了解吗"><a href="#72-你对枚举根节点做可达性分析了解吗" class="headerlink" title="72 你对枚举根节点做可达性分析了解吗?"></a>72 你对枚举根节点做可达性分析了解吗?</h3><ul>
<li>①. 基本思路是通过一系列名为”GC Roots”的对象(集合)作为起点，从这个被称为GC ROOTs 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象是不可达对象(被回收)，否则就是可达对象<br><img src="https://img-blog.csdnimg.cn/20190813202011669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="73-在java中，可作为GC-Roots的对象有"><a href="#73-在java中，可作为GC-Roots的对象有" class="headerlink" title="73 在java中，可作为GC Roots的对象有?"></a>73 在java中，可作为GC Roots的对象有?</h3><ul>
<li>注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots 集合。比如: 分代收集和局部回收(面试加分项)<br>解释:如果只针对java堆中的某一区域进行垃圾回收(比如: 典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用时候就需要一并将关联的区域对象也加入到GC Roots 集合中考虑，才能保证可达性分析的准确性</li>
</ul>
<pre><code class="handlebars">    (1).虚拟机栈(栈帧中的局部变量表)中的引用对象(比如各个线程被调用的方法中使用到的参数、
    局部变量等)
    (2).本地方法栈中JNI(即一般来说native方法)中引用的对象[ 线程中的start方法 ]
    (3).静态属性引用的对象(比如:Java类的引用类型静态变量)
    (4).方法区中常量引用的对象(比如:字符串常量池(String Table)里的引用)
        
    (5).所有被synchronized持有的对象
    (6).Java虚拟机内部的引用(基本数据类型对应的Class对象，一些常驻的异常对象
    [如NullPointerException、OutofMemoryError]，系统类加载器)
    (7).反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    (8).注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots集合。比如:分代收集和局部回收(面试加分项)
</code></pre>
<h3 id="74-复制算法及优缺点你是怎么理解的"><a href="#74-复制算法及优缺点你是怎么理解的" class="headerlink" title="74 复制算法及优缺点你是怎么理解的?"></a>74 复制算法及优缺点你是怎么理解的?</h3><ul>
<li>①. 复制算法的过程<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 优缺点</li>
</ul>
<ol>
<li>①.没有标记和清除过程，实现简单，运行高效 ②. 不会产生内存碎片，且对象完整不丢</li>
<li>缺点：①. 浪费了10%的空间 ②. 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
<li>注意:复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。因为新生代中的对象一般都是朝生夕死的，在新生代中使用复制算法是非常好的</li>
</ol>
<ul>
<li>③. 注意:是当伊甸园区满后，会触发minjor gc，进行垃圾的回收</li>
</ul>
<h3 id="75-标记清除算法-Mark一Sweep"><a href="#75-标记清除算法-Mark一Sweep" class="headerlink" title="75 标记清除算法(Mark一Sweep)"></a>75 标记清除算法(Mark一Sweep)</h3><ul>
<li>①. 标记一清除算法(Mark一Sweep)是一种非常基础和常见的垃圾收集算法，该算法被J . McCarthy等人在1960年提出并并应用于Lisp语言</li>
<li>②. 标记:Collector(垃圾回收器)从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>③. 清除: Collector(垃圾回收器)对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
<li>④. 图解: CMS使用这种方式<br><img src="https://img-blog.csdnimg.cn/20210612172349990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优:不需要额外的空间</li>
<li>缺点:①.两次扫描，耗时严重 ②.清理出来的空闲内存不连续，会产生内存碎片，需要维护一个空闲列表 ③.效率比较低:递归与全堆对象遍历两次(经历了两次遍历)</li>
</ol>
<ul>
<li>⑥. 注意:这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放</li>
</ul>
<h3 id="76-标记整理-压缩-算法-Mark-Compact"><a href="#76-标记整理-压缩-算法-Mark-Compact" class="headerlink" title="76 标记整理(压缩)算法(Mark-Compact)"></a>76 标记整理(压缩)算法(Mark-Compact)</h3><ul>
<li><p>①. 背景:</p>
<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li>
</ul>
<ul>
<li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记一压缩(Mark一Compact) 算法由此诞生</li>
<li>1970年前后，G. L. Steele 、C. J. Chene和D.S. Wise 等研究者发布标记一压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</li>
</ul>
</li>
<li><p>②. 执行过程:</p>
<ul>
<li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
</ul>
<ul>
<li><p>最后，清理边界外所有的空间。</p>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</p>
</li>
</ul>
</li>
<li><p>③. 图解:<br><img src="https://img-blog.csdnimg.cn/20200818141849116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. 指针碰撞<br>(如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer))</p>
</li>
<li><p>⑤. 优缺点</p>
<ul>
<li>优点:①. 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可②. 消除了复制算法当中，内存减半的高额代价</li>
<li>缺点:①. 从效率.上来说，标记一整理算法要低于复制算法。②. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序。即: STW</li>
</ul>
</li>
</ul>
<h3 id="77-JVM采用的是分代收集？"><a href="#77-JVM采用的是分代收集？" class="headerlink" title="77 JVM采用的是分代收集？"></a>77 JVM采用的是分代收集？</h3><blockquote>
<p>写在最前面:<br>( 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除)</p>
</blockquote>
<ul>
<li><p>①. 没有最好的算法，只有更合适的算法</p>
</li>
<li><p>②. 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除</p>
</li>
<li><p>③. 新生代(Young Gen)</p>
<ul>
<li>新生代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
</ul>
<ul>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li>
</ul>
</li>
<li><p>④. 老年代(Tenured Gen)</p>
<ul>
<li><p>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
</li>
<li><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记一整理的混合实现。<br>Mark阶段的开销与存活对象的数量成正比<br>Sweep阶段的开销与所管理区域的大小成正相关<br>Compact阶段的开销与存活对象的数据成正比</p>
</li>
</ul>
</li>
</ul>
<h3 id="78-谈谈你对finalize-方法中虚拟机的状态？"><a href="#78-谈谈你对finalize-方法中虚拟机的状态？" class="headerlink" title="78 谈谈你对finalize( )方法中虚拟机的状态？"></a>78 谈谈你对finalize( )方法中虚拟机的状态？</h3><ul>
<li><p>①. 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收，但事实上，也并非是”非死不可”的，这时候它们暂时处于”缓刑”阶段。一个无法触及的对象肯能在某一个条件下”复活”自己，如果这样，那么对它的回收就是不合理的。为此，定义虚拟机中的对象可能有三种状态。如下:(掌握)</p>
<ul>
<li>可触及的:从根节点开始，可以到达这个对象</li>
</ul>
<ul>
<li><p>可复活的:对象的所有引用都被释放，但是对象有可能在finalize( )中复活</p>
</li>
<li><p>不可触及的: 对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize( )只会被调用一次</p>
</li>
</ul>
</li>
<li><p>②. 以上3种状态中，是由于finalize( )方法的存在，进行的区分。只有对象不可触及才可以被回收</p>
</li>
</ul>
<h3 id="79-System-gc-与Runtime-getRuntime-gc-区别"><a href="#79-System-gc-与Runtime-getRuntime-gc-区别" class="headerlink" title="79 System.gc()与Runtime.getRuntime().gc()区别"></a>79 System.gc()与Runtime.getRuntime().gc()区别</h3><ul>
<li>①. 通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存</li>
</ul>
<h3 id="80-什么是内存泄漏？"><a href="#80-什么是内存泄漏？" class="headerlink" title="80 什么是内存泄漏？"></a>80 什么是内存泄漏？</h3><ul>
<li><p>①. javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存</p>
</li>
<li><p>②. 说明Java虚拟机的堆内存不够。原因有二</p>
<ul>
<li>Java虚拟机的堆内存设置不够(比如:可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整)</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</li>
</ul>
</li>
<li><p>③. 这里面隐含着一层意思是，在抛出0utOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如:在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
</ul>
<h3 id="81-什么是内存溢出？"><a href="#81-什么是内存溢出？" class="headerlink" title="81  什么是内存溢出？"></a>81  什么是内存溢出？</h3><ul>
<li>①. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</li>
<li>②. 但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏</li>
<li>③. 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</li>
</ul>
<h3 id="82-Java中内存泄漏的8种情况"><a href="#82-Java中内存泄漏的8种情况" class="headerlink" title="82  Java中内存泄漏的8种情况"></a>82  Java中内存泄漏的8种情况</h3><ul>
<li>①.单例模式(单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。)</li>
<li>②. 一些提供close的资源未关闭导致内存泄漏 数据库连接( dataSourse. getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</li>
<li>③. 静态集合类(如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收)</li>
<li>④. 内部类持有外部类(内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。)</li>
<li>⑤. 变量不合理的作用域(一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生)</li>
<li>⑥. 改变哈希值</li>
<li>⑦. 缓存泄漏(内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据)</li>
<li>⑧. 监听器和回调(内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚)</li>
</ul>
<pre><code class="typescript">//静态集合类
public class MemoryLeak &#123;
    static List list = new ArrayList();

public void oomTests() &#123;
    Object obj = new Object();//局部变量
    list.add(obj);
&#125;
&#125;
//变量不合理的作用域
public class UsingRandom &#123;
    private String msg;
    public void receiveMsg()&#123;
        //private String msg;
        readFromNet();// 从网络中接受数据保存到msg中
        saveDB();// 把msg保存到数据库中
        //msg = null;
    &#125;
&#125;
//改变哈希值
public class ChangeHashCode &#123;
    public static void main(String[] args) &#123;
        HashSet set = new HashSet();
        Person p1 = new Person(1001， &quot;AA&quot;);
        Person p2 = new Person(1002， &quot;BB&quot;);

        set.add(p1);
        set.add(p2);
        p1.name = &quot;CC&quot;;
        set.remove(p1);
        System.out.println(set);//2个对象！

        //        set.add(new Person(1001， &quot;CC&quot;));
        //        System.out.println(set);
        //        set.add(new Person(1001， &quot;AA&quot;));
        //        System.out.println(set);

    &#125;
&#125;
</code></pre>
<h3 id="83-什么情况下会导致stop-the-world"><a href="#83-什么情况下会导致stop-the-world" class="headerlink" title="83 什么情况下会导致stop the world"></a>83 什么情况下会导致stop the world</h3><ul>
<li>①. 可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</li>
<li>②. 进行gc的时候会发生STW现象(调用finalize()方法的时候会暂停用户线程</li>
<li>③. System.gc( ) | 调用finalize( )方法。我们调用System.gc( ) 会触发Full gc</li>
</ul>
<h3 id="84-谈谈你对安全点的理解-？"><a href="#84-谈谈你对安全点的理解-？" class="headerlink" title="84 谈谈你对安全点的理解 ？"></a>84 谈谈你对安全点的理解 ？</h3><ul>
<li>①. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为 “安全点(Safepoint)”</li>
<li>②. Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</li>
<li>③. 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？<ul>
<li>抢先式中断: (目前没有虚拟机采用了) 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li>主动式中断: 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
</li>
</ul>
<h3 id="85-安全区域你知道吗"><a href="#85-安全区域你知道吗" class="headerlink" title="85 安全区域你知道吗?"></a>85 安全区域你知道吗?</h3><ul>
<li><p>①. Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
</li>
<li><p>②. 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
</li>
<li><p>③. 实际执行时:</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发GC，JVM会忽略标识为Safe Region状态的线程；</li>
</ul>
<ul>
<li>当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</li>
</ul>
</li>
</ul>
<h3 id="86-强引用、软引用、弱引用、虚引用的区别？"><a href="#86-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="86 强引用、软引用、弱引用、虚引用的区别？"></a>86 强引用、软引用、弱引用、虚引用的区别？</h3><ul>
<li>①. 强引用:不回收</li>
<li>②. 软引用: 内存不足即回收</li>
<li>③. 弱引用: 发现即回收</li>
<li>④. 虚引用: 对象回收跟踪<br><img src="https://img-blog.csdnimg.cn/20210625145600775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="87-Java中垃圾回收的重点区域是？"><a href="#87-Java中垃圾回收的重点区域是？" class="headerlink" title="87  Java中垃圾回收的重点区域是？"></a>87  Java中垃圾回收的重点区域是？</h3><ul>
<li>①. 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。(其中，Java堆是垃圾收集器的工作重点)</li>
<li>②. 从次数上讲:频繁收集Young区、较少收集Old区、基本不动Perm区(或元空间)<br><img src="https://img-blog.csdnimg.cn/20210625145636718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="88-GC是什么？为什么要有GC？"><a href="#88-GC是什么？为什么要有GC？" class="headerlink" title="88 GC是什么？为什么要有GC？"></a>88 GC是什么？为什么要有GC？</h3><ul>
<li>①. 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</li>
<li>②. 如果不进行垃圾回收，垃圾会占据内存，可能会导致OOM现象</li>
</ul>
<h3 id="89-吞吐量优先选择什么垃圾回收器？响应时间优先呢"><a href="#89-吞吐量优先选择什么垃圾回收器？响应时间优先呢" class="headerlink" title="89 吞吐量优先选择什么垃圾回收器？响应时间优先呢?"></a>89 吞吐量优先选择什么垃圾回收器？响应时间优先呢?</h3><ul>
<li>①. 吞吐量优先选择Parallel GC 垃圾收集器</li>
<li>②. 响应时间优先选择: CMS、G1</li>
</ul>
<h3 id="90-谈谈你对JVM中垃圾收集器的理解？"><a href="#90-谈谈你对JVM中垃圾收集器的理解？" class="headerlink" title="90  谈谈你对JVM中垃圾收集器的理解？"></a>90  谈谈你对JVM中垃圾收集器的理解？</h3><ul>
<li>①. 不同的厂商会考虑使用不同的JVM，不同的JVM会使用不同的垃圾收集器，下面我介绍下主流的垃圾收集器有哪些(主流的7种)，下面你就可以展开去说明七种垃圾收集器的每一个细节</li>
<li>②. 截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器<br><img src="https://img-blog.csdnimg.cn/2020092610513159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>③. 同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合(连线)，如下图:<br><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="91-讲一下CMS垃圾收集器垃圾回收的流程"><a href="#91-讲一下CMS垃圾收集器垃圾回收的流程" class="headerlink" title="91 讲一下CMS垃圾收集器垃圾回收的流程"></a>91 讲一下CMS垃圾收集器垃圾回收的流程</h3><ul>
<li><p>①. 初始标记(Initial一Mark)仅仅只是标记出和GCRoots能直接关联到的对象，有STW现象、暂时时间非常短</p>
</li>
<li><p>②. 并发标记(Concurrent一Mark)阶段:从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行(并发标记阶段有三色标记，下文有记录)</p>
</li>
<li><p>③. 重新标记(Remark) 阶段:有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</p>
</li>
<li><p>④. 并发清除:此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
<li><p>⑤. 补充说明:</p>
<ul>
<li><p>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS收集器的垃圾收集算法采用的是标记一清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择空闲列表(Free List) 执行内存分配。<br>(在并发标记阶段一开始不是垃圾，最后变成了垃圾)</p>
</li>
</ul>
</li>
</ul>
<h3 id="92-CMS优缺点"><a href="#92-CMS优缺点" class="headerlink" title="92  CMS优缺点"></a>92  CMS优缺点</h3><ul>
<li><p>①. 优点:并发收集、低延迟</p>
</li>
<li><p>②. CMS的弊端:</p>
<ul>
<li><p>会产生内存碎片</p>
</li>
<li><p>CMS收集器对CPU资源非常敏感<br>(在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低)</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾。可能出现”Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间</p>
</li>
</ul>
</li>
<li><p>③.区分两个注意事项</p>
<ul>
<li><p>并发标记阶段，在遍历GCRoots，用户线程也在执行，若此时遍历过一个对象发现没有引用，但由于用户线程并发执行，这期间可能导致遍历过的这个对象又被其他对象引用，所以才需要重新标记阶段再遍历一次看又没有漏标记的，否则就会导致被重新引用的对象被清理掉</p>
</li>
<li><p>浮动垃圾:在并发标记阶段一开始不是垃圾，最后变成了垃圾(属于多标的情况)</p>
</li>
</ul>
</li>
</ul>
<h3 id="93-CMS会出现漏标，怎么解决的"><a href="#93-CMS会出现漏标，怎么解决的" class="headerlink" title="93  CMS会出现漏标，怎么解决的?"></a>93  CMS会出现漏标，怎么解决的?</h3><ul>
<li>①. 通过增量更新和写屏障(后)的方式去解决的</li>
<li>②. 在把我们新增的引用放到集合的时候，会实现一种写屏障的方式。在对象前后通过一个dirty card queue将引用信息， 存在card中，这个dirty card queue会放在cardtable中，而cardtable是记忆集的具体实现，最终这个引用就会放在记忆集中的<br>(写屏障我们可以理解为在赋值操作的前面加一个方法，赋值的后面做一些操作，也可以理解为AOP。具体的C++实现代码如下图:)<br><img src="https://img-blog.csdnimg.cn/20201014153100882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="94-三色标志谈谈你的理解是什么样的"><a href="#94-三色标志谈谈你的理解是什么样的" class="headerlink" title="94 三色标志谈谈你的理解是什么样的?"></a>94 三色标志谈谈你的理解是什么样的?</h3><ul>
<li><p>①. 在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色:</p>
<ul>
<li>黑色(black):节点被遍历完成，而且子节点都遍历完成</li>
</ul>
<ul>
<li><p>灰色(gray): 当前正在遍历的节点，而且子节点还没有遍历</p>
</li>
<li><p>白色(white):还没有遍历到的节点，即灰色节点的子节点<br><img src="https://img-blog.csdnimg.cn/20210622094337195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 根据三色扫描算法，如果有下面两种情况发生，则会出现漏扫描的场景:</p>
<ul>
<li><p>把一个白对象的引用存到黑对象的字段里，如果这个情况发生，因为标记为黑色的对象认为是扫描完成的，不会再对他进行扫描。只能通过灰色的对象(CMS垃圾收集器)<br>(如上图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障和增量更新解决)</p>
</li>
<li><p>某个白对象失去了所有能从灰对象到达它的引用路径(直接或间接)(G1垃圾收集器)<br>(如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用写屏障和原始快照)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201014152019497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 三色过程:如下图所示，假如说A引入了B，B引用了C，D没有被任何引用。那么首先我们的CMS首先扫描到了A，发现A有引用B，那么我们的CMS会将A标记为黑色，B标记为灰色，然后这时候，通过B又找到了C那么这个时候发现C已经没有任何引用了就会将C标记为黑色。但是我们的D到目前为止没有被任何引用，记住我这里说的条件!那么D从始至终都没有被扫描，此时就会一直是白色，对于白色的对象来说CMS在执行并发清理的时候就会将此类对象干掉。<br>但是这里有了一个问题:如果我们的扫描过程已经结束这一段了，但是此时此刻我的A突然引用了D类型怎么办，这样一来我们的D只要被GC干掉是不是就会出现问题？也就是说我这里产生了一个漏标的问题。当然，我们的JVM开发人员可不是傻子，这里他们用了一个操作叫做增量更新和写屏障来解决这种问题的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="95-谈谈你对G1垃圾收集器的理解？"><a href="#95-谈谈你对G1垃圾收集器的理解？" class="headerlink" title="95  谈谈你对G1垃圾收集器的理解？"></a>95  谈谈你对G1垃圾收集器的理解？</h3><ul>
<li>①. G1是一个并行回收器，它把堆内存分割为很多不相关的区域(region物理上不连续)，把堆分为2048个区域，每一个region的大小是1 - 32M不等，必须是2的整数次幂。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</li>
<li>②. 每次根据允许的收集时间，优先回收价值最大的Region<br>(每次回收完以后都有一个空闲的region，在后台维护一个优先列表)</li>
<li>③. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字:垃圾优先(Garbage First)</li>
<li>④. 下面说一个问题:既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First(G1)GC？<br>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器”的重任与期望。</li>
</ul>
<h3 id="96-G1垃圾收集器的特点、缺点"><a href="#96-G1垃圾收集器的特点、缺点" class="headerlink" title="96 G1垃圾收集器的特点、缺点"></a>96 G1垃圾收集器的特点、缺点</h3><ul>
<li><p>①. 并行和并发</p>
<ul>
<li>并行性: G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
</ul>
<ul>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p>②. 分代收集</p>
<ul>
<li><p>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p>将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。</p>
</li>
<li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210627185423634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210627185428360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 空间整合<br>(G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记一压缩(Mark一Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显)</p>
</li>
<li><p>④. 可预测的停顿时间模型(即:软实时soft real一time)<br>(这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒、可以通过参数-XX:MaxGCPauseMillis进行设置)</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
</ul>
<ul>
<li><p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。<br>(CMS的最好的情况G1不一定比的上，但是CMS最差的部分，G1可以比上)</p>
</li>
</ul>
</li>
<li><p>⑤. 缺点:</p>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</li>
</ul>
<ul>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间</li>
</ul>
</li>
</ul>
<h3 id="97-谈谈你对G1中的Region的理解"><a href="#97-谈谈你对G1中的Region的理解" class="headerlink" title="97  谈谈你对G1中的Region的理解"></a>97  谈谈你对G1中的Region的理解</h3><ul>
<li>①. 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。可以通过-XX:G1Hea pRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变</li>
<li>②. 一个region 有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于0ld内存区域。图中空白的表示未使用的内存空间</li>
<li>③. 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H<br>(对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926192008566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="98-大致说说G1的回收过程"><a href="#98-大致说说G1的回收过程" class="headerlink" title="98  大致说说G1的回收过程"></a>98  大致说说G1的回收过程</h3><ul>
<li><p>①. G1 GC的垃圾回收过程主要包括如下三个环节:</p>
<ul>
<li>年轻代GC (Young GC)</li>
</ul>
<ul>
<li><p>老年代并发标记过程 (Concurrent Marking)</p>
</li>
<li><p>混合回收(Mixed GC)</p>
</li>
<li><p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/20210627220226998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行(多个垃圾线程)的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</p>
</li>
<li><p>③. 当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程</p>
</li>
<li><p>④. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
</li>
<li><p>⑤. 举个例子:一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收</p>
</li>
</ul>
<h3 id="99-G1的年轻代GC"><a href="#99-G1的年轻代GC" class="headerlink" title="99  G1的年轻代GC?"></a>99  G1的年轻代GC?</h3><blockquote>
<p>回收时机<br>(1). 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区<br>(3). 回收前:<br><img src="https://img-blog.csdnimg.cn/20210627224109323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(4). 回收后:<br><img src="https://img-blog.csdnimg.cn/20210627224114494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>①. 根扫描： 一定要考虑remembered Set，看是否有老年代中的对象引用了新生代对象<br>(根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口)</li>
<li>②.更新RSet:处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用<br>(dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty CardQueue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多)</li>
<li>③. 处理RSet：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</li>
<li>④. 复制对象：复制算法<br>(此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间)</li>
<li>⑤. 处理引用：处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</li>
</ul>
<h3 id="100-并发标记过程"><a href="#100-并发标记过程" class="headerlink" title="100  并发标记过程"></a>100  并发标记过程</h3><ul>
<li>①. 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>②. 根区域扫描(Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成(YoungGC时，会动Survivor区，所以这一过程必须在young GC之前完成)</li>
<li>③. 并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>④. 再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)<br>(在CMS中有详细讲解)</li>
<li>⑤. 独占清理(cleanup，STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)</li>
<li>⑥. 并发清理阶段：识别并清理完全空闲的区域</li>
</ul>
<h3 id="101-混合回收-Mixed-GC"><a href="#101-混合回收-Mixed-GC" class="headerlink" title="101 混合回收 Mixed GC"></a>101 混合回收 Mixed GC</h3><ul>
<li>①. Mixed GC并不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926194129931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="102-G1和CMS相比有哪些优势"><a href="#102-G1和CMS相比有哪些优势" class="headerlink" title="102  G1和CMS相比有哪些优势?"></a>102  G1和CMS相比有哪些优势?</h3><ul>
<li>①. G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片</li>
<li>②. G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间</li>
</ul>
<h3 id="103-我们怎么去选择垃圾收集器？"><a href="#103-我们怎么去选择垃圾收集器？" class="headerlink" title="103  我们怎么去选择垃圾收集器？"></a>103  我们怎么去选择垃圾收集器？</h3><ul>
<li>①. 单CPU或者小内存，单机程序 -XX:+UseSerialGC</li>
<li>②. 多CPU，需要最大吞吐量，如后台计算型应用<br>-XX:+UseParallelGC 或者 -XX:+UseParallelOldGC</li>
<li>③. 多CPU，追求低停顿时间，需快速响应如互联网应用<br>-XX:+UseConcMarkSweepGC 或者 -XX:+ParNewGC</li>
</ul>
<h2 id="二、跨平台原理、分类、三大商业虚拟机"><a href="#二、跨平台原理、分类、三大商业虚拟机" class="headerlink" title="二、跨平台原理、分类、三大商业虚拟机"></a>二、跨平台原理、分类、三大商业虚拟机</h2><h3 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1 什么是JVM？"></a>1 什么是JVM？</h3><ul>
<li>①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</li>
<li>②. jvm是运行在操作系统之上的，与硬件没有任何关系<br><img src="https://img-blog.csdnimg.cn/20210422092200243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="2-Java的跨平台及原理"><a href="#2-Java的跨平台及原理" class="headerlink" title="2 Java的跨平台及原理"></a>2 Java的跨平台及原理</h3><ul>
<li>①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</li>
<li>②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)<br>(Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-JVM的分类"><a href="#3-JVM的分类" class="headerlink" title="3  JVM的分类"></a>3  JVM的分类</h3><ul>
<li>①. 类加载子系统</li>
<li>②. 运行时数据区 [ 我们核心关注这里 的栈、堆、方法区 ]</li>
<li>③. 执行引擎(一般都是JIT编译器和解释器共存)</li>
</ul>
<ol>
<li>JIT编译器(主要影响性能)：编译执行； 一般热点数据会进行二次编译，将字节码指令变成机器指令。将机器指令放在方法区缓存</li>
<li>解释器(负责响应时间)：逐行解释字节码</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200907172633714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907172639931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210422092252198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-三大商业虚拟机"><a href="#4-三大商业虚拟机" class="headerlink" title="4  三大商业虚拟机"></a>4  三大商业虚拟机</h3><ul>
<li><p>①. Sun HotSpot</p>
<ul>
<li>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机</li>
<li>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码， 并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</li>
<li>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务， 使用HotSpot的JIT编译器与混合的运行时系统</li>
</ul>
</li>
<li><p>②. BEA JRocket</p>
<ul>
<li>专注于服务端应用(JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行)</li>
<li>Jrockit JVM 是世界上最快的jvm3. 2008年被oracle收购</li>
</ul>
</li>
<li><p>③. iBM J9</p>
<ul>
<li>市场定位与hotspot接近，服务器端，桌面应用，嵌入式等</li>
<li>目前，是影响力的三大商业虚拟机之一</li>
</ul>
</li>
</ul>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p><img src="https://img-blog.csdnimg.cn/20210518203736751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、程序计数器"><a href="#四、程序计数器" class="headerlink" title="四、程序计数器"></a>四、程序计数器</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1 程序计数器"></a>1 程序计数器</h3><ul>
<li>①. 作用 (是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令)</li>
<li>②. 特点(是线程私有的 、不会存在内存溢出)</li>
<li>③. 注意:在物理上实现程序计数器是在寄存器实现的，整个cpu中最快的一个执行单元</li>
<li>④. 它是唯一一个在java虚拟机规范中没有OOM的区域</li>
</ul>
<blockquote>
<p>解释:<br>(1). 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向下一条指令的地址，也即将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记<br>(2). 这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令<br>(3). 如果执行的是一个Native方法，那这个计数器是undefined<br><img src="https://img-blog.csdnimg.cn/20210525155403577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200220202701869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑤. 使用PC寄存器存储字节码指令地址有什么用呢?<br>为什么使用PC寄存器记录当前线程的执行地址呢?</li>
</ul>
<ol>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li>
<li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令<br><img src="https://img-blog.csdnimg.cn/20210427211423937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>⑥. PC寄存器为什么设定为线程私有?<br>(为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器)</li>
<li>⑦. 关于线程在JVM中的说明:</li>
</ul>
<ol>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<br>(解释:当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建.Java线程执行终止后，本地线程也会被回收)</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化完毕，它就会调用Java线程中的run方法</li>
</ol>
<h3 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2  本地方法栈"></a>2  本地方法栈</h3><ul>
<li>①. Native Interface本地接口</li>
</ul>
<ol>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须由调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies</li>
<li>目前该方法的使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍</li>
</ol>
<ul>
<li>②. 本地方法栈(Native Method Stack)<br>(它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库)</li>
<li>③. native方法的举例: Object类中的clone wait notify hashCode 等 Unsafe类都是native方法<br><img src="https://img-blog.csdnimg.cn/20200505095206157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="五、虚拟机栈概述、局部变量表、操作数栈、动态链接"><a href="#五、虚拟机栈概述、局部变量表、操作数栈、动态链接" class="headerlink" title="五、虚拟机栈概述、局部变量表、操作数栈、动态链接"></a>五、虚拟机栈概述、局部变量表、操作数栈、动态链接</h2><blockquote>
<p>前言:<br>(栈并不是越大越好，越多可以防止出现StackOverflowError晚点出现，但是栈越大，也就代表着虚拟机栈是一定的，你的栈越大，别的栈就会小)</p>
</blockquote>
<h3 id="1-什么是Java-virtual-machine"><a href="#1-什么是Java-virtual-machine" class="headerlink" title="1 什么是Java virtual machine?"></a>1 什么是Java virtual machine?</h3><ul>
<li>①. 栈的概述<br>每创建一个线程就会创建一个Java栈，每一个Java栈中都会有很多栈帧(局部变量表 | 操作数栈 | 动态链接 | 方法返回地址 | 一些附加信息)<br>注意:虚拟机栈中不存在GC，但是存在StackOverflowError和OOM</li>
</ul>
<blockquote>
<p>解释:<br>(1). 虚拟机栈(Java Virtual Machine Stacks)和线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈，所以Java栈也是”线程私有”的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程[先进后出]<br>(2). 栈帧中有如下部分组成:<br><img src="https://img-blog.csdnimg.cn/20200228105322185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">(3). 栈的其他介绍<br><img src="https://img-blog.csdnimg.cn/20190628111731333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>②. 存放于栈中的东西如下<br>(8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配[局部变量])</li>
<li>③. 栈内存溢出(StackOverflowError) <code>-Xss</code>参数</li>
</ul>
<ol>
<li>栈帧过多导致栈内存溢出(方法的递归调用，没设置正确停止条件)</li>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出</li>
</ol>
<pre><code class="java">Exception in thread &quot;main&quot; java.lang.StackOverflowError
    //sayHello()发生了递归
    public class DemoT &#123;
        public static void main(String[] args) &#123;
            sayHello();
        &#125;

        public static void sayHello()&#123;
            sayHello();
        &#125;
    &#125;
</code></pre>
<ul>
<li>④. Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的 掌握</li>
</ul>
<ol>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。</li>
<li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者是在创建新的线程时就没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ol>
<ul>
<li>⑤. 如何设置栈内存的大小？ -Xss size (即:-XX:ThreadStackSize)<br>一般默认为512k-1024k，取决于操作系统(jdk5之前，默认栈大小是256k;jdk5之后，默认栈大小是1024k)<br>栈的大小直接决定了函数调用的最大可达深度</li>
</ul>
<table>
<thead>
<tr>
<th>平台</th>
<th>jdk8</th>
</tr>
</thead>
<tbody><tr>
<td>linux</td>
<td>1024</td>
</tr>
<tr>
<td>MacOS</td>
<td>1024</td>
</tr>
<tr>
<td>window</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>⑥. 栈和堆的区别是什么?</li>
</ul>
<ol>
<li>从GC、OOM、StackOverflowError的角度。<br>(栈中不存在GC，当固定大小的栈会发生StackOverflowError，动态的会发生OOM。堆中GC、OOM、StackOverflowError都存在)</li>
<li>从堆栈的执行效率<br>(栈的效率高于堆)</li>
<li>内存大小，数据结构<br>(堆的空间比栈的大一般，栈是一种FIFO先进后出的模型。堆中结构复杂，可以有链表、数组等)</li>
<li>栈管运行，堆管存储</li>
</ol>
<h3 id="2-局部变量表-LocalVariables"><a href="#2-局部变量表-LocalVariables" class="headerlink" title="2 局部变量表(LocalVariables)"></a>2 局部变量表(LocalVariables)</h3><ul>
<li>①. 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量(这些数据类型包括各种基本数据类型、对象引用(reference)以及return Address类型)</li>
<li>②. 由于局部变量是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题</li>
<li>③. 局部变量表所需容量大小是在编译期确定下来的。(并保存在方法Code属性的maximum local variables数据项中，在方法运行期间不会改变局部变量表的大小的)</li>
</ul>
<pre><code class="java">//使用javap -v 类.class 或者使用jclasslib
public class LocalVariableTest &#123;
    public static void main(String[] args) &#123;
        LocalVariableTest test=new LocalVariableTest();
        int num=10;
        test.test1();
    &#125;
    public static void test1()&#123;
        Date date=new Date();
        String name=&quot;xiaozhi&quot;;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>jclasslib说明:</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020050510515537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200505105323929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200505105818394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>④. 关于slot的理解(引用数据类型(方法的返回地址)占用1个slot)</li>
</ul>
<ol>
<li>局部变量表，是基本的存储单元是slot(变量槽)</li>
<li>在局部变量表中，32位以内的类型只占有一个slot(包括引用数据类型)，64位的类型(long和double)占有两个slot</li>
<li>byte、short、char在存储前被转换为int，boolean也被转换为int(0表示fasle，非0表示true)。long和double则占据两个slot</li>
</ol>
<ul>
<li>⑤. Jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>⑥. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可(比如:访问long或double类型变量)<br><img src="https://img-blog.csdnimg.cn/20200506174737348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑦. 如果当前帧是由构造方法或者实例方法创建，那么该对象引用this将会放在index为0的slot处<br><img src="https://img-blog.csdnimg.cn/20200506174914110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑧. 栈帧中的局部变量表中的槽位是可以复用的，如果一个局部变量过了其作用域，那么在其作用域之后申请的新的局部变量就很可能会复用过期局部变量的槽位，从而节省资源的目的</li>
</ul>
<pre><code class="java">public void localVar2()&#123;
    &#123;
        int a=0;
        System.out.println(a);
    &#125;
    //此时的b就会复用a的槽位
    int b=0;
&#125;
</code></pre>
<ul>
<li>⑨. 与GC Roots的关系<br>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li>
</ul>
<h3 id="3-操作数栈-operand-stack"><a href="#3-操作数栈-operand-stack" class="headerlink" title="3 操作数栈(operand stack)"></a>3 操作数栈(operand stack)</h3><ul>
<li>①. 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</li>
<li>②. 每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈</li>
<li>③. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈或出栈</li>
<li>④. 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>⑤. 栈中的任何一个元素都是可以任意的Java数据类型<br>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度</li>
<li>⑥. 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>⑦. 操作数栈，主要用于保存计算机过程的中间结果，同时作为计算过程中变量临时的存储空间 掌握</li>
<li>⑧. 操作数栈的具体说明[一]<br>这里的代码中操作数栈的长度最大是2，在iload_1、iload_2的时候</li>
</ul>
<pre><code class="java">public void testAddOperation()&#123;
    byte i = 15;
    int j = 8;
    int k = i + j;
&#125;
</code></pre>
<blockquote>
<p>解释:<br><img src="https://img-blog.csdnimg.cn/20200506180527992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602225927370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602225955571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230012665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230027752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230042654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2021060223005548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210602230106519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210602230114151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑧. 操作数栈的具体说明[二]</li>
</ul>
<ol>
<li>局部变量有多少个?</li>
<li>操作数栈的最大深度是多少?<br><img src="https://img-blog.csdnimg.cn/20210602232149871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<pre><code class="typescript">public class OperandStackTest &#123;
    public void testAddOperation()&#123;
        //byte、short、char、boolean:都以int型保存
        byte i=15;
        short j=8;
        int k=i+j;

        long m=12L;
        int n=800;
        //存在宽化类型转换
        m=m*n;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>解释<br><img src="https://img-blog.csdnimg.cn/20210602233254338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>⑨. 操作数栈的具体说明[三]<br>操作书栈的最大深度是2，这个2是在(new #2 、dup的时候)</li>
</ul>
<pre><code class="typescript">public class OperandStackTest &#123;
    public static void main(String[] args) &#123;
        OperandStackTest test=new OperandStackTest();
        int num=10;
        test.testAddOperation();
    &#125;
    public void testAddOperation()&#123;
        //byte、short、char、boolean:都以int型保存
        byte i=15;
        short j=8;
        int k=i+j;

        long m=12L;
        int n=800;
        //存在宽化类型转换
        m=m*n;
    &#125;


 0 new #2 &lt;com/xiaozhi/jvm/OperandStackTest&gt; 将new的对象放入操作数栈中
 3 dup 复制一份出来，在操作数栈中，这时操作数栈的长度为2
 下面用了dup出来的对象
 4 invokespecial #3 &lt;com/xiaozhi/jvm/OperandStackTest.&lt;init&gt;&gt;
 7 astore_1 将new出来的放入了局部变量表为1的位置，0的位置放的是arg
 8 bipush 10 将10放入操作数栈
10 istore_2  将操作数栈中的10放入局部变量表为2的位置
11 aload_1   将巨变变量表1的位置放入操作数栈中
下面调用了方法，也就意味着操作数栈1的位置出栈了
12 invokevirtual #4 &lt;com/xiaozhi/jvm/OperandStackTest.testAddOperation&gt;
15 return
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210602234734413.png" alt="在这里插入图片描述"></p>
<ul>
<li>⑩. 何为栈顶缓存技术？ 了解</li>
</ul>
<ol>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个题，HotSpot JVM的设计者们提出了栈顶缓存(ToS，Top-of-Stack Cashing)技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</li>
</ol>
<h3 id="4-动态链接-Dynamic-Linking"><a href="#4-动态链接-Dynamic-Linking" class="headerlink" title="4 动态链接(Dynamic Linking)"></a>4 动态链接(Dynamic Linking)</h3><p><img src="https://img-blog.csdnimg.cn/20200506183809387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>①. 运行时常量池位于方法区，字节码中的常量池结构如下:<br><img src="https://img-blog.csdnimg.cn/20200506183837610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②.为什么需要常量池呢？<br>(常量池的作用，就是为了提供一些符号和常量，便于指令的识别。下面提供一张测试类的运行时字节码文件格式)<br><img src="https://img-blog.csdnimg.cn/20200506183954829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020050618401572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</li>
<li>④. 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Refenrence)保存在class字节码文件(javap反编译查看)的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用</li>
</ul>
<h3 id="5-方法的调用-小插曲-难点"><a href="#5-方法的调用-小插曲-难点" class="headerlink" title="5 方法的调用:(小插曲)难点"></a>5 方法的调用:(小插曲)难点</h3><ul>
<li>①. 静态链接(早期绑定):当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接<br>(invokestatic | invokespecial)</li>
<li>②. 动态链接(晚期绑定):如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。**<code>体现了多态</code>**<br>(invokevirtual | invokeinterface)</li>
<li>③. <strong><code>非虚方法:</code></strong> 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法<br><strong><code>(静态方法、私有方法、final方法、实例构造器(实例已经确定，this()表示本类的构造器)、父类方法(super调用)都是非虚方法)</code></strong></li>
<li>④. 其他所有体现多态特性的方法称为虚方法</li>
<li>⑤. 如下指令要重点掌握</li>
</ul>
<pre><code class="java">普通调用指令:
1.invokestatic:调用静态方法，解析阶段确定唯一方法版本；
    2.invokespecial:调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本；
        3.invokevirtual:调用所有虚方法；
            4.invokeinterface:调用接口方法；
                动态调用指令(Java7新增):
5.invokedynamic:动态解析出需要调用的方法，然后执行 .
    前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由
    用户确定方法版本。
    其中invokestatic指令和invokespecial指令调用的方法称为非虚方法

    其中invokevirtual(final修饰的除外，JVM会把final方法调用也归为invokevirtual指
                    令，但要注意final方法调用不是虚方法)、invokeinterface指令调用的方法称称为虚方法。
    12345678910111213
    /**
 * 解析调用中非虚方法、虚方法的测试
 */
    class Father &#123;
        public Father()&#123;
            System.out.println(&quot;Father默认构造器&quot;);
        &#125;

        public static void showStatic(String s)&#123;
            System.out.println(&quot;Father show static&quot;+s);
        &#125;

        public final void showFinal()&#123;
            System.out.println(&quot;Father show final&quot;);
        &#125;

        public void showCommon()&#123;
            System.out.println(&quot;Father show common&quot;);
        &#125;

    &#125;

public class Son extends Father&#123;
    public Son()&#123;
        super();
    &#125;

    public Son(int age)&#123;
        this();
    &#125;

    public static void main(String[] args) &#123;
        Son son = new Son();
        son.show();
    &#125;

    //不是重写的父类方法，因为静态方法不能被重写
    public static void showStatic(String s)&#123;
        System.out.println(&quot;Son show static&quot;+s);
    &#125;

    private void showPrivate(String s)&#123;
        System.out.println(&quot;Son show private&quot;+s);
    &#125;

    public void show()&#123;
        //invokestatic
        showStatic(&quot; 大头儿子&quot;);
        //invokestatic
        super.showStatic(&quot; 大头儿子&quot;);
        //invokespecial
        showPrivate(&quot; hello!&quot;);
        //invokespecial
        super.showCommon();
        //invokevirtual 因为此方法声明有final 不能被子类重写，所以也认为该方法是非虚方法
        showFinal();
        //虚方法如下
        //invokevirtual
        showCommon();//没有显式加super，被认为是虚方法，因为子类可能重写showCommon
        info();

        MethodInterface in = null;
        //invokeinterface  不确定接口实现类是哪一个 需要重写
        in.methodA();

    &#125;

    public void info()&#123;

    &#125;

&#125;

interface MethodInterface &#123;
    void methodA();
&#125;
</code></pre>
<h3 id="6-关于invokedynamic指令"><a href="#6-关于invokedynamic指令" class="headerlink" title="6 关于invokedynamic指令"></a>6 关于invokedynamic指令</h3><ul>
<li>①. JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li>
<li>②. 动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</li>
<li>③. Java是静态类型语言(尽管lambda表达式为其增加了动态特性)，js，python是动态类型语言</li>
</ul>
<pre><code class="java">Java:String info = &quot;小智&quot;;//静态语言

JS:var name = &quot;小智“；var name = 10;//动态语言

Pythom: info = 130;//更加彻底的动态语言
</code></pre>
<h3 id="7-方法返回地址-Return-Address"><a href="#7-方法返回地址-Return-Address" class="headerlink" title="7 方法返回地址(Return Address)"></a>7 方法返回地址(Return Address)</h3><blockquote>
<p>理解如下话:<br>(pc寄存器每执行一条指令都会被改变<br>而返回地址在调用call之前一直是上一条call后面的地址，不改变)</p>
</blockquote>
<ul>
<li>①. 存放调用该方法的PC寄存器的值</li>
<li>②. 执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口</li>
</ul>
<ol>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含ireturn(当返回值是boolena、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型的)</li>
<li>另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200510181532986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称异常完成出口</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200510181618906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200510181625227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="8-一些附加信息"><a href="#8-一些附加信息" class="headerlink" title="8  一些附加信息"></a>8  一些附加信息</h3><ul>
<li>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</li>
</ul>
<h3 id="9-问题小结与扩展"><a href="#9-问题小结与扩展" class="headerlink" title="9  问题小结与扩展"></a>9  问题小结与扩展</h3><ul>
<li>①. 栈溢出的情况?栈溢出:StackOverflowError<br>栈中是不存在GC的，存在OOM和StackOverflowError</li>
</ul>
<ol>
<li>举个简单的例子:在main方法中调用main方法，就会不断压栈执行，直到栈溢出;</li>
<li>栈的大小可以是固定大小的，也可以是动态变化(动态扩展)的<br>如果是固定的，那么会抛出StackOverflowError<br>如果是动态扩展的，那么会抛出OOM异常(java.lang.OutOfMemoryError)</li>
</ol>
<ul>
<li>②. 调整栈大小，就能保证不出现溢出吗?<br>不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出</li>
<li>③. 分配的栈内存越大越好吗?<br>不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小</li>
<li>④. 垃圾回收是否会涉及到虚拟机栈?<br>不会;垃圾回收只会涉及到方法区和堆中，方法区和堆也会存在溢出的可能<br>程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收<br>虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收</li>
<li>⑤. 方法中定义的局部变量是否线程安全?</li>
</ul>
<pre><code class="typescript">/**方法中定义的局部变量是否线程安全?   具体问题具体分析
 * @author shkstart
 * @create 15:53
 */
public class LocalVariableThreadSafe &#123;
    //s1的声明方式是线程安全的，因为线程私有，在线程内创建的s1 ，不会被其它线程调用
    public static void method1() &#123;
        //StringBuilder:线程不安全
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        //...
    &#125;
    
    //stringBuilder的操作过程:是线程不安全的，
    // 因为stringBuilder是外面传进来的，有可能被多个线程调用
    public static void method2(StringBuilder stringBuilder) &#123;
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        //...
    &#125;

    //stringBuilder的操作:是线程不安全的；因为返回了一个stringBuilder，
    // stringBuilder有可能被其他线程共享
    public static StringBuilder method3() &#123;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        return stringBuilder;
    &#125;

    //stringBuilder的操作:是线程安全的；因为返回了一个stringBuilder.toString()相当于new了一个String，
    // 所以stringBuilder没有被其他线程共享的可能
    public static String method4() &#123;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(&quot;a&quot;);
        stringBuilder.append(&quot;b&quot;);
        return stringBuilder.toString();

        /**
         * 结论:如果局部变量在内部产生并在内部消亡的，那就是线程安全的
         */
    &#125;
&#125;
</code></pre>
<h2 id="六、堆的概述、内存结构"><a href="#六、堆的概述、内存结构" class="headerlink" title="六、堆的概述、内存结构"></a>六、堆的概述、内存结构</h2><h3 id="1-堆的概述-共享-垃圾回收"><a href="#1-堆的概述-共享-垃圾回收" class="headerlink" title="1 堆的概述(共享|垃圾回收)"></a>1 堆的概述(共享|垃圾回收)</h3><ul>
<li>①. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>②. 堆可以在物理上不连续的内存空间中，但在逻辑上是连续的</li>
<li>③. Java堆区在JVM启动的时候即被创建，其空间大小也是确定的。是Jvm管理最大的一块内存空间</li>
<li>④. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer，TLAB)</li>
<li>⑤. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才有被移除<br>(注意:一个进程就是一个JVM实例，一个进程中包含多个线程)</li>
<li>⑥. 举例</li>
</ul>
<pre><code class="typescript">public class SimpleHeap &#123;
    private int id;

    public SimpleHeap(int id) &#123;
        this.id = id;
    &#125;

    public void show() &#123;
        System.out.println(&quot;My ID is &quot; + id);
    &#125;

    public static void main(String[] args) &#123;
        SimpleHeap sl = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200524174157919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-堆的内存结构"><a href="#2-堆的内存结构" class="headerlink" title="2 堆的内存结构"></a>2 堆的内存结构</h3><ul>
<li>①. 现在垃圾收集器大部分都基于分带收集理论设计的，堆空间细分为:<br><img src="https://img-blog.csdnimg.cn/20200524174545571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. jdk1.7 堆中的结构</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019071122574729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. jdk 1.8 堆中的结构<br><img src="https://img-blog.csdnimg.cn/20190711230055189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="3-堆空间大小的设置-Xms-Xmx"><a href="#3-堆空间大小的设置-Xms-Xmx" class="headerlink" title="3  堆空间大小的设置 -Xms -Xmx"></a>3  堆空间大小的设置 -Xms -Xmx</h3><ul>
<li>①. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx 和 -Xms”来设置</li>
<li>②. -Xms(物理内存的1/64):表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>③. -Xmx(物理内存的1/4):则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
<li>④. 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能</li>
<li>⑤. 案列演示</li>
</ul>
<pre><code class="java">package com.xiaozhi.heap;

import java.util.concurrent.TimeUnit;

/**
 * -Xms:600m
 * -Xmx:600m
 * 查看设置的参数:
 * 方式一(cmd中):jps  / jstat -gc 进程id
 * 方式二(XX:+PrintGCDetails)
 */
public class HeapDemo1 &#123;
    public static void main(String[] args)throws Exception &#123;
        //返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory()/1024/1024;
        //返回Java虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory()/1024/1024;
        System.out.println(&quot;-Xms:&quot;+initialMemory+&quot;M&quot;);
        System.out.println(&quot;-Xmx:&quot;+maxMemory+&quot;M&quot;);
        //TimeUnit.SECONDS.sleep(1000000);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200524175021513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-新生代与老年代参数设置-NewRation-SurvivorRatio"><a href="#4-新生代与老年代参数设置-NewRation-SurvivorRatio" class="headerlink" title="4  新生代与老年代参数设置 NewRation SurvivorRatio"></a>4  新生代与老年代参数设置 NewRation SurvivorRatio</h3><ul>
<li>①. 配置新生代与老年代在堆结构占比<br>默认:-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5<br><img src="https://img-blog.csdnimg.cn/20200524175242481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. -XX:SurvivorRatio调整这个空间比例(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1)</li>
<li>③. -Xmn:设置新生代最大内存大小，一般使用默认值就可以了</li>
<li>④. 几乎所有的Java对象都是在Eden区被new出来的，觉大部分的Java对象的销毁都在新生代进行的</li>
</ul>
<h3 id="5-复制算法"><a href="#5-复制算法" class="headerlink" title="5  复制算法"></a>5  复制算法</h3><ul>
<li>①. 一般过程(图解)<img src="https://img-blog.csdnimg.cn/20210603113332602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200524175513674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 复制算法详解 掌握<br>(伊甸园满了，就会触发gc(minor gc)，而gc就会把标识为垃圾的对象干掉，不是垃圾的对象就要转移到幸存区，把伊甸园让出来给新的对象用)</li>
</ul>
<blockquote>
<p>过程:<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190709122909128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190709123104942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="6-Minor-GC-Major-GC-Full-GC"><a href="#6-Minor-GC-Major-GC-Full-GC" class="headerlink" title="6 Minor GC | Major GC | Full GC"></a>6 Minor GC | Major GC | Full GC</h3><ul>
<li>①. YONG GC(minor GC):发生在新生代</li>
</ul>
<ol>
<li>只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快</li>
<li>当Eden代满，会触发minor GC ，Survivor 满不会引发GC</li>
<li>minor gc 会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才能恢复</li>
</ol>
<ul>
<li>②. Major GC:发生在老年代<br>major GC 是回收老年代的垃圾；major gc 的速度一般比Minor gc 慢10倍以上，STW时间更长</li>
<li>③. Full GC:发生在</li>
</ul>
<ol>
<li>full GC 就会出现所谓的STW(stop the world)现象，即所有的进程都挂起等待清理垃圾</li>
<li>full GC是回收老年代和年轻代的垃圾</li>
<li>full gc 是开发调优中尽量避免的，这样暂时时间会短一些</li>
</ol>
<ul>
<li>④. 全局GC(major GC or Full GC):<br>(指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC(但并不是绝对的)。Major GC的速度一般要比Minor GC慢上10倍以上)</li>
</ul>
<h3 id="7-针对不同年龄阶段的对象分配原则"><a href="#7-针对不同年龄阶段的对象分配原则" class="headerlink" title="7  针对不同年龄阶段的对象分配原则"></a>7  针对不同年龄阶段的对象分配原则</h3><ul>
<li>①. 优先分配到Eden</li>
<li>②. 大对象直接分配到老年(尽量避免程序中出现过多的大对象)</li>
<li>③. 长期存活的对象分配到老年代</li>
<li>④. 动态对象年龄判断<br>(如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄对象可以直接进入老年代，无须等到MaxTenurningThreshold中要求的年龄)</li>
<li>⑤. 空间分配担保 -XX:HandlePromotionFailure<br>(JDK6之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<h3 id="8-TLAB-Thread-Local-Allocation-Buffer"><a href="#8-TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="8  TLAB(Thread Local Allocation Buffer)"></a>8  TLAB(Thread Local Allocation Buffer)</h3><ul>
<li>①. 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li>
<li>②. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</li>
<li>③. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然可通过选项”-XX:TLABWasteTargePercent”设置TLAB空间所占用Eden空间的百分比大小</li>
<li>④. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</li>
<li>⑤. 图解:<img src="https://img-blog.csdnimg.cn/20200524180231747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200524180242481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-堆空间参数总结"><a href="#9-堆空间参数总结" class="headerlink" title="9 堆空间参数总结"></a>9 堆空间参数总结</h3><ul>
<li>①. -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</li>
<li>②. -XX:+PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改(:表示修改了)，不再是初始值)</li>
<li>③. 具体查看某个参数的指令:<br>(jps:查看当前运行中的进程<br>jinfo -flag SurvivorRatio 进程id)</li>
<li>④. -Xms:初始堆空间内存 (默认为物理内存的1/64)</li>
<li>⑤. -Xmx:最大堆空间内存(默认为物理内存的1/4)</li>
<li>⑥. -Xmn:设置新生代的大小。(初始值及最大值)</li>
<li>⑦. -XX:NewRatio:配置新生代与老年代在堆结构的占比<br>(默认:-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200525141725242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>⑧. -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例<br>(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1)</li>
<li>⑨. -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄</li>
<li>⑩. -XX:+PrintGCDetails:输出详细的GC处理日志<br>(如下这两种方式是简单的打印<br>打印gc简要信息:① -XX:+PrintGC ② -verbose:gc)</li>
<li>⑩①. -XX:HandlePromotionFailure:是否设置空间分配担保<br>(JDK6之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC)</li>
</ul>
<blockquote>
<p>内存分配策略(或对象提升(Promotion)规则)<br>(1). 在繁盛Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间<br>====如果大于，则此次Minor GC是安全的<br>====如果小于，则虚拟机会检查查看-XX:HandlePromotionFailure设置值是否允许担保失败<br>=====如果 HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋级到老年代的对象的平均大小<br>========如果大于，则尝试进行一次Minor GC，但是这次Minor GC依然是有风险的<br>========如果小于，则改为一次Full GC<br>=====如果HandlePromotionFailure=false，则改为进行一次Full GC<br>(2). 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响虚拟机的空间分配担保策略，观察OpenJDK中源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它<br>(3). JDK6 Update24之后规则变为只有老年代的连续空间大于新生代对象总大小或者历次晋身的平均大小就会进行Minor GC，否则将进行Full GC</p>
</blockquote>
<h3 id="10-逃逸分析"><a href="#10-逃逸分析" class="headerlink" title="10 逃逸分析"></a>10 逃逸分析</h3><ul>
<li>①. 如何将堆上的对象分配到栈，需要使用逃逸分析手段</li>
</ul>
<ol>
<li>当一个对象在方法中被定义后，对象只在方法内部使用(这里关注的是这个对象的实体)，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</li>
</ol>
<ul>
<li>②. 代码演示</li>
</ul>
<pre><code class="java">//(1). 没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除
public void my_method() &#123;
    V v = new V();
    // use v
    // ....
    v = null;
&#125;
//(2). 下面代码中的 StringBuffer sb 发生了逃逸
public static StringBuffer createStringBuffer(String s1， String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
&#125;
//如果想要StringBuffer sb不发生逃逸，可以这样写
public static String createStringBuffer(String s1， String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
&#125;
</code></pre>
<ul>
<li>③. 逃逸分析的举例</li>
</ul>
<pre><code class="java">/**
 * 逃逸分析
 *
 * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
 */
public class EscapeAnalysis &#123;

    public EscapeAnalysis obj;

    /*
    方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance()&#123;
        return obj == null? new EscapeAnalysis() : obj;
    &#125;

    /*
    为成员属性赋值，发生逃逸
     */
    public void setObj()&#123;
        this.obj = new EscapeAnalysis();
    &#125;
    //思考:如果当前的obj引用声明为static的？ 仍然会发生逃逸。

    /*
    对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis()&#123;
        EscapeAnalysis e = new EscapeAnalysis();
    &#125;

    /*
    引用成员变量的值，发生逃逸
    
     */
    public void useEscapeAnalysis1()&#123;
        EscapeAnalysis e = getInstance(); //这个e对象，本身就是从外面的方法逃逸进来的
        //getInstance().xxx()同样会发生逃逸
    &#125;
&#125;
</code></pre>
<ul>
<li>④. 在JDK1.7版本之后，HotSpot中默认就已经开启了逃逸分析<br>如果使用的是较早的版本，开发人员则可以通过:<br>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析<br>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
<li>结论: ⑤. 开发中能使用局部变量的，就不要使用在方法外定义</li>
<li>⑥. 使用逃逸分析，编译器可以对代码做如下优化:</li>
</ul>
<ol>
<li>栈上分配:将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li>同步省略:如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换:有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在CPU寄存器中</li>
</ol>
<h3 id="11-栈上分配"><a href="#11-栈上分配" class="headerlink" title="11 栈上分配"></a>11 栈上分配</h3><ul>
<li>①. JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配</li>
<li>②.代码举例</li>
</ul>
<pre><code class="java">/**
 * 栈上分配测试
 * -Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 */
public class StackAllocation &#123;
    public static void main(String[] args) &#123;
        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 10000000; i++) &#123;
            alloc();
        &#125;
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;花费的时间为: &quot; + (end - start) + &quot; ms&quot;);
        // 为了方便查看堆内存中对象个数，线程sleep
        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125;

    private static void alloc() &#123;
        User user = new User(); //未发生逃逸
    &#125;

    static class User &#123;

    &#125;
&#125;
</code></pre>
<ul>
<li>③. 未开启逃逸分析的情况<br>-Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</li>
</ul>
<pre><code class="typescript">日志打印发生了GC
[GC (Allocation Failure) [PSYoungGen: 65536K-&gt;560K(76288K)] 65536K-&gt;568K(251392K)， 0.0017179 secs] [Times: user=0.01 sys=0.00， real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 66096K-&gt;464K(76288K)] 66104K-&gt;480K(251392K)， 0.0017602 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] 
花费的时间为: 74 ms
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210603154652195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>④. 开启逃逸分析的情况<br>-Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</li>
</ul>
<pre><code class="typescript">日志打印:并没有发生 GC，耗时 3ms ，栈上分配是真的快啊
花费的时间为: 4 ms
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210603154749586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="12-同步替换-锁消除"><a href="#12-同步替换-锁消除" class="headerlink" title="12  同步替换 锁消除"></a>12  同步替换 锁消除</h3><ul>
<li>①. 从JIT角度看相当于无视它了，这个锁对象没有被共享给其他线程</li>
<li>②. 例如下面的智障代码，根本起不到锁的作用<br>代码中对hellis这个对象加锁(每个线程都有一个hellis对象的锁)，但是hellis对象的生命周期只在f( )方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成:</li>
</ul>
<pre><code class="java">public void f() &#123;
    Object hellis = new Object();
    synchronized(hellis) &#123;
        System.out.println(hellis);
    &#125;
&#125;
// JIT会将它变成这样
public void f() &#123;
      Object hellis = new Object();
        System.out.println(hellis);
&#125;
</code></pre>
<ul>
<li>③. 注意:字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的<br><img src="https://img-blog.csdnimg.cn/20210603160130874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="13-分离对象或标量替换"><a href="#13-分离对象或标量替换" class="headerlink" title="13 分离对象或标量替换"></a>13 分离对象或标量替换</h3><ul>
<li>①. 标量(scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</li>
<li>②. 相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</li>
<li>③. 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</li>
<li>④. 举列子</li>
</ul>
<pre><code class="typescript">public static void main(String args[]) &#123;
    alloc();
&#125;
class Point &#123;
    private int x;
    private int y;
&#125;
private static void alloc() &#123;
    Point point = new Point(1，2);
    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);
&#125;
//以上代码，经过标量替换后，就会变成
private static void alloc() &#123;
    int x = 1;
    int y = 2;
    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);
&#125;
</code></pre>
<h2 id="七、方法区的概述"><a href="#七、方法区的概述" class="headerlink" title="七、方法区的概述"></a>七、方法区的概述</h2><h3 id="1-方法区的概述"><a href="#1-方法区的概述" class="headerlink" title="1 方法区的概述"></a>1 方法区的概述</h3><ul>
<li>①. 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的 | 关闭Jvm就会释放这个区域的内存</li>
<li>②. 方法区时逻辑上是堆的一个组成部分，但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)<br>(注意：方法区时一种规范，而永久代和元空间是它的一种实现方式)</li>
<li>③. 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：(java.lang.OutOfMemoryError:PermGen space、java.lang.OutOfMemoryError:Metaspace)</li>
</ul>
<ol>
<li>加载大量的第三方的jar包</li>
<li>tomcat部署的工程过多(30-50个)</li>
<li>大量动态的生成反射类</li>
</ol>
<ul>
<li>④. 对于HotspotJVM而言，方法区还有一个别名叫非堆(Non-heap)，目的就是要和堆分开，方法区可以看成一块独立于Java堆的内存空间</li>
</ul>
<h3 id="2-方法区的内部结构"><a href="#2-方法区的内部结构" class="headerlink" title="2 方法区的内部结构"></a>2 方法区的内部结构</h3><ul>
<li>①. 深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等<br><img src="https://img-blog.csdnimg.cn/20200821102437479.png#pic_center" alt="在这里插入图片描述"></li>
<li>②. 类型信息(对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必 .须在方法区中存储以下类型信息：</li>
</ul>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public， abstract， final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<ul>
<li>③. 域信息（成员变量）</li>
</ul>
<ol>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li>
</ol>
<ul>
<li>④. 方法信息：JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序</li>
</ul>
<ol>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li>
<li>异常表（ abstract和native方法除外）<br>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<ul>
<li><strong>⑤. non-final的类变量</strong><br>(Order.class字节码文件，右键Open in Teminal打开控制台，使用javap -v -p Order.class &gt; tst.txt 将字节码文件反编译并输出为txt文件，可以看到被声明为static final的常量number在编译的时候就被赋值了，这不同于没有被final修饰的static变量count是在类加载的准备阶段被赋值为默认的初始化值，在初始化的时候赋予正确的初始化值</li>
</ul>
<pre><code class="java">public static int count;
descriptor: I
    flags: ACC_PUBLIC， ACC_STATIC

        public static final int number;
descriptor: I
    flags: ACC_PUBLIC， ACC_STATIC， ACC_FINAL
        ConstantValue: int 2
</code></pre>
<p><strong><code>以下代码不会报空指针异常</code></strong></p>
<pre><code class="java">public class MethodAreaTest &#123;
    public static void main(String[] args) &#123;
        Order order = null;
        order.hello();
        System.out.println(order.count);
    &#125;
&#125;

class Order &#123;
    public static int count = 1;
    public static final int number = 2;


    public static void hello() &#123;
        System.out.println(&quot;hello!&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3-方法区的演进细节"><a href="#3-方法区的演进细节" class="headerlink" title="3 方法区的演进细节"></a>3 方法区的演进细节</h3><ul>
<li>①. Jdk 1.6 及之前：有永久代，静态变量、字符串常量池1.6在方法区</li>
<li>②. Jdk 1.7 ：有永久代，但已经逐步 “ 去永久代 “，字符串常量池、静态变量移除，保存在堆中</li>
<li>③. jdk 1.8 及之后： 无永久代，常量池1.8在元空间。但静态变量、字符串常量池仍在堆中<br><img src="https://img-blog.csdnimg.cn/2020082110325625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 为什么要用元空间取代永久代</li>
</ul>
<ol>
<li>为永久代设置空间大小是很难确定的<br>(①. 永久代参数设置过小，在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM，比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误<br>②. 永久代参数设置过大，导致空间浪费<br>③. 默认情况下，元空间的大小受本地内存限制)</li>
<li>对永久代进行调优是很困难的<br>(方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型，而不再使用的类或类的加载器回收比较复杂，full gc 的时间长)</li>
</ol>
<ul>
<li>⑤. StringTable为什么要调整</li>
</ul>
<ol>
<li>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才能触发。而full gc是老年代的空间不足、永久代不足才会触发</li>
<li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存</li>
</ol>
<h3 id="4-设置方法区大小"><a href="#4-设置方法区大小" class="headerlink" title="4 设置方法区大小"></a>4 设置方法区大小</h3><ul>
<li>①. jdk7及以前:</li>
</ul>
<ol>
<li>-XX:PermSize=100m(默认值是20.75M)</li>
<li>-XX:MaxPermSize=100m(32位机器默认是64M，64位机器模式是82M)</li>
<li>图解：<br><img src="https://img-blog.csdnimg.cn/20200821103602612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. jdk1.8及以后</li>
</ul>
<ol>
<li>-XX:MetaspaceSize=100m(windows下，默认约等于21M)</li>
<li>-XX:MaxMetaspaceSize=100m(默认是-1，即没有限制)</li>
</ol>
<h3 id="5-常量池的理解"><a href="#5-常量池的理解" class="headerlink" title="5 常量池的理解"></a>5 常量池的理解</h3><ul>
<li>①. 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息</li>
</ul>
<pre><code class="java">Constant pool:
   #1 = Methodref          #7.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Methodref          #24.#25        // com/xiaozhi/heap/Order.hello:()V
   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Fieldref           #24.#28        // com/xiaozhi/heap/Order.count:I
   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V
</code></pre>
<ul>
<li>②. 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Poo1 Table），包括各种字面量和对类型域和方法的符号引用。</li>
<li>③. 个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</li>
<li>④. 比如如下代码，虽然只有 194 字节，但是里面却使用了 string、System、Printstream 及 Object 等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多！</li>
</ul>
<pre><code class="java">Public class Simpleclass &#123;
    public void sayhelloo() &#123;
        System.out.Println (hello) &#125;
&#125;
</code></pre>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6 运行时常量池"></a>6 运行时常量池</h3><ul>
<li>①. 运行时常量池，常量池是 <code>*.class</code> 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
<li>②. 运行时常量池（ Runtime Constant Pool）是方法区的一部分。</li>
<li>③. 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>④. 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用此时不再是常量池中的符号地址了，这里换为真实地址。<br>(方法区内常量池之中主要存放的两大类常量：字面量和符号引用。<br>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。<br>而符号引用则属于编译原理方面的概念，包括下面三类常量：<br>1、类和接口的全限定名<br>2、字段的名称和描述符<br>3、方法的名称和描述符)</li>
</ul>
<h3 id="7-如何证明静态变量存在哪"><a href="#7-如何证明静态变量存在哪" class="headerlink" title="7 如何证明静态变量存在哪"></a>7 如何证明静态变量存在哪</h3><pre><code class="java">/**
 * 《深入理解Java虚拟机》中的案例：
 * staticObj、instanceObj、localObj存放在哪里？
 */
public class StaticObjTest &#123;
    static class Test &#123;
        static ObjectHolder staticObj = new ObjectHolder();
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() &#123;
            ObjectHolder localObj = new ObjectHolder();
            System.out.println(&quot;done&quot;);
        &#125;
    &#125;

    private static class ObjectHolder &#123;
    &#125;

    public static void main(String[] args) &#123;
        Test test = new StaticObjTest.Test();
        test.foo();
    &#125;
&#125;
</code></pre>
<ul>
<li>①. staticObj随着Test的类型信息存放在方法区，instance0bj 随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中</li>
</ul>
<pre><code class="handlebars">hsdb&gt;scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_ _TestCase$Obj ectHolder
0x00007f32c7a7c458 JHSDB_ TestCase$Obj ectHolder
0x00007f32c7a7c480 JHSDB_ TestCase$Obj ectHolder
0x00007f32c7a7c490 JHSDB_ TestCase$Obj ectHolder
</code></pre>
<ul>
<li>②. 测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配</li>
<li>③. 接着，找到了一个引用该staticObj对象的地方，是在一个java. lang . Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个<br>java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：<br><img src="https://img-blog.csdnimg.cn/20200824150445739.png#pic_center" alt="在这里插入图片描述"></li>
<li>④. 从《Java 虛拟机规范》所定义的概念模型来看，所有 C1ass 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 C1ass 对象存放在一起，存储于】ava 堆之中，从我们的实验中也明确验证了这一点.</li>
</ul>
<h3 id="8-方法区的垃圾回收"><a href="#8-方法区的垃圾回收" class="headerlink" title="8 方法区的垃圾回收"></a>8 方法区的垃圾回收</h3><blockquote>
<p>前言：<br>(1).有些人认为方法区（如Hotspot，虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 ZGC 收集器就不支持类卸载）<br>(2). 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。</p>
</blockquote>
<ul>
<li><p>①. 方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型</p>
</li>
<li><p>②. 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><p>③. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。</p>
</li>
<li><p>④. 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li>
</ul>
<ul>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
<li><p>⑤. Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一Xnoclassgc 参数进行控制，还可以使用一verbose：class以及一XX： +TraceClass一Loading、一XX：+TraceClassUnLoading查 看类加载和卸载信息</p>
</li>
<li><p>⑥. 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</p>
</li>
</ul>
<h2 id="八、对象的实例化"><a href="#八、对象的实例化" class="headerlink" title="八、对象的实例化"></a>八、对象的实例化</h2><blockquote>
<p>前言：<br>(1).new 最常见的方式 | 变形1 ： Xxx的静态方法 | 变形2 ： XxBuilder/XxoxFactory的静态方法<br>(2).Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public<br>(3).Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求<br>(4).使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）<br>(5).使用反序列化：从文件中、从网络中获取一个对象的二进制流<br>(6).第三方库Objenesis</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200825090915939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-从字节码角度看待对象的创建过程"><a href="#1-从字节码角度看待对象的创建过程" class="headerlink" title="1  从字节码角度看待对象的创建过程"></a>1  从字节码角度看待对象的创建过程</h3><ul>
<li>①. 从最简单的Object ref = new Object()</li>
<li><img src="https://img-blog.csdnimg.cn/20210609100228772.png" alt="在这里插入图片描述"></li>
<li>②. new:如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。</li>
<li>③. dup:在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。</li>
<li>④. invokespecial:调用对象实例方法，通过栈顶的引用变量调用init方法。<br>补充:clinit是类初始化时执行的方法， 而init 是对象初始化时执行的方法。</li>
</ul>
<h3 id="2-对象的实例化-六个步骤"><a href="#2-对象的实例化-六个步骤" class="headerlink" title="2 对象的实例化(六个步骤)"></a>2 对象的实例化(六个步骤)</h3><ul>
<li><p>①. 判断对象对应的类是否加载、链接、初始化<br>(虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。( 即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象)</p>
</li>
<li><p>②. 为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小<br>(byte、int、float、引用数据类型4个字节大小 | double、long 占八个字节)</p>
<ul>
<li>如果内存规整，使用指针碰撞<br>如果内存是规整的，那么虚拟机将采用的是指针碰撞法(BumpThePointer)来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact (整理)过程的收集器时，使用指针碰撞。</li>
<li>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配(CMS)<br>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表(Free List)</li>
<li>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。<br><img src="https://img-blog.csdnimg.cn/20210609100527176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210609100706722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>③. 处理并发安全问题<br>(在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：)</p>
<ul>
<li>CAS ( Compare And Swap )失败重试、区域加锁：保证指针更新操作的原子性</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过一XX：+/一UseTLAB参数来 设定</li>
</ul>
</li>
<li><p>④. 初始化分配到的空间:赋予默认的初始化值；比如int=0| boolean=false(默认的值)</p>
</li>
<li><p>⑤. 设置对象的对象头：将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p>⑥. 执行init方法进行初始化(进行赋值的处理)<br>(在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespecial指令所决定)，new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。)</p>
</li>
<li><p>⑦. 代码展示</p>
</li>
</ul>
<pre><code class="java">/**
 * 测试对象实例化的过程
 *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
 *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
 *
 *  给对象的属性赋值的操作：
 *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
 * 
 */
public class Customer&#123;
    int id = 1001;
    String name;
    Account acct;

    &#123;
        name = &quot;匿名客户&quot;;
    &#125;
    public Customer()&#123;
        acct = new Account();
    &#125;

&#125;

class Account&#123;

&#125;
</code></pre>
<h3 id="3-对象的内存布局"><a href="#3-对象的内存布局" class="headerlink" title="3 对象的内存布局"></a>3 对象的内存布局</h3><ul>
<li>①. 对象内部结构分为：对象头、实例数据、对齐填充(保证8个字节的倍数)</li>
<li>②. 对象头分为对象标记(markOop)和类元信息(klassOop)，类元信息存储的是指向该对象类元数据(klass)的首地址<br><img src="https://img-blog.csdnimg.cn/20210406193020801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-对象头-Header"><a href="#4-对象头-Header" class="headerlink" title="4 对象头(Header)"></a>4 对象头(Header)</h3><ul>
<li>①. 对象标记Mark Word 默认存储 (哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)等信息</li>
</ul>
<ol>
<li>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。</li>
<li>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。<br><img src="https://img-blog.csdnimg.cn/20210406193237787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 对象头多大 在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节<br><img src="https://img-blog.csdnimg.cn/20210406193345417.png" alt="在这里插入图片描述"></li>
<li>③. 类元信息(又叫类型指针) 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
<h3 id="5-实例数据（Instance-Data）"><a href="#5-实例数据（Instance-Data）" class="headerlink" title="5  实例数据（Instance Data）"></a>5  实例数据（Instance Data）</h3><ul>
<li>说明:它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段) 规则:</li>
</ul>
<ol>
<li>相同宽度的字段总被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true)，子类的窄变量可能插入到父类变量的空隙</li>
</ol>
<h3 id="6-对齐填充（Padding）"><a href="#6-对齐填充（Padding）" class="headerlink" title="6  对齐填充（Padding）"></a>6  对齐填充（Padding）</h3><ul>
<li>①. 不是必须的，也没特别含义，仅仅起到占位符作用</li>
<li>②. 解释如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200825093157382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><ul>
<li>①. 代码演示</li>
</ul>
<pre><code class="java">public class CustomerTest &#123;
    public static void main(String[] args) &#123;
        Customer cust = new Customer();
    &#125;
&#125;
</code></pre>
<ul>
<li>②. 图解代码<br><img src="https://img-blog.csdnimg.cn/20200825093342514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="8-对象的访问定位"><a href="#8-对象的访问定位" class="headerlink" title="8 对象的访问定位"></a>8 对象的访问定位</h3><blockquote>
<p>前言：<br>JVM是如何通过栈帧中的对象引|用访问到其内部的对象实例的呢？-&gt; 定位，通过栈上reference访问</p>
</blockquote>
<ul>
<li>①. 句柄访问<br><img src="https://img-blog.csdnimg.cn/20200825093620622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②. 直接指针(HotSpot采用)<br><img src="https://img-blog.csdnimg.cn/20200825093643739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-直接内存-Direct-Memory"><a href="#9-直接内存-Direct-Memory" class="headerlink" title="9  直接内存(Direct Memory)"></a>9  直接内存(Direct Memory)</h3><ul>
<li>①. 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li>
<li>②. 直接内存是Java堆外的、直接向系统申请的内存区间</li>
<li>③. 代码演示：</li>
</ul>
<pre><code class="java">/**
 *  IO                  NIO (New IO / Non-Blocking IO)
 *  byte[] / char[]     Buffer
 *  Stream              Channel
 *
 * 查看直接内存的占用与释放
 */
public class BufferTest &#123;
    private static final int BUFFER = 1024 * 1024 * 1024;//1GB

    public static void main(String[] args)&#123;
        //直接分配本地内存空间
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
        System.out.println(&quot;直接内存分配完毕，请求指示！&quot;);

        Scanner scanner = new Scanner(System.in);
        scanner.next();

        System.out.println(&quot;直接内存开始释放！&quot;);
        byteBuffer = null;
        System.gc();
        scanner.next();
    &#125;
&#125;
</code></pre>
<ul>
<li>④. 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200827085808614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200827085847326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 通常，访问直接内存的速度会优于Java堆。即读写性能高</li>
<li>⑥. 直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致</li>
<li>⑦. 简单理解： java process memory = java heap + native memory<br><img src="https://img-blog.csdnimg.cn/20200827085948662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h2 id="九、字符串常量池"><a href="#九、字符串常量池" class="headerlink" title="九、字符串常量池"></a>九、字符串常量池</h2><h3 id="1-String的基本特性"><a href="#1-String的基本特性" class="headerlink" title="1  String的基本特性"></a>1  String的基本特性</h3><ul>
<li><p>①. String：字符串，使用一对””引起来表示。</p>
<ul>
<li>String sl = “hello”；//字面量的定义方式</li>
<li>String s2 = new String（“hello”）</li>
</ul>
</li>
<li><p>②. String声明为final的，不可被继承</p>
</li>
<li><p>③. String实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>④. String在jdk8及以前内部定义了final char[ ]，value用于存储字符串数据。jdk9时改为byte[ ]</p>
</li>
</ul>
<pre><code class="java">public final class String implements 
    java.io.Serializable， Comparable&lt;String&gt;，CharSequence &#123;
    @Stable
    private final byte[] value；
&#125;
</code></pre>
<ul>
<li>⑤. String：代表不可变的字符序列。简称：不可变性。</li>
<li>⑥. 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中</li>
<li>⑦. 字符串常量池中是不会存储相同内容的字符串的</li>
</ul>
<ol>
<li>String的String Pool 是一个固定大小的Hashtable，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String. intern时性能会大幅下降。</li>
<li>使用 - XX:StringTableSize可设置StringTable的长度</li>
<li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求</li>
<li>在jdk7中，StringTable的长度默认值是60013</li>
<li>jdk8开始，1009是StringTable长度可设置的最小值</li>
</ol>
<h3 id="2-String的内存分配"><a href="#2-String的内存分配" class="headerlink" title="2 String的内存分配"></a>2 String的内存分配</h3><ul>
<li>①. 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：</li>
</ul>
<ol>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中(比如： String info = “abc” )</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法</li>
</ol>
<ul>
<li>②.String的基本操作<br><img src="https://img-blog.csdnimg.cn/20200831091630754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<pre><code class="java">class Memory &#123;
    public static void main(String[] args) &#123;//line 1
        int i = 1;//line 2
        Object obj = new Object();//line 3
        Memory mem = new Memory();//line 4
        mem.foo(obj);//line 5
    &#125;//line 9

    private void foo(Object param) &#123;//line 6
        String str = param.toString();//line 7
        System.out.println(str);
    &#125;//line 8
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083109165877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-字符串拼接操作"><a href="#3-字符串拼接操作" class="headerlink" title="3 字符串拼接操作"></a>3 字符串拼接操作</h3><ul>
<li>①. 常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>②. 常量池中不会存在相同内容的常量。</li>
<li>③. 只要其中有一个是变量，结果就在堆中<br>(只有有一个是变量，那么它会在堆中创建一个StringBuilder，调用append( )方法进行添加操作，调用toString( )方法转换为字符串【toString( )方法其实就是:new String( )】)</li>
<li>④. 如果拼接的结果调用intern（）方法分为两种情况：</li>
</ul>
<ol>
<li>JDK1.6，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它会在常量池中创建一个对象放入串池中，并返回串池中的对象地址</li>
<li>JDK1.7，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它不会创建一个对象，如果堆中已经这个字符串，那么会将堆中的引用地址赋给它</li>
<li><strong>test3、test4<code>重点掌握</code></strong></li>
</ol>
<pre><code class="java">@Test
public void test1()&#123;
    String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//编译期优化：等同于&quot;abc&quot; 在字节码文件中，s1=&quot;abc&quot;
    String s2 = &quot;abc&quot;; //&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2
    /*
         * 最终.java编译成.class，再执行.class
         * String s1 = &quot;abc&quot;;
         * String s2 = &quot;abc&quot;
         */
    System.out.println(s1 == s2); //true
    System.out.println(s1.equals(s2)); //true
&#125;

@Test
public void test2()&#123;
    String s1 = &quot;javaEE&quot;;
    String s2 = &quot;hadoop&quot;;

    String s3 = &quot;javaEEhadoop&quot;;
    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;//编译期优化
    //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop
    String s5 = s1 + &quot;hadoop&quot;;
    String s6 = &quot;javaEE&quot; + s2;
    String s7 = s1 + s2;

    System.out.println(s3 == s4);//true
    System.out.println(s3 == s5);//false
    System.out.println(s3 == s6);//false
    System.out.println(s3 == s7);//false
    System.out.println(s5 == s6);//false
    System.out.println(s5 == s7);//false
    System.out.println(s6 == s7);//false
    //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；
    //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。
    String s8 = s6.intern();
    System.out.println(s3 == s8);//true
&#125;


@Test
public void test3()&#123;
    String s1 = &quot;a&quot;;
    String s2 = &quot;b&quot;;
    String s3 = &quot;ab&quot;;
    /*
        如下的s1 + s2 的执行细节：(变量s是我临时定义的）
        ① StringBuilder s = new StringBuilder();
        ② s.append(&quot;a&quot;)
        ③ s.append(&quot;b&quot;)
        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)

        补充：在jdk5.0之后使用的是StringBuilder，
        在jdk5.0之前使用的是StringBuffer
         */
    String s4 = s1 + s2;//
    System.out.println(s3 == s4);//false
&#125;

/*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
@Test
public void test4()&#123;
    final String s1 = &quot;a&quot;;
    final String s2 = &quot;b&quot;;
    String s3 = &quot;ab&quot;;
    String s4 = s1 + s2;
    System.out.println(s3 == s4);//true
&#125;

//练习：
@Test
public void test5()&#123;
    String s1 = &quot;javaEEhadoop&quot;;
    String s2 = &quot;javaEE&quot;;
    String s3 = s2 + &quot;hadoop&quot;;
    System.out.println(s1 == s3);//false

    final String s4 = &quot;javaEE&quot;;//s4:常量
    String s5 = s4 + &quot;hadoop&quot;;
    System.out.println(s1 == s5);//true

&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200831094734720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-拼接操作与append的效率对比"><a href="#4-拼接操作与append的效率对比" class="headerlink" title="4 拼接操作与append的效率对比"></a>4 拼接操作与append的效率对比</h3><ul>
<li>append效率要比字符串拼接高很多</li>
</ul>
<pre><code class="java">/*
    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串 拼接方式！
    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象
           使用String的字符串拼接方式：创建过多个StringBuilder和String的对象
         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，
           内存占用更大；如果进行GC，需要花费额外的时间。

     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel
     的情况下，建议使用构造器实例化：
     StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]
     */
@Test
public void test6()&#123;

    long start = System.currentTimeMillis();

    //        method1(100000);//4014
    method2(100000);//7

    long end = System.currentTimeMillis();

    System.out.println(&quot;花费的时间为：&quot; + (end - start));
&#125;

public void method1(int highLevel)&#123;
    String src = &quot;&quot;;
    for(int i = 0;i &lt; highLevel;i++)&#123;
        src = src + &quot;a&quot;;//每次循环都会创建一个StringBuilder、String
    &#125;
    //        System.out.println(src);

&#125;

public void method2(int highLevel)&#123;
    //只需要创建一个StringBuilder
    StringBuilder src = new StringBuilder();
    for (int i = 0; i &lt; highLevel; i++) &#123;
        src.append(&quot;a&quot;);
    &#125;
    //        System.out.println(src);
&#125;
</code></pre>
<h3 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="5 intern()的使用"></a>5 intern()的使用</h3><blockquote>
<p>前言：<br>(1). 如果不是用双引号声明的String对象，可以使用String提供的intern方法： intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中<br>(2). 比如： String myInfo = new String(“I love u”).intern()；<br>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下 列表达式的值必定是true：<br>（“a” + “b” + “c”）.intern（）== “abc”;<br>(3). 通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
</blockquote>
<h3 id="6-new-String-“ab”-会创建几个对象"><a href="#6-new-String-“ab”-会创建几个对象" class="headerlink" title="6 new String(“ab”)会创建几个对象"></a>6 new String(“ab”)会创建几个对象</h3><ul>
<li>①. new String(“ab”)会创建几个对象<br>(new String(“ab”)会创建几个对象？看字节码，就知道是两个)</li>
</ul>
<ol>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
<li>如下图：(常量池中已经有了该对象)<br><img src="https://img-blog.csdnimg.cn/20200831095508336.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="7-new-String-“a”-new-String-“b”-创建几个对象呢？"><a href="#7-new-String-“a”-new-String-“b”-创建几个对象呢？" class="headerlink" title="7 new String(“a”) + new String(“b”)创建几个对象呢？"></a>7 new String(“a”) + new String(“b”)创建几个对象呢？</h3><ul>
<li>②. new String(“a”) + new String(“b”)呢？<br>(在常量池中是没有ab存在的 [很关键] )</li>
</ul>
<ol>
<li>对象1：new StringBuilder()</li>
<li>对象2： new String(“a”)</li>
<li>对象3： 常量池中的”a”</li>
<li>对象4： new String(“b”)</li>
<li>对象5： 常量池中的”b”<br><img src="https://img-blog.csdnimg.cn/20200831095655825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>深入剖析： StringBuilder的toString(): 对象6 ：new String(“ab”)</li>
<li>注意：强调一下，toString()的调用，在字符串常量池中，没有生成”ab” 没有ldc指令</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200831095834664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="8-关于String-intern-的面试题"><a href="#8-关于String-intern-的面试题" class="headerlink" title="8 关于String.intern( )的面试题"></a>8 关于String.intern( )的面试题</h3><ul>
<li>③. 关于String.intern( )的面试题</li>
</ul>
<pre><code class="java">/**
 * 如何保证变量s指向的是字符串常量池中的数据呢？
 * 有两种方式：
 * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式
 * 方式二： 调用intern()
 *         String s = new String(&quot;shkstart&quot;).intern();
 *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();
 *  */
public class StringIntern &#123;
    public static void main(String[] args) &#123;
        String s = new String(&quot;1&quot;);
        String s1 = s.intern();//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;
        String s2 = &quot;1&quot;;
        //s  指向堆空间&quot;1&quot;的内存地址
        //s1 指向字符串常量池中&quot;1&quot;的内存地址
        //s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2
        System.out.println(s == s2);//jdk6：false   jdk7/8：false
        System.out.println(s1 == s2);//jdk6: true   jdk7/8：true
        System.out.println(System.identityHashCode(s));//491044090
        System.out.println(System.identityHashCode(s1));//644117698
        System.out.println(System.identityHashCode(s2));//644117698

        //s3变量记录的地址为：new String(&quot;11&quot;)
        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！

        //在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;，也就有新的地址。
        //jdk7:此时常量中并没有创建&quot;11&quot;，而是创建一个指向堆空间中new String(&quot;11&quot;)的地址
        s3.intern();
        //s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址
        String s4 = &quot;11&quot;;
        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083110084534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code class="java">public class StringIntern1 &#123;
    public static void main(String[] args) &#123;
        //StringIntern.java中练习的拓展：
        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//new String(&quot;11&quot;)
        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！
        String s4 = &quot;11&quot;;//在字符串常量池中生成对象&quot;11&quot;
        String s5 = s3.intern();
        System.out.println(s3 == s4);//false
        System.out.println(s5 == s4);//true
    &#125;
&#125;
</code></pre>
<h3 id="9-总结String的intern（）的使用"><a href="#9-总结String的intern（）的使用" class="headerlink" title="9 总结String的intern（）的使用"></a>9 总结String的intern（）的使用</h3><ul>
<li>④. 如果拼接的结果调用intern（）方法分为两种情况：</li>
</ul>
<ol>
<li>JDK1.6，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它会在常量池中创建一个对象放入串池中，并返回串池中的对象地址</li>
<li>JDK1.7，将这个字符串对象尝试放入串池 ①. 如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址②. 如果没有，它不会创建一个对象，如果堆中已经这个字符串，那么会将堆中的引用地址赋给它</li>
</ol>
<pre><code class="java">public class StringExer1 &#123;
    public static void main(String[] args) &#123;
        //String x = &quot;ab&quot;;
        String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);//new String(&quot;ab&quot;)
        //在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;

        String s2 = s.intern();//jdk6中：在串池中创建一个字符串&quot;ab&quot;
                               //jdk8中：串池中没有创建字符串&quot;ab&quot;，而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回

        System.out.println(s2 == &quot;ab&quot;);//jdk6:true  jdk8:true
        System.out.println(s == &quot;ab&quot;);//jdk6:false  jdk8:true
    &#125;
&#125;
</code></pre>
<blockquote>
<p>intern题目：<br><img src="https://img-blog.csdnimg.cn/20200831101207929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200831101248253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200831101255983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="10-intern-效率测试"><a href="#10-intern-效率测试" class="headerlink" title="10  intern()效率测试"></a>10  intern()效率测试</h3><ul>
<li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern（）方法，就会明显降低内存的大小。</li>
</ul>
<pre><code class="java">/**
 * 使用intern()测试执行效率：空间使用上
 *
 * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。
 *
 */
public class StringIntern2 &#123;
    static final int MAX_COUNT = 1000 * 10000;
    static final String[] arr = new String[MAX_COUNT];

    public static void main(String[] args) &#123;
        Integer[] data = new Integer[]&#123;1，2，3，4，5，6，7，8，9，10&#125;;

        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; MAX_COUNT; i++) &#123;
//            arr[i] = new String(String.valueOf(data[i % data.length]));
            arr[i] = new String(String.valueOf(data[i % data.length])).intern();

        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;花费的时间为：&quot; + (end - start));

        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.gc();
    &#125;
&#125;
</code></pre>
<h3 id="11-StrtingTable的垃圾回收-了解"><a href="#11-StrtingTable的垃圾回收-了解" class="headerlink" title="11 StrtingTable的垃圾回收(了解)"></a>11 StrtingTable的垃圾回收(了解)</h3><pre><code class="java">/**
 * String的垃圾回收:
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails
 *
 */
public class StringGCTest &#123;
    public static void main(String[] args) &#123;
//        for (int j = 0; j &lt; 100; j++) &#123;
//            String.valueOf(j).intern();
//        &#125;
        //发生垃圾回收行为
        for (int j = 0; j &lt; 100000; j++) &#123;
            String.valueOf(j).intern();
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083110150090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十、执行引擎概述"><a href="#十、执行引擎概述" class="headerlink" title="十、执行引擎概述"></a>十、执行引擎概述</h2><blockquote>
<p>总结写在最前面<br>为什么有了AOT静态提前编译，我们没用？而是用的JLT编译器？<br>(1). 使用JLT编译器，针对的是字节码文件，可以跨平台<br>(2). 可以在动态期间对齐进行优化，比如:逃逸分析优化(逃逸分析优化可以有如下几种:栈上分配、标量替换、同步消除)<br><img src="https://img-blog.csdnimg.cn/20200907110204890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1 执行引擎概述"></a>1 执行引擎概述</h3><ul>
<li>①. 执行引擎是Java虚拟机的核心组成部分之一</li>
<li>②. JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM锁识别的字节码指令、符号表和其他辅助信息</li>
<li>③. 那么，如果想让一个Java程序运行起来、执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者</li>
<li>④. 执行引擎的工作过程 (从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果)<ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907093642615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2  Java代码编译和执行过程"></a>2  Java代码编译和执行过程</h3><ul>
<li><p>①. 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤：<br><img src="https://img-blog.csdnimg.cn/20200907094155908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>②. 什么是解释器( Interpreter)，什么是JIT编译器？</p>
<ul>
<li>解释器:当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
</ul>
<ul>
<li>JIT (Just In Time Compiler)编译器(即时编译器):就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li>
</ul>
</li>
<li><p>③. 为什么说Java是半编译半解释型语言?如下图要记住</p>
<ul>
<li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器</li>
<li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。<br><img src="https://img-blog.csdnimg.cn/20200907094820559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h3 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3 机器码、指令、汇编语言"></a>3 机器码、指令、汇编语言</h3><ul>
<li><p>①. 机器码：各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言(0 | 1 组成的)</p>
<ul>
<li><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错</p>
</li>
<li><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快</p>
</li>
<li><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>
</li>
</ul>
</li>
<li><p>②. 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好<br>(由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同)</p>
</li>
<li><p>③. 指令集</p>
<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集</li>
<li>如常见的 (x86指令集，对应的是x86架构的平台 | ARM指令集，对应的是ARM架构的平台 )</li>
</ul>
</li>
<li><p>④. 汇编语言</p>
<ul>
<li><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址</p>
</li>
<li><p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令<br>(由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行)</p>
</li>
</ul>
</li>
<li><p>⑤. 高级语言(如下图需要记住)</p>
<ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li>
<li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907100443910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-解释器-负责响应时间"><a href="#4-解释器-负责响应时间" class="headerlink" title="4 解释器 -负责响应时间"></a>4 解释器 -负责响应时间</h3><ul>
<li><p>①.JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。<br><img src="https://img-blog.csdnimg.cn/20200907104403611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>②. 解释器真正意义上所承担的角色就是<code>一个运行时“翻译者”</code>，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行</p>
</li>
<li><p>③. 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作</p>
</li>
<li><p>④. 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器(了解)<br><img src="https://img-blog.csdnimg.cn/20200907104454410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>⑤. 现状(了解)</p>
<ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C+ +程序员所调侃</li>
</ul>
<ul>
<li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术(JLT)。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升</p>
</li>
<li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-JIT编译器-主要影响性能"><a href="#5-JIT编译器-主要影响性能" class="headerlink" title="5 JIT编译器 -主要影响性能"></a>5 JIT编译器 -主要影响性能</h3><ul>
<li>①. HostSpot JVM的执行方式：当虛拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li>
<li>②. HotSpot VM 为何解释器与JIT编译器共存?①是结论，②是解释：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200907104933157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907104949435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测(采用基于计数器的热点探测，HotSpot VM将会为每一个 方法都建立2个不同类型的计数器，分别为方法调用计数器(Invocation Counter) 和回边计数器(BackEdge Counter) )</p>
<ul>
<li><p>方法调用计数器用于统计方法的调用次数</p>
</li>
<li><p>回边计数器则用于统计循环体执行的循环次数</p>
</li>
</ul>
</li>
<li><p>④. 方法调用计数器</p>
<ul>
<li><p>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译</p>
</li>
<li><p>这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求</p>
<p><img src="https://img-blog.csdnimg.cn/20210609152321253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>⑤. 回边计数器<br>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”边”(Back Edge)。显然，建立回边计数器统计的目的就是为了触发OSR编译(n-Stack Replacem ent)<br><img src="https://img-blog.csdnimg.cn/20210609151247376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>⑥. 热度衰减<br><img src="https://img-blog.csdnimg.cn/20200907105339641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="6-HotSpot-VM-可以设置程序执行方式"><a href="#6-HotSpot-VM-可以设置程序执行方式" class="headerlink" title="6 HotSpot VM 可以设置程序执行方式"></a>6 HotSpot VM 可以设置程序执行方式</h3><ul>
<li>①. 缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：<br><img src="https://img-blog.csdnimg.cn/20200907105626586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②.-Xint:完全采用解释器模式执行程序；</li>
<li>③.-Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>④.-Xmixed:采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<h3 id="7-HotSpot-VM中的JIT分类"><a href="#7-HotSpot-VM中的JIT分类" class="headerlink" title="7 HotSpot VM中的JIT分类"></a>7 HotSpot VM中的JIT分类</h3><ul>
<li><p>①. 在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server<br>Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命.令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：<br><img src="https://img-blog.csdnimg.cn/20210609152102305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>②. C1和C2编译器不同的优化策略：<br><img src="https://img-blog.csdnimg.cn/20210609152138792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>③. 总结</p>
<ul>
<li><p>一般来讲，JIT编译出来的机器码性能比解释器高。</p>
</li>
<li><p>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-AOT编译器"><a href="#8-AOT编译器" class="headerlink" title="8 AOT编译器"></a>8 AOT编译器</h3><ul>
<li>①. jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)</li>
<li>②.所谓AOT编译，是与即时编译相对立的一个概念<br>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程 .java -&gt; .class -&gt; .so</li>
<li>③. 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>④. 缺点<br>破坏了java”一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。<br>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知</li>
</ul>
<h2 id="十一、引用计数法"><a href="#十一、引用计数法" class="headerlink" title="十一、引用计数法"></a>十一、引用计数法</h2><blockquote>
<p>前言:<br>(1). 判断对象存活的两种方式(引用计数算法、枚举根节点做可达性分析)<br>(2). 标记阶段(引用计数法、枚举根节点做可达性分析)<br>(3). 清除阶段(复制算法、标记清除算法、标记整理(压缩)算法、分代收集、增量收集算法、分区算法)</p>
</blockquote>
<h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1 引用计数法"></a>1 引用计数法</h3><ul>
<li>①. 原理:假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收</li>
<li>②. 最大的缺陷:无法解决循环引用的问题，gc永远都清除不了(这也是引用计数法被淘汰的原因)</li>
<li>③. 代码展示:</li>
</ul>
<pre><code class="java">/**
 * -XX:+PrintGCDetails
 * 证明:java使用的不是引用计数算法
 */
public class RefCountGC &#123;
    //这个成员属性唯一的作用就是占用一点内存
    private byte[] bigSize = new byte[5 * 1024 * 1024];//5MB

    Object reference = null;

    public static void main(String[] args) &#123;
        RefCountGC obj1 = new RefCountGC();
        RefCountGC obj2 = new RefCountGC();

        obj1.reference = obj2;
        obj2.reference = obj1;

        obj1 = null;
        obj2 = null;
        //显式的执行垃圾回收行为
        //这里发生GC，obj1和obj2能否被回收？
        System.gc();

        try &#123;
            Thread.sleep(1000000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200818105810942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>④. 注意:Java使用的不是引用计数法(Java之所以没有使用引用计数法，是由于不能解决循环引用问题) | (Python使用了是引用计数法)</li>
<li>⑥. Python如何解决循环引用( 扩展了解 )</li>
</ul>
<ol>
<li>手动解决:很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用(只要发生了回收，弱引用都会被回收)</li>
</ol>
<h3 id="2-枚举根节点做可达性分析"><a href="#2-枚举根节点做可达性分析" class="headerlink" title="2 枚举根节点做可达性分析"></a>2 枚举根节点做可达性分析</h3><ul>
<li>①. 基本思路是通过一系列名为”GC Roots”的对象(集合)作为起点，从这个被称为GC ROOTs 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象是不可达对象(被回收)，否则就是可达对象<br><img src="https://img-blog.csdnimg.cn/20190813201726657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190813202011669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 在java中，可作为GC Roots的对象有</li>
</ul>
<pre><code class="handlebars">    (1).虚拟机栈(栈帧中的局部变量表)中的引用对象(比如各个线程被调用的方法中使用到的参数、
    局部变量等)
    (2).本地方法栈中JNI(即一般来说native方法)中引用的对象[ 线程中的start方法 ]
    (3).静态属性引用的对象(比如:Java类的引用类型静态变量)
    (4).方法区中常量引用的对象(比如:字符串常量池(String Table)里的引用)

    (5).所有被synchronized持有的对象
    (6).Java虚拟机内部的引用(基本数据类型对应的Class对象，一些常驻的异常对象
    [如NullPointerException、OutofMemoryError]，系统类加载器)
    (7).反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    (8).注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域
不同，还可以有其他对象临时加入，共同构架完成整GC Roots集合。比如:分代收集和局部回收(面试加分项)
</code></pre>
<ul>
<li>③. 关于GCroot对象集合 注意事项:<br>注意:除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots 集合。比如: 分代收集和局部回收(面试加分项)<br>解释:如果只针对java堆中的某一区域进行垃圾回收(比如: 典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用时候就需要一并将关联的区域对象也加入到GC Roots 集合中考虑，才能保证可达性分析的准确性</li>
<li>④. 小技巧:由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root<br><img src="https://img-blog.csdnimg.cn/20200818113337135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>⑤. 优势:</li>
</ul>
<ol>
<li>相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效 等特点，更重要的是该算法可以有效解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集</li>
</ol>
<ul>
<li>⑥. 可达性分析算法的 注意事项:如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在 一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。 (即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的)</li>
</ul>
<h3 id="3-finalization机制"><a href="#3-finalization机制" class="headerlink" title="3 finalization机制"></a>3 finalization机制</h3><h4 id="3-1-finalization机制说明"><a href="#3-1-finalization机制说明" class="headerlink" title="3.1 finalization机制说明"></a>3.1 finalization机制说明</h4><ul>
<li>①. finalize( ) 方法允许在子类中被重写，用于对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等</li>
<li>②. 当垃圾回收器发现没有引用指向一个对象，即:垃圾收集此对象之前，总会先调用这个对象的finalize( )方法</li>
<li>③. Java语言提提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义逻辑</li>
</ul>
<h4 id="3-2-不主动调用某个对象的finalize-方法，应该交给垃圾回收机制调用，理由包括下面三点"><a href="#3-2-不主动调用某个对象的finalize-方法，应该交给垃圾回收机制调用，理由包括下面三点" class="headerlink" title="3.2 不主动调用某个对象的finalize( ) 方法，应该交给垃圾回收机制调用，理由包括下面三点"></a>3.2 不主动调用某个对象的finalize( ) 方法，应该交给垃圾回收机制调用，理由包括下面三点</h4><ul>
<li>①. 在finalize( )时可能会导致对象复活</li>
<li>②. finalize( )方法执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize( ) 方法将没有执行机会</li>
<li>③. 一个糟糕的finalize( )会严重影响GC的性能</li>
<li>④. 由于finalize( )方法的存在，虚拟机中的对象一般处于三种可能的状态</li>
</ul>
<h4 id="3-3-finalize-方法中虚拟机的状态"><a href="#3-3-finalize-方法中虚拟机的状态" class="headerlink" title="3.3 finalize( )方法中虚拟机的状态"></a>3.3 finalize( )方法中虚拟机的状态</h4><ul>
<li>①. 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收，但事实上，也并非是”非死不可”的，这时候它们暂时处于”缓刑”阶段。一个无法触及的对象肯能在某一个条件下”复活”自己，如果这样，那么对它的回收就是不合理的。为此，定义虚拟机中的对象可能有三种状态。如下:(掌握)</li>
</ul>
<ol>
<li>可触及的:从根节点开始，可以到达这个对象</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize( )中复活</li>
<li>不可触及的: 对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize( )只会被调用一次</li>
</ol>
<ul>
<li>②. 以上3种状态中，是由于finalize( )方法的存在，进行的区分。只有对象不可触及才可以被回收</li>
</ul>
<h4 id="3-4-判断一个对象是否可以进行回收-理解"><a href="#3-4-判断一个对象是否可以进行回收-理解" class="headerlink" title="3.4 判断一个对象是否可以进行回收(理解)"></a>3.4 判断一个对象是否可以进行回收(理解)</h4><ul>
<li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。 判定是否可以回收具体过程 判定一个对象objA是否可回收，至少要经历两次标记过程:<br><img src="https://img-blog.csdnimg.cn/20200818113908998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h4 id="3-5-代码演示"><a href="#3-5-代码演示" class="headerlink" title="3.5 代码演示"></a>3.5 代码演示</h4><pre><code class="java">/**
 * 测试Object类中finalize()方法，即对象的finalization机制。
 *
 */
public class CanReliveObj &#123;
    public static CanReliveObj obj;//类变量，属于 GC Root


    //此方法只能被调用一次
    @Override
    protected void finalize() throws Throwable &#123;
        super.finalize();
        System.out.println(&quot;调用当前类重写的finalize()方法&quot;);
        obj = this;//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系
    &#125;


    public static void main(String[] args) &#123;
        try &#123;
            obj = new CanReliveObj();
            // 对象第一次成功拯救自己
            obj = null;
            System.gc();//调用垃圾回收器
            System.out.println(&quot;第1次 gc&quot;);
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) &#123;
                System.out.println(&quot;obj is dead&quot;);
            &#125; else &#123;
                System.out.println(&quot;obj is still alive&quot;);
            &#125;
            System.out.println(&quot;第2次 gc&quot;);
            // 下面这段代码与上面的完全相同，但是这次自救却失败了
            obj = null;
            System.gc();
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) &#123;
                System.out.println(&quot;obj is dead&quot;);
            &#125; else &#123;
                System.out.println(&quot;obj is still alive&quot;);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-复制算法-Copying"><a href="#4-复制算法-Copying" class="headerlink" title="4  复制算法(Copying)"></a>4  复制算法(Copying)</h3><ul>
<li>①. 核心思想:将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在.使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li>
<li>②. 描述(重点掌握)<br><img src="https://img-blog.csdnimg.cn/20191210103115370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 一般过程(图解)<br><img src="https://img-blog.csdnimg.cn/2020081814111378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 优缺点 掌握</li>
</ul>
<ol>
<li>:①.没有标记和清除过程，实现简单，运行高效 ②. 不会产生内存碎片，且对象完整不丢</li>
<li>缺点:①. 浪费了10%的空间 ②. 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
<li>注意:复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。因为新生代中的对象一般都是朝生夕死的，在新生代中使用复制算法是非常好的</li>
</ol>
<ul>
<li>⑤. 注意:是当伊甸园区满后，会触发minjor gc，进行垃圾的回收</li>
</ul>
<h3 id="5-标记清除算法-Mark一Sweep"><a href="#5-标记清除算法-Mark一Sweep" class="headerlink" title="5 标记清除算法(Mark一Sweep)"></a>5 标记清除算法(Mark一Sweep)</h3><ul>
<li>①. 标记一清除算法(Mark一Sweep)是一种非常基础和常见的垃圾收集算法，该算法被J . McCarthy等人在1960年提出并并应用于Lisp语言</li>
<li>②. 标记:Collector(垃圾回收器)从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>③. 清除: Collector(垃圾回收器)对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
<li>④. 图解: CMS使用这种方式<br><img src="https://img-blog.csdnimg.cn/20210612172349990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优:不需要额外的空间</li>
<li>缺点:①.两次扫描，耗时严重 ②.清理出来的空闲内存不连续，会产生内存碎片，需要维护一个空闲列表 ③.效率比较低:递归与全堆对象遍历两次(经历了两次遍历)</li>
</ol>
<ul>
<li>⑥. 注意:这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放</li>
</ul>
<h3 id="6-标记整理-压缩-算法-Mark-Compact"><a href="#6-标记整理-压缩-算法-Mark-Compact" class="headerlink" title="6 标记整理(压缩)算法(Mark-Compact)"></a>6 标记整理(压缩)算法(Mark-Compact)</h3><ul>
<li>①. 背景:</li>
</ul>
<ol>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li>
<li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记一压缩(Mark一Compact) 算法由此诞生</li>
<li>1970年前后，G. L. Steele 、C. J. Chene和D.S. Wise 等研究者发布标记一压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</li>
</ol>
<ul>
<li>②. 执行过程:</li>
</ul>
<ol>
<li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>最后，清理边界外所有的空间。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</li>
</ol>
<ul>
<li>③. 图解:<br><img src="https://img-blog.csdnimg.cn/20200818141849116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>④. 指针碰撞<br>(如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer))</li>
<li>⑤. 优缺点</li>
</ul>
<ol>
<li>优点:①. 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可②. 消除了复制算法当中，内存减半的高额代价</li>
<li>缺点:①. 从效率.上来说，标记一整理算法要低于复制算法。②. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序。即: STW</li>
</ol>
<h3 id="7-分代收集"><a href="#7-分代收集" class="headerlink" title="7 分代收集"></a>7 分代收集</h3><blockquote>
<p>写在最前面:<br>( 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除)</p>
</blockquote>
<ul>
<li>①. 没有最好的算法，只有更合适的算法</li>
<li>②. 分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生。与其说分代搜集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden在8分空间，survivor在两个1分，只浪费10%的空闲空间。老年代使用标记清除/标记压缩算法清除</li>
<li>③. 新生代(Young Gen)</li>
</ul>
<ol>
<li>新生代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li>
</ol>
<ul>
<li>④. 老年代(Tenured Gen)</li>
</ul>
<ol>
<li>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记一整理的混合实现。<br>Mark阶段的开销与存活对象的数量成正比<br>Sweep阶段的开销与所管理区域的大小成正相关<br>Compact阶段的开销与存活对象的数据成正比</li>
</ol>
<h3 id="8-增量收集算法-了解"><a href="#8-增量收集算法-了解" class="headerlink" title="8 增量收集算法(了解)"></a>8 增量收集算法(了解)</h3><ul>
<li>①. 上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集(Incremental Collecting) 算法的诞生</li>
<li>②. 基本思想(理解)</li>
</ul>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li>
<li>总的来说，增量收集算法的基础仍是传统的标记一清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
</ol>
<ul>
<li>③. 缺点:<br>(使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。)</li>
</ul>
<h3 id="9-分区算法-了解"><a href="#9-分区算法-了解" class="headerlink" title="9  分区算法(了解)"></a>9  分区算法(了解)</h3><ul>
<li>①. 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>②. 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间</li>
<li>③. 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200818143418977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十二、System-gc"><a href="#十二、System-gc" class="headerlink" title="十二、System.gc"></a>十二、System.gc</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1 System.gc()的理解"></a>1 System.gc()的理解</h3><ul>
<li>①. 在默认情况下，通过System.gc( )或者Runtime . getRuntime( ).gc( )的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>②. 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(无法保证马上触发GC)。[不保证一定会发生垃圾收集，只是给jvm发出提示]</li>
<li>③. JVM实现者可以通过system.gc( )调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc( )</li>
<li>④. 以下代码，如果注掉System.runFinalization( ); 那么控制台不保证一定打印，证明了System.gc( )无法保证GC一定执行</li>
</ul>
<pre><code class="java">public class SystemGCTest &#123;
    public static void main(String[] args) &#123;
        new SystemGCTest();
        System.gc();//提醒jvm的垃圾回收器执行gc，但是不确定是否马上执行gc
        //与Runtime.getRuntime().gc();的作用一样。
        System.runFinalization();//强制调用使用引用的对象的finalize()方法
    &#125;

    @Override
    protected void finalize() throws Throwable &#123;
        super.finalize();
        System.out.println(&quot;SystemGCTest 重写了finalize()&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>⑤. 手动gc理解不可达对象的回收行为</li>
</ul>
<pre><code class="java">public class LocalVarGC &#123;
    public void localvarGC1() &#123;
        byte[] buffer = new byte[10 * 1024 * 1024];//10MB
        System.gc();
        //输出: 不会被回收， FullGC时被放入老年代
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10788K(251392K)， 0.0089741 secs] [Times: user=0.01 sys=0.00， real=0.01 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 52K-&gt;10649K(175104K)] 10788K-&gt;10649K(251392K)， [Metaspace: 3253K-&gt;3253K(1056768K)]， 0.0074098 secs] [Times: user=0.01 sys=0.02， real=0.01 secs]
    &#125;

    public void localvarGC2() &#123;
        byte[] buffer = new byte[10 * 1024 * 1024];
        buffer = null;
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;544K(76288K)] 14174K-&gt;552K(251392K)， 0.0011742 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 544K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 552K-&gt;410K(251392K)， [Metaspace: 3277K-&gt;3277K(1056768K)]， 0.0054702 secs] [Times: user=0.01 sys=0.00， real=0.01 secs]

    &#125;

    public void localvarGC3() &#123;
        &#123;
            byte[] buffer = new byte[10 * 1024 * 1024];
        &#125;
        System.gc();
        //输出: 不会被回收， FullGC时被放入老年代
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10784K(251392K)， 0.0076032 secs] [Times: user=0.02 sys=0.00， real=0.01 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 48K-&gt;10649K(175104K)] 10784K-&gt;10649K(251392K)， [Metaspace: 3252K-&gt;3252K(1056768K)]， 0.0096328 secs] [Times: user=0.01 sys=0.01， real=0.01 secs]
    &#125;

    public void localvarGC4() &#123;
        &#123;
            byte[] buffer = new byte[10 * 1024 * 1024];
        &#125;
        int value = 10;
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;496K(76288K)] 14174K-&gt;504K(251392K)， 0.0016517 secs] [Times: user=0.01 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 496K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 504K-&gt;410K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0055183 secs] [Times: user=0.00 sys=0.00， real=0.01 secs]
    &#125;

    public void localvarGC5() &#123;
        localvarGC1();
        System.gc();
        //输出: 正常被回收
        //[GC (System.gc()) [PSYoungGen: 14174K-&gt;10720K(76288K)] 14174K-&gt;10744K(251392K)， 0.0121568 secs] [Times: user=0.02 sys=0.00， real=0.02 secs]
        //[Full GC (System.gc()) [PSYoungGen: 10720K-&gt;0K(76288K)] [ParOldGen: 24K-&gt;10650K(175104K)] 10744K-&gt;10650K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0101068 secs] [Times: user=0.01 sys=0.02， real=0.01 secs]
        //[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10650K-&gt;10650K(251392K)， 0.0005717 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]
        //[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10650K-&gt;410K(175104K)] 10650K-&gt;410K(251392K)， [Metaspace: 3279K-&gt;3279K(1056768K)]， 0.0045963 secs] [Times: user=0.01 sys=0.00， real=0.00 secs]
    &#125;

    public static void main(String[] args) &#123;
        LocalVarGC local = new LocalVarGC();
        local.localvarGC5();
    &#125;
&#125;
</code></pre>
<h3 id="2-内存溢出-out-of-Memory"><a href="#2-内存溢出-out-of-Memory" class="headerlink" title="2 内存溢出(out of Memory)"></a>2 内存溢出(out of Memory)</h3><ul>
<li><p>①. javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存</p>
</li>
<li><p>②. 说明Java虚拟机的堆内存不够。原因有二</p>
<ul>
<li>Java虚拟机的堆内存设置不够(比如:可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整)</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</li>
</ul>
</li>
<li><p>③. 这里面隐含着一层意思是，在抛出0utOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如:在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p><strong>④. 当然，也不是在任何情况下垃圾收集器都会被触发的</strong><br>(比如，我们去分配一一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError)</p>
</li>
</ul>
<h3 id="3-内存泄漏-Memory-Leak"><a href="#3-内存泄漏-Memory-Leak" class="headerlink" title="3 内存泄漏(Memory Leak)"></a>3 内存泄漏(Memory Leak)</h3><ul>
<li><p>①. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</p>
</li>
<li><p>②. 但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏</p>
</li>
<li><p>③. 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p>
</li>
<li><p>④. Java中内存泄漏的8种情况</p>
<ul>
<li>单例模式(单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。)</li>
<li>一些提供close的资源未关闭导致内存泄漏 数据库连接( dataSourse. getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</li>
<li>静态集合类(如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收)</li>
<li>内部类持有外部类(内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。)</li>
<li>变量不合理的作用域(一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生)</li>
</ul>
<ul>
<li><p>改变哈希值</p>
</li>
<li><p>缓存泄漏(内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据)</p>
</li>
<li><p>监听器和回调(内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚)</p>
</li>
</ul>
</li>
</ul>
<pre><code class="typescript">//静态集合类
public class MemoryLeak &#123;
    static List list = new ArrayList();

    public void oomTests() &#123;
        Object obj = new Object();//局部变量
        list.add(obj);
    &#125;
&#125;
//变量不合理的作用域
public class UsingRandom &#123;
     private String msg;
     public void receiveMsg()&#123;
        //private String msg;
        readFromNet();// 从网络中接受数据保存到msg中
        saveDB();// 把msg保存到数据库中
        //msg = null;
     &#125;
&#125;
//改变哈希值
public class ChangeHashCode &#123;
    public static void main(String[] args) &#123;
        HashSet set = new HashSet();
        Person p1 = new Person(1001， &quot;AA&quot;);
        Person p2 = new Person(1002， &quot;BB&quot;);

        set.add(p1);
        set.add(p2);
        p1.name = &quot;CC&quot;;
        set.remove(p1);
        System.out.println(set);//2个对象！
        
//        set.add(new Person(1001， &quot;CC&quot;));
//        System.out.println(set);
//        set.add(new Person(1001， &quot;AA&quot;));
//        System.out.println(set);

    &#125;
&#125;
</code></pre>
<h3 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4 Stop The World"></a>4 Stop The World</h3><ul>
<li><p>①. Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW</p>
</li>
<li><p>②. STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li><p>③. 哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p>④. STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉</p>
</li>
<li><p>⑤. 开发中不要用System.gc()，会导致full gc，会导致Stop一the一world的发生</p>
</li>
<li><p>⑥. 什么情况下会导致stop the world 记住</p>
<ul>
<li>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</li>
</ul>
<ul>
<li>进行gc的时候会发生STW现象(调用finalize()方法的时候会暂停用户线程</li>
<li>System.gc( ) | 调用finalize( )方法</li>
</ul>
</li>
</ul>
<h3 id="5-多线程中的并行与并发"><a href="#5-多线程中的并行与并发" class="headerlink" title="5 多线程中的并行与并发"></a>5 多线程中的并行与并发</h3><ul>
<li><p>①. 并发(Concurrent)</p>
<ul>
<li>在操作系统中，是指一个时间段中有几个程序都处于己启动运行到运行完毕之间，且这几个程序都是在同一个处理器_上运行</li>
<li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li>
</ul>
<ul>
<li>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163718413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>②. 并行(Parallel)</p>
<ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)</li>
</ul>
<ul>
<li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以 并行</p>
</li>
<li><p>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163818501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="6-垃圾回收的并行、串行、并发"><a href="#6-垃圾回收的并行、串行、并发" class="headerlink" title="6 垃圾回收的并行、串行、并发"></a>6 垃圾回收的并行、串行、并发</h3><ul>
<li><p>①. 并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、 Parallel Scavenge、 Parallel 0ld；</p>
</li>
<li><p>②. 串行(Serial)</p>
<ul>
<li>相较于并行的概念，单线程执行。</li>
</ul>
<ul>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
<li>图解:<br><img src="https://img-blog.csdnimg.cn/20200818163928870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>③. 并发</p>
<ul>
<li><p>指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行</p>
</li>
<li><p>在同一个时间段，用户线程和垃圾回收线程同时执行</p>
</li>
<li><p>图解<br><img src="https://img-blog.csdnimg.cn/20200818164027906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-安全点-Safepoint"><a href="#7-安全点-Safepoint" class="headerlink" title="7 安全点(Safepoint)"></a>7 安全点(Safepoint)</h3><ul>
<li><p>①. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为 “安全点(Safepoint)”</p>
</li>
<li><p>②. Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</p>
</li>
<li><p>③. 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><p>抢先式中断: (目前没有虚拟机采用了) 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
</li>
<li><p>主动式中断: 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-安全区域-Safe-Region"><a href="#8-安全区域-Safe-Region" class="headerlink" title="8 安全区域(Safe Region)"></a>8 安全区域(Safe Region)</h3><ul>
<li><p>①. Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
</li>
<li><p>②. 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
</li>
<li><p>③. 实际执行时:</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发GC，JVM会忽略标识为Safe Region状态的线程；</li>
</ul>
<ul>
<li>当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</li>
</ul>
</li>
</ul>
<h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9 引用"></a>9 引用</h3><ul>
<li><p>①. 我们希望能描述这样一类对象: 当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。 -【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用.场景是什么？</p>
</li>
<li><p>②. 在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong<br>Reference)、软引用(Soft Reference) 、弱引用(Weak Reference) 和虚引用(Phantom Reference) 4种，这4种引用强度依次逐渐减弱</p>
</li>
<li><p>③. 除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。<br><img src="https://img-blog.csdnimg.cn/20200819092213852.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
</li>
<li><p>⑤. 简单介绍下强软弱虚引用</p>
<ul>
<li>强引用(StrongReference)I :最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object( )”这种引用关系。 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
</ul>
<ul>
<li><p>软引用(SoftReference) :在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常 内存不足即回收</p>
</li>
<li><p>弱引用(WeakReference) :被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。 发现即回收</p>
</li>
<li><p>虚引用(PhantomReference) :一个对象是否有虛引用的存在，完全不会对其生存时 间构成影响，也无法通过虚引用来获得一个对象的实例。 为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210331225705856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="9-1-强引用-不回收"><a href="#9-1-强引用-不回收" class="headerlink" title="9.1  强引用:不回收"></a>9.1  强引用:不回收</h4><ul>
<li>在Java程序中，最常见的引用类型是强引用(普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。</li>
<li>当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li>
<li>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li>
</ul>
<h4 id="9-2-软引用-内存不足即回收"><a href="#9-2-软引用-内存不足即回收" class="headerlink" title="9.2 软引用: 内存不足即回收"></a>9.2 软引用: 内存不足即回收</h4><ul>
<li><p>①. 软引用是用来描述一 些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>注意:一次回收是回收强引用中没有引用的对象</p>
</li>
<li><p>②. 软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存</p>
</li>
<li><p>③. 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得.已才清理</p>
</li>
<li><p>④. 软引用:</p>
<ul>
<li><p>当内存足够: 不会回收软用的可达对象</p>
</li>
<li><p>当内存不够时: 会回收软引用的可达对象</p>
</li>
</ul>
</li>
<li><p>⑤. 在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
</li>
</ul>
<pre><code class="java">Object obj = new object()； //声明强引用
SoftReference&lt;0bject&gt; sf = new SoftReference&lt;0bject&gt;(obj)；
obj = null； //销毁强引用
</code></pre>
<ul>
<li>⑥. 测试代码</li>
</ul>
<pre><code class="java">/**
 * 软引用的测试:内存不足即回收
 * -Xms10m -Xmx10m -XX:+PrintGCDetails
 */
public class SoftReferenceTest &#123;
    public static class User &#123;
        public User(int id， String name) &#123;
            this.id = id;
            this.name = name;
        &#125;

        public int id;
        public String name;

        @Override
        public String toString() &#123;
            return &quot;[id=&quot; + id + &quot;， name=&quot; + name + &quot;] &quot;;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //创建对象，建立软引用
//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1， &quot;songhk&quot;));
        //上面的一行代码，等价于如下的三行代码
        User u1 = new User(1，&quot;songhk&quot;);
        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(u1);
        u1 = null;//取消强引用


        //从软引用中重新获得强引用对象
        System.out.println(userSoftRef.get());

        System.gc();
        System.out.println(&quot;After GC:&quot;);
//        //垃圾回收之后获得软引用中的对象
        System.out.println(userSoftRef.get());//由于堆空间内存足够，所有不会回收软引用的可达对象。
//
        try &#123;
            //让系统认为内存资源紧张、不够
//            byte[] b = new byte[1024 * 1024 * 7];
            byte[] b = new byte[1024 * 7168 - 399 * 1024];//恰好能放下数组又放不下u1的内存分配大小 不会报OOM
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //再次从软引用中获取数据
            System.out.println(userSoftRef.get());//在报OOM之前，垃圾回收器会回收软引用的可达对象。
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="9-3-弱引用-发现即回收"><a href="#9-3-弱引用-发现即回收" class="headerlink" title="9.3 弱引用: 发现即回收"></a>9.3 弱引用: 发现即回收</h4><ul>
<li>①. 弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</li>
<li>②. 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li>
<li>③. 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li>
<li>④. 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</li>
<li>⑤. 在JDK1.2版之后提后了java.lang.ref.WeakReference类来实现弱引用</li>
</ul>
<pre><code class="java">Object obj = new object()； //声明强引用
WeakReference&lt;0bject&gt; sf = new WeakReference&lt;0bject&gt;(obj)；
obj = null； //销毁强引用
</code></pre>
<ul>
<li>⑥. 面试题:你开发中使用过WeakHashMap吗？</li>
</ul>
<ol>
<li>通过查看WeakHashMap源码，可以看到其内部类Entry使用的就是弱引用</li>
<li>line 702 -&gt; private static class Entry&lt;K，V&gt; extends WeakReference implements Map.Entry&lt;K，V&gt; {…}</li>
</ol>
<pre><code class="java">public class WeakReferenceTest &#123;
    public static class User &#123;
        public User(int id， String name) &#123;
            this.id = id;
            this.name = name;
        &#125;

        public int id;
        public String name;

        @Override
        public String toString() &#123;
            return &quot;[id=&quot; + id + &quot;， name=&quot; + name + &quot;] &quot;;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //构造了弱引用
        WeakReference&lt;User&gt; userWeakRef = new WeakReference&lt;User&gt;(new User(1， &quot;songhk&quot;));
        //从弱引用中重新获取对象
        System.out.println(userWeakRef.get());

        System.gc();
        // 不管当前内存空间足够与否，都会回收它的内存
        System.out.println(&quot;After GC:&quot;);
        //重新尝试从弱引用中获取对象
        System.out.println(userWeakRef.get());
    &#125;
&#125;
</code></pre>
<h4 id="9-4-虚引用-对象回收跟踪"><a href="#9-4-虚引用-对象回收跟踪" class="headerlink" title="9.4 虚引用: 对象回收跟踪"></a>9.4 虚引用: 对象回收跟踪</h4><ul>
<li>①. 虚引用(Phantom Reference)，也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li>
<li>②. 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知。</li>
<li>③. 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。虚引用的get方法总是返回给null，因此无法访问对应的引用对象 理解</li>
<li>④. 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录‘’</li>
<li>⑤. 在JDK 1. 2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<pre><code class="java">object obj = new object();
ReferenceQueuephantomQueue = new ReferenceQueue( ) ;
PhantomReference&lt;object&gt; pf = new PhantomReference&lt;object&gt;(obj， phantomQueue); 
obj = null;
</code></pre>
<ul>
<li>⑥. 测试代码</li>
</ul>
<pre><code class="java">/***
 * -xms10m -xmx10m
 */
public class MyObject &#123;
    public static void main(String[] args) &#123;

        ReferenceQueue&lt;MyObject&gt; referenceQueue = new ReferenceQueue();
        PhantomReference&lt;MyObject&gt; phantomReference = new PhantomReference&lt;&gt;(new MyObject()，referenceQueue);
        //System.out.println(phantomReference.get());

        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();

        new Thread(() -&gt; &#123;
            while (true)
            &#123;
                list.add(new byte[1 * 1024 * 1024]);
                try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;
                System.out.println(phantomReference.get());
            &#125;
        &#125;，&quot;t1&quot;).start();

        new Thread(() -&gt; &#123;
            while (true)
            &#123;
                Reference&lt;? extends MyObject&gt; reference = referenceQueue.poll();
                if (reference != null) &#123;
                    //下面这句话被打印出说明进行了gc，然后将对象放在了引用队列中，我们可以使用poll方法获取
                    System.out.println(&quot;***********有虚对象加入队列了&quot;+reference);
                &#125;
            &#125;
        &#125;，&quot;t2&quot;).start();

        //暂停几秒钟线程
        try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;

    &#125;

    @Override
    protected void finalize() throws Throwable &#123;
        // gc finalize method over 这句话被打印出来，说明进行了gc
        System.out.println(&quot;gc finalize method over&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="十三、评估GC性能指标"><a href="#十三、评估GC性能指标" class="headerlink" title="十三、评估GC性能指标"></a>十三、评估GC性能指标</h2><blockquote>
<p>面试遇到面试官问这部分可以这样回答:<br>不同的厂商会考虑使用不同的JVM，不同的JVM会使用不同的垃圾收集器，下面我介绍下主流的垃圾收集器有哪些(主流的7种)，下面你就可以展开去说明七种垃圾收集器的每一个细节。<br>(1).截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器<br><img src="https://img-blog.csdnimg.cn/2020092610513159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>(2).不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合(连线)，如下图:<br><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200926105608725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-评估GC的性能指标"><a href="#1-评估GC的性能指标" class="headerlink" title="1 评估GC的性能指标"></a>1 评估GC的性能指标</h3><ul>
<li>①. 吞吐量:运行用户代码的时间占总运行时间的比例<br>吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)<br>比如:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%<br>吞吐量优先，意味着在单位时间内，STW的时间最短:0.2 + 0.2 = 0.4</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621105540919.png" alt="在这里插入图片描述"></p>
<ul>
<li>②. 暂停时间:执行垃圾收集时，程序的工作线程被暂停的时间<br>暂停时间优先，意味着尽可能让单次STW的时间最短:0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621105512858.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 内存占用: Java堆区所占的内存大小</p>
</li>
<li><p>④. 垃圾收集开销:吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p>
</li>
<li><p>⑤. 收集频率:相对于应用程序的执行，收集操作发生的频率<br>(类似于大学洗衣服，天天洗，每次很快洗完;一周洗，洗很久)<br>(手机频率高，垃圾线程所用时间短，吞吐量低)</p>
</li>
<li><p>⑥. 评估GC的性能指标:吞吐量vs暂停时间</p>
<ul>
<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用 多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
</ul>
<ul>
<li><p>简单来说，主要抓住两点:吞吐量、暂停时间</p>
</li>
<li><p>现在JVM调优标准:在最大吞吐量优先的情况下，降低停顿时间</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2 不同的垃圾回收器概述"></a>2 不同的垃圾回收器概述</h3><ul>
<li><p>①. 垃圾收集器发展史<br>1999年随JDK1.3.1一起来的是串行方式的Serial GC ，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本<br>2002年2月26日，Parallel GC 和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布<br>Parallel GC在JDK6之后成为HotSpot默认GC<br>2012年，在JDK1.7u4版本中，G1可用。-XX:+UseG1GC<br>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS<br>2018年3月，JDK 10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟<br>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为”No-Op(无操作)”回收器。同时，引入ZGC:可伸缩的低延迟垃圾回收器(Experimental)<br>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC:低停顿时间的GC(Experimental)<br>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统<br>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</p>
</li>
<li><p>②. 7款经典的垃圾收集器<br>串行回收器:Serial、Serial Old<br>并行回收器:ParNew、Parallel Scavenge、Parallel Old<br>并发回收器:CMS、G1</p>
</li>
<li><p>③. 7款经典的垃圾收集器与垃圾分代之间的关系<br>新生代收集器: Serial GC、ParNew GC、Parallel Scavenge GC<br>老年代收集器: Serial 0ld GC、 Parallel 0ld GC、 CMS GC<br>整堆收集器: G1 GC<br><img src="https://img-blog.csdnimg.cn/20200926110651301.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>④. 垃圾收集器的组合关系</p>
<ul>
<li><p>两个收集器间有连线，表明它们可以搭配使用:Serial/Serial 01d、Serial/CMS、 ParNew/Serial 01d、ParNew/CMS、Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；</p>
</li>
<li><p>其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial 01d这两个组合声明为废弃(JEP 173) ，并在JDK 9中完全取消了这些组合的支持(JEP214)，即:移除。(绿色虚线)JDK 14中:弃用Parallel Scavenge和Serial0ld GC组合(JEP366 )(青色虚线)JDK 14中:删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210621104214580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/37b129b3e4a7405b992584c91962da37.png" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 查看默认的垃圾收集器</li>
</ul>
<ol>
<li>-xx:+PrintCommandLineFlags: 查看命令行相关参数(包含使用的垃圾收集器)</li>
</ol>
<pre><code class="java">/**
 *  -XX:+PrintCommandLineFlags
 *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC
 *  -XX:+UseParNewGC:标明新生代使用ParNew GC
 *  -XX:+UseParallelGC:表明新生代使用Parallel GC
 *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC
 *  说明:二者可以相互激活
 *  -XX:+UseConcMarkSweepGC:表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用
 */
public class GCUseTest &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();

        while(true)&#123;
            byte[] arr = new byte[100];
            list.add(arr);
            try &#123;
                Thread.sleep(10);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
输出:
(-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 
-XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers 
-XX:+UseCompressedOops -XX:+UseParallelGC)
</code></pre>
<ol>
<li>使用命令行指令: jinfo 一flag 相关垃圾回收器参数进程ID<br>( jinfo -flag UseParallelGC 进程id<br>jinfo -flag UseParallelOldGC 进程id )<br><img src="https://img-blog.csdnimg.cn/20200926111157662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="3-Serial、SerialOld-回收器-串行回收-了解"><a href="#3-Serial、SerialOld-回收器-串行回收-了解" class="headerlink" title="3 Serial、SerialOld 回收器:串行回收(了解)"></a>3 Serial、SerialOld 回收器:串行回收(了解)</h3><ul>
<li>①. Serial收集器采用复制算法、串行回收和”Stop一 the一World”机制的方式执行内存回收</li>
<li>②. Serial 0ld收集器同样也采用了串行回收 和”Stop the World”机制，只不过内存回收算法使用的是标记一压缩算法</li>
<li>③. 单线程回收:使用一个cpu或一条线程去完成垃圾收集工作 | 必须暂停其他所有的工作线程</li>
<li>④. 使用 -XX: +UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器<br>等价于新生代用Serial GC，且老年代用Serial 0ld GC<br>控制台输出:<br>-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC<br><img src="https://img-blog.csdnimg.cn/20210621204739933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-ParNew回收器-并行回收-了解"><a href="#4-ParNew回收器-并行回收-了解" class="headerlink" title="4 ParNew回收器:并行回收(了解)"></a>4 ParNew回收器:并行回收(了解)</h3><ul>
<li>①. 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本</li>
<li>②. ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop一 the一World”机制</li>
<li>③. 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li>
<li>④. 在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用.ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器， 不影响老年代</li>
<li>⑤. -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数。<br><img src="https://img-blog.csdnimg.cn/20210621204818609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. SerialGC 和 ParNewGC哪个更好?<ul>
<li>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销</li>
</ul>
</li>
</ul>
<h3 id="5-Parallel、ParallelOld-吞吐量优先"><a href="#5-Parallel、ParallelOld-吞吐量优先" class="headerlink" title="5 Parallel、ParallelOld:吞吐量优先"></a>5 Parallel、ParallelOld:吞吐量优先</h3><ul>
<li><p>①. HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scav enge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。在Java8中，默认是此垃圾收集器</p>
</li>
<li><p>②. 那么Parallel收集器的出现是否多此一举？</p>
<ul>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughp ut)，它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别</p>
</li>
</ul>
</li>
<li><p>③. 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>④. Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 Parallel 0ld收集器，用来代替老年代的Serial 0ld收集器</p>
</li>
<li><p>⑤. Parallel 0ld收集器采用了标记一压缩算法，但同样也是基于并行回收和”Stop一the一World”机制<br><img src="https://img-blog.csdnimg.cn/20210621205034323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>⑥. 在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错</p>
</li>
<li><p>⑦. 参数配置<br>-XX:+UseParallelGC手动指定年轻代使用Parallel并行收集器执行内存回收任务<br>-XX:+UseParallelOldGC手动指定老年代都是使用并行回收收集器。<br>(分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活))<br>-XX:ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能<br>(在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。<br>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]/8] )<br>-XX:MaxGCPauseMillis:设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒<br>(为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数<br>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制<br>该参数使用需谨慎)<br>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略<br>(在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio)和停顿时间(MaxGCPauseMills)，让虚拟机自己完成调优工作)</p>
</li>
</ul>
<h3 id="6-详解-XX-PrintGCDetails"><a href="#6-详解-XX-PrintGCDetails" class="headerlink" title="6 详解-XX:+PrintGCDetails"></a>6 详解-XX:+PrintGCDetails</h3><ul>
<li>①. Minor GC<br><img src="https://img-blog.csdnimg.cn/20200926194721899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>②. Full GC<br><img src="https://img-blog.csdnimg.cn/20200926194816173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>③. 举例补充</li>
</ul>
<pre><code class="java">/**
 * 在jdk7 和 jdk8中分别执行
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
 */
public class GCLogTest1 &#123;
    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() &#123;
        byte[] allocation1， allocation2， allocation3， allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    &#125;

    public static void main(String[] agrs) &#123;
        testAllocation();
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200926194908760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-其他垃圾回收器概述"><a href="#7-其他垃圾回收器概述" class="headerlink" title="7 其他垃圾回收器概述"></a>7 其他垃圾回收器概述</h3><ul>
<li><p>①. Open JDK12的Shenandoah GC</p>
<ul>
<li>暂时时间短、吞吐量下降</li>
<li>red hot 团队</li>
</ul>
</li>
<li><p>②. 革命性的ZGC(jdk11-oracle)<br>( 在尽可能对吞吐量影响不大的前提下.实现在任意堆内存大小都可以把垃圾收集的停顿时间控制在10毫秒之内)</p>
</li>
</ul>
<h2 id="十四、字节码文件"><a href="#十四、字节码文件" class="headerlink" title="十四、字节码文件"></a>十四、字节码文件</h2><h3 id="1-字节码文件的跨平台性-了解"><a href="#1-字节码文件的跨平台性-了解" class="headerlink" title="1 字节码文件的跨平台性(了解)"></a>1 字节码文件的跨平台性(了解)</h3><ul>
<li><p>①. Java语言：跨平台的语言</p>
<ul>
<li>当Java源代码成功编译为字节码后，如果想在不同的平台上运行，则无须再次编译</li>
</ul>
<ul>
<li>这个优势不再那么吸引人了。Python PHP perl ruby lisp等有强大的解释器</li>
<li>跨平台似乎已经快成为一门语言必须的特征</li>
</ul>
</li>
<li><p>②. Java虚拟机：跨语言的平台：<br>( Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>③. 想要让一个Java程序正确地运行在JVM中，Java源码就必须要编译为符合JVM规范的字节码</p>
<ul>
<li><strong>前端编译器的主要任务`</strong> 就是负责将符合Java语言规范的Java代码转换为符合JVM规范的字节码文件</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
</ul>
<ul>
<li>javac编译器在将Java源码编译为一个有效的字节码文件过程中经历了4个步骤：分别是词法解析、语法解析、语义解析以及生成字节码<img src="https://img-blog.csdnimg.cn/20201004103706891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210125201559980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h3 id="2-Java的前端编译器-了解"><a href="#2-Java的前端编译器-了解" class="headerlink" title="2  Java的前端编译器(了解)"></a>2  Java的前端编译器(了解)</h3><ul>
<li>①. 前端编译器 vs 后端编译器<br><img src="https://img-blog.csdnimg.cn/20210125202110613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 图解：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201004103842512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-透过字节码指令看代码细节"><a href="#3-透过字节码指令看代码细节" class="headerlink" title="3 透过字节码指令看代码细节"></a>3 透过字节码指令看代码细节</h3><ul>
<li>①. Integer：透过字节码可以看出，当Integer的范围在-128 - +127 之间会在数组中直接拿取数值，超过这个范围会重新new对象</li>
</ul>
<pre><code class="java">public class IntegerTest &#123;
    public static void main(String[] args) &#123;

        /*
        * 透过字节码可以看出，当Integer的范围在-128 - +127 之间会在数组中直接拿取数值
        * 超过这个范围会重新new对象
        * */
        Integer x = 5;
        int y = 5;
        System.out.println(x == y);

        Integer i1 = 10;
        Integer i2 = 10;
        System.out.println(i1 == i2);//true

        Integer i3 = 128;
        Integer i4 = 128;
        System.out.println(i3 == i4);//false
    &#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210518210300611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. 在父类中调用方法，如果子类有重写，那么调用的是子类的方法，如代码中的this.print( )<br>注意:这里的this是指的 new son( )</li>
</ul>
<pre><code class="java">/*
成员变量（非静态的）的赋值过程：
 ① 默认初始化 -
 ② 显式初始化 /代码块中初始化 -
 ③ 构造器中初始化 -
 ④ 有了对象之后，可以“对象.属性”或&quot;对象.方法&quot;
 的方式对成员变量进行赋值。
 */
class Father &#123;
    int x = 10;
    public Father() &#123;
        this.print();
        x = 20;
    &#125;
    public void print() &#123;
        System.out.println(&quot;Father.x = &quot; + x);
    &#125;
&#125;
class Son extends Father &#123;
    int x = 30;
//    float x = 30.1F;
    public Son() &#123;
        this.print();
        x = 40;
    &#125;
    public void print() &#123;
        System.out.println(&quot;Son.x = &quot; + x);
    &#125;
&#125;

public class SonTest &#123;
    public static void main(String[] args) &#123;
        Father f = new Son();
        System.out.println(f.x);//编译看左边，执行也看左边
    &#125;
&#125;
    /*
     son.x=0 
     son.x=30
     20
    */
</code></pre>
<h3 id="4-如何解读供虚拟机解释执行的二进制字节码？"><a href="#4-如何解读供虚拟机解释执行的二进制字节码？" class="headerlink" title="4 如何解读供虚拟机解释执行的二进制字节码？"></a>4 如何解读供虚拟机解释执行的二进制字节码？</h3><ul>
<li>①. 一个一个二进制的看。这里用到的是Notepad++，需要安装一个HEX-Editor插件，或者使用Binary Viewer<br><img src="https://img-blog.csdnimg.cn/20210501170009655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 使用javap指令：jdk自带的反解析工具</li>
<li>③. 使用IDEA插件：jclasslib 或jclasslib bytecode viewer客户端工具(可视化更好)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501170050355.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021050117005648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-什么是字节码指令"><a href="#5-什么是字节码指令" class="headerlink" title="5 什么是字节码指令"></a>5 什么是字节码指令</h3><ul>
<li>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码<br>比如:操作码(操作数)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021050121242727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="十五、Class文件结构"><a href="#十五、Class文件结构" class="headerlink" title="十五、Class文件结构"></a>十五、Class文件结构</h2><p><img src="https://img-blog.csdnimg.cn/20210502100311471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-class文件结构细节概述"><a href="#1-class文件结构细节概述" class="headerlink" title="1  class文件结构细节概述"></a>1  class文件结构细节概述</h3><ul>
<li>①. Class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的</li>
<li>②. Class 文件格式采用一种类似于 C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</li>
</ul>
<ol>
<li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。 由于表没有固定长度，所以通常会在其前面加上个数说明</li>
</ol>
<pre><code class="java">public class Demo &#123;
    private int num = 1;

    public int add()&#123;
        num = num + 2;
        return num;

    &#125;
&#125;
123456789
</code></pre>
<ul>
<li>③. Class文件的总体结构如下<br>(魔数、Class文件版本、常量池、访问标识(或标志)、索引，父类索引，接口索引集合、字段表集合、方法表集合、属性表集合)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501213605574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210501213837208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-class文件的魔数是什么"><a href="#2-class文件的魔数是什么" class="headerlink" title="2  class文件的魔数是什么"></a>2  class文件的魔数是什么</h3><ul>
<li>①. 每个Class文件开头的4个字节的无符号整数称为魔数(Magic Number)</li>
<li>②. 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符</li>
<li>③. 魔数值固定为0xCAFEBABE。不会改变</li>
<li>④. 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：<br><img src="https://img-blog.csdnimg.cn/20210501214023654.png" alt="在这里插入图片描述"></li>
<li>⑤. 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</li>
</ul>
<h3 id="3-如何确保高版本的JVM可执行低版本的class文件？"><a href="#3-如何确保高版本的JVM可执行低版本的class文件？" class="headerlink" title="3  如何确保高版本的JVM可执行低版本的class文件？"></a>3  如何确保高版本的JVM可执行低版本的class文件？</h3><ul>
<li>①. 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常(向下兼容)</li>
<li>②. class文件版本号:紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本major_version</li>
<li>③. 它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m</li>
<li>④. 版本号和Java编译器的对应关系如下表：<br>Java 的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。<br><img src="https://img-blog.csdnimg.cn/20210501214355404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-常量池-class文件的基石"><a href="#4-常量池-class文件的基石" class="headerlink" title="4  常量池(class文件的基石)"></a>4  常量池(class文件的基石)</h3><h4 id="4-1-什么是常量池？"><a href="#4-1-什么是常量池？" class="headerlink" title="4.1 什么是常量池？"></a>4.1 什么是常量池？</h4><ul>
<li>①. 常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一</li>
<li>②. 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210501215523194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-2-常量池计数器"><a href="#4-2-常量池计数器" class="headerlink" title="4.2 常量池计数器"></a>4.2 常量池计数器</h4><ul>
<li>①. 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
</ul>
<ul>
<li>②. 常量池容量计数值(u2类型):从1开始，表示常量池中有多少项常量。即constant_pool_ count=1表示常量池中有0个常量项</li>
<li>③. Demo的值为：其值为0x0016，掐指一算，也就是22。需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？<br>(通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示)<br><img src="https://img-blog.csdnimg.cn/20210501214923109.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="4-3-常量池表"><a href="#4-3-常量池表" class="headerlink" title="4.3 常量池表"></a>4.3 常量池表</h4><ul>
<li>①. constant_pool是一种表结构，以 1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</li>
<li>②. 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）<br><img src="https://img-blog.csdnimg.cn/20210501215620699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记,用于确定该项的格式,这个字节称为tag byte (标记字节、标签字节)<br><img src="https://img-blog.csdnimg.cn/20210501215300311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="4-4-字面量和符号引用"><a href="#4-4-字面量和符号引用" class="headerlink" title="4.4 字面量和符号引用"></a>4.4 字面量和符号引用</h4><ul>
<li><p>①. 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：<br><img src="https://img-blog.csdnimg.cn/20210501215732234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li></li>
<li><p>②. 全限定名<br>(com/xiaozhi/test/Demo这个就是类的全限定名，仅仅是把包名的”.“替换成”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束)</p>
</li>
<li><p>③. 简单名称<br>(简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num)</p>
</li>
<li><p>③. 描述符</p>
<ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表: (数据类型：基本数据类型 、 引用数据类型))</p>
</li>
<li><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如：<br>方法java.lang.String toString()的描述符为() Ljava/lang/String;，<br>方法int abc(int[] x��� int y)的描述符为([II) I。<br><img src="https://img-blog.csdnimg.cn/20210501215943281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-符号引用、直接引用的理解？"><a href="#4-5-符号引用、直接引用的理解？" class="headerlink" title="4.5  符号引用、直接引用的理解？"></a>4.5  符号引用、直接引用的理解？</h4><ul>
<li>①. 虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行起来时，需要从常量池中获得对应的符号引用，再在类加载过程中(初始化阶段)将其替换直接引用，并翻译到具体的内存地址中</li>
<li>②. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</li>
<li>③. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<h4 id="4-6-常量类型和结构"><a href="#4-6-常量类型和结构" class="headerlink" title="4.6  常量类型和结构"></a>4.6  常量类型和结构</h4><ul>
<li>①. 常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021050122084756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210501220852757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. 这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型</li>
<li>③. 这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_ Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度</li>
</ul>
<h3 id="5-访问标识-或标志"><a href="#5-访问标识-或标志" class="headerlink" title="5 访问标识(或标志)"></a>5 访问标识(或标志)</h3><ul>
<li>①. 在常量池后，紧跟着访问标记。该标记使用两个字节表示(u2)，用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口;是否定义为 public 类型;是否定义为 abstract 类型;如果是类的话，是否被声明为 final 等。各种访问标记如下所示：<img src="https://img-blog.csdnimg.cn/20210502101832506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210502102035820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 类的访问权限通常为 ACC_ 开头的常量。</li>
<li>③. 每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL</li>
<li>④. 带有ACC_INTERFACE标志的calss文件表示的是接口而不是类，反之则表示的是类而不是接口</li>
</ul>
<ol>
<li>如果一个class文件设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志</li>
<li>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表除了ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置</li>
</ol>
<ul>
<li>⑤. ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于JavaSE8及后续版本来说，无论class文件中这个标志实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个Class文件均设置了ACC_SUPER标志</li>
<li>⑥. ACC_SYNTHETIC标志意味着该类或接口由编译器生产的，而不是由源代码生成的</li>
<li>⑦. 注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志</li>
<li>⑧. ACC_ENUM标志标明该类或其父类为枚举类型</li>
</ul>
<h3 id="6-类索引-父类索引-接口索引集合"><a href="#6-类索引-父类索引-接口索引集合" class="headerlink" title="6 类索引|父类索引|接口索引集合"></a>6 类索引|父类索引|接口索引集合</h3><ul>
<li>①. 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：(这三项数据来确定这个类的继承关系)</li>
</ul>
<ol>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的Java类都有父类，因此除了java.lang.Object 外，所有Java类的父类索引都不为 0</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将 implements语句(如果这个类本身是一个接口，则应当是 extends 语句)后的接口顺序从左到右排列在接口索引集合中</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210502104756773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. this_class(类索引)<br>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com/xiaozhi/Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口</li>
<li>③. super_class(父类索引)</li>
</ul>
<ol>
<li>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个</li>
<li>superclass指向的父类不能是final。</li>
</ol>
<ul>
<li>④. interfaces_count (接口计数器):interfaces_count项的值表示当前类或接口的直接超接口数量。</li>
<li>⑤. interfaces <code>[ ](接口索引集合)</code><br>(interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。 每个成员 interfaces[i]必须为 CONSTANT_Class_info结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210502220333243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="7-字段表集合"><a href="#7-字段表集合" class="headerlink" title="7 字段表集合"></a>7 字段表集合</h3><ul>
<li>①. 用于描述接口或类中声明的变量。字段(field)包括 类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量(local variables)</li>
<li>②. 字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述</li>
<li>③. 它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符(public、private或protected)、是类变量还是实例变量(static修饰符)、是否是常量(final修饰符)等</li>
<li>④. 注意事项</li>
</ul>
<ol>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段</li>
<li>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的</li>
</ol>
<ul>
<li>⑤. 字段计数器<br>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示</li>
<li>⑥. 字段表<br><img src="https://img-blog.csdnimg.cn/20210502221818870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. 字段表访问标识<br>(我们知道,一个字段可以被各个关键字去修饰,比如:作用域修饰符(public、private、protected)、static修饰符、final修饰符、volatile修饰符等等。因此,其可像类的访问标志那样,使用一些标志来标记字段。字段的访问标志有如下这些)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210502222218240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="8-方法表集合"><a href="#8-方法表集合" class="headerlink" title="8 方法表集合"></a>8 方法表集合</h3><ul>
<li>①. 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private或protected)，方法的返回值类型以及方法的参数信息等</li>
<li>②. 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来</li>
<li>③. 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如：类(接口)初始化方法()和实例初始化方法())</li>
<li>④. 方法计数器methods_count<br>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示<br>methods 表中每个成员都是一个method_info结构</li>
<li>⑤. 方法表<br><img src="https://img-blog.csdnimg.cn/20210502223428790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. 方法表访问标志<br>(跟字段表一样,方法表也有访问标志,而且他们的标志有部分相同,部分则不同,方法表具体访问标志如下:)<br><img src="https://img-blog.csdnimg.cn/20210502223746347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="9-属性表集合"><a href="#9-属性表集合" class="headerlink" title="9 属性表集合"></a>9 属性表集合</h3><ul>
<li>①. 属性计数器:attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构</li>
<li>②. 属性的通用格式<br><img src="https://img-blog.csdnimg.cn/20210502224735486.png" alt="在这里插入图片描述"></li>
<li>③. Code属性<br>(Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了)<br>Code属性表的结构，如下图：<br><img src="https://img-blog.csdnimg.cn/20210502224534906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>④. LineNumberTable属性</li>
</ul>
<ol>
<li>LineNumberTable 属性是可选变长属性，位于 Code结构的属性表</li>
<li>LineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数(start_pc，即字节码行号;line_number，即Java源代码行号)</li>
<li>在 Code 属性的属性表中,LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一 一对应<br><img src="https://img-blog.csdnimg.cn/20210502225024359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>⑤.LocalVariableTable属性<br>(LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中,LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVa riableTable 属性)<br><img src="https://img-blog.csdnimg.cn/20210502225140662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. SourceFile属性<br><img src="https://img-blog.csdnimg.cn/20210502225217779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="10-IDEA中集成jclasslib说明Class文件信息"><a href="#10-IDEA中集成jclasslib说明Class文件信息" class="headerlink" title="10 IDEA中集成jclasslib说明Class文件信息"></a>10 IDEA中集成jclasslib说明Class文件信息</h3><h4 id="10-1-Class文件详解"><a href="#10-1-Class文件详解" class="headerlink" title="10.1 Class文件详解"></a>10.1 Class文件详解</h4><p><img src="https://img-blog.csdnimg.cn/20210502225845779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-2-方法表集合"><a href="#10-2-方法表集合" class="headerlink" title="10.2  方法表集合"></a>10.2  方法表集合</h4><p><img src="https://img-blog.csdnimg.cn/2020050510515537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-3-code属性"><a href="#10-3-code属性" class="headerlink" title="10.3 code属性"></a>10.3 code属性</h4><p><img src="https://img-blog.csdnimg.cn/20200505105323929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-4-LineNumberTable、LocalVariableTable"><a href="#10-4-LineNumberTable、LocalVariableTable" class="headerlink" title="10.4 LineNumberTable、LocalVariableTable"></a>10.4 LineNumberTable、LocalVariableTable</h4><p><img src="https://img-blog.csdnimg.cn/20200505105818394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="10-5-SourceFile属性"><a href="#10-5-SourceFile属性" class="headerlink" title="10.5 SourceFile属性"></a>10.5 SourceFile属性</h4><p><img src="https://img-blog.csdnimg.cn/20210502230349399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="十六、类的生命周期"><a href="#十六、类的生命周期" class="headerlink" title="十六、类的生命周期"></a>十六、类的生命周期</h2><h3 id="1-说说类加载分几步？"><a href="#1-说说类加载分几步？" class="headerlink" title="1 说说类加载分几步？"></a>1 说说类加载分几步？</h3><ul>
<li><p>①. 按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段:</p>
<ul>
<li>第一过程的加载(loading)也称为装载</li>
<li>验证、准备、解析3个部分统称为链接(Linking)</li>
<li>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载<br><img src="https://img-blog.csdnimg.cn/20210504185259863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>②. 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载、类的链接、类的初始化这三个步骤来对类进行初始化。如果不出现意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者初始化<br><img src="https://img-blog.csdnimg.cn/20200216215157575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>③. 从程序中类的使用过程看:<br><img src="https://img-blog.csdnimg.cn/20210504185409460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="2-过程一-类的加载-Loading"><a href="#2-过程一-类的加载-Loading" class="headerlink" title="2 过程一:类的加载(Loading)"></a>2 过程一:类的加载(Loading)</h3><ul>
<li><p>①. 类的加载指的是将类的.class文件中的二进制数据读取到内存中，存放在运行时数据区的方法区中，并创建一个大的Java.lang.Class对象，用来封装方法区内的数据结构 在加载类时，Java虚拟机必须完成以下3件事情:</p>
<ul>
<li><p>通过类的全名，获取类的二进制数据流</p>
</li>
<li><p>解析类的二进制数据流为方法区内的数据结构(Java类模型)</p>
</li>
<li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口<br><img src="https://img-blog.csdnimg.cn/20210504190930335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 对于①的说明，我们也可以这样去理解:所谓装载(加载)，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象<br>(所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用)</p>
</li>
<li><p>③. 对于类的二进制数据流，虚拟机可以通过多种途径产生或获得(只要所读取的字节码符合JVM规范即可)</p>
<ul>
<li><p>虚拟机可能通过文件系统读入一个class后缀的文件(最常见)</p>
</li>
<li><p>读入jar、zip等归档数据包，提取类文件。</p>
</li>
<li><p>事先存放在数据库中的类的二进制数据</p>
</li>
<li><p>使用类似于HTTP之类的协议通过网络进行加载</p>
</li>
<li><p>在运行时生成一段Class的二进制信息等</p>
</li>
</ul>
</li>
<li><p>④. Class实例的位置<br>(类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象)</p>
</li>
</ul>
<h3 id="3-过程二-链接-Linking"><a href="#3-过程二-链接-Linking" class="headerlink" title="3 过程二:链接(Linking)"></a>3 过程二:链接(Linking)</h3><ul>
<li><p>①. 验证:确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</p>
<ul>
<li><p>目的是确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p>
</li>
<li><p>主要包括四种验证:文件格式验证，元数据验证，字节码验证，符号引用验证</p>
</li>
<li><p>格式检查:是否以魔术oxCAFEBABE开头，主版本和副版本是否在当前Java虚拟机的支持范围内，数据中每一项是否都拥有正确的长度等<br><img src="https://img-blog.csdnimg.cn/20210504191300443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>②. 准备(静态变量，不能是常量)</p>
<ul>
<li><p>为类变量分配内存并且设置该类变量的默认初始化值</p>
</li>
<li><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式赋值</p>
</li>
<li><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中</p>
</li>
<li><p>注意:Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值就是false<br><img src="https://img-blog.csdnimg.cn/20210504192223337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>③. 解析:将常量池中的符号引号转换为直接引用的过程(简言之，将类、接口、字段和方法的符号引用转为直接引用)</p>
<ul>
<li>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行起来时，需要从常量池中获得对应的符号引用，再在类加载过程中(初始化阶段)将其替换直接引用，并翻译到具体的内存地址中</li>
</ul>
<ul>
<li><p>符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中</p>
</li>
<li><p>直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>
</li>
<li><p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>符号引号有:类和接口的权限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
<blockquote>
<p>解释什么是符号引号和直接引用?<br>(1). 教室里有个空的位子没坐人，座位上边牌子写着小明的座位(符号引用)，后来小明进来坐下去掉牌子(符号引用换成直接引用)<br>(2). 我们去做菜，看菜谱，步骤都是什么样的(这是符号引号)，当我们实际上去做，这个过程是直接引用<br>(3). 举例:输出操作System.out.println()对应的字节码:<br>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</p>
<p>以方法为例<img src="https://img-blog.csdnimg.cn/20210525215340991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p>
</blockquote>
<h3 id="4-过程三-初始化-Initialization"><a href="#4-过程三-初始化-Initialization" class="headerlink" title="4 过程三:初始化(Initialization)"></a>4 过程三:初始化(Initialization)</h3><ul>
<li>①. 为类变量赋予正确的初始化值</li>
<li>②. 初始化阶段就是执行类构造器方法&lt; clinit &gt;()的过程。此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码快中的语句合并而来</li>
</ul>
<pre><code class="java">public class ClassInitTest &#123;
    private  static int num=1; //类变量的赋值动作
    //静态代码快中的语句
    static&#123;
        num=2;
        number=20;
        System.out.println(num);
        //System.out.println(number); 报错:非法的前向引用
    &#125;
    //Linking之prepare: number=0 --&gt;initial:20--&gt;10
    private static int number=10;

    public static void main(String[] args) &#123;
        System.out.println(ClassInitTest.num);
        System.out.println(ClassInitTest.number);
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210426221549496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 若该类具有父类，Jvm会保证子类的&lt; clinit &gt;() 执行前，父类的&lt; clinit &gt;() 已经执行完成。clinit 不同于类的构造方法(init) (由父及子，静态先行)</li>
</ul>
<pre><code class="java">public class ClinitTest1 &#123;
    static class Father&#123;
        public static int A=1;
        static&#123;
            A=2;
        &#125;
    &#125;
    static class Son extends Father&#123;
        public static int B=A;
    &#125;

    public static void main(String[] args) &#123;
        //这个输出2，则说明父类已经全部加载完毕
        System.out.println(Son.B);
    &#125;
&#125;
</code></pre>
<ul>
<li>④. Java编译器并不会为所有的类都产生<code>&lt;clinit&gt;()</code>初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<code>&lt;clinit&gt;()</code>方法？</li>
</ul>
<ol>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
<li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器，则在链接阶段)</li>
</ol>
<pre><code class="java">/**
 * @author TANGZHI
 * @create 2021-01-01 18:49
 * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法
 */
public class InitializationTest1 &#123;
    //场景1:对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法
    public int num = 1;
    //场景2:静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法
    public static int num1;
    //场景3:比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法
    public static final int num2 = 1;
&#125;
</code></pre>
<ul>
<li>⑤. static与final的搭配问题<br>(使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行)</li>
</ul>
<pre><code class="java">/**
 * @author TANGZHI
 * @create 2021-01-01 
 *
 * 说明:使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1:在链接阶段的准备环节赋值
 * 情况2:在初始化阶段&lt;clinit&gt;()中赋值
 * 结论:
 * 在链接阶段的准备环节赋值的情况:
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段&lt;clinit&gt;()中赋值的情况:
 * 排除上述的在准备环节赋值的情况之外的情况。
 * 最终结论:使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。
 */
public class InitializationTest2 &#123;
    public static int a = 1;//在初始化阶段&lt;clinit&gt;()中赋值
    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值

    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段&lt;clinit&gt;()中赋值
    public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段&lt;clinit&gt;()中赋值

    public static final String s0 = &quot;helloworld0&quot;;//在链接阶段的准备环节赋值
    public static final String s1 = new String(&quot;helloworld1&quot;);//在初始化阶段&lt;clinit&gt;()中赋值

    public static String s2 = &quot;helloworld2&quot;;
    public static final int NUM1 = new Random().nextInt(10);//在初始化阶段&lt;clinit&gt;()中赋值
&#125;
</code></pre>
<ul>
<li>⑥. clinit()的调用会死锁吗?</li>
</ul>
<ol>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕</li>
<li>正是因为函数<code>&lt;clinit&gt;()</code>带锁线程安全的，因此，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息</li>
</ol>
<pre><code class="typescript">package com.xiaozhi;

/**
 * @author TANGZHI
 * @create 2021-05-25
 */
class StaticA &#123;
    static &#123;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        try &#123;
            Class.forName(&quot;com.xiaozhi.StaticB&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;StaticA init OK&quot;);
    &#125;
&#125;

class StaticB &#123;
    static &#123;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        try &#123;
            Class.forName(&quot;com.xiaozhi.StaticA&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;StaticB init OK&quot;);
    &#125;
&#125;

public class StaticDeadLockMain extends Thread &#123;
    private char flag;

    public StaticDeadLockMain(char flag) &#123;
        this.flag = flag;
        this.setName(&quot;Thread&quot; + flag);
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            Class.forName(&quot;com.xiaozhi.Static&quot; + flag);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(getName() + &quot; over&quot;);
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        StaticDeadLockMain loadA = new StaticDeadLockMain(&#39;A&#39;);
        loadA.start();
        StaticDeadLockMain loadB = new StaticDeadLockMain(&#39;B&#39;);
        loadB.start();
    &#125;
&#125;
</code></pre>
<h3 id="5-主动引用-触发在初始化阶段的Clinit方法"><a href="#5-主动引用-触发在初始化阶段的Clinit方法" class="headerlink" title="5 主动引用(触发在初始化阶段的Clinit方法)"></a>5 主动引用(触发在初始化阶段的Clinit方法)</h3><ul>
<li>①. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li>
<li>②. 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>③. 调用类的静态方法</li>
<li>④. 反射(比如:Class.forName(“com.xiaozhi.Test”))</li>
<li>⑤. 初始化一个子类(当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化)</li>
<li>⑥. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类</li>
<li>⑦. JDK7开始提供的动态语言支持<br>(涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)</li>
<li>⑧. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li>
</ul>
<pre><code class="java"># 注意，如果把A接口中的默认方法注释，那么就只输出:子类初始化......
输出:
CompareB的初始化
子类初始化.....
public class DemoB implements A&#123;
    static&#123;
        System.out.println(&quot;子类初始化......&quot;);
    &#125;
    public static void main(String[] args) &#123;

    &#125;
&#125;
interface A&#123;
    public static final Thread t = new Thread() &#123;
        &#123;
            System.out.println(&quot;CompareB的初始化&quot;);
        &#125;
    &#125;;
    default void method1()&#123;
        System.out.println(&quot;====&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="6-被动使用"><a href="#6-被动使用" class="headerlink" title="6 被动使用"></a>6 被动使用</h3><ul>
<li>①. 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。意味着没有<code>&lt;clinit&gt;()</code>的调用。</li>
<li>②. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
<li>③. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<br>当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>④. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</li>
<li>⑤. 通过数组定义类引用，不会触发此类的初始化</li>
</ul>
<pre><code class="typescript"># 这里不会进行初始化，因为相当于parent只开辟了空间，没赋值
Parent[]parent=new Parent[10];
</code></pre>
<h3 id="7-过程四-类的Using-使用"><a href="#7-过程四-类的Using-使用" class="headerlink" title="7 过程四:类的Using(使用)"></a>7 过程四:类的Using(使用)</h3><ul>
<li>①. 任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便”万事俱备，只欠东风”就等着开发者使用了</li>
<li>②. 开发人员可以在程序中访问和调用它的静态类成员信息(比如:静态字段、静态方法)或者使用new关键字为其创建对象实例</li>
</ul>
<h3 id="8-过程五-类的Unloading-卸载"><a href="#8-过程五-类的Unloading-卸载" class="headerlink" title="8 过程五:类的Unloading(卸载)"></a>8 过程五:类的Unloading(卸载)</h3><ul>
<li>①. 类、类的加载器、类的实例之间的引用关系</li>
</ul>
<ol>
<li>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系</li>
<li>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象<br><img src="https://img-blog.csdnimg.cn/20210504222427561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 方法区的垃圾回收</li>
</ul>
<ol>
<li>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li>
<li>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210504222534257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 类的卸载</li>
</ul>
<ol>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小</li>
<li>开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如:很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</li>
</ol>
<h2 id="十七、类的概述"><a href="#十七、类的概述" class="headerlink" title="十七、类的概述"></a>十七、类的概述</h2><h3 id="1-类的加载器"><a href="#1-类的加载器" class="headerlink" title="1 类的加载器"></a>1 类的加载器</h3><ul>
<li>①. ClassLoader的作用</li>
</ul>
<ol>
<li>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作、因此，ClassLoader在整个装载(加载)阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定</li>
<li>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而研发出来。但如今类加载器却在OSGI(热部署)、字节码加密解密领域大放异彩。这主要归功于Java虚拟机的设计者当初在设计类加载器的时候，并没有考虑将它绑定在Jvm内部，这样做的好处就是能够更加灵活和动态地执行类加载操作</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210507205510198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>②. class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式(在日常开发以上两种方式一般会混合使用)</li>
</ul>
<ol>
<li>显式加载:指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象</li>
<li>隐式加载:则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。比如 new User()</li>
</ol>
<h3 id="2-类的加载器分类与测试"><a href="#2-类的加载器分类与测试" class="headerlink" title="2 类的加载器分类与测试"></a>2 类的加载器分类与测试</h3><h4 id="2-1-类加载器的介绍"><a href="#2-1-类加载器的介绍" class="headerlink" title="2.1 类加载器的介绍"></a>2.1 类加载器的介绍</h4><ul>
<li>①. JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)</li>
<li>②. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范并没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li>
<li>③. 无论类加载器的类型如何划分，在程序中我们常见的类加载器如下所示:<br>除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器</li>
<li><img src="https://img-blog.csdnimg.cn/20210426223104306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191207090719392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210427210730635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-2-启动-引导-类加载器-Bootstrap"><a href="#2-2-启动-引导-类加载器-Bootstrap" class="headerlink" title="2.2 启动(引导)类加载器 Bootstrap"></a>2.2 启动(引导)类加载器 Bootstrap</h4><ul>
<li>①. 这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
<li>②. 它用来加载Java的核心类库(JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容)，用于提供JVM自身需要的类(String类就是使用的这个类加载器)</li>
<li>③. 由于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
<li>④. 并不继承自java.lang.ClassLoader，没有父加载器</li>
<li>⑤. 加载扩展类和应用程序类加载器，并指定为他们的父类加载器<br><img src="https://img-blog.csdnimg.cn/20210507212157768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="2-3-扩展类加载器-Extension"><a href="#2-3-扩展类加载器-Extension" class="headerlink" title="2.3 扩展类加载器 Extension"></a>2.3 扩展类加载器 Extension</h4><ul>
<li>①. Java语言编写，由sum.music.Launcher$ExtClassLoader实现</li>
<li>②. 派生于ClassLoader类，父类加载器为启动类加载器</li>
<li>③. 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载<br><img src="https://img-blog.csdnimg.cn/2021050721243536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="2-4-应用程序-系统-类加载器-AppClassLoader"><a href="#2-4-应用程序-系统-类加载器-AppClassLoader" class="headerlink" title="2.4 应用程序(系统)类加载器 AppClassLoader"></a>2.4 应用程序(系统)类加载器 AppClassLoader</h4><ul>
<li>①. java语言编写，由sum.misc.Launcher$AppClassLoader实现</li>
<li>②. 派生于ClassLoader类，父类加载器为扩展类加载器</li>
<li>③. 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>④. 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>⑤. 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<h4 id="2-5-用户自定义类加载器"><a href="#2-5-用户自定义类加载器" class="headerlink" title="2.5 用户自定义类加载器"></a>2.5 用户自定义类加载器</h4><ul>
<li>①. 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们换可以自定义类加载器，来定制类的加载方式(自定义类加载器通常需要继承于 ClassLoader)</li>
<li>②. 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源</li>
<li>③. 自定义 ClassLoader 的子类时候，我们常见的会有两种做法:</li>
</ul>
<ol>
<li>重写loadClass()方法(不推荐，这个方法会保证类的双亲委派机制)</li>
<li>重写findClass()方法 –&gt;推荐</li>
<li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
</ol>
<ul>
<li>④. 如何手写一个简单的自定义加载器</li>
</ul>
<pre><code class="java">public class UserClassLoader extends ClassLoader &#123;
    private String rootDir;

    public UserClassLoader(String rootDir) &#123;
        this.rootDir = rootDir;
    &#125;

    /**
     * 编写findClass方法的逻辑
     */
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;
        // 获取类的class文件字节数组
        byte[] classData = getClassData(name);
        if (classData == null) &#123;
            throw new ClassNotFoundException();
        &#125; else &#123;
            //直接生成class对象
            return defineClass(name， classData， 0， classData.length);
        &#125;
    &#125;

    /**
     * 编写获取class文件并转换为字节码流的逻辑 * @param className * @return
     */
    private byte[] getClassData(String className) &#123;
        // 读取类文件的字节
        String path = classNameToPath(className);
        try &#123;
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len = 0;
            // 读取类文件的字节码
            while ((len = ins.read(buffer)) != -1) &#123;
                baos.write(buffer， 0， len);
            &#125;
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    /**
     * 类文件的完全路径
     */
    private String classNameToPath(String className) &#123;
        return rootDir + &quot;\\&quot; + className.replace(&#39;.&#39;， &#39;\\&#39;) + &quot;.class&quot;;
    &#125;

    public static void main(String[] args) &#123;
        String rootDir = &quot;D:\\code\\workspace_teach\\JVMdachang210416\\chapter02_classload\\src\\&quot;;

        try &#123;
            //创建自定义的类的加载器1
            UserClassLoader loader1 = new UserClassLoader(rootDir);
            Class clazz1 = loader1.findClass(&quot;com.xiaozhi.java3.User&quot;);

            //创建自定义的类的加载器2
            UserClassLoader loader2 = new UserClassLoader(rootDir);
            Class clazz2 = loader2.findClass(&quot;com.xiaozhi.java3.User&quot;);
            //clazz1与clazz2对应了不同的类模板结构
            System.out.println(clazz1 == clazz2); 
            System.out.println(clazz1.getClassLoader());
            System.out.println(clazz2.getClassLoader());
            
            Class clazz3 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.xiaozhi.java3.User&quot;);
            System.out.println(clazz3.getClassLoader());
            System.out.println(clazz1.getClassLoader().getParent());

        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="2-6-测试不同的类加载器"><a href="#2-6-测试不同的类加载器" class="headerlink" title="2.6 测试不同的类加载器"></a>2.6 测试不同的类加载器</h4><ul>
<li>①. 每个Class对象都会包含一个定义它的ClassLoader的一个引用</li>
<li>②. 获取ClassLoader的途径</li>
</ul>
<pre><code class="handlebars">    (1). 获得当前类的ClassLoader
    clazz.getClassLoader()
    (2). 获得当前线程上下文的ClassLoader(系统类加载器)
    Thread.currentThread().getContextClassLoader()
    (3). 获得系统的ClassLoader
    ClassLoader.getSystemClassLoader()
</code></pre>
<ul>
<li>③. 站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值</li>
<li>④. 数组类的Class对象，不是由类加载器去加载的，而是在Java运行期JVM根据需要自动创建的。对于数组的类加载器来说，是通过Class.getClassLoader()返回的，与数组中元素类型的类加载器是一样的;如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的(基本数据类型由虚拟机预先定义)</li>
</ul>
<pre><code class="java">public class ClassLoaderDemo &#123;
    public static void main(String[] args) &#123;
        ClassLoader classloader1 = ClassLoader.getSystemClassLoader();
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(classloader1);
        //获取到扩展类加载器
        //sun.misc.Launcher$ExtClassLoader@424c0bc4
        System.out.println(classloader1.getParent());
        //获取到引导类加载器 null
        System.out.println(classloader1.getParent().getParent());
        //获取系统的ClassLoader
        ClassLoader classloader2 = Thread.currentThread().getContextClassLoader();
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(classloader2);
        String[]strArr=new String[10];
        ClassLoader classLoader3 = strArr.getClass().getClassLoader();
        //null，表示使用的是引导类加载器
        System.out.println(classLoader3);
        ClassLoaderDemo[]refArr=new ClassLoaderDemo[10];
        //sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(refArr.getClass().getClassLoader());
        int[]intArr=new int[10];
        //null，如果数组的元素类型是基本数据类型，数组类是没有类加载器的
        System.out.println(intArr.getClass().getClassLoader());
    &#125;
&#125;
</code></pre>
<h3 id="3-ClassLoader源码剖析"><a href="#3-ClassLoader源码剖析" class="headerlink" title="3 ClassLoader源码剖析"></a>3 ClassLoader源码剖析</h3><h4 id="3-1-ClassLoader与现有类加载器的关系"><a href="#3-1-ClassLoader与现有类加载器的关系" class="headerlink" title="3.1 ClassLoader与现有类加载器的关系"></a>3.1 ClassLoader与现有类加载器的关系</h4><ul>
<li>①. ClassLoader是一个抽象类。如果我们给定了一个类的二进制名称，类加载器应尝试去定位或生成构成定义类的数据。一种典型的策略是将给定的二进制名称转换为文件名，然后去文件系统中读取这个文件名所对应的class文件</li>
<li>②. ClassLoader与现有类加载器的关系<br><img src="https://img-blog.csdnimg.cn/20210509172614178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式</li>
<li>④. AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</li>
</ul>
<h4 id="3-2-抽象类ClassLoader的主要方法-内部没有抽象方法"><a href="#3-2-抽象类ClassLoader的主要方法-内部没有抽象方法" class="headerlink" title="3.2 抽象类ClassLoader的主要方法(内部没有抽象方法)"></a>3.2 抽象类ClassLoader的主要方法(内部没有抽象方法)</h4><ul>
<li>①. public final ClassLoader getParent():返回该类加载器的超类加载器</li>
<li>②. public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException<br>(加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNot FoundException 异常。该方法中的逻辑就是双亲委派模式的实现)</li>
<li>③. protected Class&lt;?&gt; findClass (String name) throws ClassNotFoundException<br>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</li>
<li>④. protected final Class&lt;?&gt; defineClass(String name， byte[] b， int off， int len)<br>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</li>
<li>⑤. protected final void resolveClass(Class&lt;?&gt; c)<br>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用</li>
<li>⑥. 源码解析Classloader方法</li>
</ul>
<pre><code class="java"> 测试代码:
 ClassLoader.getSystemClassLoader().loadClass(&quot;com.xiaozhi.java.User&quot;);
 //resolve==true，加载class的同时需要进行解析操作
 protected Class&lt;?&gt; loadClass(String name， boolean resolve) 
        throws ClassNotFoundException
    &#123;
        //同步操作，保证只能加载一次
        synchronized (getClassLoadingLock(name)) &#123;
            // 在缓存中判断是否已经加载同名的类
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) &#123;
                long t0 = System.nanoTime();
                try &#123;
                    //获取当前类的父类加载器
                    if (parent != null) &#123;
                        //如果存在父类加载器，则调用父类加载器进行类的加载(双亲委派机制)
                        c = parent.loadClass(name， false);
                    &#125; else &#123;
                        //parent==null 父类加载器是引导类加载器
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; catch (ClassNotFoundException e) &#123;
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                &#125;
                // 当前类的加载器的父类加载器未加载此类 or 当前类的加载器未加载此类
                if (c == null) &#123;
                    // 调用当前classloader的findClass
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                &#125;
            &#125;
            //是否进行解析操作
            if (resolve) &#123;
                resolveClass(c);
            &#125;
            return c;
        &#125;
    &#125;
</code></pre>
<h4 id="3-3-SecureClassLoader与URLClassLoader"><a href="#3-3-SecureClassLoader与URLClassLoader" class="headerlink" title="3.3 SecureClassLoader与URLClassLoader"></a>3.3 SecureClassLoader与URLClassLoader</h4><ul>
<li>①. 接着SecureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联</li>
<li>②. 前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<h4 id="3-4-Class-forName-与ClassLoader-loadClass-对比"><a href="#3-4-Class-forName-与ClassLoader-loadClass-对比" class="headerlink" title="3.4 Class.forName()与ClassLoader.loadClass()对比"></a>3.4 Class.forName()与ClassLoader.loadClass()对比</h4><ul>
<li>①. Class.forName():是一个静态方法，最常用的是Class.forName(String className);根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如:Class.forName(“com.atguigu.java.HelloWorld”);</li>
<li>②. ClassLoader.loadClass():这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。</li>
</ul>
<h3 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4 双亲委派机制"></a>4 双亲委派机制</h3><ul>
<li>①. 工作原理</li>
</ul>
<ol>
<li>如果一个类加载收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>
<li>如果父类的加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式<br><img src="https://img-blog.csdnimg.cn/20210426224243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 本质(规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载)<br><img src="https://img-blog.csdnimg.cn/20210509161013261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>③. 源码分析(双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下)</li>
</ul>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name， false)接口进行加载</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lan g.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
<li>双亲委派的模型就隐藏在这第2和第3步中</li>
</ol>
<ul>
<li>④. 双亲委派机制优势:</li>
</ul>
<ol>
<li>避免类的重复加载，确保一个类的全局唯一性(当父ClassLoader已经加载了该类的时候，就没有必要子ClassLoader再加载一次)</li>
<li>保护程序安全，防止核心API被随意篡改<br>(自定义类:java.lang.String | java.lang.ShkStart)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210426224550346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>⑤. 双亲委托模式的弊端<br>(检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类)</li>
<li>⑥. 结论(由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法)</li>
<li>⑦. 破坏双亲委派机制及举例</li>
</ul>
<ol>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代</li>
<li>第二次破坏双亲委派机制:线程上下文类加载器(ClassLoader.getSystemClassLoader( ))</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换(Hot Swap)、模块热部署(Hot Deployment)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210509174051199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5 沙箱安全机制"></a>5 沙箱安全机制</h3><ul>
<li>①. 如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制，启动加载器会加载java核心类库的String类(BootStrap启动类加载器只加载包名为java、javax、sun等开头的类)，而核心类库中的String并没有main方法<br><img src="https://img-blog.csdnimg.cn/20210426224550346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 自定义String类，但是在加载子弟敬意String类的时候回率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件(rt.jar包中的java\lang\String.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制</li>
<li>③. 沙箱安全机制作用:</li>
</ul>
<ol>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ol>
<ul>
<li>④. JDK1.6时期，当前最新的安全机制实现，则引入了域(Domain)的概念<br>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型(jdk1.6)<br><img src="https://img-blog.csdnimg.cn/2021050917442854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="十八、tomcat打破双亲委派制度"><a href="#十八、tomcat打破双亲委派制度" class="headerlink" title="十八、tomcat打破双亲委派制度"></a>十八、tomcat打破双亲委派制度</h2><h3 id="1-Tomcat类加载机制"><a href="#1-Tomcat类加载机制" class="headerlink" title="1 Tomcat类加载机制"></a>1 Tomcat类加载机制</h3><ul>
<li>①. 可以看到，在原来的 JVM 的类加载机制上面，Tomcat 新增了几个类加载器，包括 3 个基础类加载器和每个 Web 应用的类加载器。3个基础类加载器在 conf/catalina.properties 中进行配置:</li>
</ul>
<pre><code class="typescript">common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;，&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;，&quot;$&#123;catalina.home&#125;/lib&quot;，&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;
server.loader=
shared.loader=
</code></pre>
<ul>
<li>②.Common:以应用类加载器为父类，是Tomcat顶层的公用类加载器，其路径由conf/catalina.pr operties中的common.loader指定，默认指向${catalina.home}/lib下的包</li>
<li>③. Catalina:Tomcat容器私有的类加载器，加载路径中的class对于Webapp不 可见，其路径由server.loader指定，默认为空，此时Tomcat使用Common类加载器加载应用服务器</li>
<li>④. Shared:以Common类加载器为父类，是所有Web应用的父类加载器，其路径由shared.loader指定，默认为空，此时Tomcat使用Common类加载器作为Web应用的父加载器</li>
<li>⑤. Web应用:以Shared类加载器为父类，加载/WEB-INF/classes目录下的未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包，该类加载器只对当前Web应用可见，对其他Web应用均不可见</li>
<li>⑥. Tomcat8 和 Tomcat6比较大的区别是:<br>Tomcat8可以通过配置 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code>表示遵循双亲委派机制</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210529222814729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-Tomcat执行顺序"><a href="#2-Tomcat执行顺序" class="headerlink" title="2 Tomcat执行顺序"></a>2 Tomcat执行顺序</h3><ul>
<li>①. 使用bootstrap引导类加载器加载</li>
<li>②. 使用system系统类加载器加载</li>
<li>③. 使用应用类加载器在WEB-INF/classes中加载</li>
<li>④. 使用应用类加载器在WEB-INF/lib中加载</li>
<li>⑤. 使用common类加载器在CATALINA_HOME/lib中加载</li>
<li>⑥.我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat违背了java推荐的双亲委派模型了吗？答案是:违背了。我们前面说过:双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。<br>很显然，tomcat不是这样实现，tomcat为了实现隔离性，没有遵守这个约定，每个webappClassLoad er加载自己的目录下的class文件，不会传递给父类加载器。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210529224034684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-ClassLoader的创建"><a href="#3-ClassLoader的创建" class="headerlink" title="3 ClassLoader的创建"></a>3 ClassLoader的创建</h3><ul>
<li>①. 加载器类图:<br><img src="https://img-blog.csdnimg.cn/20210529225641796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 先从 BootStrap 的main方法看起:<br>可以看到这里先判断了bootstrap是否为null，如果不为null直接把CatalinaClassLoader设置到了当前线程，如果为null下面是走到了init()方法</li>
</ul>
<pre><code class="java">public static void main(String args[]) &#123;
    synchronized (daemonLock) &#123;
        if (daemon == null) &#123;
            // Don&#39;t set daemon until init() has completed
            Bootstrap bootstrap = new Bootstrap();
            try &#123;
                bootstrap.init();
            &#125; catch (Throwable t) &#123;
                handleThrowable(t);
                t.printStackTrace();
                return;
            &#125;
            daemon = bootstrap;
        &#125; else &#123;
            // When running as a service the call to stop will be on a new
            // thread so make sure the correct class loader is used to
            // prevent a range of class not found exceptions.
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
        &#125;
        // 省略其余代码...
    &#125;
&#125;
</code></pre>
<ul>
<li>③. 接着这里看到了会调用 initClassLoaders() 方法进行类加载器的初始化，初始化完成后，同样会设置 Catalina ClassLoader到当前线程</li>
</ul>
<pre><code class="java">public void init() throws Exception &#123;
    // 初始化类加载器
    initClassLoaders();
    // 设置线程类加载器，将容器的加载器传入
    Thread.currentThread().setContextClassLoader(catalinaLoader);
    // 设置区安全类加载器
    SecurityClassLoad.securityClassLoad(catalinaLoader);
    // 省略其余代码...
&#125;
</code></pre>
<ul>
<li>④ .看到这里应该就清楚了，会创建三个ClassLoader:CommClassLoader，CatalinaClassLoader，SharedCla ssLoader，正好对应前面介绍的三个基础类加载器</li>
</ul>
<pre><code class="java">private void initClassLoaders() &#123;
    try &#123;
        commonLoader = createClassLoader(&quot;common&quot;， null);
        if (commonLoader == null) &#123;
            // no config file， default to this loader - we might be in a &#39;single&#39; env.
            commonLoader = this.getClass().getClassLoader();
        &#125;
        catalinaLoader = createClassLoader(&quot;server&quot;， commonLoader);
        sharedLoader = createClassLoader(&quot;shared&quot;， commonLoader);
    &#125; catch (Throwable t) &#123;
        handleThrowable(t);
        log.error(&quot;Class loader creation threw exception&quot;， t);
        System.exit(1);
    &#125;
&#125;
</code></pre>
<ul>
<li>⑤. 接着进入createClassLoader() 查看代码:<br>可以看到，这里加载的资源正好是我们刚才看到的配置文件conf/catalina.properties 中的 common.loader ，server.loader 和 shared.loader</li>
</ul>
<pre><code class="java">private ClassLoader createClassLoader(String name， ClassLoader parent)
    throws Exception &#123;

    String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;);
    if ((value == null) || (value.equals(&quot;&quot;)))
        return parent;
    value = replace(value);
    List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;();
    String[] repositoryPaths = getPaths(value);
    for (String repository : repositoryPaths) &#123;
        // Check for a JAR URL repository
        try &#123;
            @SuppressWarnings(&quot;unused&quot;)
            URL url = new URL(repository);
            repositories.add(new Repository(repository， RepositoryType.URL));
            continue;
        &#125; catch (MalformedURLException e) &#123;
            // Ignore
        &#125;
        // Local repository
        if (repository.endsWith(&quot;*.jar&quot;)) &#123;
            repository = repository.substring
                (0， repository.length() - &quot;*.jar&quot;.length());
            repositories.add(new Repository(repository， RepositoryType.GLOB));
        &#125; else if (repository.endsWith(&quot;.jar&quot;)) &#123;
            repositories.add(new Repository(repository， RepositoryType.JAR));
        &#125; else &#123;
            repositories.add(new Repository(repository， RepositoryType.DIR));
        &#125;
    &#125;

    return ClassLoaderFactory.createClassLoader(repositories， parent);
&#125;
</code></pre>
<h3 id="4-ClassLoader加载过程"><a href="#4-ClassLoader加载过程" class="headerlink" title="4 ClassLoader加载过程"></a>4 ClassLoader加载过程</h3><ul>
<li>①. 接打开 ParallelWebappClassLoader ，至于为啥不是看 WebappClassLoader ，从名字上就知道 ParallelW ebappClassLoader 是一个并行的 WebappClassLoader<br>然后看下 ParallelWebappClassLoader 的 loadclass 方法是在它的父类 WebappClassLoaderBase 中实现的</li>
</ul>
<pre><code class="typescript"> 1 public Class loadClass(String name， boolean resolve)
 2             throws ClassNotFoundException &#123;
 3         Class clazz = null;
 4         // (0) 先从自己的缓存中查找，有则返回，无则继续
 5         clazz = findLoadedClass0(name);
 6         if (clazz != null) &#123;
 7             if (resolve) resolveClass(clazz);            
 8             return (clazz);
 9         &#125;
10         // (0.1) 再从parent的缓存中查找
11         clazz = findLoadedClass(name);
12         if (clazz != null) &#123;
13             if (resolve) resolveClass(clazz);
14             return (clazz);
15         &#125;
16         // (0.2) 缓存中没有，则首先使用system类加载器来加载
17         clazz = system.loadClass(name);
18          if (clazz != null) &#123;
19              if (resolve) resolveClass(clazz);
20              return (clazz);
21          &#125;
22         //判断是否需要先让parent代理
23         boolean delegateLoad = delegate || filter(name);
24         // (1) 先让parent加载，通常delegateLoad == false，即这一步不会执行
25 
26         if (delegateLoad) &#123;
27             ClassLoader loader = parent;
28             if (loader == null)
29                 loader = system;
30             clazz = loader.loadClass(name);
31             if (clazz != null) &#123;
32                 if (resolve) resolveClass(clazz);
33                 return (clazz);
34             &#125;
35         &#125;
36         // (2) delegateLoad == false 或者 parent加载失败，调用自身的加载机制
37         clazz = findClass(name);
38         if (clazz != null) &#123;
39             if (resolve) resolveClass(clazz);
40             return (clazz);
41         &#125;
42         // (3) 自己加载失败，则请求parent代理加载
43 
44         if (!delegateLoad) &#123;
45             ClassLoader loader = parent;
46             if (loader == null)
47                 loader = system;
48             clazz = loader.loadClass(name);
49             if (clazz != null) &#123;
50                 return (clazz);
51             &#125;
52         &#125;
53         throw new ClassNotFoundException(name);
54     &#125;
</code></pre>
<ul>
<li>②. 总结如上源码:</li>
</ul>
<ol>
<li>先从缓存中加载(自己的缓存和父类中的缓存)</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载；</li>
<li>如果没有，则从当前类加载器加载(按照 WEB-INF/classes 、 WEB-INF/lib 的顺序)</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是 AppClassLoader 、 Common 、 Shared</li>
</ol>
<h3 id="5-Tomcat破坏双亲委派机制带来的面试题"><a href="#5-Tomcat破坏双亲委派机制带来的面试题" class="headerlink" title="5 Tomcat破坏双亲委派机制带来的面试题"></a>5 Tomcat破坏双亲委派机制带来的面试题</h3><ul>
<li>①. 既然Tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？(阿里面试问题)<br>显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？<br>tomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader</li>
<li>②. 我们思考一下:Tomcat是个web容器，那么它要解决什么问题？</li>
</ul>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？所以，web容器需要支持jsp修改后不用重启。</li>
</ol>
<ul>
<li>③. Tomcat如果使用默认的类加载机制行不行？<br>答案是不行的。为什么？我们看:<br>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。<br>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。<br>第三个问题和第一个问题一样。<br>第四个问题，我们想我们要怎么实现jsp文件的热替换，jsp文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</li>
<li>④. 如果tomcat的CommonClassLoader想加载WebAppClassLoader中的类，该怎么办？<br>看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。</li>
<li>⑤. 为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class?<br>tomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在WEB-INF/class中。<br>而Eclipse/IDEA外部引用的jar包，则相当于放在WEB-INF/lib中。<br>因此肯定是java文件或者JSP文件编译出的class优先加载。</li>
<li>⑥. 为什么JDBC需要打破双亲委派机制<br>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包，DriverManager类中要加载各个实现了Driver接口的类，然后进行管理，也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类，这就打破了双亲委派机制</li>
</ul>
<h2 id="十九、CMS低延迟垃圾收集器"><a href="#十九、CMS低延迟垃圾收集器" class="headerlink" title="十九、CMS低延迟垃圾收集器"></a>十九、CMS低延迟垃圾收集器</h2><h3 id="1-CMS概述"><a href="#1-CMS概述" class="headerlink" title="1 CMS概述"></a>1 CMS概述</h3><ul>
<li>①. 在JDK1.5时期， HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器: CMS (Concurrent 一Mark 一 Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</li>
<li>②. CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。</li>
<li>③. CMS的垃圾收集算法采用标记一清除算法，并且也会” stop一the一world”</li>
<li>④. 不幸的是，CMS 作为老年代的收集器，却无法与JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1. 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</li>
<li>⑤. 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC<br><img src="https://img-blog.csdnimg.cn/20210621212300976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>⑥. CMS收集器在JDK9中被废弃，在JDK14中被移除</li>
</ul>
<h3 id="2-CMS过程-原理"><a href="#2-CMS过程-原理" class="headerlink" title="2 CMS过程(原理)"></a>2 CMS过程(原理)</h3><ul>
<li>①. 初始标记(Initial一Mark)仅仅只是标记出和GCRoots能直接关联到的对象，有STW现象、暂时时间非常短</li>
<li>②. 并发标记(Concurrent一Mark)阶段:从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行(并发标记阶段有三色标记，下文有记录)</li>
<li>③. 重新标记(Remark) 阶段:有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li>
<li>④. 并发清除:此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
<li>⑤. 补充说明:</li>
</ul>
<ol>
<li>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>CMS收集器的垃圾收集算法采用的是标记一清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择空闲列表(Free List) 执行内存分配。<br>(在并发标记阶段一开始不是垃圾，最后变成了垃圾)</li>
</ol>
<h3 id="3-CMS优缺点"><a href="#3-CMS优缺点" class="headerlink" title="3 CMS优缺点"></a>3 CMS优缺点</h3><ul>
<li>①. 优点:并发收集、低延迟</li>
<li>②. CMS的弊端:</li>
</ul>
<ol>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源非常敏感<br>(在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低)</li>
<li>CMS收集器无法处理浮动垃圾。可能出现”Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间</li>
</ol>
<ul>
<li>③.区分两个注意事项</li>
</ul>
<ol>
<li>并发标记阶段，在遍历GCRoots，用户线程也在执行，若此时遍历过一个对象发现没有引用，但由于用户线程并发执行，这期间可能导致遍历过的这个对象又被其他对象引用，所以才需要重新标记阶段再遍历一次看又没有漏标记的，否则就会导致被重新引用的对象被清理掉</li>
<li>浮动垃圾:在并发标记阶段一开始不是垃圾，最后变成了垃圾(属于多标的情况)</li>
</ol>
<h3 id="4-CMS参数设置"><a href="#4-CMS参数设置" class="headerlink" title="4 CMS参数设置"></a>4 CMS参数设置</h3><ul>
<li>①. -XX:+UseConcMarkSweepGc:手动指定使用CMS收集器执行内存回收任务<br>(开启该参数后会自动将一XX: +UseParNewGc打开。即: ParNew (Young区用) +CMS (0ld区用) +Serial 0ld的组合)</li>
<li>②. -XX:CMSlnitiatingOccupanyFraction:设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</li>
</ul>
<ol>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上版本默认值为92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数</li>
</ol>
<ul>
<li>③. -XX:+UseCMSCompactAtFullCollection:用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</li>
<li>④. -XX:CMSFullGCsBeforeCompaction:设置在执行多少次Full GC后对内存空间进行压缩整理</li>
<li>⑤. -XX:ParallelCMSThreads:设置CMS的线程数量<br>(CMS 默认启动的线程数是(ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕)</li>
</ul>
<h3 id="5-CMS三色标记概述、问题、解决方案"><a href="#5-CMS三色标记概述、问题、解决方案" class="headerlink" title="5 CMS三色标记概述、问题、解决方案"></a>5 CMS三色标记概述、问题、解决方案</h3><ul>
<li>①. 在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色:</li>
</ul>
<ol>
<li>黑色(black):节点被遍历完成，而且子节点都遍历完成</li>
<li>灰色(gray): 当前正在遍历的节点，而且子节点还没有遍历</li>
<li>白色(white):还没有遍历到的节点，即灰色节点的子节点<br><img src="https://img-blog.csdnimg.cn/20210622094337195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 根据三色扫描算法，如果有下面两种情况发生，则会出现漏扫描的场景:</li>
</ul>
<ol>
<li>把一个白对象的引用存到黑对象的字段里，如果这个情况发生，因为标记为黑色的对象认为是扫描完成的，不会再对他进行扫描。只能通过灰色的对象(CMS垃圾收集器)<br>(如上图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障和增量更新解决)</li>
<li>某个白对象失去了所有能从灰对象到达它的引用路径(直接或间接)(G1垃圾收集器)<br>(如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用写屏障和原始快照)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201014152019497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 三色过程:如下图所示，假如说A引入了B，B引用了C，D没有被任何引用。那么首先我们的CMS首先扫描到了A，发现A有引用B，那么我们的CMS会将A标记为黑色，B标记为灰色，然后这时候，通过B又找到了C那么这个时候发现C已经没有任何引用了就会将C标记为黑色。但是我们的D到目前为止没有被任何引用，记住我这里说的条件!那么D从始至终都没有被扫描，此时就会一直是白色，对于白色的对象来说CMS在执行并发清理的时候就会将此类对象干掉。<br>但是这里有了一个问题:如果我们的扫描过程已经结束这一段了，但是此时此刻我的A突然引用了D类型怎么办，这样一来我们的D只要被GC干掉是不是就会出现问题？也就是说我这里产生了一个漏标的问题。当然，我们的JVM开发人员可不是傻子，这里他们用了一个操作叫做增量更新和写屏障来解决这种问题的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="6-原始快照SATB-和-增量更新Incremental-Update"><a href="#6-原始快照SATB-和-增量更新Incremental-Update" class="headerlink" title="6 原始快照SATB 和 增量更新Incremental Update"></a>6 原始快照SATB 和 增量更新Incremental Update</h3><ul>
<li>①. 增量更新(Incremental Update):在并发标记过程中，把赋值的这种新增的引用，做一个集合存起来。 在重新标记的时候会找到集合里面的引用然后重新去扫描，再把源头标记为灰色。这就是我们的增量更新<br>(如下图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法:使用写屏障(这个写屏障在之后)和增量更新解决)<br><img src="https://img-blog.csdnimg.cn/20210622100441837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>②. 在把我们新增的引用放到集合的时候，会实现一种写屏障的方式。在对象前后通过一个dirty card queue将引用信息， 存在card中，这个dirty card queue会放在cardtable中，而cardtable是记忆集的具体实现，最终这个引用就会放在记忆集中的<br>(写屏障我们可以理解为在赋值操作的前面加一个方法，赋值的后面做一些操作，也可以理解为AOP。具体的C++实现代码如下图:)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201014153100882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>③. 原始快照(SATB)算法认为开始标记的都认为是活的对象，如上下图所示，引用B到D的引用改为B到C时，通过write barrier写屏障技术，会把B到D的引用推到gc遍历执行的堆栈上，保证还可以遍历到D对象，相对于d来说，引用从B–&gt;A，SATB 是从源入手解决的，即上面说的第2种情况，<br>这也能理解为啥叫satb了，即认为开始时所有能遍历到的对象都是需要标记的，即都认为是活的。如果我把b = null，那么d就是垃圾了， satb算法也还是会把D最终标记为黑色，导致D在本轮gc不能回收，成了浮动垃圾<br>(自己的理解:如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法:使用原始快照和写屏障 注意:这个写屏障在前面)<img src="https://img-blog.csdnimg.cn/20210622102523886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201014153730621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="7-记忆集与卡表"><a href="#7-记忆集与卡表" class="headerlink" title="7 记忆集与卡表"></a>7 记忆集与卡表</h3><ul>
<li>①. 在刚刚我们再说写屏障的时候提到了卡表，那么我们现在就来说说卡表是干什么用的。但是在说记忆集与卡表之前，我们要先知道what is 跨带引用~</li>
<li>②. 跨带引用:<br>所谓跨带引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。</li>
<li>③. 记忆集(在新生代中)<br>记忆集也叫rememberSet，垃圾收集器在新生代中建立了记忆集这样的数据结构，用来避免把整个老年代加入到GC ROOTS的扫描范围中。对于记忆集来说，我们可以理解为他是一个抽象类，那么具体实现它的方法将由子类去完成。这里我们简单列举一下实现记忆集的三种方式:<br>1.字长精度<br>2.对象精度<br>3.卡精度(卡表)</li>
<li>④. 卡表(在老年代中)<br>卡表(Card Table)是一种对记忆集的具体实现。主要定义了记忆集的记录精度、与堆内存的映射关系等。卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块我们称之为卡页(card page)，当存在跨带引用的时候，它会将卡页标记为dirty。那么JVM对于卡页的维护也是通过写屏障的方式，这也就是为什么刚刚我们跟进写屏障操作到最后会发现它会对卡表进行一系列的操作。</li>
<li>注意:(1). 卡表是使用一个字节数组实现:CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为”卡页”。hotSpot使用的卡页是2^9大小，即512字节<br>(2). 一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0。GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</li>
</ul>
<h2 id="二十、G1垃圾收集器概述"><a href="#二十、G1垃圾收集器概述" class="headerlink" title="二十、G1垃圾收集器概述"></a>二十、G1垃圾收集器概述</h2><h3 id="1-什么是G1垃圾收集器"><a href="#1-什么是G1垃圾收集器" class="headerlink" title="1 什么是G1垃圾收集器"></a>1 什么是G1垃圾收集器</h3><ul>
<li>①. G1(Garbage-First)是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征</li>
<li>②. 在JDK1.7版本正式启用，是JDK 9以后的默认垃圾收集器，取代了CMS 回收器。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210627185110429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-为什么名字叫Garbage-First"><a href="#2-为什么名字叫Garbage-First" class="headerlink" title="2 为什么名字叫Garbage First"></a>2 为什么名字叫Garbage First</h3><ul>
<li>①. G1是一个并行回收器，它把堆内存分割为很多不相关的区域(region物理上不连续)，把堆分为2048个区域，每一个region的大小是1 - 32M不等，必须是2的整数次幂。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</li>
<li>②. 每次根据允许的收集时间，优先回收价值最大的Region<br>(每次回收完以后都有一个空闲的region，在后台维护一个优先列表)</li>
<li>③. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字:垃圾优先(Garbage First)</li>
<li>④. 下面说一个问题:既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First(G1)GC？<br>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器”的重任与期望。</li>
</ul>
<h3 id="3-G1垃圾收集器的特点、缺点"><a href="#3-G1垃圾收集器的特点、缺点" class="headerlink" title="3 G1垃圾收集器的特点、缺点"></a>3 G1垃圾收集器的特点、缺点</h3><ul>
<li>①. 并行和并发</li>
</ul>
<ol>
<li>并行性: G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ol>
<ul>
<li>②. 分代收集</li>
</ul>
<ol>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210627185423634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210627185428360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>③. 空间整合<br>(G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记一压缩(Mark一Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显)</li>
<li>④. 可预测的停顿时间模型(即:软实时soft real一time)<br>(这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒、可以通过参数-XX:MaxGCPauseMillis进行设置)</li>
</ul>
<ol>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。<br>(CMS的最好的情况G1不一定比的上，但是CMS最差的部分，G1可以比上)</li>
</ol>
<ul>
<li>⑤. 缺点:</li>
</ul>
<ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间</li>
</ol>
<h3 id="4-参数设置"><a href="#4-参数设置" class="headerlink" title="4 参数设置"></a>4 参数设置</h3><ul>
<li>①. -XX:+UseG1GC:手动指定使用G1收集器执行内存回收任务</li>
<li>②. -XX:G1HeapRegionSize:设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000</li>
<li>③. -XX:MaxGCPauseMillis:设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms<br>(如果这个值设置很小，如20ms，那么它收集的region会少，这样长时间后，堆内存会满。产生FullGC，FullGC会出现STW，反而影响用户体验)</li>
<li>④. -XX:ParallelGCThread:设置stw时GC线程数的值。最多设置为8(垃圾回收线程)</li>
<li>⑤. -XX:ConcGCThreads:设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</li>
<li>⑥. -XX:Ini tiatingHeapOccupancyPercent:设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45</li>
</ul>
<h3 id="5-调优操作步骤"><a href="#5-调优操作步骤" class="headerlink" title="5 调优操作步骤"></a>5 调优操作步骤</h3><ul>
<li>①. G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</li>
</ul>
<ol>
<li>开启G1垃圾收集器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间</li>
</ol>
<ul>
<li>②. G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发</li>
</ul>
<h3 id="6-Region详解"><a href="#6-Region详解" class="headerlink" title="6 Region详解"></a>6 Region详解</h3><ul>
<li>①. 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。可以通过-XX:G1Hea pRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变</li>
<li>②. 一个region 有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于0ld内存区域。图中空白的表示未使用的内存空间</li>
<li>③. 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H<br>(对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926192008566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="7-记忆集与写屏障"><a href="#7-记忆集与写屏障" class="headerlink" title="7 记忆集与写屏障"></a>7 记忆集与写屏障</h3><ul>
<li>①. 问题:一个Region不可能是孤立的，一个Region中的对象可能被其他对象引用，如新生代中引用了老年代，这个时候垃圾回收时，会去扫描老年代，会出现STW</li>
<li>②. 解决:无论是G1还是分带收集器，JVM都是使用Remembered Set来避免全局扫描。每个Region都有一个对应的Remembered Set；[下面过程需要掌握]</li>
</ul>
<ol>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region (其他收集器:检查老年代对象是否引用了新生代对象)</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏<br><img src="https://img-blog.csdnimg.cn/20200926192909723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="8-G1回收器垃圾回收过程"><a href="#8-G1回收器垃圾回收过程" class="headerlink" title="8 G1回收器垃圾回收过程"></a>8 G1回收器垃圾回收过程</h3><ul>
<li>①. G1 GC的垃圾回收过程主要包括如下三个环节：</li>
</ul>
<ol>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程 (Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
<li>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/20210627220226998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>②. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行(多个垃圾线程)的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</li>
<li>③. 当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程</li>
<li>④. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>⑤. 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收</li>
</ul>
<h4 id="8-1-年轻代GC"><a href="#8-1-年轻代GC" class="headerlink" title="8.1 年轻代GC"></a>8.1 年轻代GC</h4><blockquote>
<p>回收时机<br>(1). 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区<br>(3). 回收前:<br><img src="https://img-blog.csdnimg.cn/20210627224109323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(4). 回收后:<br><img src="https://img-blog.csdnimg.cn/20210627224114494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>①. 根扫描: 一定要考虑remembered Set，看是否有老年代中的对象引用了新生代对象<br>(根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口)</li>
<li>②.更新RSet:处理dirty card queue(见备注)中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用<br>(dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty CardQueue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多)</li>
<li>③. 处理RSet:识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</li>
<li>④. 复制对象:复制算法<br>(此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间)</li>
<li>⑤. 处理引用:处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</li>
</ul>
<h4 id="8-2-并发标记过程"><a href="#8-2-并发标记过程" class="headerlink" title="8.2 并发标记过程"></a>8.2 并发标记过程</h4><ul>
<li>①. 初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>②. 根区域扫描(Root Region Scanning):G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成(YoungGC时，会动Survivor区，所以这一过程必须在young GC之前完成)</li>
<li>③. 并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>④. 再次标记(Remark):由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)<br>(在CMS中有详细讲解)</li>
<li>⑤. 独占清理(cleanup，STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)</li>
<li>⑥. 并发清理阶段:识别并清理完全空闲的区域</li>
</ul>
<h4 id="8-3-混合回收-Mixed-GC"><a href="#8-3-混合回收-Mixed-GC" class="headerlink" title="8.3 混合回收 Mixed GC"></a>8.3 混合回收 Mixed GC</h4><ul>
<li>①. Mixed GC并不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200926194129931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="8-4-Full-GC"><a href="#8-4-Full-GC" class="headerlink" title="8.4 Full GC"></a>8.4 Full GC</h4><ul>
<li>①. 堆内存过小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决</li>
<li>②. 暂停时间-XX:MaxGCPauseMillis设置短，回收频繁。由于用户线程和GC线程一起执行，可能用户线程产生的垃圾大于GC线程回收的垃圾，会导致内存不足，触发Full gc</li>
</ul>
<h3 id="9-优化建议"><a href="#9-优化建议" class="headerlink" title="9 优化建议"></a>9 优化建议</h3><ul>
<li>①. 年轻代发送GC频率高，避免使用-Xmn或-XX:NewRatio，让JVM自己设置</li>
<li>②. 暂停时间目标不要太过严苛</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/JVM" style=color:#ffa2c4>
                JVM
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/JVM/JVM虚拟机/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/">
        <h2>
            Mybaits使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="MyBaits使用详解"><a href="#MyBaits使用详解" class="headerlink" title="MyBaits使用详解"></a>MyBaits使用详解</h1><blockquote>
<p> 环境说明：</p>
</blockquote>
<ul>
<li>jdk 8 +</li>
<li>MySQL 5.7.19</li>
<li>maven-3.6.1</li>
<li>IDEA</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1、Mybaits简介"><a href="#1-1、Mybaits简介" class="headerlink" title="1.1、Mybaits简介"></a>1.1、Mybaits简介</h3><ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</li>
<li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到<strong>Github</strong> .</li>
<li>Mybatis官方文档 : <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li>
<li>GitHub : <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li>
</ul>
<h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p>
<ul>
<li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
<li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li>
</ul>
<p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p>
<ul>
<li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li>
<li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p><strong>什么是持久层？</strong></p>
<ul>
<li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li>
<li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li>
<li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li>
<li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li>
</ul>
<h3 id="1-4、Mybaits功能"><a href="#1-4、Mybaits功能" class="headerlink" title="1.4、Mybaits功能"></a>1.4、Mybaits功能</h3><ul>
<li><p>Mybatis就是帮助程序员将数据存入数据库中 , 和从数据库中取数据 .</p>
</li>
<li><p>传统的jdbc操作 , 有很多重复代码块 。比如：数据取出时的封装 , 数据库的建立连接等等，通过框架可以减少重复代码，提高开发效率 。</p>
</li>
<li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p>
</li>
<li><p>MyBatis的优点</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
</ul>
<ul>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<h3 id="1-5、Mybaits程序"><a href="#1-5、Mybaits程序" class="headerlink" title="1.5、Mybaits程序"></a>1.5、Mybaits程序</h3><h4 id="1-5-1、数据库搭建"><a href="#1-5-1、数据库搭建" class="headerlink" title="1.5.1、数据库搭建"></a>1.5.1、数据库搭建</h4><pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
`id` int(20) NOT NULL,
`name` varchar(30) DEFAULT NULL,
`pwd` varchar(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) 
values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);
</code></pre>
<h4 id="1-5-2、导入依赖"><a href="#1-5-2、导入依赖" class="headerlink" title="1.5.2、导入依赖"></a>1.5.2、导入依赖</h4><pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1-5-3、核心配置文件"><a href="#1-5-3、核心配置文件" class="headerlink" title="1.5.3、核心配置文件"></a>1.5.3、核心配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
   &lt;!-- 配置环境 --&gt;
   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
               &lt;property name=&quot;url&quot; 
                         value=&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;amp;
                                useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
    
   &lt;!-- 加载映射地址 --&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="1-5-4、Mybaits工具类"><a href="#1-5-4、Mybaits工具类" class="headerlink" title="1.5.4、Mybaits工具类"></a>1.5.4、Mybaits工具类</h4><pre><code class="java">import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils &#123;

    /**
     * 禁止外界通过new方法创建
         private MybatisUtil()&#123;&#125;
     */
    
   private static SqlSessionFactory sqlSessionFactory;

   static &#123;
       try &#123;
           String resource = &quot;mybatis-config.xml&quot;;
           // 加载核心配置文件
           InputStream inputStream = Resources.getResourceAsStream(resource);
           // 创建sqlsession工厂 --&gt;相当于connection
           sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
      &#125; catch (IOException e) &#123;
           e.printStackTrace();
      &#125;
  &#125;

   //获取SqlSession连接 --&gt;相当于执行sql语句对象
   public static SqlSession getSession()&#123;
       
       /*       
           //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象为空
            if(sqlSession == null)&#123;
                //在SqlSessionFactory非空的情况下，获取SqlSession对象
                sqlSession = sqlSessionFactory.openSession();
                //将SqlSession对象与当前线程绑定在一起
                threadLocal.set(sqlSession);
            &#125;       
       */
       
       return sqlSessionFactory.openSession();
  &#125;
    
   /**
     * 
          关闭SqlSession与当前线程分开
           public static void closeSqlSession()&#123;
            //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象非空
            if(sqlSession != null)&#123;
                //关闭SqlSession对象
                sqlSession.close();
                //分开当前线程与SqlSession对象的关系，目的是让GC尽早回收
                threadLocal.remove();
            &#125;
        &#125;
     
     */
  

&#125;
</code></pre>
<p><strong>MybatisUtil工具类的作用</strong>:</p>
<ul>
<li>在静态初始化块中加载mybatis配置文件和StudentMapper.xml文件一次</li>
<li>使用ThreadLocal对象让当前线程与SqlSession对象绑定在一起</li>
<li>获取当前线程中的SqlSession对象，如果没有的话，从SqlSessionFactory对象中获取SqlSession对象</li>
<li>获取当前线程中的SqlSession对象，再将其关闭，释放其占用的资源</li>
</ul>
<h4 id="1-5-5、实体类"><a href="#1-5-5、实体类" class="headerlink" title="1.5.5、实体类"></a>1.5.5、实体类</h4><pre><code class="java">@Data
public class User &#123;
   
   private int id;  //id
   private String name;   //姓名
   private String pwd;   //密码
   
&#125;
</code></pre>
<h4 id="1-5-6、Mapper接口类"><a href="#1-5-6、Mapper接口类" class="headerlink" title="1.5.6、Mapper接口类"></a>1.5.6、Mapper接口类</h4><pre><code class="java">import com.kuang.pojo.User;
import java.util.List;

public interface UserMapper &#123;
   List&lt;User&gt; selectUser();
&#125;
</code></pre>
<h4 id="1-5-7、Mapper-xml配置文件"><a href="#1-5-7、Mapper-xml配置文件" class="headerlink" title="1.5.7、Mapper.xml配置文件"></a>1.5.7、Mapper.xml配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;
 &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
  select * from user
 &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="1-5-8、测试类"><a href="#1-5-8、测试类" class="headerlink" title="1.5.8、测试类"></a>1.5.8、测试类</h4><pre><code class="java">public class MyTest &#123;
   @Test
   public void selectUser() &#123;
       SqlSession session = MybatisUtils.getSession();
       //方法一:
       List&lt;User&gt; users1 = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);
       
       for (User user: users1)&#123;
           System.out.println(user);
      &#125;    
       
       
       //方法二:
       UserMapper mapper = session.getMapper(UserMapper.class);
       List&lt;User&gt; users2 = mapper.selectUser();
   
       for (User user: users2)&#123;
           System.out.println(user);
      &#125;
       session.close();
  &#125;
&#125;
</code></pre>
<h3 id="1-6、问题说明"><a href="#1-6、问题说明" class="headerlink" title="1.6、问题说明"></a>1.6、问题说明</h3><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/resources&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="二、CUDR操作及配置解析"><a href="#二、CUDR操作及配置解析" class="headerlink" title="二、CUDR操作及配置解析"></a>二、CUDR操作及配置解析</h2><h3 id="2-1、namespace"><a href="#2-1、namespace" class="headerlink" title="2.1、namespace"></a>2.1、namespace</h3><ol>
<li>将上面案例中的UserMapper接口改名为 UserDao；</li>
<li>将UserMapper.xml中的namespace改为为UserDao的路径 ；</li>
<li>再次测试</li>
</ol>
<p><strong>结论：</strong></p>
<p>​        <strong>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名，必须一致！</strong></p>
<h3 id="2-2、CUDR操作"><a href="#2-2、CUDR操作" class="headerlink" title="2.2、CUDR操作"></a>2.2、CUDR操作</h3><h4 id="2-2-1、select操作"><a href="#2-2-1、select操作" class="headerlink" title="2.2.1、select操作"></a>2.2.1、select操作</h4><ul>
<li><p>select标签是mybatis中最常用的标签之一</p>
</li>
<li><p>select语句有很多属性可以详细配置每一条SQL语句</p>
</li>
<li><ul>
<li>SQL语句返回值类型。【完整的类名或者别名】</li>
<li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li>
<li>命名空间中唯一的标识符</li>
<li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li>
<li>id</li>
<li>parameterType</li>
<li>resultType</li>
</ul>
</li>
</ul>
<p><strong>需求一：根据id查询用户</strong></p>
<p>1、在UserMapper中添加对应方法</p>
<pre><code class="java">public interface UserMapper &#123;
   //查询全部用户
   List&lt;User&gt; selectUser();
   //根据id查询用户
   User selectUserById(int id);
&#125;
</code></pre>
<p>2、在UserMapper.xml中添加Select语句</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>select参数：</p>
<p>1). id：</p>
<p>2). <strong>parametweType：</strong>传递的参数</p>
<p>3). <strong>resultType：</strong>是SQL映射文件中定义返回值类型，返回值有基本类型，对象类型，List类型，Map类型等。</p>
<ul>
<li>基本类型：resultType=基本类型</li>
<li>List类型：resultType=<strong>List中元素的类型</strong></li>
<li>Map类型  <ul>
<li>单条记录：resultType=map</li>
<li>多条记录：resultType =Map中value的类型</li>
</ul>
</li>
</ul>
<p><strong>注：</strong>为什么是使用map而不是Map呢？</p>
<p>刚刚配置中的**resultType=”map”**，为什么是map，不是Map呢？</p>
<p>如果想写Map，需要写成全限定类名，即：<strong>resultType = “java.util.Map”</strong> map是java.util.Map的一个简写，还有其他的简写可以参考下方表格：</p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M1.png"></p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M2.png"></p>
<p>3、测试类中测试</p>
<pre><code class="java">@Test
public void tsetSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   System.out.println(user);
   
   session.close();
&#125;
</code></pre>
<p><strong>需求二：根据密码和名字查询用户</strong></p>
<p><strong>思路一：直接在方法中传递参数</strong></p>
<p>1、在接口方法的参数前加 @Param属性</p>
<p>2、Sql语句编写的时候，直接取**@Param中设置的值**即可，不需要单独设置参数类型</p>
<pre><code class="java">//通过密码和名字查询用户
User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);
</code></pre>
<p>3、Mapper.xml配置文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p><strong>思路二：使用Map</strong></p>
<p>1、在接口方法中，参数直接传递Map；</p>
<pre><code class="java">User selectUserByNP2(Map&lt;String,Object&gt; map);
</code></pre>
<p>2、编写sql语句的时候，需要传递参数类型，参数类型为map</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p>3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put(&quot;username&quot;,&quot;小明&quot;);
map.put(&quot;pwd&quot;,&quot;123456&quot;);
User user = mapper.selectUserByNP2(map);
</code></pre>
<p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可.</p>
<h4 id="2-2-2、insert操作"><a href="#2-2-2、insert操作" class="headerlink" title="2.2.2、insert操作"></a>2.2.2、insert操作</h4><p><strong>需求：给数据库增加一个用户</strong></p>
<p>1、在UserMapper接口中添加对应的方法</p>
<pre><code class="java">//添加一个用户
int addUser(User user);
</code></pre>
<p>2、在UserMapper.xml中添加insert语句</p>
<pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
&lt;/insert&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);
   int i = mapper.addUser(user);
   System.out.println(i);
   
   // 提交事务，将事务提交到数据库
   session.commit(); 
   session.close();
&#125;
</code></pre>
<p>​    <strong>注：</strong>增、删、改操作需要提交事务！</p>
<h4 id="2-2-3、update操作"><a href="#2-2-3、update操作" class="headerlink" title="2.2.3、update操作"></a>2.2.3、update操作</h4><p><strong>需求：修改用户的信息</strong></p>
<p>1、同理，编写接口方法</p>
<pre><code class="java">//修改一个用户
int updateUser(User user);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   user.setPwd(&quot;asdfgh&quot;);
   int i = mapper.updateUser(user);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-4、delete操作"><a href="#2-2-4、delete操作" class="headerlink" title="2.2.4、delete操作"></a>2.2.4、delete操作</h4><p><strong>需求：根据id删除一个用户</strong></p>
<p>1、编写接口方法</p>
<pre><code class="java">//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from user where id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   int i = mapper.deleteUser(5);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-5、模糊查询like语句"><a href="#2-2-5、模糊查询like语句" class="headerlink" title="2.2.5、模糊查询like语句"></a>2.2.5、模糊查询like语句</h4><p>方法一：在Java代码中添加sql通配符。</p>
<pre><code class="java">string wildcardname = “%smi%”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like #&#123;value&#125;
&lt;/select&gt;
</code></pre>
<p>方法二：在sql语句中拼接通配符，会引起sql注入</p>
<pre><code class="java">string wildcardname = “smi”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
&lt;/select&gt;
</code></pre>
<h4 id="2-4-6、小结"><a href="#2-4-6、小结" class="headerlink" title="2.4.6、小结"></a>2.4.6、小结</h4><ul>
<li>所有的增删改操作都需要提交事务！</li>
<li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li>
<li>有时候根据业务的需求，可以考虑使用map传递参数！</li>
<li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li>
</ul>
<h3 id="2-3、配置解析"><a href="#2-3、配置解析" class="headerlink" title="2.3、配置解析"></a>2.3、配置解析</h3><h4 id="2-3-1、核心配置文件"><a href="#2-3-1、核心配置文件" class="headerlink" title="2.3.1、核心配置文件"></a>2.3.1、核心配置文件</h4><ul>
<li>mybatis-config.xml 系统核心配置文件</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
<li>能配置的内容如下：</li>
</ul>
<pre><code class="xml">configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;
</code></pre>
<p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p>
<h4 id="2-3-2、environments元素"><a href="#2-3-2、environments元素" class="headerlink" title="2.3.2、environments元素"></a>2.3.2、environments元素</h4><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;

        &lt;!-- 事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<ul>
<li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p>
</li>
<li><p>子元素节点：<strong>environment</strong></p>
<ul>
<li>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</li>
</ul>
<ul>
<li><p>数据源是必须配置的。</p>
</li>
<li><p>有三种内建的数据源类型</p>
</li>
</ul>
</li>
</ul>
<pre><code class="xml">type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）
</code></pre>
<ul>
<li><p><strong>unpooled：</strong>这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
</li>
<li><p><strong>JNDI：</strong>这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
<li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p>
</li>
<li><p>详情：点击查看官方文档</p>
</li>
<li><p>这两种事务管理器类型都不需要设置任何属性。</p>
</li>
<li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p>
</li>
<li><p>子元素节点：transactionManager - [ 事务管理器 ]</p>
</li>
</ul>
<pre><code class="xml">&lt;!-- 语法 --&gt;
&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;
</code></pre>
<ul>
<li>子元素节点：<strong>数据源（dataSource）</strong></li>
</ul>
<h4 id="2-3-3、mappers元素"><a href="#2-3-3、mappers元素" class="headerlink" title="2.3.3、mappers元素"></a>2.3.3、mappers元素</h4><p><strong>mappers</strong></p>
<ul>
<li><strong>映射器 :</strong> 定义映射SQL语句文件</li>
<li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用<strong>相对于类路径的资源引用</strong>， 或<strong>完全限定资源定位符</strong>（包括 <code>file:///</code> 的 URL），或类名和包名等。</li>
<li>映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li>
</ul>
<p><strong>引入资源方式</strong></p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
    使用映射器接口实现类的完全限定类名
    需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Mapper文件</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
   
&lt;/mapper&gt;
</code></pre>
<ul>
<li><p>namespace中文意思：命名空间，作用如下：</p>
<ul>
<li>namespace的命名必须跟某个接口同名</li>
</ul>
<ul>
<li>接口中的方法与映射文件中sql语句id应该一一对应<ul>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p>
<h4 id="2-3-4、Properties优化"><a href="#2-3-4、Properties优化" class="headerlink" title="2.3.4、Properties优化"></a>2.3.4、Properties优化</h4><p>​        数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<p>​        第一步 ; 在资源目录下新建一个<strong>db.properties</strong></p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
username=root
password=123456
</code></pre>
<p>​        第二步 : 将文件导入properties 配置文件</p>
<pre><code class="xml">&lt;configuration&gt;
   &lt;!--导入properties文件--&gt;
   &lt;properties resource=&quot;db.properties&quot;/&gt;

   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
               &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>更多操作，可以查看官方文档！【演示带领学习】</p>
<ul>
<li>配置文件优先级问题</li>
<li>新特性：使用占位符</li>
</ul>
<h4 id="2-4-5、typeAliases优化"><a href="#2-4-5、typeAliases优化" class="headerlink" title="2.4.5、typeAliases优化"></a>2.4.5、typeAliases优化</h4><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<pre><code class="xml">&lt;!--配置别名,注意顺序--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p>
<pre><code class="xml">&lt;typeAliases&gt;
   &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p>
<p>若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class User &#123;
  ...
&#125;
</code></pre>
<p>去官网查看一下Mybatis默认的一些类型别名！</p>
<h4 id="2-4-6、其他浏览设置"><a href="#2-4-6、其他浏览设置" class="headerlink" title="2.4.6、其他浏览设置"></a>2.4.6、其他浏览设置</h4><ul>
<li><p>设置（settings）相关 =&gt; 查看帮助文档</p>
<ul>
<li>懒加载</li>
</ul>
<ul>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li><p>一个配置完整的 settings 元素的示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;!--该配置影响的所有映射器中配置的缓存的全局开关--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态--&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--是否允许单一语句返回多结果集（需要兼容驱动）。--&gt;
    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。--&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。--&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。--&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
   
    &lt;!----&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    
    &lt;!--配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。--&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
   
    &lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。--&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
   
    &lt;!--Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.--&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    
    &lt;!--允许在嵌套语句中使用分页（RowBounds）。--&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
   
    &lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。--&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。--&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    
    &lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。--&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    
    &lt;!--指定哪个对象的方法触发一次延迟加载。--&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;

    &lt;!--指定动态 SQL 生成的默认语言。--&gt;
    &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver&quot;/&gt;

    &lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。--&gt;
    &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;

    &lt;!--定 MyBatis 增加到日志名称的前缀。--&gt;
    &lt;setting name=&quot;logPrefix&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 MyBatis 所用日志的具体实现，未指定时将自动查找。--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。--&gt;
    &lt;setting name=&quot;proxyFactory&quot; value=&quot;JAVASSIST&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
</ul>
<p><strong>类型处理器</strong></p>
<ul>
<li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li>
<li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li>
</ul>
<p><strong>对象工厂</strong></p>
<ul>
<li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li>
<li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li>
<li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li>
</ul>
<h4 id="2-4-7、生命周期和作用域"><a href="#2-4-7、生命周期和作用域" class="headerlink" title="2.4.7、生命周期和作用域"></a>2.4.7、生命周期和作用域</h4><p>​        理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>作用域理解</strong></p>
<ul>
<li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li>
<li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li>
<li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li>
<li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li>
<li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li>
<li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、ResultMap以及分页"><a href="#三、ResultMap以及分页" class="headerlink" title="三、ResultMap以及分页"></a>三、ResultMap以及分页</h2><h3 id="3-1、查询为null"><a href="#3-1、查询为null" class="headerlink" title="3.1、查询为null"></a>3.1、查询为null</h3><h4 id="3-1-1、属性名和字段名不一致问题"><a href="#3-1-1、属性名和字段名不一致问题" class="headerlink" title="3.1.1、属性名和字段名不一致问题"></a>3.1.1、属性名和字段名不一致问题</h4><p>环境：新建一个项目，将之前的项目拷贝过来</p>
<p>1、查看之前的数据库的字段名</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KdXPq6whFkfHe43CtgZMJrr62lCnbfxl25aQ4ZDwlU4JiaMZHs3nqAoNxFsJYZRC4Cm11uSH0USNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、Java中的实体类设计</p>
<pre><code class="java">@Data
public class User &#123;

   private int id;  //id
   private String name;   //姓名
   private String password;   //密码和数据库不一样！
   
&#125;
</code></pre>
<p>3、接口</p>
<pre><code class="java">//根据id查询用户
User selectUserById(int id);
</code></pre>
<p>4、mapper映射文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   System.out.println(user);
   session.close();
&#125;
</code></pre>
<p><strong>结果:</strong></p>
<ul>
<li>User{id=1, name=’狂神’, password=’null’}</li>
<li>查询出来发现 password 为空 . 说明出现了问题！</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li><p>select * from user where id = #{id} 可以看做</p>
<p>select  id,name,pwd  from user where id = #{id}</p>
</li>
<li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p>
</li>
</ul>
<h4 id="3-1-2、解决方案"><a href="#3-1-2、解决方案" class="headerlink" title="3.1.2、解决方案"></a>3.1.2、解决方案</h4><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;
    select id , name , pwd as password 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>方案二：使用结果集映射——-&gt;ResultMap</strong> 【推荐】</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
    select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;

&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!-- id为主键 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="3-2、ResultMap"><a href="#3-2、ResultMap" class="headerlink" title="3.2、ResultMap"></a>3.2、ResultMap</h3><p><strong>自动映射</strong></p>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li>
<li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li>
<li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li>
</ul>
<p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;
    select id , name , pwd
    from user
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p>
<p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p>
<p><strong>手动映射</strong></p>
<p>1、返回值类型为resultMap</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
  select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>2、编写resultMap，实现手动映射！</p>
<pre><code class="xml">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
   &lt;!-- id为主键 --&gt;
   &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
   &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
   &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<p>​        数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p>
<h3 id="3-3、分页"><a href="#3-3、分页" class="headerlink" title="3.3、分页"></a>3.3、分页</h3><h4 id="3-3-1、日志工厂"><a href="#3-3-1、日志工厂" class="headerlink" title="3.3.1、日志工厂"></a>3.3.1、日志工厂</h4><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p>
<p>​        如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p>
<p>​        对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p>
<p>​        Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>​        具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p>
<p><strong>标准日志实现</strong></p>
<p>​        指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p>
<pre><code class="xml">&lt;settings&gt;
       &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>​        测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p>
<h4 id="3-3-2、Log4j简介："><a href="#3-3-2、Log4j简介：" class="headerlink" title="3.3.2、Log4j简介："></a>3.3.2、Log4j<strong>简介：</strong></h4><ul>
<li>Log4j是Apache的一个开源项目</li>
<li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p><strong>使用步骤：</strong></p>
<p>1、导入log4j的包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置文件编写</p>
<pre><code class="properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
<p>3、setting设置日志实现</p>
<pre><code class="xml">&lt;settings&gt;
   &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>4、在程序中使用Log4j进行输出！</p>
<pre><code class="java">//注意导包：org.apache.log4j.Logger
static Logger logger = Logger.getLogger(MyTest.class);

@Test
public void selectUser() &#123;
   logger.info(&quot;info：进入selectUser方法&quot;);
   logger.debug(&quot;debug：进入selectUser方法&quot;);
   logger.error(&quot;error: 进入selectUser方法&quot;);
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   List&lt;User&gt; users = mapper.selectUser();
   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<p>5、测试，看控制台输出！</p>
<ul>
<li>使用Log4j 输出日志</li>
<li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</li>
</ul>
<h4 id="3-3-3、limit实现分页"><a href="#3-3-3、limit实现分页" class="headerlink" title="3.3.3、limit实现分页"></a>3.3.3、limit实现分页</h4><p><strong>思考：为什么需要分页？</strong></p>
<p>​        在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p>
<p><strong>使用Limit实现分页</strong></p>
<pre><code class="sql">#语法
SELECT * FROM table LIMIT stratIndex，pageSize

SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  

#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   
SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  

#如果只给定一个参数，它表示返回最大的记录行数目：   
SELECT * FROM table LIMIT 5; //检索前 5 个记录行  

#换句话说，LIMIT n 等价于 LIMIT 0,n。 
</code></pre>
<p><strong>步骤：</strong></p>
<p>1、修改Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;
    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>
<p>2、Mapper接口，参数为map</p>
<pre><code class="java">//选择全部用户实现分页
List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);
</code></pre>
<p>3、在测试类中传入参数测试</p>
<ul>
<li>推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li>
</ul>
<pre><code class="java">//分页查询 , 两个参数startIndex , pageSize
@Test
public void testSelectUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   int currentPage = 1;  //第几页
   int pageSize = 2;  //每页显示几个
   Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();
   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);
   map.put(&quot;pageSize&quot;,pageSize);

   List&lt;User&gt; users = mapper.selectUser(map);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<blockquote>
<p>RowBounds分页</p>
</blockquote>
<p>​        我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p>
<p><strong>步骤：</strong></p>
<p>1、mapper接口</p>
<pre><code class="java">//选择全部用户RowBounds实现分页
List&lt;User&gt; getUserByRowBounds();
</code></pre>
<p>2、mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<p>在这里，我们需要使用RowBounds类</p>
<pre><code class="java">@Test
public void testUserByRowBounds() &#123;
   SqlSession session = MybatisUtils.getSession();

   int currentPage = 2;  //第几页
   int pageSize = 2;  //每页显示几个
   RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);

   //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]
   List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<h4 id="3-3-4、PageHelper"><a href="#3-3-4、PageHelper" class="headerlink" title="3.3.4、PageHelper"></a>3.3.4、PageHelper</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<h2 id="四、注解开发"><a href="#四、注解开发" class="headerlink" title="四、注解开发"></a>四、注解开发</h2><h3 id="4-1、面向接口编程"><a href="#4-1、面向接口编程" class="headerlink" title="4.1、面向接口编程"></a>4.1、面向接口编程</h3><ul>
<li><strong>根本原因 :  解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<h4 id="4-1-1、关于接口的理解"><a href="#4-1-1、关于接口的理解" class="headerlink" title="4.1.1、关于接口的理解"></a>4.1.1、关于接口的理解</h4><ul>
<li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p>
</li>
<li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p>
</li>
<li><p>接口应有两类：</p>
<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； </li>
</ul>
<ul>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li>
</ul>
</li>
<li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p>
</li>
</ul>
<h4 id="4-1-2、三个面向区别"><a href="#4-1-2、三个面向区别" class="headerlink" title="4.1.2、三个面向区别"></a>4.1.2、三个面向区别</h4><ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</li>
</ul>
<h3 id="4-2、利用注解开发"><a href="#4-2、利用注解开发" class="headerlink" title="4.2、利用注解开发"></a>4.2、利用注解开发</h3><ul>
<li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p>
</li>
<li><p>sql 类型主要分成 :</p>
<ul>
<li>@select () </li>
</ul>
<ul>
<li>@update ()</li>
<li>@Insert ()</li>
<li>@delete ()</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>利用注解开发就不需要mapper.xml映射文件了 .</p>
<p>1、我们在我们的接口中添加注解</p>
<pre><code class="java">//查询全部用户
@Select(&quot;select id,name,pwd password from user&quot;)
public List&lt;User&gt; getAllUser();
</code></pre>
<p>2、在mybatis的核心配置文件中注入</p>
<pre><code class="xml">&lt;!--使用class绑定接口--&gt;
&lt;mappers&gt;
   &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>3、我们去进行测试</p>
<pre><code class="java">@Test
public void testGetAllUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   //本质上利用了jvm的动态代理机制
   UserMapper mapper = session.getMapper(UserMapper.class);

   List&lt;User&gt; users = mapper.getAllUser();
   for (User user : users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<p>4、利用Debug查看本质</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNnMiahVkdvictXZkDDWHQCwob9rMlKtxnhiaQee5Kxa6K0BCbHH2ibRERibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、本质上利用了jvm的动态代理机制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNeukjWMleICg2Jsm8hTI63hvVLiarGmD7zT1CmgXlUXSUbmdhialeIjpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>6、Mybatis详细的执行流程</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="4-3、注解增删改"><a href="#4-3、注解增删改" class="headerlink" title="4.3、注解增删改"></a>4.3、注解增删改</h3><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。</p>
<pre><code class="java">//获取SqlSession连接
public static SqlSession getSession()&#123;
    return getSession(true); //事务自动提交
&#125;

public static SqlSession getSession(boolean flag)&#123;
    return sqlSessionFactory.openSession(flag);
&#125;
</code></pre>
<p>【注意】确保实体类和数据库字段对应</p>
<p><strong>查询：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id查询用户
@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
User selectUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.selectUserById(1);
   System.out.println(user);

   session.close();
&#125;
</code></pre>
<p><strong>新增：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//添加一个用户
@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)
int addUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;);
   mapper.addUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>修改：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//修改一个用户
@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)
int updateUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);
   mapper.updateUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>删除：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id删除用
@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
int deleteUser(@Param(&quot;id&quot;)int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   mapper.deleteUser(6);
   
   session.close();
&#125;
</code></pre>
<p>【注意点：增删改一定记得对事务的处理】</p>
<h3 id="4-4、关于-Param"><a href="#4-4、关于-Param" class="headerlink" title="4.4、关于@Param"></a>4.4、关于@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p>
<ul>
<li>在方法只接受一个参数的情况下，可以不使用@Param。</li>
<li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li>
<li>如果参数是 JavaBean ， 则不能使用@Param。</li>
<li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li>
</ul>
<h3 id="4-5、-与-的区别"><a href="#4-5、-与-的区别" class="headerlink" title="4.5、#与$的区别"></a>4.5、#与$的区别</h3><ul>
<li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (#&#123;name&#125;);
INSERT INTO user (name) VALUES (?);
</code></pre>
</li>
<li><p>${} 的作用是直接进行字符串替换</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);
INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);
</code></pre>
</li>
</ul>
<h2 id="五、一对多处理与多对一处理"><a href="#五、一对多处理与多对一处理" class="headerlink" title="五、一对多处理与多对一处理"></a>五、一对多处理与多对一处理</h2><h3 id="5-1、多对一处理"><a href="#5-1、多对一处理" class="headerlink" title="5.1、多对一处理"></a>5.1、多对一处理</h3><h4 id="5-1-1、数据库设计"><a href="#5-1-1、数据库设计" class="headerlink" title="5.1.1、数据库设计"></a>5.1.1、数据库设计</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LPbib5To6slfFhMArq5QvCjofjccx37cuQgKsWEHibax0bDiaicU6ojNfEzWrj3TibFsX3MJju4sAp5Pg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="sql">CREATE TABLE `teacher` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);

CREATE TABLE `student` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
`tid` INT(10) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `fktid` (`tid`),
CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
</code></pre>
<h4 id="5-1-2、搭建测试环境"><a href="#5-1-2、搭建测试环境" class="headerlink" title="5.1.2、搭建测试环境"></a>5.1.2、搭建测试环境</h4><p>1、IDEA安装Lombok插件</p>
<p>2、引入Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.16.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、在代码中增加注解</p>
<pre><code class="java">@Data //GET,SET,ToString，有参，无参构造
public class Teacher &#123;
   private int id;
   private String name;
&#125;
@Data
public class Student &#123;
   private int id;
   private String name;
   //多个学生可以是同一个老师，即多对一
   private Teacher teacher;
&#125;
</code></pre>
<p>4、编写实体类对应的Mapper接口 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="java">public interface StudentMapper &#123;
&#125;
public interface TeacherMapper &#123;
&#125;
</code></pre>
<p>5、编写Mapper接口对应的 mapper.xml配置文件 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

&lt;/mapper&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="5-1-3、按查询嵌套处理"><a href="#5-1-3、按查询嵌套处理" class="headerlink" title="5.1.3、按查询嵌套处理"></a>5.1.3、按查询嵌套处理</h4><p>1、给StudentMapper接口增加方法</p>
<pre><code class="java">//获取所有学生及对应老师的信息
public List&lt;Student&gt; getStudents();
</code></pre>
<p>2、编写对应的Mapper文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

   &lt;!--
   需求：获取所有学生及对应老师的信息
   思路：
       1. 获取所有学生的信息
       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息
       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？
           1. 做一个结果集映射：StudentTeacher
           2. StudentTeacher结果集的类型为 Student
           3. 学生中老师的属性为teacher，对应数据库中为tid。
              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多
           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询
   --&gt;
   &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
   &lt;/select&gt;
   &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
       &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
       &lt;association property=&quot;teacher&quot;  column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
   &lt;/resultMap&gt;
   &lt;!--
   这里传递过来的id，只有一个属性的时候，下面可以写任何值
   association中column多参数配置：
       column=&quot;&#123;key=value,key=value&#125;&quot;
       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
      select * from teacher where id = #&#123;id&#125;
   &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p>
<p>4、注意点说明：</p>
<pre><code class="xml">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
   &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
   &lt;association property=&quot;teacher&quot;  column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
这里传递过来的id，只有一个属性的时候，下面可以写任何值
association中column多参数配置：
   column=&quot;&#123;key=value,key=value&#125;&quot;
   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
--&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testGetStudents()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<h4 id="5-1-4、按结果嵌套处理"><a href="#5-1-4、按结果嵌套处理" class="headerlink" title="5.1.4、按结果嵌套处理"></a>5.1.4、按结果嵌套处理</h4><p>我们还可以按照结果进行嵌套处理；</p>
<p>1、接口方法编写</p>
<pre><code class="java">public List&lt;Student&gt; getStudents2();
</code></pre>
<p>2、编写对应的mapper文件</p>
<pre><code class="xml">&lt;!--
按查询结果嵌套处理
思路：
   1. 直接查询出结果，进行结果集的映射
--&gt;
&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;
  select s.id sid, s.name sname , t.name tname
  from student s,teacher t
  where s.tid = t.id
&lt;/select&gt;

&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
   &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
   &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
   &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;
   &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
       &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
   &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<p>3、去mybatis-config文件中注入【此处应该处理过了】</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetStudents2()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents2();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>按照查询进行嵌套处理就像SQL中的子查询</p>
<p>按照结果进行嵌套处理就像SQL中的联表查询</p>
<h3 id="5-2、一对多处理"><a href="#5-2、一对多处理" class="headerlink" title="5.2、一对多处理"></a>5.2、一对多处理</h3><h4 id="5-2-1、实体类编写"><a href="#5-2-1、实体类编写" class="headerlink" title="5.2.1、实体类编写"></a>5.2.1、实体类编写</h4><pre><code class="java">@Data
public class Student &#123;
   private int id;
   private String name;
   private int tid;
&#125;

@Data
public class Teacher &#123;
   private int id;
   private String name;
   //一个老师多个学生
   private List&lt;Student&gt; students;
&#125;
</code></pre>
<h4 id="5-2-2、按结果嵌套"><a href="#5-2-2、按结果嵌套" class="headerlink" title="5.2.2、按结果嵌套"></a>5.2.2、按结果嵌套</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">//获取指定老师，及老师下的所有学生
public Teacher getTeacher(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

   &lt;!--
   思路:
       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名
       2. 对查询出来的操作做结果集映射
           1. 集合的话，使用collection！
               JavaType和ofType都是用来指定对象类型的
               JavaType是用来指定pojo中属性的类型
               ofType指定的是映射到list集合属性中pojo的类型。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
      select s.id sid, s.name sname , t.name tname, t.id tid
      from student s,teacher t
      where s.tid = t.id and t.id=#&#123;id&#125;
   &lt;/select&gt;

   &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
       &lt;result  property=&quot;name&quot; column=&quot;tname&quot;/&gt;
       &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
           &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;
           &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;
           &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;
       &lt;/collection&gt;
   &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<pre><code class="xml">&lt;mappers&gt;
   &lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<h4 id="5-2-3、按查询嵌套处理"><a href="#5-2-3、按查询嵌套处理" class="headerlink" title="5.2.3、按查询嵌套处理"></a>5.2.3、按查询嵌套处理</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">public Teacher getTeacher2(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;
    select * from teacher where id = #&#123;id&#125;
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher2()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher2(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、关联-association</p>
<p>2、集合-collection</p>
<p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p>
<p>4、JavaType和ofType都是用来指定对象类型的</p>
<ul>
<li>JavaType是用来指定pojo中属性的类型</li>
<li>ofType指定的是映射到list集合属性中pojo的类型。</li>
</ul>
<p><strong>注意说明：</strong></p>
<p>1、保证SQL的可读性，尽量通俗易懂</p>
<p>2、根据实际要求，尽量编写性能更高的SQL语句</p>
<p>3、注意属性名和字段不一致的问题</p>
<p>4、注意一对多和多对一 中：字段和属性对应的问题</p>
<p>5、尽量使用Log4j，通过日志来查看自己的错误</p>
<h2 id="六、动态SQL"><a href="#六、动态SQL" class="headerlink" title="六、动态SQL"></a>六、动态SQL</h2><h3 id="6-1、动态SQL简介"><a href="#6-1、动态SQL简介" class="headerlink" title="6.1、动态SQL简介"></a>6.1、动态SQL简介</h3><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p>
<pre><code>官网描述：
MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。
虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。
动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

  -------------------------------
  - if
  - choose (when, otherwise)
  - trim (where, set)
  - foreach
  -------------------------------
</code></pre>
<p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p>
<p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p>
<h3 id="6-2、搭建环境"><a href="#6-2、搭建环境" class="headerlink" title="6.2、搭建环境"></a>6.2、搭建环境</h3><h4 id="6-2-1、数据库"><a href="#6-2-1、数据库" class="headerlink" title="6.2.1、数据库"></a>6.2.1、数据库</h4><pre><code class="sql">CREATE TABLE `blog` (
`id` varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,
`author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
`create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
`views` int(30) NOT NULL COMMENT &#39;浏览量&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<h4 id="6-2-2、创建Mybaits基础工程"><a href="#6-2-2、创建Mybaits基础工程" class="headerlink" title="6.2.2、创建Mybaits基础工程"></a>6.2.2、创建Mybaits基础工程</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JISvrLfLvE3e9Wv1kpFL9qzPPOq4EuoibKKLvGve4vEicLpXeEHfz1flqX3ribyzpbjDlOGzziapTsIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、IDutil工具类</p>
<pre><code class="java">public class IDUtil &#123;

   public static String genId()&#123;
       return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);
  &#125;

&#125;
</code></pre>
<p>3、实体类编写  【注意set方法作用】</p>
<pre><code class="java">import java.util.Date;

public class Blog &#123;

   private String id;
   private String title;
   private String author;
   private Date createTime;
   private int views;
   //set，get....
&#125;
</code></pre>
<p>4、编写Mapper接口及xml文件</p>
<pre><code class="java">public interface BlogMapper &#123;
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<p>5、mybatis核心配置文件，下划线驼峰自动转换</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
&lt;!--注册Mapper.xml--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>6、插入初始数据</p>
<p>编写接口</p>
<pre><code class="java">//新增一个博客
int addBlog(Blog blog);
</code></pre>
<p>sql配置文件</p>
<pre><code class="xml">&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;
  insert into blog (id, title, author, create_time, views)
  values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);
&lt;/insert&gt;
</code></pre>
<p>初始化博客方法</p>
<pre><code class="java">@Test
public void addInitBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   Blog blog = new Blog();
   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Mybatis如此简单&quot;);
   blog.setAuthor(&quot;狂神说&quot;);
   blog.setCreateTime(new Date());
   blog.setViews(9999);

   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Java如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Spring如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;微服务如此简单&quot;);
   mapper.addBlog(blog);

   session.close();
&#125;
</code></pre>
<p>初始化数据完毕！</p>
<h3 id="6-3、if语句"><a href="#6-3、if语句" class="headerlink" title="6.3、if语句"></a>6.3、if语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p>
<p>1、编写接口类</p>
<pre><code class="java">//需求1
List&lt;Blog&gt; queryBlogIf(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询
select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;
--&gt;
&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog where
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogIf()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！</p>
<h3 id="6-4、Where语句"><a href="#6-4、Where语句" class="headerlink" title="6.4、Where语句"></a>6.4、Where语句</h3><p>修改上面的SQL语句；</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;if test=&quot;title != null&quot;&gt;
          title = #&#123;title&#125;
       &lt;/if&gt;
       &lt;if test=&quot;author != null&quot;&gt;
          and author = #&#123;author&#125;
       &lt;/if&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p>
<h3 id="6-5、Set语句"><a href="#6-5、Set语句" class="headerlink" title="6.5、Set语句"></a>6.5、Set语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p>
<p>1、编写接口方法</p>
<pre><code class="java">int updateBlog(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;!--注意set是用的逗号隔开--&gt;
&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;
  update blog
     &lt;set&gt;
         &lt;if test=&quot;title != null&quot;&gt;
            title = #&#123;title&#125;,
         &lt;/if&gt;
         &lt;if test=&quot;author != null&quot;&gt;
            author = #&#123;author&#125;
         &lt;/if&gt;
     &lt;/set&gt;
  where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;动态SQL&quot;);
   map.put(&quot;author&quot;,&quot;秦疆&quot;);
   map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);

   mapper.updateBlog(map);


   session.close();
&#125;
</code></pre>
<h3 id="6-6、choose语句"><a href="#6-6、choose语句" class="headerlink" title="6.6、choose语句"></a>6.6、choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>1、编写接口方法</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogChoose(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;choose&gt;
           &lt;when test=&quot;title != null&quot;&gt;
                title = #&#123;title&#125;
           &lt;/when&gt;
           &lt;when test=&quot;author != null&quot;&gt;
              and author = #&#123;author&#125;
           &lt;/when&gt;
           &lt;otherwise&gt;
              and views = #&#123;views&#125;
           &lt;/otherwise&gt;
       &lt;/choose&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void testQueryBlogChoose()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   map.put(&quot;views&quot;,9999);
   List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<h3 id="6-7、SQL片段"><a href="#6-7、SQL片段" class="headerlink" title="6.7、SQL片段"></a>6.7、SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p>
<p><strong>提取SQL片段：</strong></p>
<pre><code class="xml">&lt;sql id=&quot;if-title-author&quot;&gt;
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<p><strong>引用SQL片段：</strong></p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;
       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>注意：</p>
<p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p>
<p>②、在 sql 片段中不要包括 where</p>
<h3 id="6-8、Foreach"><a href="#6-8、Foreach" class="headerlink" title="6.8、Foreach"></a>6.8、Foreach</h3><p>将数据库中前三个数据的id修改为1,2,3；</p>
<p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p>
<p>1、编写接口</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogForeach(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!--
       collection:指定输入对象中的集合属性
       item:每次遍历生成的对象
       open:开始遍历时的拼接字符串
       close:结束时拼接的字符串
       separator:遍历对象之间需要拼接的字符串
       select * from blog where 1=1 and (id=1 or id=2 or id=3)
     --&gt;
       &lt;foreach collection=&quot;ids&quot;  item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
          id=#&#123;id&#125;
       &lt;/foreach&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogForeach()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap map = new HashMap();
   List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
   ids.add(1);
   ids.add(2);
   ids.add(3);
   map.put(&quot;ids&quot;,ids);

   List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。</p>
<h2 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h2><h3 id="7-1、缓存简介"><a href="#7-1、缓存简介" class="headerlink" title="7.1、缓存简介"></a>7.1、缓存简介</h3><h4 id="7-1-1、缓存"><a href="#7-1-1、缓存" class="headerlink" title="7.1.1、缓存"></a>7.1.1、缓存</h4><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
<h4 id="7-1-2、Mybaits缓存"><a href="#7-1-2、Mybaits缓存" class="headerlink" title="7.1.2、Mybaits缓存"></a>7.1.2、Mybaits缓存</h4><ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p>
</li>
<li><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="7-2、一级缓存"><a href="#7-2、一级缓存" class="headerlink" title="7.2、一级缓存"></a>7.2、一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<h4 id="7-2-1、测试"><a href="#7-2-1、测试" class="headerlink" title="7.2.1、测试"></a>7.2.1、测试</h4><p>1、在mybatis中加入日志，方便测试结果</p>
<p>2、编写接口方法</p>
<pre><code class="java">//根据id查询用户
User queryUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>3、接口对应的Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
  select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>5、结果分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="7-2-2、一级缓存失效情况"><a href="#7-2-2、一级缓存失效情况" class="headerlink" title="7.2.2、一级缓存失效情况"></a>7.2.2、一级缓存失效情况</h4><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
   session2.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！</p>
<p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(2);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！很正常的理解</p>
<p>结论：<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<pre><code class="java">//修改用户
int updateUser(Map map);
</code></pre>
<p>编写SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;
  update user set name = #&#123;name&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   HashMap map = new HashMap();
   map.put(&quot;name&quot;,&quot;kuangshen&quot;);
   map.put(&quot;id&quot;,4);
   mapper.updateUser(map);

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：查询在中间执行了增删改操作后，重新执行了</p>
<p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   session.clearCache();//手动清除缓存

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>一级缓存就是一个map</p>
<h3 id="7-3、二级缓存"><a href="#7-3、二级缓存" class="headerlink" title="7.3、二级缓存"></a>7.3、二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、开启全局缓存 【mybatis-config.xml】</p>
<pre><code class="xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<pre><code class="xml">&lt;cache/&gt;

官方示例=====&gt;查看官方文档
&lt;cache
 eviction=&quot;FIFO&quot;
 flushInterval=&quot;60000&quot;
 size=&quot;512&quot;
 readOnly=&quot;true&quot;/&gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
</code></pre>
<p>3、代码测试</p>
<ul>
<li>所有的实体类先实现序列化接口</li>
<li>测试代码</li>
</ul>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();

   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   session.close();

   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session2.close();
&#125;
</code></pre>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<h3 id="7-4、缓存原理图"><a href="#7-4、缓存原理图" class="headerlink" title="7.4、缓存原理图"></a>7.4、缓存原理图</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-5、EhCache"><a href="#7-5、EhCache" class="headerlink" title="7.5、EhCache"></a>7.5、EhCache</h3><p>第三方缓存实现–EhCache: 查看百度百科</p>
<p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p>
<p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
   &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在mapper.xml中使用对应的缓存即可</p>
<pre><code class="xml">&lt;mapper namespace = “org.acme.FooMapper” &gt;
   &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;
&lt;/mapper&gt;
</code></pre>
<p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&gt;
   &lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      user.home – 用户主目录
      user.dir – 用户当前工作目录
      java.io.tmpdir – 默认临时文件路径
    --&gt;
   &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
   
   &lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

   &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
   &lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
   &lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&gt;

&lt;/ehcache&gt;
</code></pre>
<p>合理的使用缓存，可以让我们程序的性能大大提升！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#ffa2c4>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/">
        <h2>
            Spring整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、Mybaits-Spring包"><a href="#一、Mybaits-Spring包" class="headerlink" title="一、Mybaits-Spring包"></a>一、Mybaits-Spring包</h2><p>MyBatis-Spring 会帮助我们将 MyBatis 代码无缝地整合到 Spring 中，MyBatis-Spring 需要以下版本：</p>
<pre><code class="java">| MyBatis-Spring | MyBatis | Spring 框架 | Spring Batch | Java   |
| -------------- | ------- | --------- | ------------ | ------- |
| 2.0            | 3.5+    | 5.0+      | 4.0+         | Java 8+ |
| 1.3            | 3.4+    | 3.2.2+    | 2.1+         | Java 6+ |
</code></pre>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        要和 Spring 一起使用 MyBatis，首先需要<code>SqlSessionFactory</code>，在MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>,配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>注</strong>：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 <code>DataSource</code>，只需要和配置其它 Spring 数据库连接一样配置它就可以了</p>
<p><strong><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。</strong></p>
<p>作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。<code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
<p>可以使用 <code>SqlSessionFactory</code> 作为构造方法的参数来创建 <code>SqlSessionTemplate</code> 对象。</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样:</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
  private SqlSession sqlSession;
  public void setSqlSession(SqlSession sqlSession) &#123;
    this.sqlSession = sqlSession;
  &#125;
  public User getUser(String userId) &#123;
    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);
  &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;
  &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="二、Spring整个Mybaits"><a href="#二、Spring整个Mybaits" class="headerlink" title="二、Spring整个Mybaits"></a>二、Spring整个Mybaits</h2><h3 id="2-1、user数据表："><a href="#2-1、user数据表：" class="headerlink" title="2.1、user数据表："></a>2.1、<strong>user数据表：</strong></h3><pre><code class="sql">CREATE TABLE user(
    id INT NOT NULL,
    &#39;name&#39; VARCHAR(20) NOT NULL,
    &#39;pwd&#39; VARCHAR(20) NOT NULL,
    PRIMARY KEY(id)
)ENGINE=InnoDB DEFAULT CHARSET=utf-8; 
</code></pre>
<h3 id="2-2、实体类"><a href="#2-2、实体类" class="headerlink" title="2.2、实体类"></a>2.2、<strong>实体类</strong></h3><pre><code class="java">@Data
@ALLArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
<h3 id="2-3、导包"><a href="#2-3、导包" class="headerlink" title="2.3、导包"></a>2.3、<strong>导包</strong></h3><ul>
<li>mybatis-spring整合包 【最重要】</li>
<li>mybaits</li>
<li>mysql驱动的</li>
<li>junit</li>
<li>spring-core</li>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-jdbc 【数据源】</li>
<li>spring-tx 【事务】</li>
<li>…</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--mybaits--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--mysql连接驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.9&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"><a href="#2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件" class="headerlink" title="2.4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"></a>2.4、<strong>配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.westos.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/westos/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="2-5、编写Spring配置文件"><a href="#2-5、编写Spring配置文件" class="headerlink" title="2.5、编写Spring配置文件"></a>2.5、<strong>编写Spring配置文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!--1.配置数据源,我们使用的是spring的数据源，还可以使用第三方的数据源
        dbcp,c3p0
        com.mchange.v2.c3p0.ComboPooledDataSource
        org.apache.commons.dbcp.BasicDataSource
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--2.配置SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--关联mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--3.创建selSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="2-6、接口实现类增加一个属性：sqlSession"><a href="#2-6、接口实现类增加一个属性：sqlSession" class="headerlink" title="2.6、接口实现类增加一个属性：sqlSession"></a>2.6、<strong>接口实现类增加一个属性：sqlSession</strong></h3><pre><code class="java">import org.apache.ibatis.session.SqlSession;
import org.westos.pojo.User;
import java.util.List;

public class UserMapperImpl implements UserMapper &#123;
    private SqlSession sqlSession;
    public void setSqlSession(SqlSession sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;
    public List&lt;User&gt; getUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
    &#125;
&#125;
</code></pre>
<h3 id="2-7、将接口的实现类交给spring来管理"><a href="#2-7、将接口的实现类交给spring来管理" class="headerlink" title="2.7、将接口的实现类交给spring来管理"></a>2.7、<strong>将接口的实现类交给spring来管理</strong></h3><pre><code class="xml">&lt;!--4.接口实现类注入sqlSession--&gt;
&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.westos.dao.UserMapperImpl&quot;&gt;
   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2-8、测试类"><a href="#2-8、测试类" class="headerlink" title="2.8、测试类"></a>2.8、<strong>测试类</strong></h3><pre><code class="java">import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.westos.pojo.User;
import java.util.List;

public class TestUserMapper &#123;
    
    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapperImpl userMapperImpl = (UserMapperImpl) context.getBean(&quot;UserMapperImpl&quot;);
        List&lt;User&gt; users = userMapperImpl.getUser();
        for (User user : users) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="三、整合Druid并开启监控"><a href="#三、整合Druid并开启监控" class="headerlink" title="三、整合Druid并开启监控"></a>三、整合Druid并开启监控</h2><h3 id="3-1、整合Druid"><a href="#3-1、整合Druid" class="headerlink" title="3.1、整合Druid"></a>3.1、整合Druid</h3><h4 id="3-1-1-导入starter"><a href="#3-1-1-导入starter" class="headerlink" title="3.1.1 导入starter"></a>3.1.1 导入starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.1.2、配置yaml</p>
<pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    type: com.alibaba.druid.pool.DruidDataSource
    
    #连接池配置(可选)
    # 连接池的配置信息初始化大小，最小，最大
    name: testDruidDataSource
    initial-size: 5    #初始化连接大小
    max-active: 20    #最大连接数
    min-idle: 5        #最小空闲连接数
    max-wait: 60000   # 配置获取连接等待超时的时间
    
    #######监控配置  说明请参考Druid Wiki
    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙
    filters: stat,wall
    #配置 Web Stat Filter
    web-stat-filter:
      enabled: true
      url-pattern: /*
      exclusions: /druid/*,*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico
      session-stat-enable: true
      session-stat-max-count: 10
      principal-session-name: session_name
      principal-cookie-name: cookie_name
      profile-enable:
      
    # Stat View Servlet 配置  配置默认false
    stat-view-servlet:
      enabled: true
      url-pattern: /druid/*
      reset-enable: false   #禁用HTML页面上的“Reset All”功能
      login-username: admin  #监控页面登录的用户名
      login-password: 123  #监控页面登录的密码
      #IP白名单(没有配置或者为空，则允许所有访问)
      allow:
      #IP黑名单 (存在共同时，deny优先于allow)
      deny:
</code></pre>
<p><strong>由于springboot默认的是hikari，号称最快的数据源，这里我们换成了阿里巴巴的数据源，druid最强大的则是监控功能</strong></p>
<pre><code class="java">class com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper
com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@3f866f50
</code></pre>
<h3 id="3-2、整合Mybaits"><a href="#3-2、整合Mybaits" class="headerlink" title="3.2、整合Mybaits"></a>3.2、整合Mybaits</h3><h4 id="3-2-1、导包"><a href="#3-2-1、导包" class="headerlink" title="3.2.1、导包"></a>3.2.1、导包</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="3-2-2、实体类"><a href="#3-2-2、实体类" class="headerlink" title="3.2.2、实体类"></a>3.2.2、实体类</h4><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student &#123;
    private int id;
    private String name;
    private int tid;
&#125;
</code></pre>
<h4 id="3-2-3、StudentMapper"><a href="#3-2-3、StudentMapper" class="headerlink" title="3.2.3、StudentMapper"></a>3.2.3、StudentMapper</h4><pre><code class="java">@Mapper
@Repository
public interface StudentMapper &#123;
     List&lt;Student&gt; selectAllStudent();
&#125;
</code></pre>
<h4 id="3-2-4、StudentMapper-xml"><a href="#3-2-4、StudentMapper-xml" class="headerlink" title="3.2.4、StudentMapper .xml"></a>3.2.4、StudentMapper .xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.kexing.mapper.StudentMapper&quot;&gt;
    &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt;
        select * from student
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="3-2-5、配置数据源、实体别名、mapper地址"><a href="#3-2-5、配置数据源、实体别名、mapper地址" class="headerlink" title="3.2.5、配置数据源、实体别名、mapper地址"></a>3.2.5、配置数据源、实体别名、mapper地址</h4><pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    
mybatis:
  type-aliases-package: site.kexing.pojo
  mapper-locations: classpath:mapper/*.xml
</code></pre>
<h4 id="3-2-6、测试输出"><a href="#3-2-6、测试输出" class="headerlink" title="3.2.6、测试输出"></a>3.2.6、测试输出</h4><pre><code class="java">@RestController
public class StudentController &#123;
    @Autowired
    StudentMapper studentMapper;
    @RequestMapping(&quot;/selectall&quot;)
    public List&lt;Student&gt; selectAllStudent()&#123;
        List&lt;Student&gt; students = studentMapper.selectAllStudent();
        return students;
    &#125;
&#125;
</code></pre>
<pre><code class="java">[&#123;
    &quot;id&quot;:1,&quot;name&quot;:&quot;小明&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:2,&quot;name&quot;:&quot;小红&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:3,&quot;name&quot;:&quot;小张&quot;,&quot;tid&quot;:2&#125;,&#123;
    &quot;id&quot;:4,&quot;name&quot;:&quot;小李&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:5,&quot;name&quot;:&quot;旺旺&quot;,&quot;tid&quot;:1&#125;]
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#1bccbc>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/">
        <h2>
            SSM整合
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SSM整合笔记"><a href="#SSM整合笔记" class="headerlink" title="SSM整合笔记"></a>SSM整合笔记</h1><h2 id="一、数据库环境"><a href="#一、数据库环境" class="headerlink" title="一、数据库环境"></a>一、数据库环境</h2><h3 id="1-1、创建数据库及数据表"><a href="#1-1、创建数据库及数据表" class="headerlink" title="1.1、创建数据库及数据表"></a>1.1、创建数据库及数据表</h3><pre><code class="sql">CREATE TABLE `books`(    
    `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,    
    `bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;, 
    `bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,    
    `detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,   
    KEY `bookId` (`bookId`)
) ENGINE=INNODB DEFAULT CHARSET=utf8; 

INSERT INTO books(`bookId`,`bookName`,`bookCounts`,`detail`) 
    VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;), (2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;), (3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);
</code></pre>
<h2 id="二、导入依赖"><a href="#二、导入依赖" class="headerlink" title="二、导入依赖"></a>二、导入依赖</h2><h3 id="2-1、导入jar包"><a href="#2-1、导入jar包" class="headerlink" title="2.1、导入jar包"></a>2.1、导入jar包</h3><p>​        创建一个maven工程，导入依赖和静态资源处理的配置。</p>
<pre><code class="xml">&lt;dependencies&gt;
    
    &lt;!--Junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--数据库驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.35&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--连接池--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--servlet--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jsp--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--JSTL--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--mybatis-spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jdbc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--静态资源导出问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="2-2、建包："><a href="#2-2、建包：" class="headerlink" title="2.2、建包："></a>2.2、建包：</h3><p>​        连接数据库；    </p>
<p>​        在src/main/java下创建pojo、service、controller、dao、util。</p>
<p>​        在resource文件夹下创建mybatis-config.xml、applicationContext.xml、database.properties。</p>
<h3 id="2-3、修改resource下的配置文件："><a href="#2-3、修改resource下的配置文件：" class="headerlink" title="2.3、修改resource下的配置文件："></a>2.3、修改resource下的配置文件：</h3><h4 id="2-3-1、mybatis-config-xml"><a href="#2-3-1、mybatis-config-xml" class="headerlink" title="2.3.1、mybatis-config.xml"></a>2.3.1、mybatis-config.xml</h4><p>​        关联数据库文件源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--
        数据源配置交给spring做
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.example.pojo&quot;/&gt;
        &lt;/typeAliases&gt;
    --&gt;
    
    &lt;!--写一些mapper配置文件的注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<p>​        编写pojo文件夹下的实体类：Books；</p>
<p>​        编写dao文件夹下的接口：BookMapper；</p>
<p>​        编写BookMapper.xml</p>
<h4 id="2-3-2、applicationContext-xml"><a href="#2-3-2、applicationContext-xml" class="headerlink" title="2.3.2、applicationContext.xml"></a>2.3.2、applicationContext.xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--将其他三层的spring配置文件合在一起即可--&gt;
    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="2-3-3、database-properties"><a href="#2-3-3、database-properties" class="headerlink" title="2.3.3、database.properties"></a>2.3.3、database.properties</h4><p>​        数据库的配置文件    </p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
# 如果使用MySQL8.0，还需要增加一个时区的配置 &amp;serverTimezone=Asia/Shanghai
jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=123456
</code></pre>
<h2 id="三、Mybatis层的配置："><a href="#三、Mybatis层的配置：" class="headerlink" title="三、Mybatis层的配置："></a>三、Mybatis层的配置：</h2><h3 id="3-1、创建pojo对象"><a href="#3-1、创建pojo对象" class="headerlink" title="3.1、创建pojo对象"></a>3.1、创建pojo对象</h3><p>​    采用lombok依赖对这个pojo生成get、set方法等一系列方法。</p>
<pre><code class="xml">&lt;!--lombok--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    
    &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@Data       //get、set等方法
@AllArgsConstructor     //有参构造
@NoArgsConstructor      //无参构造
public class Book &#123;
    private Integer bookId;
    private String bookName;
    private Integer bookCounts;
    private String detail;
&#125;
</code></pre>
<h3 id="3-2、创建dao接口。"><a href="#3-2、创建dao接口。" class="headerlink" title="3.2、创建dao接口。"></a>3.2、创建dao接口。</h3><pre><code class="java">public interface BookMapper &#123;
    int addBook(Book book);
    int deleteBookById(@Param(&quot;id&quot;) Integer id);
    int updateBook(Book book);
    Book queryBookById(@Param(&quot;id&quot;) Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<h3 id="3-3、创建mapper配置文件"><a href="#3-3、创建mapper配置文件" class="headerlink" title="3.3、创建mapper配置文件"></a>3.3、创建mapper配置文件</h3><p>​        并在全局配置中进行注册</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.example.pojo.Book&quot;&gt;
        insert into books(`bookName`,`bookCounts`,`detail`) values
        (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;details&#125;)
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot;&gt;
        delete from books where bookId = #&#123;id&#125;
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot;&gt;
        update books set `bookName` = #&#123;bookName&#125;,`bookCounts` = #&#123;bookCounts&#125;,
        `detail` = #&#123;detail&#125; where `bookId` = #&#123;bookId&#125;
    &lt;/update&gt;

    &lt;select id=&quot;queryBookById&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books where `bookId` = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBooks&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="3-4、创建service业务。"><a href="#3-4、创建service业务。" class="headerlink" title="3.4、创建service业务。"></a>3.4、创建service业务。</h3><pre><code class="java">public interface BookService &#123;
    int addBook(Book book);
    int deleteBookById(Integer id);
    int updateBook(Book book);
    Book queryBookById(Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<pre><code class="java">public class BookServiceImpl implements BookService&#123;
    // 之后用spring自动注入
    // service调dao层：组合Dao
    private BookMapper bookMapper;
    
    @Override
    public int addBook(Book book) &#123;
        return bookMapper.addBook(book);
    &#125;
    @Override
    public int deleteBookById(Integer id) &#123;
        return bookMapper.deleteBookById(id);
    &#125;
    @Override
    public int updateBook(Book book) &#123;
        return bookMapper.updateBook(book);
    &#125;
    @Override
    public Book queryBookById(Integer id) &#123;
        return bookMapper.queryBookById(id);
    &#125;
    @Override
    public List&lt;Book&gt; queryAllBooks() &#123;
        return bookMapper.queryAllBooks();
    &#125;
&#125;
</code></pre>
<h2 id="四、Spring层的配置："><a href="#四、Spring层的配置：" class="headerlink" title="四、Spring层的配置："></a>四、Spring层的配置：</h2><h3 id="4-1、创建一个新的spring配置文件去整合dao层"><a href="#4-1、创建一个新的spring配置文件去整合dao层" class="headerlink" title="4.1、创建一个新的spring配置文件去整合dao层"></a>4.1、创建一个新的spring配置文件去整合dao层</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--关联数据库配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
    
    &lt;!--连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--绑定数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--绑定mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--配置dao接口扫描包，可以将dao接口注入到spring的容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描dao包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.example.dao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="4-2、创建一个新的spring配置文件去整合service层。"><a href="#4-2、创建一个新的spring配置文件去整合service层。" class="headerlink" title="4.2、创建一个新的spring配置文件去整合service层。"></a>4.2、创建一个新的spring配置文件去整合service层。</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service包--&gt;
    &lt;context:component-scan base-package=&quot;com.example.service&quot;/&gt;

    &lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--aop事务支持--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.example.dao.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="五、springMVC层配置："><a href="#五、springMVC层配置：" class="headerlink" title="五、springMVC层配置："></a>五、springMVC层配置：</h2><h3 id="5-1、添加web支持，创建web-xml"><a href="#5-1、添加web支持，创建web-xml" class="headerlink" title="5.1、添加web支持，创建web.xml"></a>5.1、添加web支持，创建web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    
    &lt;!--配置前端处理器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--绑定的是spring的全局配置文件--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;!--
            /  :
            /* :会过滤到jsp等资源
        --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;!--配置乱码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!--配置session--&gt;
    &lt;session-config&gt;
        &lt;!--配置session超时时间--&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="5-2、创建spring的mvc配置文件"><a href="#5-2、创建spring的mvc配置文件" class="headerlink" title="5.2、创建spring的mvc配置文件"></a>5.2、创建spring的mvc配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--注解驱动--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--扫描controller--&gt;
    &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt;
    &lt;!--视图解析器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="5-3、在WEB-INF下创建jsp目录。"><a href="#5-3、在WEB-INF下创建jsp目录。" class="headerlink" title="5.3、在WEB-INF下创建jsp目录。"></a>5.3、在WEB-INF下创建jsp目录。</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#1bccbc>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/">
        <h2>
            Spring整合Log4j
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Sping整合Log4j"><a href="#Sping整合Log4j" class="headerlink" title="Sping整合Log4j"></a>Sping整合Log4j</h1><h2 id="一、log4j日志简介"><a href="#一、log4j日志简介" class="headerlink" title="一、log4j日志简介"></a>一、log4j日志简介</h2><p>​        Log4j是Apache的一个开放源代码项目，通过使用Log4j，控制日志信息输送的目的地可以为控制台、文件、数据库、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；可以控制每一条日志的信息内容和信息输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；甚至还可以在不需要修改业务逻辑代码、重启web服务，只需要通过一个修改配置文件就可以实现控制项目的日志动作。</p>
<p>​        Log4j由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p>
<h2 id="二、定义配置文件"><a href="#二、定义配置文件" class="headerlink" title="二、定义配置文件"></a>二、定义配置文件</h2><p>​        其实您也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件（键=值）。下面我们介绍使用Java特性文件做为配置文件的方法：</p>
<h3 id="2-1、配置根Logger"><a href="#2-1、配置根Logger" class="headerlink" title="2.1、配置根Logger"></a>2.1、配置根Logger</h3><pre><code class="java">log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre>
<p>​        其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p>
<p>eg：</p>
<pre><code class="properties">### set log levels ###  
log4j.rootLogger = debug,stdout,D,E  
 
log4j.appender.stdout = org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.Target = System.out  
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout  
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  
 
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.D.File = F://logs/log.log  
log4j.appender.D.Append = true  
log4j.appender.D.Threshold = DEBUG   
log4j.appender.D.layout = org.apache.log4j.PatternLayout  
log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n  
 
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.E.File =F://logs/error.log   
log4j.appender.E.Append = true  
log4j.appender.E.Threshold = ERROR   
log4j.appender.E.layout = org.apache.log4j.PatternLayout  
log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n
</code></pre>
<h3 id="2-2、配置日志信息输出目的地Appender"><a href="#2-2、配置日志信息输出目的地Appender" class="headerlink" title="2.2、配置日志信息输出目的地Appender"></a>2.2、配置日志信息输出目的地Appender</h3><pre><code class="properties">log4j.appender.appenderName = fully.qualified.name.of.appender.class
 
log4j.appender.appenderName.option1 = value1
 
…
 
log4j.appender.appenderName.option = valueN
</code></pre>
<p>​        其中，Log4j提供的appender有以下几种：</p>
<pre><code class="properties">org.apache.log4j.ConsoleAppender（控制台），
 
org.apache.log4j.FileAppender（文件），
 
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），
 
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
 
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre>
<h3 id="2-3、配置日志信息的格式（布局）"><a href="#2-3、配置日志信息的格式（布局）" class="headerlink" title="2.3、配置日志信息的格式（布局）"></a>2.3、配置日志信息的格式（布局）</h3><pre><code class="properties">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
 
log4j.appender.appenderName.layout.option1 = value1
 
…
 
log4j.appender.appenderName.layout.option = valueN
</code></pre>
<p>​        其中，Log4j提供的layout有以e几种：</p>
<pre><code class="css">org.apache.log4j.HTMLLayout（以HTML表格形式布局），
 
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
 
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
 
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre>
<p>​        Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息</p>
<pre><code class="properties">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  
%r 输出自应用启动到输出该log信息耗费的毫秒数  
%c 输出所属的类目，通常就是所在类的全名  
%t 输出产生该日志事件的线程名  
%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  
%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  
%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)
</code></pre>
<p>首先，日志的级别有：OFF 、FATAL 、ERROR、WARN、INFO、DEBUG、TRACE 、ALL 等等。</p>
<ul>
<li><p>OFF：关闭了日志信息  </p>
</li>
<li><p>FATAL：可能导致应用中止的严重事件错误  </p>
</li>
<li><p>ERROR：严重错误 主要是程序的错误  </p>
</li>
<li><p>WARN：一般警告，比如session丢失  </p>
</li>
<li><p>INFO：一般要显示的信息，比如登录登出  </p>
</li>
<li><p>DEBUG：程序的调试信息  </p>
</li>
<li><p>TRACE：比DEBUG更细粒度的事件信息  </p>
</li>
<li><p>ALL：打开所有级别的日志</p>
</li>
</ul>
<p>log4j提供了一系列的Appender，允许将日志输送到不同的地方，如控制台、文件、数据库等：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.jdbc.JDBCAppender（数据库）</li>
<li>org.apache.log4j.net.SMTPAppender（邮件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h2 id="三、Spring框架整合log4j"><a href="#三、Spring框架整合log4j" class="headerlink" title="三、Spring框架整合log4j"></a>三、Spring框架整合log4j</h2><h3 id="3-1、pom-xml-引入log4j组件依赖包："><a href="#3-1、pom-xml-引入log4j组件依赖包：" class="headerlink" title="3.1、pom.xml 引入log4j组件依赖包："></a>3.1、pom.xml 引入log4j组件依赖包：</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："><a href="#3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：" class="headerlink" title="3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："></a>3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：</h3><pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:conf/log4j.properties&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;!-- 5000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; 
&lt;context-param&gt;
      &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;
      &lt;param-value&gt;5000&lt;/param-value&gt;
&lt;/context-param&gt;
 
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>​        首先是这个关于JavaWeb的工程的总配置位置。我们要在里面声明要使用Spring与Log4j。值得注意的Log4j的配置必须在Spring配置之前，否则如果先启动Spring，那个必须整合Log4j才不吐警告的Spring，由于Log4j还没有启动，找不到Spring，又会在任性地吐警告。当然，你设置那些什么优先级也行，不过，先启动的直接放前面，这个文件不是更好看吗？</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
    version=&quot;3.0&quot;&gt;
    &lt;!-- Log4j配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!-- 指定Log4j的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
    
    &lt;!-- Spring配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    
&lt;/web-app&gt;  
</code></pre>
<p>​        这里，我将log4j.properties配置文件存放到classpath的conf目录下，并启动一个watchdog线程每5秒扫描配置文件的变化，重新调整日志的策略，实现在不调整逻辑代码即可实现日志的策略变更。通过log4j.properties详细配置了日志的策略，如下：</p>
<pre><code class="properties"># +======================================================================+#
log4j.rootLogger=$&#123;log4j.log.level&#125;,$&#123;log4j.log.target&#125;
log4j.addivity.org.apache=true
# +======================================================================+#
# | [target] - Console
# +----------------------------------------------------------------------+#
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.CONSOLE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.CONSOLE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - FILE
# +----------------------------------------------------------------------+#
log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.FILE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.FILE.File=$&#123;log4j.log.dir&#125;/runtime.log
log4j.appender.FILE.Append=true
log4j.appender.FILE.MaxFileSize=2048KB
log4j.appender.FILE.MaxBackupIndex=10
log4j.appender.FILE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.FILE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - DATABASE
# +----------------------------------------------------------------------+#
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.DATABASE.Threshold=ERROR
log4j.appender.DATABASE.URL=jdbc:mysql://127.0.0.1:3306/spring
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver
log4j.appender.DATABASE.user=root
log4j.appender.DATABASE.password=liuriqi
log4j.appender.DATABASE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.DATABASE.sql=INSERT INTO tv_log4j(message)VALUES(&#39;$&#123;log4j.log.layout.pattern&#125;&#39;)
# +======================================================================+#
# | [target] - EMAIL
# +----------------------------------------------------------------------+#
log4j.appender.EMAIL=org.apache.log4j.net.SMTPAppender
log4j.appender.EMAIL.Threshold=FATAL
log4j.appender.EMAIL.BufferSize=10
log4j.appender.EMAIL.From=fromuser@gmail.com
log4j.appender.EMAIL.SMTPHost=localhost
log4j.appender.EMAIL.Subject=Log4J Message
log4j.appender.EMAIL.To=touser@gmail.com
log4j.appender.EMAIL.layout=$&#123;log4j.log.layout&#125;
log4j.appender.EMAIL.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
上面配置相关的变量，我提取出来统一放到变量配置文件里边，如下：
 
# +======================================================================+#
# | log4j config
# +----------------------------------------------------------------------+#
log4j.log.dir=logs/
#log4j.log.level=ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF
log4j.log.level=DEBUG
#log4j.log.target=CONSOLE,FILE,DATABASE,EMAIL,SOCKET
log4j.log.target=CONSOLE,FILE
log4j.log.encoding=UTF-8
log4j.log.layout=org.apache.log4j.PatternLayout
log4j.log.layout.pattern=[%d %r] [%-5p] [%t] [%l] [%m]%n
# +======================================================================+#
</code></pre>
<p>​        通过以上配置，在项目启动的时候，会将DEBUG日志信息发送到控制台和文件日志中。</p>
<p>​        另一种配置方式：</p>
<pre><code class="properties">#log4j.rootLogger = [ level ] , appenderName, appenderName, ...
log4j.rootLogger = all, console, R

#Console
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] %m%n

#File
log4j.appender.R = org.apache.log4j.RollingFileAppender
log4j.appender.R.File = c:/log.txt
log4j.appender.R.MaxFileSize = 500KB
log4j.appender.R.MaxBackupIndex = 1
log4j.appender.R.layout = org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] - %m%n
</code></pre>
<p>​        首先第一部分是log4j的总配置部分，all代表debug,info,error,fatal四种类型的信息都会输出。一般不设置为all。因为那些debug,info信息对我们半点意义没有，还因为有很多系统内部的文件运行都会输出debug与info信息刷屏、刷版。关键是输出到磁盘的日志文件会极速递增，浪费磁盘空间。玩SQL Server的时候大家又不知道那个.ldb是多么恐怖？</p>
<p>​        因此第一部分，一般写成：</p>
<pre><code class="properties">log4j.rootLogger = ERROR, console, R
</code></pre>
<p>​        代表仅输出error与fatal错误。<br>​        之后的console，R分别代表在控制台与文件输出。同时在之后的代码必须配置好这个两输出。</p>
<p>​        第二部分控制台#Console<br>​        首先要使用log4j特定的包，这个没有什么好说，最后一句指明输出格式。一会儿大招对照输出结果就明白怎么回事了。</p>
<p>​        第三部分文件#File</p>
<p>​        log4j.appender.R.File=c:/log.txt是指这个Web工程错误日志皆输出到c:/log.txt。不要像网上那些大神输出一个什么.log后缀，关键是能够直接打开。</p>
<p>​        之后log4j.appender.R.MaxFileSize = 500KB指明这个log.txt文件大小最多为500KB，如果超过这个大小，自动开一个新文件，而log4j.appender.R.MaxBackupIndex=1指明此工程顶多只能有1个这个的日志文件。注：新内容覆盖旧内容。</p>
<p>​        最后，可以在应用程序中采用log4j自带的debug()、info()、warn()、error()方法来记录你想要记录的操作，至于如何存储日志及日志的目的地发送的工作就交给log4j好了。</p>
<p>​        最后一点说明的问题：配置较低级别的错误日志策略会记录高级的错误信息，配置高级的错误日志策略会忽略低级错误信息。如将错误日志的level配置为debug，则log4j组件会记录包含debug以上所有的级别日志如debug、info、warn、error、fatal等。加入你配置的为error级别，则不会记录error以下级别的日志信息如debug、info、warn等等。</p>
<pre><code class="java">import org.apache.log4j.Logger;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
public class Log4jTest &#123;
     private static Logger logger =Logger.getLogger(Log4jTest.class);
     
     @RequestMapping(&quot;/log&quot;)
     public void writeLog() &#123;
            // 记录debug级别的信息    
            logger.debug(&quot;This is debug message.&quot;);    
            // 记录info级别的信息    
            logger.info(&quot;This is info message.&quot;);    
            // 记录error级别的信息    
            logger.error(&quot;This is error message.&quot;); 
     &#125;
     
&#125;
</code></pre>
<h2 id="四、Spring整合log4j2"><a href="#四、Spring整合log4j2" class="headerlink" title="四、Spring整合log4j2"></a>四、Spring整合log4j2</h2><p>4.1、pom.xml文件</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;!-- something --&gt;
 
        &lt;!-- log配置 --&gt;
        &lt;!-- 排除springboot原有的log依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 添加log4j2依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>4.2、log4j2.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 
&lt;!-- 日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL --&gt;
&lt;!-- status：设置log4j2本身的日志信息打印级别，可以不设置。当设置为info及以下级别时，在更改当前log4j2.xml文件后，自动检测功能发现xml文件有更改，将会打印更改日志，可以在console中看到。因此该status是log4j2.xml文件的日志设置。 --&gt;
&lt;!-- monitorInterval：设置间隔时间，单位为秒。Log4j2能够自动检测修改，并在monitorInterval设定的时间周期重新加载配置，无需重启应用 --&gt;
&lt;configuration status=&quot;info&quot; monitorInterval=&quot;5&quot;&gt;
    &lt;!-- 自定义属性 --&gt;
    &lt;Properties&gt;
        &lt;!-- 缺省配置（用于开发环境），配置日志文件输出目录和动态参数。其他环境需要在VM参数中指定； --&gt;
        &lt;!-- “sys:”表示：如果VM参数中没指定这个变量值，则使用本文件中定义的缺省全局变量值 --&gt;
        &lt;Property name=&quot;instance&quot;&gt;spring-boot-demo-log4j2&lt;/Property&gt;
        &lt;Property name=&quot;log.dir&quot;&gt;D:\log4j2&lt;/Property&gt;
    &lt;/Properties&gt;
    
    &lt;!-- 定义所有的appender --&gt;
    &lt;Appenders&gt;
        &lt;!--这个是输出控制台的配置--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT --&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!--输出日志的格式--&gt;
            &lt;!-- PatternLayout:输出格式，不设置默认为:%m%n --&gt;
            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%level] [%l] - %message%n&quot;/&gt;
            
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;accept&quot; onMismatch=&quot;deny&quot;/&gt;
            &lt;/Filters&gt;
        &lt;/Console&gt;
        
        &lt;!-- info及以上级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- fileName:指定输出日志的目的文件带全路径的文件名 --&gt;
        &lt;!-- filePattern:指定新建日志文件的名称格式 --&gt;
        &lt;RollingRandomAccessFile name=&quot;infoLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-info.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            
            &lt;!-- PatternLayout:日志输出格式，不设置默认为:%m%n --&gt;
            &lt;!-- &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%level][%class][%line]:%message%n&quot;/&gt; --&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;!-- 过滤器 --&gt;
            &lt;!-- 注意，这里要做一些特点说明： --&gt;
            &lt;!-- 等级大小关系为：OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL。 --&gt;
            &lt;!-- 在ThresholdFilter配置中，level属性是用来标识“匹配范围”的，且“被匹配（onMatch）范围”为该level及其以上的等级（例如level=&quot;WARN&quot;，那么onMatch范围为“OFF,FATAL,ERROR,WARN”），而“未匹配（onMismatch）范围”为所匹配途中剩下未被匹配的范围（例如level=&quot;WARN&quot;，那么onMismatch范围为“INFO,DEBUG,TRACE,ALL”）。 --&gt;
            &lt;!-- 需要注意，如果在一个&lt;Filters&gt;里面有多个&lt;ThresholdFilter&gt;，那么这些&lt;ThresholdFilter&gt;的书写是有上下关系的。 --&gt;
            &lt;!-- 写在上面的&lt;ThresholdFilter&gt;将通过level属性确定了已经匹配过的范围，那么，写在下面的&lt;ThresholdFilter&gt;的level必须在未被匹配的范围内选择，否则将无法生效（例如第一个&lt;ThresholdFilter&gt;中的level=&quot;WARN&quot;，那么第二个&lt;ThresholdFilter&gt;中的level属性值只能在“INFO、DEBUG、TRACE、ALL”里面选择）。 --&gt;
            &lt;!-- 因此，我们做一个规定： --&gt;
            &lt;!-- 在一个含有多个&lt;ThresholdFilter&gt;的&lt;Filters&gt;里面，在从上到下的&lt;ThresholdFilter&gt;列表顺序中，每一个&lt;ThresholdFilter&gt;中的level属性值我们规定必须由高等级至低等级填写。 --&gt;
            &lt;!-- 例如： --&gt;
            &lt;!-- 
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;XXX&quot;/&gt;
            --&gt;
            &lt;Filters&gt;
                &lt;!-- onMatch=&quot;ACCEPT&quot; 表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;DENY&quot; 表示拒绝该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;NEUTRAL&quot; 表示中立，该级别及以上的日志的onMatch通过性，将由下一个ThresholdFilter的onMatch属性处理，如果当前ThresholdFilter是最后一个，则表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMismatch=&quot;ACCEPT&quot; 表示允许该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;DENY&quot; 表示拒绝该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;NEUTRAL&quot; 表示中立，该级别以下的日志的onMismatch通过性，将由下一个ThresholdFilter的onMismatch属性处理，如果当前是最后一个，则允许该级别以下的日志--&gt;
                &lt;!-- level属性缺省，默认为level=&quot;ERROR&quot;，注意：缺省意思是没有该属性，而非level=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMatch属性缺省，默认为onMatch=&quot;accept&quot;，注意：缺省意思是没有该属性，而非onMatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMismatch属性缺省，默认为onMismatch=&quot;deny&quot;，注意：缺省意思是没有该属性，而非onMismatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;!-- Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 --&gt;
            &lt;Policies&gt;
                &lt;!-- 基于时间的滚动策略 --&gt;
                &lt;!-- interval：表示历史日志封存间隔时间，单位为hour，默认是1 --&gt;
                &lt;!-- modulate：表示是否历史日志生成时间纠偏，纠偏以零点为基准进行。比如：17:30生成了$&#123;instance&#125;-info-2019032817.log.gz文件，那么纠偏后会在18:00生成$&#123;instance&#125;-info-2019032818.log.gz --&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;!-- 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小 --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
            
            &lt;!-- DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个(通过max属性定义)日志文件时开始删除最旧的，创建新的 --&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot;&gt;
                &lt;Delete basePath=&quot;$&#123;log.dir&#125;&quot; maxDepth=&quot;1&quot;&gt;
                    &lt;IfFileName glob=&quot;*.log.gz&quot; /&gt;
                    &lt;!-- 小时：H，天：d --&gt;
                    &lt;IfLastModified age=&quot;5d&quot; /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
 
        &lt;!-- warn级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;warnLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-warn.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- error级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;errorLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-error.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- 测试日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;testLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-test.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-test-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;deny&quot; onMismatch=&quot;accept&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
    &lt;/Appenders&gt;
    
    &lt;!-- 用来配置Logger，包含一个root和若干个logger --&gt;
    &lt;!-- additivity指定是否同时输出当前logger的父类的日志，缺省为true --&gt;
    &lt;!-- 一个logger可以绑定多个不同的Appender。只有定义了logger并通过AppenderRef引入appender，该appender才会生效 --&gt;
    &lt;!-- &lt;logger&gt;可以不配置&lt;AppenderRef&gt;，这样可以控制指定的包在控制台的日志打印，而无需考虑日志文件的存储问题 --&gt;
    &lt;!--     （等效于在application.properties文件配置logging.level.xxx=LEVEL，xxx代指包名，如org.apache.kafka，LEVEL代指日志基本，如error等） --&gt;
    &lt;!--     （例如要屏蔽org.apache.kafka包下的所用日志打印，则可以这样写logging.level.org.apache.kafka=off） --&gt;
    &lt;Loggers&gt;
        &lt;!-- Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 --&gt;
        &lt;!-- additivity：这个属性的意思是需不需要打印此logger继承的父logger，默认为true，如果是false则只打印当前logger；如果是true则继续打印上一层的logger，直到root --&gt;
        &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- 屏蔽kafka的日志打印 --&gt;
        &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;off&quot;&gt;&lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.config&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.web&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;testLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- Root节点用来指定项目的根日志，如果没有类似上面所配置的单独指定的logger，那么就会默认使用该Root日志输出 --&gt;
        &lt;!-- &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt; --&gt;
        &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt;
            &lt;!-- 用来指定该日志输出到哪个Appender --&gt;
            &lt;AppenderRef ref=&quot;Console&quot;/&gt;
        &lt;/Root&gt;
 
        &lt;!-- AsyncRoot - 异步记录日志 - 需要LMAXDisruptor的支持 --&gt;
        &lt;!--
        &lt;AsyncRoot level=&quot;info&quot; additivity=&quot;false&quot;&gt;
          &lt;AppenderRef ref=&quot;Console&quot;/&gt;
          &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
          &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/AsyncRoot&gt;
        --&gt;
    &lt;/Loggers&gt;
 
&lt;/configuration&gt;
</code></pre>
<p>参数说明</p>
<pre><code>    ********************************************************************************************************************
    参数        说明                                         举例                    输出显示媒介
    ********************************************************************************************************************
    %c          列出logger名字空间的全称，如果加上&#123;&lt;层数&gt;&#125;，   假设当前logger的命名空间是&quot;a.b.c&quot;
                则表示列出从最内层算起的指定层数的名字空间
                                                            %c                  a.b.c
                                                            %c&#123;2&#125;               b.c
                                                            %20c                （若名字空间长度小于20，则左边用空格填充）
                                                            %-20c               （若名字空间长度小于20，则右边用空格填充）
                                                            %.30c               （若名字空间长度超过30，截去多余字符）
                                                            %20.30c             （若名字空间长度小于20，则左边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
                                                            %-20.30c            （若名字空间长度小于20，则右边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
    ********************************************************************************************************************
    %C          列出调用logger的类的全名（包含包路径）         假设当前类是&quot;org.apache.xyz.SomeClass&quot;
                                                            %C                  org.apache.xyz.SomeClass
                                                            %C&#123;1&#125;               SomeClass
    %class
    ********************************************************************************************************************
    %d          显示日志记录时间，&#123;&lt;日期格式&gt;&#125;使用ISO8601定义的日期格式
                                                            %d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;     2005/10/12 22:23:30,117
                                                            %d&#123;ABSOLUTE&#125;        22:23:30,117
                                                            %d&#123;DATE&#125;            12 Oct 2005 22:23:30,117
                                                            %d&#123;ISO8601&#125;         2005-10-12 22:23:30,117
    ********************************************************************************************************************
    %F          显示调用logger的源文件名                     %F                   MyClass.java
    ********************************************************************************************************************
    %l          显示日志事件的发生位置，包含包路径、方法名、
                源文件名，以及在代码中的行数                  %l                   com.a.b.MyClass.main(MyClass.java:168)
    ********************************************************************************************************************
    %L          显示调用logger的代码行                       %L                   129
    %line                                                  %line                129
    ********************************************************************************************************************
    %level      显示该条日志的优先级                         %level               INFO
    %p                                                     %p                   INFO
    ********************************************************************************************************************
    %m          显示输出消息                                 %m                  This is a message for debug.
    %message                                                %message            This is a message for debug.
    ********************************************************************************************************************
    %M          显示调用logger的方法名                       %M                   main
    ********************************************************************************************************************
    %n          当前平台下的换行符                           %n                   Windows平台下表示rn，UNIX平台下表示n
    ********************************************************************************************************************
    %p          显示该条日志的优先级                         %p                   INFO
    %level                                                 %level               INFO
    ********************************************************************************************************************
    %r          显示从程序启动时到记录该条日志时已经经过的毫秒数  %r                 1215
    ********************************************************************************************************************
    %t          输出产生该日志事件的线程名                    %t                   http-nio-8080-exec-10
    %thread                                                 %thread              http-nio-8080-exec-10
    ********************************************************************************************************************
    %x          按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志           假设某程序调用顺序是MyApp调用com.foo.Bar
                                                            %c %x - %m%n        MyApp - Call com.foo.Bar.
                                                                                com.foo.Bar - Log in Bar
                                                                                MyApp - Return to MyApp.
    ********************************************************************************************************************
    %X          按MDC（Mapped Diagnostic Context，线程映射表）
                输出日志。通常用于多个客户端连接同一台服务器，
                方便服务器区分是那个客户端访问留下来的日志。     %X&#123;5&#125;             （记录代号为5的客户端的日志）
    ********************************************************************************************************************
    %%          显示一个百分号                               %%                  %
    ********************************************************************************************************************
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#1bccbc>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/">
        <h2>
            Spring中Bean作用域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><h2 id="一、Spring生命周期流程图"><a href="#一、Spring生命周期流程图" class="headerlink" title="一、Spring生命周期流程图"></a>一、Spring生命周期流程图</h2><p>下图描述的是从Spring容器初始化Bean开始直到Spring容器销毁Bean，所经历的关键节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20211208133748318.png" alt="file"></p>
<p>​        从上图可以看出，Spring Bean的生命周期管理的基本思路是：在Bean出现之前，先准备操作Bean的BeanFactory，然后操作完Bean，所有的Bean也还会交给BeanFactory进行管理。在所有Bean操作准备BeanPostProcessor作为回调。在Bean的完整生命周期管理过程中，经历了以下主要几个步骤：</p>
<h3 id="1-1-Bean创建前的准备阶段"><a href="#1-1-Bean创建前的准备阶段" class="headerlink" title="1.1 Bean创建前的准备阶段"></a>1.1 Bean创建前的准备阶段</h3><ul>
<li>步骤1： Bean容器在配置文件中找到Spring Bean的定义以及相关的配置，如init-method和destroy-method指定的方法。</li>
<li>步骤2： 实例化回调相关的后置处理器如BeanFactoryPostProcessor、BeanPostProcessor、InstantiationAwareBeanPostProcessor等</li>
</ul>
<h3 id="1-2-创建Bean的实例"><a href="#1-2-创建Bean的实例" class="headerlink" title="1.2 创建Bean的实例"></a>1.2 创建Bean的实例</h3><ul>
<li>步骤3： Srping 容器使用Java反射API创建Bean的实例。</li>
<li>步骤4：扫描Bean声明的属性并解析。</li>
</ul>
<h3 id="1-3-开始依赖注入"><a href="#1-3-开始依赖注入" class="headerlink" title="1.3 开始依赖注入"></a>1.3 开始依赖注入</h3><ul>
<li>步骤5：开始依赖注入，解析所有需要赋值的属性并赋值。</li>
<li>步骤6：如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。</li>
<li>步骤7：如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。</li>
<li>步骤8：如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。</li>
<li>步骤9：如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。</li>
</ul>
<h3 id="1-4-缓存到Spring容器"><a href="#1-4-缓存到Spring容器" class="headerlink" title="1.4 缓存到Spring容器"></a>1.4 缓存到Spring容器</h3><ul>
<li>步骤10： 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。</li>
<li>步骤11：如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。</li>
</ul>
<h3 id="1-5-销毁Bean的实例"><a href="#1-5-销毁Bean的实例" class="headerlink" title="1.5 销毁Bean的实例"></a>1.5 销毁Bean的实例</h3><ul>
<li>步骤12：如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。</li>
<li>步骤13：如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</li>
</ul>
<h2 id="二、Bean的作用域"><a href="#二、Bean的作用域" class="headerlink" title="二、Bean的作用域"></a>二、Bean的作用域</h2><p>​        创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方”。把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域，分别阐述如下表。</p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton">singleton</a></td>
<td>默认的。一个bean定义，在一个IoC容器内只会产生一个对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype">prototype</a></td>
<td>一个bean定义会产生多个对象实例</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-request">request</a></td>
<td>一个bean定义产生的bean生命周期为一个HTTP请求；也就是，每一个HTTP请求都会根据bean定义产生一个对象实例。该作用域只有在Spring web ApplicationContext 上下文环境中才有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-session">session</a></td>
<td>产生的bean生命周期在HTTP 会话期间。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-application">application</a></td>
<td>将单个bean定义范围限定为ServletContext的生命周期。 该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope">websocket</a></td>
<td>将单个bean定义范围限定为WebSocket的生命周期。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
</tbody></table>
<p>　    五种作用域中，request、session和global session三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<p>　　(1)当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>　　(2)当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
&lt;!--或者--&gt;
&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 
</code></pre>
<p>　　(3)当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>　　针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<p>　　(4)当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>　　针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<p>　　(5)当一个bean的作用域为Global Session，表示在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>　　global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p>
<h3 id="2-1-Spring中request请求作用域是什么？"><a href="#2-1-Spring中request请求作用域是什么？" class="headerlink" title="2.1 Spring中request请求作用域是什么？"></a>2.1 Spring中request请求作用域是什么？</h3><p>每个请求初始化具有此作用域的Bean注解。这听起来像是原型作用域的描述，但它们有一些差异。第一个区别是原型作用域在Spring的上下文中可用。而请求作用域仅适用于Web应用程序。第二个是原型bean根据需求进行初始化，而请求bean是在每个请求下构建的。需要说的是，request作用域bean在其作用域内有且仅有一个实例。而你可以拥有一个或多个原型作用域bean实例。</p>
<p>在以下代码中，你可以看到请求作用域bean的示例：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartRequest&quot; scope=&quot;request&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>当使用注解驱动组件或Java Config时，<code>@RequestScope</code>注解可以用于将一个组件分配给<code>request</code>作用域。</p>
<pre><code class="java">@RequestScope
@Component
public class ShoppingCartRequest &#123;
    // ...
&#125;
// request bean

// injection sample
@Controller
public class TestController &#123;
    @Autowired
    private ShoppingCartRequest shoppingCartRequest;

    @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)
    public String test(HttpServletRequest request) &#123;
        LOGGER.debug(&quot;shoppingCartRequest is :&quot;+shoppingCartRequest);
        // ...
    &#125;
&#125;
</code></pre>
<p>请注意<strong>定义内</strong>存在的**&lt;aop: scoped-proxy /&gt;**标签。这代表着使用代理对象。所以实际上，TestController持有的是代理对象的引用。我们所有的调用该对象都会转发到真正的<code>ShoppingCartRequest</code>对象。</p>
<p>有时我们需要使用<code>DispatcherServlet</code>的另一个<code>servlet</code>来处理请求。在这种情况下，我们必须确保Spring中所有请求都可用(否则可以抛出与下面类似的异常)。为此，我们需要在<code>web.xml</code>中定义一个监听器:</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>调用/测试URL后，你应该能在日志中的发现以下信息:</p>
<pre><code class="java">shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@2586b11c
shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@3bd5b945
</code></pre>
<p>如果我们尝试在单例bean中使用request作用域的bean，则会在应用程序上下文加载阶段抛出一个<code>BeanCreationException</code>:</p>
<pre><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;testController&#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:700)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:381)
    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293)
    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)
    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4701)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5204)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5199)
    at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source)
    at java.util.concurrent.FutureTask.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)
Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289)
    ... 21 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1014)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:957)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480)
    ... 23 more
Caused by: java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.web.context.request.RequestContextHolder.currentRequestAttributes(RequestContextHolder.java:131)
    at org.springframework.web.context.request.AbstractRequestAttributesScope.get(AbstractRequestAttributesScope.java:41)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338)
    ... 28 more
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="2-2-什么是Spring的Session作用域？"><a href="#2-2-什么是Spring的Session作用域？" class="headerlink" title="2.2 什么是Spring的Session作用域？"></a>2.2 什么是Spring的Session作用域？</h3><p>Session作用域的bean与request 作用域的bean没有太大的不同。它们也与纯Web应用程序上下文相关联。注解为Session作用域的Bean对于每个用户的会话仅创建一次。他们在会话结束时被破坏销毁掉。</p>
<p>由Session作用域限制的Bean可以被认为是面向Web的单例，因为给定环境(用户会话)仅存在一个实例。但请记住，你无法在Web应用程序上下文中使用它们(说个好理解点的，就是一个函数内部自定义变量所在的作用域，函数执行完就销毁了，没有什么逃逸，关于此处更深入的理解请看我的博文<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2016/11/08/%E7%94%B1%E5%9F%9F%E8%81%94%E7%B3%BB%E5%88%B0%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">由域联系到的逃逸分析</a>)。</p>
<p>想知道Session作用域bean在Spring中的操作，我们需要在配置文件中定义一个bean:</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartSession&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>通过<code>@Autowired</code>注解，查找这个bean的方式与request 作用域的bean相同。可以看到以下结果:</p>
<pre><code class="java">shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@2f87fafc
</code></pre>
<p>你可以看到，前5个打印输出代表相同的对象。最后一个是不同的。这是什么意思 ?简单来说，这代表 着一个新的用户使用自动注入的Session作用域访问该页面。我们可以通过打开两个浏览器的测试页(/test)来观察它。每个都将初始化一个新的会话Session，因此也就创建新的<code>ShoppingCartSession bean</code>实例。</p>
<p>关于全局会话作用域(Global session scope)属于4.3x的范畴了，Spring5已经没有了，Spring5文档是去掉了因为4的存在所以还是说两句，它保留给portlet应用程序。 是不是一脸懵逼，so，来解释一下portlet是什么。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与servlet不同，每个portlet都有不同的会话。在这种情况下，Spring提供了一个名为<code>global-session</code>的作用域。通过它，一个bean可以通过应用程序中的多个portlet共享。</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>至此，我们解释了请求和面向会话的作用域。第一个的作用是在每个request请求上创建新的bean。第二个在Session会话开始的时候初始化bean。</p>
<h2 id="三、Bean的生命周期"><a href="#三、Bean的生命周期" class="headerlink" title="三、Bean的生命周期"></a>三、Bean的生命周期</h2><p>　Spring中Bean的实例化过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210510144229675.png" alt="img"></p>
<p>Bean的生命周期：</p>
<p><img src="https://img-blog.csdnimg.cn/2021051014425161.png" alt="img"></p>
<p>Bean实例生命周期的执行过程如下：</p>
<ul>
<li>Spring对bean进行实例化，默认bean是单例；</li>
<li>Spring对bean进行依赖注入；</li>
<li>如果bean实现了BeanNameAware接口，Spring将bean的名称传给setBeanName()方法；</li>
<li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory实例传进来；</li>
<li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization()方法将被调用；</li>
<li>如果bean中有方法添加了@PostConstruct注解，那么该方法将被调用；</li>
<li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li>
<li>如果在xml文件中通过<bean>标签的init-method元素指定了初始化方法，那么该方法将被调用；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization()接口方法将被调用；</li>
<li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>
<li>如果bean中有方法添加了@PreDestroy注解，那么该方法将被调用；</li>
<li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ul>
<p>　　这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。</p>
<p>　　其实很多时候我们并不会真的去实现上面所描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<h3 id="3-1-单例管理的对象"><a href="#3-1-单例管理的对象" class="headerlink" title="3.1 单例管理的对象"></a>3.1 单例管理的对象</h3><p>　　当scope=”singleton”，即默认情况下，会在启动容器时（即实例化容器时）时实例化。但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。如下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;serviceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p>
<pre><code class="xml">&lt;beans default-lazy-init=&quot;true&quot;&gt;
</code></pre>
<p>　　默认情况下，Spring在读取xml文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用init-method属性值中所指定的方法。对象在被销毁的时候，会调用destroy-method属性值中所指定的方法（例如调用Container.destroy()方法的时候）。写一个测试类，代码如下：</p>
<pre><code class="java">public class LifeBean &#123;
    private String name;  
    
    public LifeBean()&#123;  
        System.out.println(&quot;LifeBean()构造函数&quot;);  
    &#125;  
    public String getName() &#123;  
        return name;  
    &#125;  
  
    public void setName(String name) &#123;  
        System.out.println(&quot;setName()&quot;);  
        this.name = name;  
    &#125;  

    public void init()&#123;  
        System.out.println(&quot;this is init of lifeBean&quot;);  
    &#125;  
      
    public void destory()&#123;  
        System.out.println(&quot;this is destory of lifeBean &quot; + this);  
    &#125;  
&#125;
</code></pre>
<p>　　life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_singleton&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;singleton&quot; 
            init-method=&quot;init&quot; destroy-method=&quot;destory&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　测试代码如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = 
        new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life&quot;);
        System.out.println(life1);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<h3 id="2-2-非单例管理的对象"><a href="#2-2-非单例管理的对象" class="headerlink" title="2.2 非单例管理的对象"></a>2.2 非单例管理的对象</h3><p>　　当scope=”prototype”时，容器也会延迟初始化bean，Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。在第一次请求每一个prototype的bean时，Spring容器都会调用其构造器创建这个对象，然后调用init-method属性值中所指定的方法。对象销毁的时候，Spring容器不会帮我们调用任何方法，因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<p>　　为了测试prototype bean的生命周期life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_prototype&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;
</code></pre>
<p>　　测试程序如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life_singleton&quot;);
        System.out.println(life1);
        
        LifeBean life3 = (LifeBean)container.getBean(&quot;life_prototype&quot;);
        System.out.println(life3);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：　</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@5ae9a829
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<p>　　可以发现，对于作用域为prototype的bean，其destroy方法并没有被调用。如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>　　Spring容器可以管理singleton作用域下bean的生命周期，在此作用域下，Spring能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的bean，Spring只负责创建，当容器创建了bean的实例后，bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<h3 id="2-3-引申"><a href="#2-3-引申" class="headerlink" title="2.3 引申"></a>2.3 引申</h3><p>　　在学习Spring IoC过程中发现，每次产生ApplicationContext工厂的方式是：</p>
<pre><code class="java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p>　　这样产生ApplicationContext就有一个弊端，每次访问加载bean的时候都会产生这个工厂，所以这里需要解决这个问题。</p>
<p>　　ApplicationContext是一个接口，它继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持。</p>
<p>　　解决问题的方法很简单，在web容器启动的时候将ApplicationContext转移到ServletContext中，因为在web应用中所有的Servlet都共享一个ServletContext对象。那么我们就可以利用ServletContextListener去监听ServletContext事件，当web应用启动的是时候，我们就将ApplicationContext装载到ServletContext中。 Spring容器底层已经为我们想到了这一点，在spring-web-xxx-release.jar包中有一个已经实现了ServletContextListener接口的类ContextLoader，其源码如下：</p>
<pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;
    private ContextLoader contextLoader;

    public ContextLoaderListener() &#123;

    &#125;

    public ContextLoaderListener(WebApplicationContext context) &#123;
        super(context);
    &#125;

    public void contextInitialized(ServletContextEvent event) &#123;
        this.contextLoader = createContextLoader();
        if (this.contextLoader == null) &#123;
            this.contextLoader = this;
        &#125;
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    &#125;

    @Deprecated
    protected ContextLoader createContextLoader() &#123;
        return null;
    &#125;

    @Deprecated
    public ContextLoader getContextLoader() &#123;
        return this.contextLoader;
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        if (this.contextLoader != null) &#123;
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
        &#125;
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    &#125;
&#125;
</code></pre>
<p>　　这里就监听到了servletContext的创建过程, 那么 这个类又是如何将applicationContext装入到serveletContext容器中的呢?</p>
<p>　　this.contextLoader.initWebApplicationContext(event.getServletContext())方法的具体实现中：</p>
<pre><code class="java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;
     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;
         throw new IllegalStateException(
                 &quot;Cannot initialize context because there is already a root application context present - &quot; +
                 &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
     &#125;

     Log logger = LogFactory.getLog(ContextLoader.class);
     servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
     if (logger.isInfoEnabled()) &#123;
         logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
     &#125;
     long startTime = System.currentTimeMillis();

     try &#123;
           // Store context in local instance variable, to guarantee that
          // it is available on ServletContext shutdown.
         if (this.context == null) &#123;
             this.context = createWebApplicationContext(servletContext);
         &#125;
         if (this.context instanceof ConfigurableWebApplicationContext) &#123;
             ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
             if (!cwac.isActive()) &#123;
                 // The context has not yet been refreshed -&gt; provide services such as
                 // setting the parent context, setting the application context id, etc
                 if (cwac.getParent() == null) &#123;
                     // The context instance was injected without an explicit parent -&gt;
                     // determine parent for root web application context, if any.
                     ApplicationContext parent = loadParentContext(servletContext);
                     cwac.setParent(parent);
                 &#125;
                 configureAndRefreshWebApplicationContext(cwac, servletContext);
             &#125;
         &#125;
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

         ClassLoader ccl = Thread.currentThread().getContextClassLoader();
         if (ccl == ContextLoader.class.getClassLoader()) &#123;
             currentContext = this.context;
         &#125;
         else if (ccl != null) &#123;
             currentContextPerThread.put(ccl, this.context);
         &#125;

         if (logger.isDebugEnabled()) &#123;
             logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
                     WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
         &#125;
         if (logger.isInfoEnabled()) &#123;
             long elapsedTime = System.currentTimeMillis() - startTime;
             logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
         &#125;

         return this.context;
     &#125;
     catch (RuntimeException ex) &#123;
         logger.error(&quot;Context initialization failed&quot;, ex);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
         throw ex;
     &#125;
     catch (Error err) &#123;
         logger.error(&quot;Context initialization failed&quot;, err);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
         throw err;
     &#125;
 &#125;
</code></pre>
<p>　　这里的重点是servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)，用key:WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE value: this.context的形式将applicationContext装载到servletContext中了。另外从上面的一些注释我们可以看出： WEB-INF/applicationContext.xml， 如果我们项目中的配置文件不是这么一个路径的话 那么我们使用ContextLoaderListener 就会出问题, 所以我们还需要在web.xml中配置我们的applicationContext.xml配置文件的路径。</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>　　剩下的就是在项目中开始使用 servletContext中装载的applicationContext对象了： 那么这里又有一个问题，装载时的key是 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们在代码中真的要使用这个吗? 其实Spring为我们提供了一个工具类WebApplicationContextUtils，接着我们先看下如何使用，然后再去看下这个工具类的源码：</p>
<pre><code class="java">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());
</code></pre>
<p>　　接着来看下这个工具类的源码：</p>
<pre><code class="java">public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;
    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
&#125;
</code></pre>
<p>　　这里就能很直观清晰地看到 通过key值直接获取到装载到servletContext中的 applicationContext对象了。</p>
<p>　　ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，整个加载配置过程由ContextLoader来完成。</p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>​        理解spring中bean的生命周期，对于学习和使用spring很有帮助。本文将从两个角度对spring中bean的生命周期进行介绍，一是bean定义生成；二是bean在初始化、使用、销毁的生命周期中经历的阶段。</p>
<h3 id="4-2-bean定义生成"><a href="#4-2-bean定义生成" class="headerlink" title="4.2 bean定义生成"></a>4.2 bean定义生成</h3><p>​        bean定义生成主要分为三个步骤，即bean定义的获取、bean定义的注册。<br><strong>1、bean定义的获取</strong><br>​        bean的定义来源各种各样，如xml定义、java注解定义等。<br>​        spring对各种来源提供了统一的接口org.springframework.core.io.Resource，<br>​        Resource接口即也是对spring内的所有底层资源进行了抽象（如file、url、classpath）。<br>​        Resource接口相关的类结构图如下：<br><img src="https://img-blog.csdnimg.cn/20181114231111589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5hYmVzdGNoaW5h,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​        各类bean定义的加载请参数相应spring源码。<br><strong>2、bean定义的解析</strong><br>​        由于来源的不同，bean的解析也是各种各样的（如xml内标签的解析）。<br>​        spring对bean的定义仍然有公共的接口org.springframework.beans.factory.config.BeanDefinition。<br>​        具体解析请查看spring源码。<br><strong>3、bean的注册</strong><br>​        解析得到的bean，最终会注册到容器中，其实也就是ConcurrentHashMap，<br>​        即org.springframework.beans.factory.support.DefaultListableBeanFactory类中的实例变量</p>
<pre><code class="java">/** Map of bean definition objects, keyed by bean name */
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<p>​        此bean的加载完成</p>
<h3 id="4-3-spring的生命周期"><a href="#4-3-spring的生命周期" class="headerlink" title="4.3 spring的生命周期"></a>4.3 spring的生命周期</h3><p>​        spring生命周期中的阶段，包括初始化、使用、销毁。<br><strong>1、初始化阶段</strong><br>​        1）调用bean的构造函数，创建实例；<br>​        2）进行参数依赖注入；<br>​        3）若实现org.springframework.beans.BeanNameAware接口，则调用BeanNameAware的setBeanName()方法;<br>​        4）若实现org.springframework.beans.factory.BeanClassLoaderAware接口，则调用BeanClassLoaderAware的setBeanClassLoader()方法;<br>​        5）若实现org.springframework.context.ApplicationContextAware接口，则调用ApplicationContextAware的setApplicationContext()方法;<br>​        6）若使用了注解@PostConstruct，则调相应方法；<br>​        7）若实现org.springframework.beans.factory.InitializingBean接口，则调用InitializingBean接口的afterPropertiesSet方法;<br>​        8）若bean定义的使用了initMethod，则调相应方法；<br>​        9）若实现org.springframework.beans.factory.config.BeanPostProcessor接口，则调用BeanPostProcessor的postProcessBeforeInitialization()方法和postProcessAfterInitialization方法;<br><strong>2、使用阶段</strong><br>​        1）bean在项目的使用；<br><strong>3、销毁阶段</strong><br>​        1）若使用注解@PreDestroy，则调用相应方法；<br>​        2）若bean定义中配置了destroyMethod，则调用相应方法；<br>​        3）若实现org.springframework.beans.factory.DisposableBean接口，则调用DisposableBean接口的destroy方法; </p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>综合前面的代码和分析，现在我们用大白话描述下：</p>
<ol>
<li>Bean容器找到Spring配置文件中Bean的定义；</li>
<li>Bean容器利用java 反射机制实例化Bean；</li>
<li>Bean容器为实例化的Bean设置属性值；</li>
<li>如果Bean实现了BeanNameAware接口，则执行setBeanName方法；</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则执行setBeanClassLoader方法；</li>
<li>如果Bean实现了BeanFactoryAware接口，则执行setBeanFactory方法；</li>
<li>如果 ……真的，到这我经常忘记，但前面三个Aware接口肯定能记住；</li>
<li>如果Bean实现了ApplicationContextAware接口，则执行setApplicationContext方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessBeforeInitialization方法；</li>
<li>如果Bean定义初始化方法（PostConstruct注解、配置init-method、实现了InitializingBean接口），则执行定义的初始化方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessAfterInitialization方法；</li>
<li>当要销毁这个Bean时，如果自定义了销毁方法（PreDestroy注解、配置destroy-method、实现了DisposableBean接口），则执行定义的销毁方法。</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/">
        <h2>
            Spring使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring使用详解"><a href="#Spring使用详解" class="headerlink" title="Spring使用详解"></a>Spring使用详解</h1><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><h3 id="1-1、Spring组成"><a href="#1-1、Spring组成" class="headerlink" title="1.1、Spring组成"></a>1.1、Spring组成</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF6KnNia5YDhfatibrMvAUAhxgF27g4HdJsBGl6Fae9yQlUQJc9Bf8uftw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFetRkkw19r7H3mHDibgs4RpRNHdG6CcIMdnxRCu2yYXNiano7ESCCMF0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <strong>BeanFactory</strong>，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式<strong>将应用程序的配置和依赖性规范与实际的应用程序代码分开</strong>。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架<strong>提供上下文信息</strong>。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象<strong>提供事务管理服务</strong>。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来<strong>管理异常处理和不同数据库供应商抛出的错误消息</strong>。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h3 id="1-2、拓展"><a href="#1-2、拓展" class="headerlink" title="1.2、拓展"></a>1.2、拓展</h3><p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li>
<li>Spring Cloud是基于Spring Boot实现的；</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
<li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFH5GFXM4YPUGrmA2JdpPic3FwYaI1JZHBZxibaUJVXWzzTFeCayk4XAIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="二、IOC讲解"><a href="#二、IOC讲解" class="headerlink" title="二、IOC讲解"></a>二、IOC讲解</h2><h3 id="2-1、IOC基础"><a href="#2-1、IOC基础" class="headerlink" title="2.1、IOC基础"></a>2.1、IOC基础</h3><p>新建一个空白的maven项目</p>
<blockquote>
<p>分析实现</p>
</blockquote>
<p>我们先用我们原来的方式写一段代码。</p>
<p>1、UserDao接口</p>
<pre><code class="java">public interface UserDao &#123;
    public void getUser();
&#125;
</code></pre>
<p>2、Dao的实现类</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>3、UserService接口</p>
<pre><code class="java">public interface UserService &#123;
    public void getUser();
&#125;
</code></pre>
<p>4、Service实现类</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>5、测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
    UserService service = new UserServiceImpl();
    service.getUser();
&#125;
</code></pre>
<blockquote>
<p>=========================接下来做一下修改=================================</p>
</blockquote>
<p>增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoMySqlImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;MySql获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoMySqlImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>假设再增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoOracleImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;Oracle获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>​        那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现。假设我们的这种需求非常大 , 这种方式就根本不适用。这种设计的耦合性太高了, 牵一发而动全身。</p>
<p><strong>那我们如何去解决呢 ?</strong> </p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    
    // 利用set实现
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
&#125;
</code></pre>
<p>​        这两者有着本质区别：以前的思路都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者。程序不用去管怎么创建,怎么实现了。 它只负责提供一个接口。</p>
<p>​        这种思想 , 从本质上解决了问题 , 程序员不再去管理对象的创建 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="2-2、IOC本质"><a href="#2-2、IOC本质" class="headerlink" title="2.2、IOC本质"></a>2.2、IOC本质</h3><p>​        <strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFuYibmavlBHq9e4cDqiclpYSG8VT4EicVsnqKp65yJKQeNibsVdTiahQibJSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        <strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>​        <u>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</u></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p>​        <strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="三、HelloSpring"><a href="#三、HelloSpring" class="headerlink" title="三、HelloSpring"></a>三、HelloSpring</h2><h3 id="3-1、helloSpring的创建"><a href="#3-1、helloSpring的创建" class="headerlink" title="3.1、helloSpring的创建"></a>3.1、helloSpring的创建</h3><blockquote>
<p>导入jar包依赖</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 但是利用maven会自动下载对应的依赖项。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="java">@Data
public class Hello &#123;
   private String name;

   public void show()&#123;
       System.out.println(&quot;Hello,&quot;+ name );
  &#125;
&#125;
</code></pre>
<p>2、编写spring的文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>其中，bean标签各个参数解释如下：</p>
<ul>
<li><strong>id：</strong>JavaBean在BeanFactory中唯一标识，代码中通过BeanFactory获取JavaBean实例时需要此参数作为索引名称</li>
<li>name：可以为Bean指定多个名称（起别名）</li>
<li><strong>class：</strong>JavaBean 类名</li>
<li><strong>scope：</strong>设定Bean的作用域<ul>
<li><strong>singleton</strong>：指定此Java Bean是否使用单例模式，如果设为“True”，则在BeanFactory作用范围内只维护此Java Bean的一个实例，代码通BeanFactory获取此javaBean实例的引用;反这如果设为“False”，则通过BeanFactory获取javaBean实例时，BeanFactory每次都将创建一个新的实例返回。</li>
<li><strong>Prototype：</strong>原型：表示通过IoC容器获取的Bean是不同的</li>
<li><strong>request：</strong>请求：表示在一次HTTP请求内有效</li>
<li><strong>session：</strong>会话：表示在一个用户会话内有效</li>
</ul>
</li>
<li><strong>init-method：</strong>初始化方法，此方法将在BeanFactory创建JavaBean实例之后，在向应用层返回引用之前执行。一般用于一些资源的初始化工作。</li>
<li>销毁方法：此方法将在BeanFactory销毁的时候执行，一般用于资源释放。</li>
<li><strong>depends-on：</strong>Bean依赖关系。一般情况下无需设定。Spring会根据情况组织各个依赖关系的构建工作（这里<br>示例中的depends-on属性非必须）。只有某些特殊情况下，如JavaBean中的某些静态变量需要进行初始化（这是一种Bad Smell，应该在设计上应该避免）。通过depends-on指定其依赖关系可保证在此Bean加载之前，首先对depends-on所指定的资源进行加载。</li>
<li><strong>value：</strong>通过<value/>节点可指定属性值。BeanFactory将自动根据Java Bean对应的属性类型加以匹配。注意<value></value>代表一个空字符串，如果需要将属性值设定为null，必须使用<null/>节点。</li>
<li><strong>ref：</strong>指定了属性对BeanFactory中其他Bean的引用关系。</li>
<li><strong>property：</strong>Bean的子元素，用来指定需要赋值的属性</li>
<li><strong>constructor-arg：</strong>用于有参构造的注入<ul>
<li>index：指定下标</li>
<li>value：赋值</li>
<li>type：参数类型</li>
<li>ref：将注入别的Bean</li>
</ul>
</li>
<li><strong>import：</strong>用于导入别的XML文件</li>
</ul>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   // 解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   // getBean : 参数即为spring配置文件中bean的id .
   Hello hello = (Hello) context.getBean(&quot;hello&quot;);
   // 调用对象hello的show方法
   hello.show();
&#125;
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  <ul>
<li>hello 对象是由Spring创建的</li>
</ul>
</li>
<li>Hello 对象的属性是怎么设置的 ?  <ul>
<li>hello 对象的属性是由Spring容器设置的</li>
</ul>
</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p><strong>依赖注入 :</strong> 就是利用set方法来进行注入的.</p>
<p>​         IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>​        可以通过newClassPathXmlApplicationContext去浏览一下底层源码 。</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>新增一个Spring配置文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
&#125;
</code></pre>
<p>​        OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p>
<h3 id="3-2、IOC创建对象方式"><a href="#3-2、IOC创建对象方式" class="headerlink" title="3.2、IOC创建对象方式"></a>3.2、IOC创建对象方式</h3><h4 id="3-2-1、通过无参构造方法创建"><a href="#3-2-1、通过无参构造方法创建" class="headerlink" title="3.2.1、通过无参构造方法创建"></a>3.2.1、通过无参构造方法创建</h4><p>1、User.java</p>
<pre><code class="java">public class User &#123;

    private String name;

    public User() &#123;
        System.out.println(&quot;user无参构造方法&quot;);
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
&#125;
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h4 id="3-2-2、通过有参构造方法创建"><a href="#3-2-2、通过有参构造方法创建" class="headerlink" title="3.2.2、通过有参构造方法创建"></a>3.2.2、通过有参构造方法创建</h4><p>1、UserT . java</p>
<pre><code class="java">public class UserT &#123;

    private String name;

    public UserT(String name) &#123;
        this.name = name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- index指构造方法 , 下标从0开始 --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- name指参数名 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testT()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    UserT user = (UserT) context.getBean(&quot;userT&quot;);
    user.show();
&#125;
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h3 id="3-3、Spring配置"><a href="#3-3、Spring配置" class="headerlink" title="3.3、Spring配置"></a>3.3、Spring配置</h3><h4 id="3-3-1、别名"><a href="#3-3-1、别名" class="headerlink" title="3.3.1、别名"></a>3.3.1、别名</h4><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h4 id="3-3-2、Bean的配置"><a href="#3-3-2、Bean的配置" class="headerlink" title="3.3.2、Bean的配置"></a>3.3.2、Bean的配置</h4><pre><code class="xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3-3-3、import"><a href="#3-3-3、import" class="headerlink" title="3.3.3、import"></a>3.3.3、import</h4><p>团队的合作通过import来实现 .</p>
<pre><code class="xml">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;
</code></pre>
<h2 id="四、依赖注入（DI）"><a href="#四、依赖注入（DI）" class="headerlink" title="四、依赖注入（DI）"></a>四、依赖注入（DI）</h2><h3 id="4-1、依赖注入"><a href="#4-1、依赖注入" class="headerlink" title="4.1、依赖注入"></a>4.1、依赖注入</h3><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p><strong>Address.java</strong></p>
<pre><code class="java"> public class Address &#123;
 
     private String address;
 
     public String getAddress() &#123;
         return address;
    &#125;
 
     public void setAddress(String address) &#123;
         this.address = address;
    &#125;
 &#125;
</code></pre>
<p><strong>Student.java</strong></p>
<pre><code class="java">@Data
public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbys;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name
                           + &quot;,address=&quot;+ address.getAddress()
                           + &quot;,books=&quot;
                          );
        for (String book:books)&#123;
            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);
        &#125;
        System.out.println(&quot;\n爱好:&quot;+hobbys);

        System.out.println(&quot;card:&quot;+card);

        System.out.println(&quot;games:&quot;+games);

        System.out.println(&quot;wife:&quot;+wife);

        System.out.println(&quot;info:&quot;+info);

    &#125;
&#125;
</code></pre>
<h4 id="4-1-1、常量注入"><a href="#4-1-1、常量注入" class="headerlink" title="4.1.1、常量注入"></a>4.1.1、常量注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test01()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    Student student = (Student) context.getBean(&quot;student&quot;);

    System.out.println(student.getName());

&#125;
</code></pre>
<h4 id="4-1-2、Bean注入"><a href="#4-1-2、Bean注入" class="headerlink" title="4.1.2、Bean注入"></a>4.1.2、Bean注入</h4><p>注意点：这里的值是一个引用，ref</p>
<pre><code class="xml">&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-3、数组注入"><a href="#4-1-3、数组注入" class="headerlink" title="4.1.3、数组注入"></a>4.1.3、数组注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;西游记&lt;/value&gt;
            &lt;value&gt;红楼梦&lt;/value&gt;
            &lt;value&gt;水浒传&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-4、List注入"><a href="#4-1-4、List注入" class="headerlink" title="4.1.4、List注入"></a>4.1.4、List注入</h4><pre><code class="xml">&lt;property name=&quot;hobbys&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;听歌&lt;/value&gt;
        &lt;value&gt;看电影&lt;/value&gt;
        &lt;value&gt;爬山&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-5、Map注入"><a href="#4-1-5、Map注入" class="headerlink" title="4.1.5、Map注入"></a>4.1.5、Map注入</h4><pre><code class="xml">&lt;property name=&quot;card&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt;
        &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-6、set注入"><a href="#4-1-6、set注入" class="headerlink" title="4.1.6、set注入"></a>4.1.6、set注入</h4><pre><code class="xml">&lt;property name=&quot;games&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;LOL&lt;/value&gt;
        &lt;value&gt;BOB&lt;/value&gt;
        &lt;value&gt;COC&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-7、Null注入"><a href="#4-1-7、Null注入" class="headerlink" title="4.1.7、Null注入"></a>4.1.7、Null注入</h4><pre><code class="xml">&lt;property name=&quot;wife&quot;&gt;
    &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-9、Properties注入"><a href="#4-1-9、Properties注入" class="headerlink" title="4.1.9、Properties注入"></a>4.1.9、Properties注入</h4><pre><code class="xml">&lt;property name=&quot;info&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;
        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
<p>测试结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYGHEFnrCA8Jyr6ian5MWrUHtnKBpYYTTtysbp5UPYKQxSiaUHJibPKlicuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-1-10、p命名和c命名注入"><a href="#4-1-10、p命名和c命名注入" class="headerlink" title="4.1.10、p命名和c命名注入"></a>4.1.10、p命名和c命名注入</h4><p>User.java ：【注意：这里没有有参构造器！】</p>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>1、<strong>P命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;
</code></pre>
<p>2、<strong>c 命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;

&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;
</code></pre>
<p>​        发现问题：显示错误，代码标红</p>
<p>​        解决：把有参构造器加上，这里也能知道，c 就是所谓的<strong>构造器注入</strong>！</p>
<p>测试代码：</p>
<pre><code class="java">@Test
public void test02()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    System.out.println(user);
&#125;
</code></pre>
<h3 id="4-2、Bean的作用域"><a href="#4-2、Bean的作用域" class="headerlink" title="4.2、Bean的作用域"></a>4.2、Bean的作用域</h3><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYfmmAQF8hrnicY49FRXEkR5xkxD5A4H5pVUia3mFhrDdh4gBt183EiaFaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="4-2-1、Singleton"><a href="#4-2-1、Singleton" class="headerlink" title="4.2.1、Singleton"></a>4.2.1、Singleton</h4><p>​        <strong>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</strong>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test03()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    User user2 = (User) context.getBean(&quot;user&quot;);
    System.out.println(user==user2);
&#125;
</code></pre>
<h4 id="4-2-2、Prototype"><a href="#4-2-2、Prototype" class="headerlink" title="4.2.2、Prototype"></a>4.2.2、Prototype</h4><p>​        <strong>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。</strong>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml"> &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
 或者
 &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;
</code></pre>
<h4 id="4-2-3、Request"><a href="#4-2-3、Request" class="headerlink" title="4.2.3、Request"></a>4.2.3、Request</h4><p>​        <strong>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例</strong>；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>​        针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="4-2-4、Session"><a href="#4-2-4、Session" class="headerlink" title="4.2.4、Session"></a>4.2.4、Session</h4><p>​        <strong>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。</strong>该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>​        针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<h2 id="五、自动装配"><a href="#五、自动装配" class="headerlink" title="五、自动装配"></a>五、自动装配</h2><h3 id="5-1、自动装配"><a href="#5-1、自动装配" class="headerlink" title="5.1、自动装配"></a>5.1、自动装配</h3><blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ul>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ul>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ul>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ul>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h4 id="5-1-1、测试环境搭建"><a href="#5-1-1、测试环境搭建" class="headerlink" title="5.1.1、测试环境搭建"></a>5.1.1、测试环境搭建</h4><p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="java">public class Cat &#123;
   public void shout() &#123;
       System.out.println(&quot;miao~&quot;);
  &#125;
&#125;
    
public class Dog &#123;
   public void shout() &#123;
       System.out.println(&quot;wang~&quot;);
  &#125;
&#125;
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="java">public class User &#123;
   private Cat cat;
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void testMethodAutowire() &#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  &#125;
&#125;
</code></pre>
<p>结果正常输出。</p>
<h4 id="5-1-2、byName"><a href="#5-1-2、byName" class="headerlink" title="5.1.2、byName"></a>5.1.2、byName</h4><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=”byName”</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<h4 id="5-1-3、byType"><a href="#5-1-3、byType" class="headerlink" title="5.1.3、byType"></a>5.1.3、byType</h4><p>​        <strong>autowire byType (按类型自动装配)</strong></p>
<p>​        使用autowire byType首先需要保证：<strong>同一类型的对象，在spring容器中唯一</strong>。如果不唯一，会报不唯一的异常。</p>
<pre><code class="xml">NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="5-2、使用注解"><a href="#5-2、使用注解" class="headerlink" title="5.2、使用注解"></a>5.2、使用注解</h3><blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;
</code></pre>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="java">public class User &#123;
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String str;

   public Cat getCat() &#123;
       return cat;
  &#125;
   public Dog getDog() &#123;
       return dog;
  &#125;
   public String getStr() &#123;
       return str;
  &#125;
&#125;
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【小狂神科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code class="java">//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;

@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p><strong>实体类</strong>：</p>
<pre><code class="java">public class User &#123;
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="java">@Resource
private Cat cat;

@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<p><strong>小结</strong></p>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="六、使用注解开发"><a href="#六、使用注解开发" class="headerlink" title="六、使用注解开发"></a>六、使用注解开发</h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h3><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IzypAUHDfDEujP4ry6cHxWTvAS6qRS0qrmMCic3QqF9icGNcPj8IZwNo3R9VEgpAgWHrStBN1ya6Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="6-2、Bean的实现"><a href="#6-2、Bean的实现" class="headerlink" title="6.2、Bean的实现"></a>6.2、Bean的实现</h3><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   public String name = &quot;秦疆&quot;;
&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext applicationContext =
       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   User user = (User) applicationContext.getBean(&quot;user&quot;);
   System.out.println(user.name);
&#125;
</code></pre>
<h3 id="6-3、属性注入"><a href="#6-3、属性注入" class="headerlink" title="6.3、属性注入"></a>6.3、属性注入</h3><p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   @Value(&quot;秦疆&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   public String name;
&#125;
</code></pre>
<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<pre><code class="java">@Component(&quot;user&quot;)
public class User &#123;

   public String name;

   @Value(&quot;秦疆&quot;)
   public void setName(String name) &#123;
       this.name = name;
  &#125;
&#125;
</code></pre>
<h3 id="6-4、衍生注解"><a href="#6-4、衍生注解" class="headerlink" title="6.4、衍生注解"></a>6.4、衍生注解</h3><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User &#123;
   @Value(&quot;秦疆&quot;)
   public String name;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code>&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li><p>进行注解驱动注册，从而使注解生效</p>
</li>
<li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li><p>如果不扫描包，就需要手动配置bean</p>
</li>
<li><p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<h3 id="6-5、基于Java类进行配置"><a href="#6-5、基于Java类进行配置" class="headerlink" title="6.5、基于Java类进行配置"></a>6.5、基于Java类进行配置</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog &#123;
   public String name = &quot;dog&quot;;
&#125;
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig &#123;

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
&#125;
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig2 &#123;
&#125;
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="java">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig &#123;

   @Bean
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
<h2 id="七、静态-动态代理模式"><a href="#七、静态-动态代理模式" class="headerlink" title="七、静态/动态代理模式"></a>七、静态/动态代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p>
<p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>学习aop之前 , 我们要先了解一下代理模式！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLRnfS7LpO0Iic7fEEPFCgRs0ggNXCwf6IKo1tibjPmNSTEYeII5ro7YLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-1、静态代理"><a href="#7-1、静态代理" class="headerlink" title="7.1、静态代理"></a>7.1、静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li><p>抽象角色 : 一般使用接口或者抽象类来实现</p>
</li>
<li><p>真实角色 : 被代理的角色</p>
</li>
<li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p>
</li>
<li><p>客户  :  使用代理角色来进行一些操作 </p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>Proxy . java 即代理角色</p>
<pre><code class="java">//代理角色：中介
public class Proxy implements Rent &#123;

   private Host host;
   public Proxy() &#123; &#125;
   public Proxy(Host host) &#123;
       this.host = host;
  &#125;

   //租房
   public void rent()&#123;
       seeHouse();
       host.rent();
       fare();
  &#125;
   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;
&#125;
</code></pre>
<p>Client . java 即客户</p>
<pre><code class="java">//客户类，一般客户都会去找代理！
public class Client &#123;
   public static void main(String[] args) &#123;
       //房东要租房
       Host host = new Host();
       //中介帮助房东
       Proxy proxy = new Proxy(host);

       //你去找中介！
       proxy.rent();
  &#125;
&#125;
</code></pre>
<p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="7-2、静态代理再理解"><a href="#7-2、静态代理再理解" class="headerlink" title="7.2、静态代理再理解"></a>7.2、静态代理再理解</h3><p>练习步骤：</p>
<p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p>
<pre><code class="java">//抽象角色：增删改查业务
public interface UserService &#123;
   void add();
   void delete();
   void update();
   void query();
&#125;
</code></pre>
<p>2、我们需要一个真实对象来完成这些增删改查操作</p>
<pre><code class="java">//真实对象，完成增删改查操作的人
public class UserServiceImpl implements UserService &#123;

   public void add() &#123;
       System.out.println(&quot;增加了一个用户&quot;);
  &#125;

   public void delete() &#123;
       System.out.println(&quot;删除了一个用户&quot;);
  &#125;

   public void update() &#123;
       System.out.println(&quot;更新了一个用户&quot;);
  &#125;

   public void query() &#123;
       System.out.println(&quot;查询了一个用户&quot;);
  &#125;
&#125;
</code></pre>
<p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
<p>4、设置一个代理类来处理日志！代理角色</p>
<pre><code class="java">//代理角色，在这里面增加日志的实现
public class UserServiceProxy implements UserService &#123;
   private UserServiceImpl userService;

   public void setUserService(UserServiceImpl userService) &#123;
       this.userService = userService;
  &#125;

   public void add() &#123;
       log(&quot;add&quot;);
       userService.add();
  &#125;

   public void delete() &#123;
       log(&quot;delete&quot;);
       userService.delete();
  &#125;

   public void update() &#123;
       log(&quot;update&quot;);
       userService.update();
  &#125;

   public void query() &#123;
       log(&quot;query&quot;);
       userService.query();
  &#125;

   public void log(String msg)&#123;
       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>5、测试访问类：</p>
<pre><code class="java">public class Client &#123;
   public static void main(String[] args) &#123;
       //真实业务
       UserServiceImpl userService = new UserServiceImpl();
       //代理类
       UserServiceProxy proxy = new UserServiceProxy();
       //使用代理类实现日志功能！
       proxy.setUserService(userService);

       proxy.add();
  &#125;
&#125;
</code></pre>
<p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLJqcgicA5aEKtxYibgLPicNfDwicKIn9NlFl86rriaVRicKnEXlPNiacbHiaLibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、动态代理"><a href="#7-3、动态代理" class="headerlink" title="7.3、动态代理"></a>7.3、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLxvyvZMwn9gIEibuxjFwE3enJ4TgKO5PXxM5BPr6Bh7GQwExLvst4AsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>Object invoke(Object proxy, 方法 method, Object[] args)；
//参数
//proxy - 调用该方法的代理实例
//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。
</code></pre>
<p>【Proxy  : 代理】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="java">//生成代理类
public Object getProxy()&#123;
   return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                 rent.getClass().getInterfaces(),this);
&#125;
</code></pre>
<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>ProxyInvocationHandler. java 即代理角色</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Rent rent;

   public void setRent(Rent rent) &#123;
       this.rent = rent;
  &#125;

   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               rent.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.
   // 处理代理实例上的方法调用并返回结果
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       seeHouse();
       //核心：本质利用反射实现！
       Object result = method.invoke(rent, args);
       fare();
       return result;
  &#125;

   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;

&#125;
</code></pre>
<p>Client . java</p>
<pre><code class="java">//租客
public class Client &#123;

   public static void main(String[] args) &#123;
       //真实角色
       Host host = new Host();
       //代理实例的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setRent(host); //将真实角色放置进去！
       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！
       proxy.rent();
  &#125;

&#125;
</code></pre>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h3 id="7-4、深入理解"><a href="#7-4、深入理解" class="headerlink" title="7.4、深入理解"></a>7.4、深入理解</h3><p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Object target;

   public void setTarget(Object target) &#123;
       this.target = target;
  &#125;

   //生成代理类
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  &#125;

   public void log(String methodName)&#123;
       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>测试！</p>
<pre><code class="java">public class Test &#123;
   public static void main(String[] args) &#123;
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setTarget(userService); //设置要代理的对象
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       proxy.delete();
  &#125;
&#125;
</code></pre>
<p>测试，增删改查，查看结果！</p>
<blockquote>
<h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h2 id="八、AOP"><a href="#八、AOP" class="headerlink" title="八、AOP"></a>八、AOP</h2><h3 id="8-1、AOP简介"><a href="#8-1、AOP简介" class="headerlink" title="8.1、AOP简介"></a>8.1、AOP简介</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。<ul>
<li>前置通知：在某连接点之前执行的通知，这个通知不能组织连接点之前的执行流程</li>
<li>后置通知：在某连接点正常完成后执行的通知</li>
<li>异常通知：在方法抛出异常退出时执行的通知</li>
<li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li>
<li>环绕通知：保卫一个连接点的通知，如方法调用</li>
</ul>
</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="8-2、使用AOP"><a href="#8-2、使用AOP" class="headerlink" title="8.2、使用AOP"></a>8.2、使用AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="8-2-1、通过-Spring-API-实现"><a href="#8-2-1、通过-Spring-API-实现" class="headerlink" title="8.2.1、通过 Spring API 实现"></a>8.2.1、通过 Spring API 实现</h4><p>首先编写我们的业务接口和实现类</p>
<pre><code class="java">public interface UserService &#123;

   public void add();

   public void delete();

   public void update();

   public void search();

&#125;

public class UserServiceImpl implements UserService&#123;

   @Override
   public void add() &#123;
       System.out.println(&quot;增加用户&quot;);
  &#125;

   @Override
   public void delete() &#123;
       System.out.println(&quot;删除用户&quot;);
  &#125;

   @Override
   public void update() &#123;
       System.out.println(&quot;更新用户&quot;);
  &#125;

   @Override
   public void search() &#123;
       System.out.println(&quot;查询用户&quot;);
  &#125;
&#125;
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="java">public class Log implements MethodBeforeAdvice &#123;

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;
       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  &#125;
&#125;
public class AfterLog implements AfterReturningAdvice &#123;
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  &#125;
&#125;
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  &#125;
&#125;
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<h4 id="8-2-2、自定义类来实现Aop"><a href="#8-2-2、自定义类来实现Aop" class="headerlink" title="8.2.2、自定义类来实现Aop"></a>8.2.2、自定义类来实现Aop</h4><p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="java">public class DiyPointcut &#123;

   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;
   
&#125;
</code></pre>
<p>去spring中配置</p>
<pre><code class="xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  &#125;
&#125;
</code></pre>
<h4 id="8-2-3、使用注解实现"><a href="#8-2-3、使用注解实现" class="headerlink" title="8.2.3、使用注解实现"></a>8.2.3、使用注解实现</h4><p>第一步：编写一个注解实现的增强类</p>
<pre><code class="java">package com.kuang.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class AnnotationPointcut &#123;
   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;

   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;

   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable &#123;
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  &#125;
&#125;
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
<h2 id="九、声明式事务"><a href="#九、声明式事务" class="headerlink" title="九、声明式事务"></a>九、声明式事务</h2><h3 id="9-1、Spring的事务管理"><a href="#9-1、Spring的事务管理" class="headerlink" title="9.1、Spring的事务管理"></a>9.1、Spring的事务管理</h3><p>​        Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li><p>优点：将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p>
</li>
<li><p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li><p>一般情况下比编程式事务好用。</p>
</li>
<li><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p>
</li>
<li><p>将事务管理作为横切关注点，通过aop方法模块化。</p>
</li>
</ul>
<h3 id="9-2、通过Spring-AOP框架支持声明式事务管理"><a href="#9-2、通过Spring-AOP框架支持声明式事务管理" class="headerlink" title="9.2、通过Spring AOP框架支持声明式事务管理"></a>9.2、通过Spring AOP框架支持声明式事务管理</h3><p>​        使用Spring管理事务，注意<strong>头文件的约束导入 : tx</strong></p>
<pre><code class="xml">&lt;beans xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<h4 id="9-2-1、spring事务传播特性："><a href="#9-2-1、spring事务传播特性：" class="headerlink" title="9.2.1、spring事务传播特性："></a>9.2.1、spring事务传播特性：</h4><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<h4 id="9-2-2、配置AOP"><a href="#9-2-2、配置AOP" class="headerlink" title="9.2.2、配置AOP"></a>9.2.2、配置AOP</h4><p>导入aop的头文件！</p>
<pre><code class="xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#ff7d73>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/">
        <h2>
            Spring设计模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><h2 id="一、解释器设计模式"><a href="#一、解释器设计模式" class="headerlink" title="一、解释器设计模式"></a>一、解释器设计模式</h2><p>​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用<strong>解释器设计模式</strong>来做。</p>
<p>​        此模式基于<strong>表达式和评估器</strong>部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个上下文中进行的。</p>
<p>​        Spring主要以<strong>Spring Expression Language</strong>（Spel）为例。</p>
<p>​        这里提个醒，SpEL是一种由Spring的<strong>org.springframework.expression.ExpressionParser</strong>实现分析和执行的语言。</p>
<p>​        这些实现使用作为字符串给出的Spel表达式，并将它们转换为<strong>org.springframework.expression.Expression的</strong>实例。上</p>
<p>​        下文组件由<strong>org.springframework.expression.EvaluationContext</strong>实现表示，例如：StandardEvaluationContext。</p>
<p>举个Spel的一个例子：</p>
<pre><code class="Java">Writer writer = new Writer();
writer.setName(&quot;Writer&#39;s name&quot;);
StandardEvaluationContext modifierContext = new StandardEvaluationContext(subscriberContext);
modifierContext.setVariable(&quot;name&quot;, &quot;Overriden writer&#39;s name&quot;);
parser.parseExpression(&quot;name = #name&quot;).getValue(modifierContext);
System.out.println(&quot;writer&#39;s name is : &quot; + writer.getName());
</code></pre>
<p>​        输出应打印“Overriden writer’s name”。如你所见，一个对象的属性是通过一个表达式<code>name = #name</code>进行修改的，这个表达式只有在<code>ExpressionParser</code>才能理解，因为提供了<code>context</code>（前面的样例中的<code>modifierContext</code>实例）。</p>
<h2 id="二、建设者模式"><a href="#二、建设者模式" class="headerlink" title="二、建设者模式"></a>二、建设者模式</h2><p>​        <strong>建设者设计模式</strong>是属于创建对象模式三剑客的第一种模式。<strong>该模式用于简化复杂对象的构造</strong>。要理解这个概念，想象一个说明程序员简历的对象。在这个对象中，我们想存储个人信息（名字，地址等）以及技术信息（知识语言，已实现的项目等）。该对象的构造可能如下所示：</p>
<pre><code class="Java">// with constructor
Programmer programmer = new Programmer(&quot;first name&quot;, &quot;last name&quot;, &quot;address Street 39&quot;, &quot;ZIP code&quot;, &quot;City&quot;, &quot;Country&quot;, birthDateObject, new String[] &#123;&quot;Java&quot;, &quot;PHP&quot;, &quot;Perl&quot;, &quot;SQL&quot;&#125;, new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);

// or with setters
Programmer programmer = new Programmer();
programmer.setName(&quot;first name&quot;);
programmer.setLastName(&quot;last name&quot;);
// ... multiple lines after
programmer.setProjects(new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);
</code></pre>
<p>​        Builder允许我们通过使用将值传递给父类的内部构建器对象来清楚地分解对象构造。所以对于我们这个程序员简历的对象的创建，构建器可以看起来像：</p>
<pre><code class="Java">public class BuilderTest &#123;

  @Test
  public void test() &#123;
    Programmer programmer = new Programmer.ProgrammerBuilder()
            .setFirstName(&quot;F&quot;)
            .setLastName(&quot;L&quot;)
            .setCity(&quot;City&quot;)
            .setZipCode(&quot;0000A&quot;)
            .setAddress(&quot;Street 39&quot;)
            .setLanguages(new String[] &#123;&quot;bash&quot;, &quot;Perl&quot;&#125;)
            .setProjects(new String[] &#123;&quot;Linux kernel&quot;&#125;).build();
    assertTrue(&quot;Programmer should be &#39;F L&#39; but was &#39;&quot;+ programmer+&quot;&#39;&quot;, programmer.toString().equals(&quot;F L&quot;));
  &#125;

&#125;

class Programmer &#123;
  private String firstName;
  private String lastName;
  private String address;
  private String zipCode;
  private String city;
  private String[] languages;
  private String[] projects;

  private Programmer(String fName, String lName, String addr, String zip, String city, String[] langs, String[] projects) &#123;
    this.firstName = fName;
    this.lastName = lName;
    this.address = addr;
    this.zipCode = zip;
    this.city = city;
    this.languages = langs;
    this.projects = projects;
  &#125;

  public static class ProgrammerBuilder &#123;
    private String firstName;
    private String lastName;
    private String address;
    private String zipCode;
    private String city;
    private String[] languages;
    private String[] projects;

    public ProgrammerBuilder setFirstName(String firstName) &#123;
      this.firstName = firstName;
      return this;
    &#125;

    public ProgrammerBuilder setLastName(String lastName) &#123;
      this.lastName = lastName;
      return this;
    &#125;

    public ProgrammerBuilder setAddress(String address) &#123;
      this.address = address;
      return this;
    &#125;

    public ProgrammerBuilder setZipCode(String zipCode) &#123;
      this.zipCode = zipCode;
      return this;
    &#125;

    public ProgrammerBuilder setCity(String city) &#123;
      this.city = city;
      return this;
    &#125;

    public ProgrammerBuilder setLanguages(String[] languages) &#123;
      this.languages = languages;
      return this;
    &#125;
    public ProgrammerBuilder setProjects(String[] projects) &#123;
      this.projects = projects;
      return this;
    &#125;

    public Programmer build() &#123;
      return new Programmer(firstName, lastName, address, zipCode, city, languages, projects);
    &#125;
  &#125;

  @Override
  public String toString() &#123;
    return this.firstName + &quot; &quot;+this.lastName;
  &#125;

&#125;
</code></pre>
<p>​        可以看出，构建器后面隐藏了对象构造的复杂性，内部静态类接受链接方法的调用。</p>
<p>​        在Spring中，我们可以在<strong>org.springframework.beans.factory.support.BeanDefinitionBuilder</strong>类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。我们可以在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/09/16/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84bean%E5%B7%A5%E5%8E%82%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">bean工厂后处理器的</a>文章中看到它，<code>BeanDefinitionBuilder</code>包含几个方法，它们为<strong>AbstractBeanDefinition</strong>抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：</p>
<pre><code class="java">public class BeanDefinitionBuilder &#123;
    /**
        * The &#123;@code BeanDefinition&#125; instance we are creating.
    */
    private AbstractBeanDefinition beanDefinition;

    // ... some not important methods for this article

    // Some of building methods
    /**
    * Set the name of the parent definition of this bean definition.
    */
    public BeanDefinitionBuilder setParentName(String parentName) &#123;
        this.beanDefinition.setParentName(parentName);
        return this;
    &#125;

    /**
    * Set the name of the factory method to use for this definition.
    */
    public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) &#123;
        this.beanDefinition.setFactoryMethodName(factoryMethod);
        return this;
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    * @deprecated since Spring 2.5, in favor of &#123;@link #addConstructorArgValue&#125;
    */
    @Deprecated
    public BeanDefinitionBuilder addConstructorArg(Object value) &#123;
        return addConstructorArgValue(value);
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    */
    public BeanDefinitionBuilder addConstructorArgValue(Object value) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
        this.constructorArgIndex++, value);
        return this;
    &#125;

    /**
    * Add a reference to a named bean as a constructor arg.
    * @see #addConstructorArgValue(Object)
    */
    public BeanDefinitionBuilder addConstructorArgReference(String beanName) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
            this.constructorArgIndex++, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Add the supplied property value under the given name.
    */
    public BeanDefinitionBuilder addPropertyValue(String name, Object value) &#123;
        this.beanDefinition.getPropertyValues().add(name, value);
        return this;
    &#125;

    /**
    * Add a reference to the specified bean name under the property specified.
    * @param name the name of the property to add the reference to
    * @param beanName the name of the bean being referenced
    */
    public BeanDefinitionBuilder addPropertyReference(String name, String beanName) &#123;
        this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Set the init method for this definition.
    */
    public BeanDefinitionBuilder setInitMethodName(String methodName) &#123;
        this.beanDefinition.setInitMethodName(methodName);
        return this;
    &#125;

    // Methods that can be used to construct BeanDefinition
    /**
    * Return the current BeanDefinition object in its raw (unvalidated) form.
    * @see #getBeanDefinition()
    */
    public AbstractBeanDefinition getRawBeanDefinition() &#123;
        return this.beanDefinition;
    &#125;

    /**
    * Validate and return the created BeanDefinition object.
    */
    public AbstractBeanDefinition getBeanDefinition() &#123;
        this.beanDefinition.validate();
        return this.beanDefinition;
    &#125;
&#125;
</code></pre>
<h2 id="三、工厂模式"><a href="#三、工厂模式" class="headerlink" title="三、工厂模式"></a>三、工厂模式</h2><p>​        创建对象模式三剑客的第二个成员是<strong>工厂方法设计模式</strong>。它完全适于使用<strong>动态环境</strong>作为Spring框架。实际上，<strong>这种模式允许通过公共静态方法对象进行初始化，称为工厂方法</strong>。在这个概念中，我们需要定义一个接口来创建对象。但是创建是由使用相关对象的类创建的。</p>
<p>​        但是在跳到Spring世界之前，让我们用Java代码做一个例子：</p>
<pre><code class="Java">public class FactoryMethodTest &#123;

    @Test
    public void test() &#123;
        Meal fruit = Meal.valueOf(&quot;banana&quot;);
        Meal vegetable = Meal.valueOf(&quot;carrot&quot;);
        assertTrue(&quot;Banana should be a fruit but is &quot;+fruit.getType(), fruit.getType().equals(&quot;fruit&quot;));
        assertTrue(&quot;Carrot should be a vegetable but is &quot;+vegetable.getType(),                                                     vegetable.getType().equals(&quot;vegetable&quot;));
    &#125;

&#125;

class Meal &#123;

    private String type;

    public Meal(String type) &#123;
        this.type = type;
    &#125;

    public String getType() &#123;
        return this.type;
    &#125;

    // Example of factory method - different object is created depending on current context
    public static Meal valueOf(String ingredient) &#123;
        if (ingredient.equals(&quot;banana&quot;)) &#123;
            return new Meal(&quot;fruit&quot;);
        &#125;
        return new Meal(&quot;vegetable&quot;);
    &#125;
&#125;
</code></pre>
<p>​        在Spring中，我们可以通过指定的工厂方法创建bean。该方法与以前代码示例中看到的valueOf方法完全相同。它是静态的，可以采取没有或多个参数。为了更好地了解案例，让我们来看一下实例。首先搞定下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;welcomerBean&quot; class=&quot;com.mysite.Welcomer&quot; factory-method=&quot;createWelcomer&quot;&gt;
    &lt;constructor-arg ref=&quot;messagesLocator&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messagesLocator&quot; class=&quot;com.mysite.MessageLocator&quot;&gt;
    &lt;property name=&quot;messages&quot; value=&quot;messages_file.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>​        现在请关注这个bean的初始化：</p>
<pre><code class="java">public class Welcomer &#123;
    private String message;

    public Welcomer(String message) &#123;
        this.message = message;
    &#125;

    public static Welcomer createWelcomer(MessageLocator messagesLocator) &#123;
        Calendar cal = Calendar.getInstance();
        String msgKey = &quot;welcome.pm&quot;;
        if (cal.get(Calendar.AM_PM) == Calendar.AM) &#123;
            msgKey = &quot;welcome.am&quot;;
        &#125;
        return new Welcomer(messagesLocator.getMessageByKey(msgKey));
    &#125;
&#125;
</code></pre>
<p>​        当Spring将构造welcomerBean时，它不会通过传统的构造函数，而是通过定义的静态工厂方法createWelcomer来实现。还要注意，这个方法接受一些参数（MessageLocator bean的实例包含所有可用的消息） 标签，通常保留给传统的构造函数。</p>
<h2 id="四、抽象工厂"><a href="#四、抽象工厂" class="headerlink" title="四、抽象工厂"></a>四、抽象工厂</h2><p>​        <strong>抽象的工厂设计模式</strong>，看起来类似于工厂方法。不同之处在于，我们可以将抽象工厂视为这个词的工业意义上的工厂，即。作为提供所需对象的东西。工厂部件有：抽象工厂，抽象产品，产品和客户。更准确地说，<strong>抽象工厂定义了构建对象的方法</strong>。抽象产品是这种结构的结果。产品是具有同样结构的具体结果。客户是要求创造产品来抽象工厂的人。</p>
<p>​        同样的，在进入Spring的细节之前，我们将首先通过示例Java代码说明这个概念：</p>
<pre><code class="java">public class FactoryTest &#123;

    // Test method which is the client
    @Test
    public void test() &#123;
        Kitchen factory = new KitchenFactory();
        KitchenMeal meal = factory.getMeal(&quot;P.1&quot;);
        KitchenMeal dessert = factory.getDessert(&quot;I.1&quot;);
        assertTrue(&quot;Meal&#39;s name should be &#39;protein meal&#39; and was &#39;&quot;+meal.getName()+&quot;&#39;&quot;, meal.getName().equals(&quot;protein meal&quot;));
        assertTrue(&quot;Dessert&#39;s name should be &#39;ice-cream&#39; and was &#39;&quot;+dessert.getName()+&quot;&#39;&quot;, dessert.getName().equals(&quot;ice-cream&quot;));
    &#125;

&#125;

// abstract factory
abstract class Kitchen &#123;
    public abstract KitchenMeal getMeal(String preferency);
    public abstract KitchenMeal getDessert(String preferency);
&#125;

// concrete factory
class KitchenFactory extends Kitchen &#123;
    @Override
    public KitchenMeal getMeal(String preferency) &#123;
        if (preferency.equals(&quot;F.1&quot;)) &#123;
            return new FastFoodMeal();
        &#125; else if (preferency.equals(&quot;P.1&quot;)) &#123;
            return new ProteinMeal();
        &#125;
        return new VegetarianMeal();
    &#125;

    @Override
    public KitchenMeal getDessert(String preferency) &#123;
        if (preferency.equals(&quot;I.1&quot;)) &#123;
            return new IceCreamMeal();
        &#125;
        return null;
    &#125;
&#125;

// abstract product
abstract class KitchenMeal &#123;
    public abstract String getName();
&#125;

// concrete products
class ProteinMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;protein meal&quot;;
    &#125;
&#125;

class VegetarianMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;vegetarian meal&quot;;
    &#125;
&#125;

class FastFoodMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;fast-food meal&quot;;
    &#125;
&#125;

class IceCreamMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;ice-cream&quot;;
    &#125;
&#125;
</code></pre>
<p>​        我们可以在这个例子中看到，<strong>抽象工厂封装了对象的创建</strong>。对象创建可以使用与经典构造函数一样使用的工厂方法模式。在Spring中，工厂的例子是<strong>org.springframework.beans.factory.BeanFactory</strong>。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，<strong>getBean</strong>方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。</p>
<p>​        在<code>BeanFactory</code>的实现中，我们可以区分：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>；</li>
<li><code>XmlWebApplicationContext</code>；</li>
<li><code>StaticWebApplicationContext</code>；</li>
<li><code>StaticPortletApplicationContext</code>；</li>
<li><code>GenericApplicationContext</code>；</li>
<li><code>StaticApplicationContext</code>。</li>
</ul>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;file:test-context.xml&quot;&#125;)
public class TestProduct &#123;

    @Autowired
    private BeanFactory factory;

    @Test
    public void test() &#123;
        System.out.println(&quot;Concrete factory is: &quot;+factory.getClass());
        assertTrue(&quot;Factory can&#39;t be null&quot;, factory != null);
        ShoppingCart cart = (ShoppingCart) factory.getBean(&quot;shoppingCart&quot;);
        assertTrue(&quot;Shopping cart object can&#39;t be null&quot;, cart != null);
        System.out.println(&quot;Found shopping cart bean:&quot;+cart.getClass());
    &#125;
&#125;
</code></pre>
<p>​        在这种情况下，抽象工厂由BeanFactory接口表示。</p>
<p>​        具体工厂是在第一个System.out中打印的，是<strong>org.springframework.beans.factory.support.DefaultListableBeanFactory</strong>的实例。它的抽象产物是一个对象。在我们的例子中，具体的产品就是被强转为ShoppingCart实例的抽象产品（Object）。</p>
<h2 id="五、代理模式"><a href="#五、代理模式" class="headerlink" title="五、代理模式"></a>五、代理模式</h2><p>​        面向对象编程（OOP）可能是编程中最流行的概念。然而，Spring引入了另一种编码规范，<strong>面向切面编程</strong>（AOP）。为了简化定义，AOP是面向系统特定点的一种编程，如：异常抛出，特定类别方法的执行等。AOP允许在执行这些特定点之前或之后执行补充动作。如何实现这种操作？它可以**通过监听器(listeners)**进行。但在这种情况下，我们应该在只要可能存在调用的地方都需要定义监听器来进行监听（比如在一个方法的开始的地方）。这就是为什么Spring不采用这个idea。相反，Spring实现了一种能够通过额外的方法调用完成任务的设计模式 - <strong>代理设计模式</strong>。</p>
<p>​        代理就像对象的镜像一样。也正因为如此，代理对象不仅可以覆盖真实对象，还可以扩展其功能。因此，对于只能在屏幕上打印一些文本的对象，我们可以添加另一个对象来过滤显示单词。可以通过代理来定义第二个对象的调用。代理是封装真实对象的对象。例如，如果您尝试调用Waiter bean，那么您将调用该Bean的代理，其行为方式完全相同。</p>
<p>​        代理设计模式的一个很好的例子是<strong>org.springframework.aop.framework.ProxyFactoryBean</strong>。该工厂根据Spring bean构建AOP代理。该类实现了定义**getObject()**方法的<code>FactoryBean</code>接口。此方法用于将需求<code>Bean</code>的实例返回给<code>bean factory</code>。在这种情况下，它不是返回的实例，而是<code>AOP代理</code>。在执行代理对象的方法之前，可以通过调用补充方法来进一步“修饰”代理对象(其实所谓的静态代理不过是在装饰模式上加了个要不要你来干动作行为而已，而不是装饰模式什么也不做就加了件衣服，其他还得由你来全权完成)。</p>
<p><code>ProxyFactory</code>的一个例子是：</p>
<pre><code class="java">public class TestProxyAop &#123;

    @Test
    public void test() &#123;
        ProxyFactory factory = new ProxyFactory(new House());
        factory.addInterface(Construction.class);
        factory.addAdvice(new BeforeConstructAdvice());
        factory.setExposeProxy(true);

        Construction construction = (Construction) factory.getProxy();
        construction.construct();
        assertTrue(&quot;Construction is illegal. &quot;
                   + &quot;Supervisor didn&#39;t give a permission to build &quot;
                   + &quot;the house&quot;, construction.isPermitted());
    &#125;

&#125;

interface Construction &#123;
    public void construct();
    public void givePermission();
    public boolean isPermitted();
&#125;

class House implements Construction&#123;

    private boolean permitted = false;

    @Override
    public boolean isPermitted() &#123;
        return this.permitted;
    &#125;

    @Override
    public void construct() &#123;
        System.out.println(&quot;I&#39;m constructing a house&quot;);
    &#125;

    @Override
    public void givePermission() &#123;
        System.out.println(&quot;Permission is given to construct a simple house&quot;);
        this.permitted = true;
    &#125;
&#125;

class BeforeConstructAdvice implements MethodBeforeAdvice &#123;

    @Override
    public void before(Method method, Object[] arguments, Object target) throws Throwable &#123;
        if (method.getName().equals(&quot;construct&quot;)) &#123;
            ((Construction) target).givePermission();
        &#125;
    &#125;

&#125;
</code></pre>
<p>​        这个测试应该通过，因为我们不直接在House实例上操作，而是代理它。代理调用第一个<code>BeforeConstructAdvice</code>的<code>before</code>方法（指向在执行目标方法之前执行，在我们的例子中为<code>construct()</code>）通过它，给出了一个“权限”来构造对象的字段（house）。代理层提供了一个额外新功能，因为它可以简单地分配给另一个对象。要做到这一点，我们只能在before方法之前修改过滤器。</p>
<h2 id="六、复合模式"><a href="#六、复合模式" class="headerlink" title="六、复合模式"></a>六、复合模式</h2><p>​        另一种结构模式是<strong>复合模式</strong>。在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/07/20/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)">Spring中设计模式</a>的第一篇文章中，我们使用构建器来构造复杂对象。另一种实现方法是使用复合模式。这种模式是<strong>基于具有共同行为的多个对象的存在</strong>，用于构建更大的对象。较大的对象仍然具有与最小对象相同的特征。那么用它来定义相同的行为。</p>
<p>​        复合对象的非Spring示例可以是一个写入HTML的文本对象，由包含span或em标签的段落组成：</p>
<pre><code class="java">public class CompositeTest &#123;

    @Test
    public void test() &#123;
        TextTagComposite composite = new PTag();
        composite.addTag(new SpanTag());
        composite.addTag(new EmTag());

        // sample client code
        composite.startWrite();
        for (TextTag leaf : composite.getTags()) &#123;
            leaf.startWrite();
            leaf.endWrite();
        &#125;
        composite.endWrite();
        assertTrue(&quot;Composite should contain 2 tags but it contains &quot;+composite.getTags().size(), composite.getTags().size() == 2);
    &#125;

&#125;

interface TextTag &#123;
    public void startWrite();
    public void endWrite();
&#125;

interface TextTagComposite extends TextTag &#123;
    public List&lt;TextTag&gt; getTags();
    public void addTag(TextTag tag);
&#125;

class PTag implements TextTagComposite &#123;
    private List&lt;TextTag&gt; tags = new ArrayList&lt;TextTag&gt;();

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;p&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/p&gt;&quot;);
    &#125;

    @Override
    public List&lt;TextTag&gt; getTags() &#123;
        return tags;
    &#125;

    @Override
    public void addTag(TextTag tag) &#123;
        tags.add(tag);
    &#125;
&#125;

class SpanTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;span&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/span&gt;&quot;);
    &#125;

&#125;

class EmTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;em&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/em&gt;&quot;);
    &#125;

&#125;
</code></pre>
<p>​        在这种情况下，可以看到一个复合对象。我们可以区分复合与非复合对象，因为第一个可以容纳一个或多个非复合对象（<code>PTag</code>类中的<code>private List tags</code>字段）。非复合对象称为<strong>叶子</strong>。<code>TextTag</code>接口被称为<strong>组件</strong>，因为它为两个对象类型提供了共同的行为规范(有点像<code>Linux</code>文件管理系统的有共同点的文件放在一个文件夹下进行管理，其实就是节点管理)。</p>
<p>​        在<code>Spring</code>世界中，我们检索复合对象的概念是<strong>org.springframework.beans.BeanMetadataElement</strong>接口，用于配置<code>bean</code>对象。它是所有继承对象的基本界面。</p>
<p>​        现在，在一方面，我们有一个叶子，由<strong>org.springframework.beans.factory.parsing.BeanComponentDefinition</strong>表示，另一边是复合<strong>org.springframework.beans.factory.parsing.CompositeComponentDefinition</strong>。</p>
<p>​        <code>CompositeComponentDefinition</code>类似于组件，因为它包含<strong>addNestedComponent（ComponentDefinition component）</strong>方法，它允许将叶子添加到私有final列表中<code>nestedComponents</code>。您可以看到，由于此列表，<code>BeanComponentDefinition</code>和<code>CompositeComponentDefinition</code>的组件是<strong>org.springframework.beans.factory.parsing.ComponentDefinition</strong>。</p>
<p><img src="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg" alt="img"></p>
<h2 id="七、策略模式"><a href="#七、策略模式" class="headerlink" title="七、策略模式"></a>七、策略模式</h2><p>​        <strong>策略设计模式</strong>。<strong>策略定义了通过不同方式完成相同事情的几个对象</strong>。完成任务的方式取决于采用的策略。举个例子说明，我们可以去一个国家。我们可以乘公共汽车，飞机，船甚至汽车去那里。所有这些方法将把我们运送到目的地国家。但是，我们将通过检查我们的银行帐户来选择最适应的方式。如果我们有很多钱，我们将采取最快的方式（可能是私人飞行）。如果我们没有足够的话，我们会采取最慢的（公车，汽车）。该银行账户作为确定适应策略的因素。</p>
<p>​        Spring在<strong>org.springframework.web.servlet.mvc.multiaction.MethodNameResolver</strong>类(过时，但不影响拿来研究)中使用策略设计模式。它是<code>MultiActionController</code>(同样过时)的参数化实现。在开始解释策略之前，我们需要了解MultiActionController的实用性。这个类允许同一个类处理几种类型的请求。</p>
<p>​        作为Spring中的每个控制器，MultiActionController执行方法来响应提供的请求。策略用于检测应使用哪种方法。解析过程在MethodNameResolver实现中实现，例如在同一个包中的<strong>ParameterMethodNameResolver中</strong>。方法可以通过多个条件解决：属性映射，HTTP请求参数或URL路径。</p>
<pre><code class="java">@Override
public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException &#123;
    String methodName = null;

    // Check parameter names where the very existence of each parameter
    // means that a method of the same name should be invoked, if any.
    if (this.methodParamNames != null) &#123;
        for (String candidate : this.methodParamNames) &#123;
            if (WebUtils.hasSubmitParameter(request, candidate)) &#123;
                methodName = candidate;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                                 &quot;&#39; based on existence of explicit request parameter of same name&quot;);
                &#125;
                break;
            &#125;
        &#125;
    &#125;

    // Check parameter whose value identifies the method to invoke, if any.
    if (methodName == null &amp;&amp; this.paramName != null) &#123;
        methodName = request.getParameter(this.paramName);
        if (methodName != null) &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                             &quot;&#39; based on value of request parameter &#39;&quot; + this.paramName + &quot;&#39;&quot;);
            &#125;
        &#125;
    &#125;

    if (methodName != null &amp;&amp; this.logicalMappings != null) &#123;
        // Resolve logical name into real method name, if appropriate.
        String originalName = methodName;
        methodName = this.logicalMappings.getProperty(methodName, methodName);
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Resolved method name &#39;&quot; + originalName + &quot;&#39; to handler method &#39;&quot; + methodName + &quot;&#39;&quot;);
        &#125;
    &#125;

    if (methodName != null &amp;&amp; !StringUtils.hasText(methodName)) &#123;
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Method name &#39;&quot; + methodName + &quot;&#39; is empty: treating it as no method name found&quot;);
        &#125;
        methodName = null;
    &#125;

    if (methodName == null) &#123;
        if (this.defaultMethodName != null) &#123;
            // No specific method resolved: use default method.
            methodName = this.defaultMethodName;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Falling back to default handler method &#39;&quot; + this.defaultMethodName + &quot;&#39;&quot;);
            &#125;
        &#125;
        else &#123;
            // If resolution failed completely, throw an exception.
            throw new NoSuchRequestHandlingMethodException(request);
        &#125;
    &#125;

    return methodName;
&#125;
</code></pre>
<p>​        正如我们在前面的代码中可以看到的，方法的名称通过提供的参数映射，URL中的预定义属性或参数存在来解决（默认情况下，该参数的名称是action）。</p>
<h2 id="八、模板模式"><a href="#八、模板模式" class="headerlink" title="八、模板模式"></a>八、模板模式</h2><p>​        <strong>模板方法</strong>。此模式定义了类行为的骨架，并将子步骤的某些步骤的延迟执行(具体就是下面例子中一个方法放在另一个方法中，只有调用另一方方法的时候这个方法才会执行,而且还可能会在其他行为方法之后按顺序执行)。其中写了一种方法(下面例子中的construct())，注意定义为final，起着同步器的角色。它以给定的顺序执行由子类定义的方法。在现实世界中，我们可以将模板方法与房屋建设进行比较。独立于建造房屋的公司，我们需要从建立基础开始，只有在我们完成之后才能做其他的工作。这个执行逻辑将被保存在一个我们不能改变的方法中。例如基础建设或刷墙会被作为一个模板方法中的方法，具体到建筑房屋的公司。我们可以在给定的例子中看到它：</p>
<pre><code class="java">public class TemplateMethod &#123;

  public static void main(String[] args) &#123;
    HouseAbstract house = new SeaHouse();
    house.construct();
  &#125;

&#125;

abstract class HouseAbstract &#123;
  protected abstract void constructFoundations();
  protected abstract void constructWall();

  // template method
  public final void construct() &#123;
    constructFoundations();
    constructWall();
  &#125;
&#125;

class EcologicalHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Making foundations with wood&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Making wall with wood&quot;);
  &#125;

&#125;

class SeaHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Constructing very strong foundations&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Constructing very strong wall&quot;);
  &#125;

&#125;
</code></pre>
<p>​        该代码应该输出：</p>
<pre><code class="java">Constructing very strong foundations
Constructing very strong wall
</code></pre>
<p>​        Spring在<strong>org.springframework.context.support.AbstractApplicationContext</strong>类中使用模板方法。他们不是一个模板方法（在我们的例子中是construct ），而是多个。例如，<strong>getsFreshBeanFactory</strong>返回内部<code>bean工厂</code>的新版本，调用两个抽象方法：<code>refreshBeanFactory</code>（刷新工厂bean）和<code>getBeanFactory</code>（以获取更新的工厂bean）。这个方法和其他一些方法一样，用在<strong>public void refresh()<strong>中，抛出</strong>构造应用程序上下文的BeansException，IllegalStateException</strong>方法(这里会在后面Spring中与应用程序上下文分析中再次提到)。</p>
<p>​        我们可以从同一个包中的GenericApplicationContext找到一些通过模板方法所实现的抽象方法的实现的例子(说的有点拗口，多读几遍就好):</p>
<pre><code class="java">/**
  * Do nothing: We hold a single internal BeanFactory and rely on callers
  * to register beans through our public methods (or the BeanFactory&#39;s).
  * @see #registerBeanDefinition
  */
@Override
protected final void refreshBeanFactory() throws IllegalStateException &#123;
  if (this.refreshed) &#123;
    throw new IllegalStateException(
      &quot;GenericApplicationContext does not support multiple refresh attempts: just call &#39;refresh&#39; once&quot;);
  &#125;
  this.beanFactory.setSerializationId(getId());
  this.refreshed = true;
&#125;

@Override
protected void cancelRefresh(BeansException ex) &#123;
  this.beanFactory.setSerializationId(null);
  super.cancelRefresh(ex);
&#125;

/**
  * Not much to do: We hold a single internal BeanFactory that will never
  * get released.
  */
@Override
protected final void closeBeanFactory() &#123;
  this.beanFactory.setSerializationId(null);
&#125;

/**
  * Return the single internal BeanFactory held by this context
  * (as ConfigurableListableBeanFactory).
  */
@Override
public final ConfigurableListableBeanFactory getBeanFactory() &#123;
  return this.beanFactory;
&#125;

/**
  * Return the underlying bean factory of this context,
  * available for registering bean definitions.
  * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; You need to call &#123;@link #refresh()&#125; to initialize the
  * bean factory and its contained beans with application context semantics
  * (autodetecting BeanFactoryPostProcessors, etc).
  * @return the internal bean factory (as DefaultListableBeanFactory)
  */
public final DefaultListableBeanFactory getDefaultListableBeanFactory() &#123;
  return this.beanFactory;
&#125;
</code></pre>
<p>​        经过上面这些可以让我们发现Spring如何通过使用行为和结构设计模式来更好地组织上下文（<strong>模板方法</strong>），并通过相应<strong>策略</strong>来解决执行方法。它使用两种结构设计模式，通过<strong>代理模式</strong>来简化AOP部分并通过<strong>复合模式</strong>来构造复杂对象。</p>
<h2 id="九、原型模式"><a href="#九、原型模式" class="headerlink" title="九、原型模式"></a>九、原型模式</h2><p>​        可以通过官方文档查找有关Spring作用域中的bean作用域的文章中介绍了类似的概念(<strong>prototype</strong>)。原型设计模式与有用相同名称的(<strong>prototype</strong>)作用域有点相似。此设计模式允许通过复制已存在的对象来创建一个对象的实例。副本应该是<strong>真正的副本</strong>。这意味着新对象的所有属性应与复制对象的属性相同。如果不清楚，比一个简单的<code>JUnit</code>案例更好的说明：</p>
<pre><code class="java">public class PrototypeTest &#123;

  @Test
  public void test() &#123;
    Robot firstRobot = new Robot(&quot;Droid#1&quot;);
    Robot secondRobot = (Robot) firstRobot.clone();
    assertTrue(&quot;Cloned robot&#39;s instance can&#39;t be the same as the&quot;
      +&quot; source robot instance&quot;,
      firstRobot != secondRobot);
    assertTrue(&quot;Cloned robot&#39;s name should be &#39;&quot;+firstRobot.getName()+&quot;&#39;&quot;
      +&quot; but was &#39;&quot;+secondRobot.getName()+&quot;&#39;&quot;,
      secondRobot.getName().equals(firstRobot.getName()));
  &#125;

&#125;


class Robot implements Cloneable &#123;
  private String name;

  public Robot(String name) &#123;
    this.name = name;
  &#125;

  public String getName() &#123;
    return this.name;
  &#125;

  protected Object clone() throws CloneNotSupportedException &#123;
    return super.clone();
  &#125;
&#125;
</code></pre>
<p>​        在<code>Spring</code>中，在<strong>org.springframework.beans.factory.support.AbstractBeanFactory</strong>中使用一种特定的原型设计模式，它将初始化<code>bean原型作用域</code>。新对象基于配置文件中的bean定义。我们可以看到，在给定的例子中：</p>
<pre><code class="java">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; scope=&quot;prototype&quot;&gt;
  &lt;property name=&quot;id&quot; value=&quot;9&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;applicationContext-test.xml&quot;&#125;)
public class SpringPrototypeTest &#123;

  @Autowired
  private BeanFactory beanFactory;

  @Test
  public void test() &#123;
    ShoppingCart cart1 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart1 should be 9 but was &quot;+cart1.getId(),
      cart1.getId() == 9);
    cart1.setId(100);
    ShoppingCart cart2 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart2 should be 9 but was &quot;+cart2.getId(),
      cart2.getId() == 9);
    assertTrue(&quot;Id of second cart (&quot;+cart2.getId()+&quot;) shouldn&#39;t be the same as the first one: &quot;+cart1.getId(),
      cart1.getId() != cart2.getId());
    cart2.setId(cart1.getId());
    assertTrue(&quot;Now (after cart2.setId(cart1.getId())), the id of second cart (&quot;+cart2.getId()+&quot;) should be the same as the first one: &quot;
      +cart1.getId(), cart1.getId() == cart2.getId());
    assertTrue(&quot;Both instance shouldn&#39;t be the same&quot;, cart1 != cart2);
  &#125;

&#125;
</code></pre>
<p>​        从前面的例子可以看出，<code>ShoppingCart</code>实例是直接从bean定义创建的。最初，<code>cart1</code>和<code>cart2</code>对象的<code>id</code>值为<code>9</code>.它在测试结束时被修改，以证明两个引用都属于两个不同的对象。</p>
<h2 id="十、对象池"><a href="#十、对象池" class="headerlink" title="十、对象池"></a>十、对象池</h2><p>​        <code>Spring</code>中使用的另一个模型是<strong>对象池设计模式</strong>。其主要目的在于在一个池中保存特定数量的对象，并根据需要重新使用。通过它，我们可以改善我们想要使用<code>巨型对象</code>的响应时间。<code>巨型</code>意味着这些对象的构造需要很多时间（例如：持有数据库连接的对象），最好重用已经存在的和未获取的对象，而不是创建新对象。</p>
<p>​        Spring还使用线程池来管理其调度部分。一些示例位于<strong>org.springframework.scheduling.concurrent中</strong>。我们检索数据库（<code>Spring JDBC</code>）项目中的对象池的想法。数据库连接池不是由<code>Spring</code>直接实现的，而是适用于<code>Spring</code>工作方式的项目，如<code>C3P0</code>或<code>Jakarta Commons DBCP</code>连接池。</p>
<h2 id="十一、观察者"><a href="#十一、观察者" class="headerlink" title="十一、观察者"></a>十一、观察者</h2><p>​        当一个或几个课程正在等待具体事件时可以使用它。观察者模式由一个科目和观察员名单组成。一个很好的例子就是<code>GUI界面</code>，其中点击按钮（按钮是主题）会引起听众（观察者）启动的一些操作(再说的直白点就是电影院一场电影这个<code>subject</code>,需要<code>观众</code>(也就是观察者咯),电影产生的一些画面产生的事件，比如恐怖 电影给男人女人带来的不同的感官的感受，传播到观察者也就是观众的眼里所带来的不一样的反应，这个中间一般会添加一个<code>事件传播者</code>，在后面解释<code>Spring</code>的例子的时候会说到)，例如：打开一个新页面这个动作。可以参考下面的例子：</p>
<pre><code class="java">public class ObserverTest &#123;

  @Test
  public void test() &#123;
    Observer pageOpener = new PageOpener();
    Observer register = new Register();
    Button btn = new Button();
    btn.addListener(pageOpener);
    btn.addListener(register);
    btn.clickOn();
    assertTrue(&quot;Button should be clicked but it wasn&#39;t&quot;,
      btn.wasClicked());
    assertTrue(&quot;Page opener should be informed about click but it wasn&#39;t&quot;,
      pageOpener.wasInformed());
    assertTrue(&quot;Register should be informed about click but it wasn&#39;t&quot;,
      register.wasInformed());
  &#125;

&#125;

class Button &#123;

  private boolean clicked;
  private List&lt;observer&gt; listeners;

  public List&lt;observer&gt; getListeners() &#123;
    if (this.listeners == null) &#123;
      this.listeners = new ArrayList&lt;observer&gt;();
    &#125;
    return this.listeners;
  &#125;

  public void addListener(Observer observer) &#123;
    getListeners().add(observer);
  &#125;

  public boolean wasClicked() &#123;
    return this.clicked;
  &#125;

  public void clickOn() &#123;
    this.clicked = true;
    informAll();
  &#125;

  private void informAll() &#123;
    for (Observer observer : getListeners()) &#123;
      observer.informAboutEvent();
    &#125;
  &#125;

&#125;

abstract class Observer &#123;
  protected boolean informed;

  public void informAboutEvent() &#123;
    this.informed = true;
  &#125;

  public boolean wasInformed() &#123;
    return this.informed;
  &#125;
&#125;

class PageOpener extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Preparing download of new page&quot;);
    super.informAboutEvent();
  &#125;

&#125;

class Register extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Adding the action to register&quot;);
    super.informAboutEvent();
  &#125;
&#125;
</code></pre>
<p>​        可以看到，关于我们的<code>Button</code>实例点击的事件被发送到所有的观察者对象。从这些对象开始下载页面内容，第二个将在事件的信息保存在注册表中。在<code>Spring</code>中，观察者设计模式用于将与应用程序上下文相关的事件传输到<strong>org.springframework.context.ApplicationListener的实现</strong>。要了解它们的实现方法，我们来看一下<code>AbstractApplicationContext</code>类(老版本的代码，新版本的请自行对照)：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader
  implements ConfigurableApplicationContext, DisposableBean &#123;
  /** Statically specified listeners */
  private Set&lt;applicationlistener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;applicationlistener&lt;?&gt;&gt;();

  // some other fields and methods
  @Override
  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;
    if (this.applicationEventMulticaster != null) &#123;
      this.applicationEventMulticaster.addApplicationListener(listener);
    &#125;
    else &#123;//新版本这里直接咔嚓掉，上面的applicationEventMulticaster一旦为空，就会报错的
      this.applicationListeners.add(listener);
    &#125;
  &#125;

  /**
    * Return the list of statically specified ApplicationListeners.
    */
  public Collection&lt;applicationlistener&lt;?&gt;&gt; getApplicationListeners() &#123;
    return this.applicationListeners;
  &#125;

  /**
    * Add beans that implement ApplicationListener as listeners.
    * Doesn&#39;t affect other listeners, which can be added without being beans.
    */
  protected void registerListeners() &#123;
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;
      getApplicationEventMulticaster().addApplicationListener(listener);
    &#125;
    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String lisName : listenerBeanNames) &#123;
      getApplicationEventMulticaster().addApplicationListenerBean(lisName);
    &#125;
  &#125;
&#125;java
</code></pre>
<p>​        在提供的代码中，监听器在内部添加到应用程序上下文类中，并且在<code>registerListeners()</code>方法之后，它们被注册到由接口<strong>org.springframework.context.event.ApplicationEventMulticaster</strong>表示的适当的事件多路广播器(因为有很多listeners)。<code>EventMulticaster</code>负责管理不同的<code>listener</code>和向他们发布事件。</p>
<pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;
    private Executor taskExecutor;
    private ErrorHandler errorHandler;

    public SimpleApplicationEventMulticaster() &#123;
    &#125;

    public SimpleApplicationEventMulticaster(BeanFactory beanFactory) &#123;
        this.setBeanFactory(beanFactory);
    &#125;

    public void setTaskExecutor(Executor taskExecutor) &#123;
        this.taskExecutor = taskExecutor;
    &#125;

    protected Executor getTaskExecutor() &#123;
        return this.taskExecutor;
    &#125;

    public void setErrorHandler(ErrorHandler errorHandler) &#123;
        this.errorHandler = errorHandler;
    &#125;

    protected ErrorHandler getErrorHandler() &#123;
        return this.errorHandler;
    &#125;

    public void multicastEvent(ApplicationEvent event) &#123;
        this.multicastEvent(event, this.resolveDefaultEventType(event));
    &#125;
    //发布事件:通过池执行任务的方式来做并发处理，这样就把之前的对象池模式给利用上了
    public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123;
        ResolvableType type = eventType != null?eventType:this.resolveDefaultEventType(event);
        Iterator var4 = this.getApplicationListeners(event, type).iterator();

        while(var4.hasNext()) &#123;
            final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();
            Executor executor = this.getTaskExecutor();
            if(executor != null) &#123;
                executor.execute(new Runnable() &#123;
                    public void run() &#123;
                        SimpleApplicationEventMulticaster.this.invokeListener(listener, event);
                    &#125;
                &#125;);
            &#125; else &#123;
                this.invokeListener(listener, event);
            &#125;
        &#125;

    &#125;
...
&#125;
</code></pre>
<p>​        这次我们讲3种设计模式:用于在同一个调用作用域内创建<code>bean的原型</code>，避免重新创建巨型对象的对象池，以及将应用程序的上下文事件分派给适当的监听器的观察者。</p>
<h2 id="十二、适配器"><a href="#十二、适配器" class="headerlink" title="十二、适配器"></a>十二、适配器</h2><p>​        当我们需要在给定场景下(也就是给定接口)想要不改变自身行为而又想做到一些事情的情况下(就是我给电也就是接口了，你来做事也就是各种电器)，使用<strong>适配器设计模式</strong>(这里再说一点，就相当于我们再一个规章制度的环境下，如何去适应并达到我们期待的效果，放在架构设计这里，可以拿一个php系统和一个Java系统来说，假如两者要互相调用对方的功能，我们可以设计一套对外的api来适配)。这意味着在调用此对象之前，我们将更改使用对象而不改变机制。拿一个现实中的例子进行说明，想象一下你想要用电钻来钻一个洞。要钻一个小洞，你会使用小钻头，钻一个大的需要用大钻头。可以看下面的代码：</p>
<pre><code class="java">public class AdapterTest &#123;

  public static void main(String[] args) &#123;
    HoleMaker maker = new HoleMakerImpl();
    maker.makeHole(1);
    maker.makeHole(2);
    maker.makeHole(30);
    maker.makeHole(40);
  &#125;
&#125;

interface HoleMaker &#123;
  public void makeHole(int diameter);
&#125;

interface DrillBit &#123;
  public void makeSmallHole();
  public void makeBigHole();
&#125;

// Two adaptee objects
class BigDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    // do nothing
  &#125;

  @Override
  public void makeBigHole() &#123;
    System.out.println(&quot;Big hole is made byt WallBigHoleMaker&quot;);
  &#125;
&#125;

class SmallDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    System.out.println(&quot;Small hole is made byt WallSmallHoleMaker&quot;);
  &#125;

  @Override
  public void makeBigHole() &#123;
    // do nothing
  &#125;
&#125;

// Adapter class
class Drill implements HoleMaker &#123;

  private DrillBit drillBit;

  public Drill(int diameter) &#123;
    drillBit = getMakerByDiameter(diameter);
  &#125;

  @Override
  public void makeHole(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            drillBit.makeSmallHole();
    &#125; else &#123;
            drillBit.makeBigHole();
    &#125;
  &#125;

  private DrillBit getMakerByDiameter(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            return new SmallDrillBit();
    &#125;
    return new BigDrillBit();
  &#125;

  private boolean isSmallDiameter(int diameter) &#123;
    return diameter &lt; 10;
  &#125;
&#125;

// Client class
class HoleMakerImpl implements HoleMaker &#123;

  @Override
  public void makeHole(int diameter) &#123;
    HoleMaker maker = new Drill(diameter);
    maker.makeHole(diameter);
  &#125;
&#125;
</code></pre>
<p>以上代码的结果如下:</p>
<pre><code class="java">Small hole is made byt SmallDrillBit
Small hole is made byt SmallDrillBit
Big hole is made byt BigDrillBit
Big hole is made byt BigDrillBit
</code></pre>
<p>​        可以看到，hole 是由所匹配的DrillBit对象制成的。如果孔的直径小于10，则使用SmallDrillBit。如果它更大，我们使用BigDrillBit。</p>
<p>​        思路就是，要打洞，那就要有打洞的工具，这里提供一个电钻接口和钻头。电钻就是用来打洞的，所以，它就一个接口方法即可，接下来定义钻头的接口，无非就是钻头的尺寸标准，然后搞出两个钻头实现类出来，接下来就是把钻头和电钻主机组装起来咯，也就是<code>Drill</code>类，里面有电钻接口+钻头(根据要钻的孔大小来确定用哪个钻头)，其实也就是把几个单一的东西组合起来拥有丰富的功能，最后我们进行封装下:<code>HoleMakerImpl</code>，这样只需要根据尺寸就可以打相应的孔了，对外暴露的接口极为简单，无须管内部逻辑是多么复杂</p>
<p>​        Spring使用适配器设计模式来处理不同servlet容器中的<strong>加载时编织</strong>(<strong>load-time-weaving</strong>)。在面向切面编程（AOP）中使用<strong>load-time-weaving</strong>，一种方式是在类加载期间将AspectJ的方面注入字节码。另一种方式是对类进行编译时注入或对已编译的类进行静态注入。</p>
<p>​        我们可以从关于Spring和JBoss的处理接口这里找到一个很好的例子，它包含在<strong>org.springframework.instrument.classloading.jboss</strong>包中。我们检索<code>JBossLoadTimeWeaver类</code>负责<code>JBoss容器</code>的编织管理。然而，类加载器对于<code>JBoss 6</code>（使用<code>JBossMCAdapter</code>实例）和<code>JBoss 7/8</code>（使用<code>JBossModulesAdapter</code>实例）是不同的。根据<code>JBoss</code>版本，我们在<code>JBossLoadTimeWeaver</code>构造函数中初始化相应的适配器（与我们示例中的<code>Drill</code>的构造函数完全相同）：</p>
<pre><code class="java">public JBossLoadTimeWeaver(ClassLoader classLoader) &#123;
  private final JBossClassLoaderAdapter adapter;

  Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
  if (classLoader.getClass().getName().startsWith(&quot;org.jboss.modules&quot;)) &#123;
    // JBoss AS 7 or WildFly 8
    this.adapter = new JBossModulesAdapter(classLoader);
  &#125;
  else &#123;
    // JBoss AS 6
    this.adapter = new JBossMCAdapter(classLoader);
  &#125;
&#125;
</code></pre>
<p>​        而且，此适配器所创建的实例用于根据运行的servlet容器版本进行编织操作：</p>
<pre><code class="java">@Override
public void addTransformer(ClassFileTransformer transformer) &#123;
  this.adapter.addTransformer(transformer);
&#125;

@Override
public ClassLoader getInstrumentableClassLoader() &#123;
  return this.adapter.getInstrumentableClassLoader();
&#125;
</code></pre>
<blockquote>
<p>总结：适配器模式，其实就是我们用第一人称的视角去看世界，我想拓展我自己的技能的时候，就实行拿来主义，就好比这里的我是电钻的视角，那么我想拥有钻大孔或者小孔的功能，那就把钻头拿到手组合起来就好。</p>
<p>和装饰模式的区别：装饰模式属于第三人称的视角，也就是上帝视角！我只需要把几个功能性的组件给拿到手，进行组合一下，实现一个更加<code>niubility</code>的功能这里提前说下，这样看下面的内容能好理解些。下面解释装饰模式</p>
</blockquote>
<h2 id="十三、装饰"><a href="#十三、装饰" class="headerlink" title="十三、装饰"></a>十三、装饰</h2><p>​        这里描述的第二种设计模式看起来类似于适配器。它是<strong>装饰模式</strong>。这种设计模式的主要作用是为给定的对象添加补充角色。举个现实的例子，就拿咖啡来讲。通常越黑越苦，你可以添加（<code>装饰</code>）糖和牛奶，使咖啡不那么苦。咖啡在这里被装饰的对象，糖与牛奶是用来装饰的。可以参考下面的例子：</p>
<pre><code class="java">public class DecoratorSample &#123;

  @Test
  public void test() &#123;
    Coffee sugarMilkCoffee=new MilkDecorator(new SugarDecorator(new BlackCoffee()));
    assertEquals(sugarMilkCoffee.getPrice(), 6d, 0d);
  &#125;
&#125;

// decorated
abstract class Coffee&#123;
  protected int candied=0;
  protected double price=2d;
  public abstract int makeMoreCandied();
  public double getPrice()&#123;
    return this.price;
  &#125;
  public void setPrice(double price)&#123;
    this.price+=price;
  &#125;
&#125;
class BlackCoffee extends Coffee&#123;
  @Override
  public int makeMoreCandied()&#123;
    return 0;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.price;
  &#125;
&#125;

// abstract decorator
abstract class CoffeeDecorator extends Coffee&#123;
  protected Coffee coffee;
  public CoffeeDecorator(Coffee coffee)&#123;
    this.coffee=coffee;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.coffee.getPrice();
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return this.coffee.makeMoreCandied();
  &#125;
&#125;

// concrete decorators
class MilkDecorator extends CoffeeDecorator&#123;
  public MilkDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+1d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
class SugarDecorator extends CoffeeDecorator&#123;
  public SugarDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+3d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
</code></pre>
<p>​        上面这个简单的装饰器的小例子是基于对父方法的调用，从而改变最后的属性（我们这里是指价格和加糖多少）。在Spring中，我们在处理与Spring管理缓存同步事务的相关类中可以 发现装饰器设计模式的例子。这个类是<strong>org.springframework.cache.transaction.TransactionAwareCacheDecorator</strong>。</p>
<p>​        这个类的哪些特性证明它是<strong>org.springframework.cache.Cache</strong>对象的装饰器？首先，与我们的咖啡示例一样，<code>TransactionAwareCacheDecorator</code>的构造函数接收参数装饰对象（Cache）：</p>
<pre><code class="java">private final Cache targetCache;
/**
 * Create a new TransactionAwareCache for the given target Cache.
 * @param targetCache the target Cache to decorate
 */
public TransactionAwareCacheDecorator(Cache targetCache) &#123;
  Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
  this.targetCache = targetCache;
&#125;
</code></pre>
<p>​        其次，通过这个对象，我们可以得到一个新的行为:为给定的目标缓存创建一个新的TransactionAwareCache。这个我们可以在<code>TransactionAwareCacheDecorator</code>的注释中可以阅读到，其主要目的是提供缓存和Spring事务之间的同步级别。这是通过<strong>org.springframework.transaction.support.TransactionSynchronizationManager</strong>中的两种缓存方法实现的：<code>put</code> 和 <code>evict</code>(其实最终不还是通过<code>targetCache</code>来实现的么)：</p>
<pre><code class="java">@Override
public void put(final Object key, final Object value) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
    TransactionSynchronizationManager.registerSynchronization(
      new TransactionSynchronizationAdapter() &#123;
        @Override
        public void afterCommit() &#123;
          targetCache.put(key, value);
        &#125;
    &#125;);
  &#125;
  else &#123;
    this.targetCache.put(key, value);
  &#125;
&#125;

@Override
public void evict(final Object key) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
          TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronizationAdapter() &#123;
              @Override
              public void afterCommit() &#123;
                targetCache.evict(key);
              &#125;
          &#125;);
  &#125;
  else &#123;
    this.targetCache.evict(key);
  &#125;
&#125;
</code></pre>
<p>​        这种模式看起来类似于适配器，对吧？但是，它们还是有区别的。我们可以看到，适配器将对象适配到运行时环境，即。如果我们在JBoss 6中运行，我们使用与JBoss 7不同的类加载器。Decorator每次使用相同的主对象（Cache）工作，并且仅向其添加新行为（与本例中的Spring事务同步），另外，可以通过我在解读这个设计模式之前的说法来区分二者。</p>
<p>​        我们再以springboot的初始化来举个例子的，这块后面会进行仔细的源码分析的，这里就仅仅用设计模式来说下的:</p>
<pre><code class="java">/**
 * Event published as early as conceivably possible as soon as a &#123;@link SpringApplication&#125;
 * has been started - before the &#123;@link Environment&#125; or &#123;@link ApplicationContext&#125; is
 * available, but after the &#123;@link ApplicationListener&#125;s have been registered. The source
 * of the event is the &#123;@link SpringApplication&#125; itself, but beware of using its internal
 * state too much at this early stage since it might be modified later in the lifecycle.
 *
 * @author Dave Syer
 */
@SuppressWarnings(&quot;serial&quot;)
public class ApplicationStartedEvent extends SpringApplicationEvent &#123;

    /**
     * Create a new &#123;@link ApplicationStartedEvent&#125; instance.
     * @param application the current application
     * @param args the arguments the application is running with
     */
    public ApplicationStartedEvent(SpringApplication application, String[] args) &#123;
        super(application, args);
    &#125;

&#125;
</code></pre>
<p>​        从注释可以看出 <code>ApplicationListener</code>要先行到位的，然后就是started的时候<code>Event published</code>走起，接着就是<code>Environment</code>配置好，<code>ApplicationContext</code>进行初始化完毕，那我们去看<code>ApplicationListener</code>的源码:</p>
<pre><code class="java">/**
 * Listener for the &#123;@link SpringApplication&#125; &#123;@code run&#125; method.
 * &#123;@link SpringApplicationRunListener&#125;s are loaded via the &#123;@link SpringFactoriesLoader&#125;
 * and should declare a public constructor that accepts a &#123;@link SpringApplication&#125;
 * instance and a &#123;@code String[]&#125; of arguments. A new
 * &#123;@link SpringApplicationRunListener&#125; instance will be created for each run.
 *
 * @author Phillip Webb
 * @author Dave Syer
 */
public interface SpringApplicationRunListener &#123;

    /**
     * Called immediately when the run method has first started. Can be used for very
     * early initialization.
     */
    void started();

    /**
     * Called once the environment has been prepared, but before the
     * &#123;@link ApplicationContext&#125; has been created.
     * @param environment the environment
     */
    void environmentPrepared(ConfigurableEnvironment environment);

    /**
     * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but
     * before sources have been loaded.
     * @param context the application context
     */
    void contextPrepared(ConfigurableApplicationContext context);

    /**
     * Called once the application context has been loaded but before it has been
     * refreshed.
     * @param context the application context
     */
    void contextLoaded(ConfigurableApplicationContext context);

    /**
     * Called immediately before the run method finishes.
     * @param context the application context or null if a failure occurred before the
     * context was created
     * @param exception any run exception or null if run completed successfully.
     */
    void finished(ConfigurableApplicationContext context, Throwable exception);

&#125;
</code></pre>
<p>​        看类注释我们可以知道，需要实现此接口内所定义的这几个方法，ok，来看个实现类:</p>
<pre><code class="java">/**
 * &#123;@link SpringApplicationRunListener&#125; to publish &#123;@link SpringApplicationEvent&#125;s.
 * &lt;p&gt;
 * Uses an internal &#123;@link ApplicationEventMulticaster&#125; for the events that are fired
 * before the context is actually refreshed.
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 */
public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;

    private final SpringApplication application;

    private final String[] args;

    private final ApplicationEventMulticaster initialMulticaster;

    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;
        this.application = application;
        this.args = args;
        this.initialMulticaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;
            this.initialMulticaster.addApplicationListener(listener);
        &#125;
    &#125;

    @Override
    public int getOrder() &#123;
        return 0;
    &#125;

    @Override
    public void started() &#123;
        this.initialMulticaster
                .multicastEvent(new ApplicationStartedEvent(this.application, this.args));
    &#125;

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) &#123;
        this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(
                this.application, this.args, environment));
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;

    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        for (ApplicationListener&lt;?&gt; listener : this.application.getListeners()) &#123;
            if (listener instanceof ApplicationContextAware) &#123;
                ((ApplicationContextAware) listener).setApplicationContext(context);
            &#125;
            context.addApplicationListener(listener);
        &#125;
        this.initialMulticaster.multicastEvent(
                new ApplicationPreparedEvent(this.application, this.args, context));
    &#125;

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;
        // Listeners have been registered to the application context so we should
        // use it at this point
        context.publishEvent(getFinishedEvent(context, exception));
    &#125;

    private SpringApplicationEvent getFinishedEvent(
            ConfigurableApplicationContext context, Throwable exception) &#123;
        if (exception != null) &#123;
            return new ApplicationFailedEvent(this.application, this.args, context,
                    exception);
        &#125;
        return new ApplicationReadyEvent(this.application, this.args, context);
    &#125;

&#125;
</code></pre>
<p>​        从上可以看出，<code>EventPublishingRunListener</code>里对接口功能的实现，主要是通过<code>SpringApplication</code> <code>ApplicationEventMulticaster</code> 来实现的，自己不干活，挂个虚名，从上帝模式的角度来看，这不就是应用了装饰模式来实现的么</p>
<h2 id="十四、单例模式"><a href="#十四、单例模式" class="headerlink" title="十四、单例模式"></a>十四、单例模式</h2><p>​        <strong>单例</strong>，我们最常用的设计模式。正如我们在很多Spring Framework中关于单例和原型bean的文章(网上太多了)中已经看到过的，单例是几个bean作用域中的中的一个。此作用域在每个应用程序上下文中仅创建一个给定bean的实例。与signleton设计模式有所区别的是，Spring将实例的数量限制的作用域在整个应用程序的上下文。而Singleton设计模式在Java应用程序中是将这些实例的数量限制在给定类加载器管理的整个空间中。这意味着我们可以为两个Spring的上下文(同一份配置文件起两个容器，也就是不同端口的容器实例)使用相同的类加载器，并检索两个单例作用域的bean。</p>
<p>​        在看Spring单例应用之前，让我们来看一个Java的单例例子：</p>
<pre><code class="java">public class SingletonTest &#123;

  @Test
  public void test() &#123;
    President president1 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    President president2 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    assertTrue(&quot;Both references of President should point to the same object&quot;, president1 == president2);
    System.out.println(&quot;president1 = &quot;+president1+&quot; and president2 = &quot;+president2);
    // sample output
    // president1 = com.migo.test.President@17414c8 and president2 = com.migo.test.President@17414c8

  &#125;

&#125;

enum SingletonsHolder &#123;

  PRESIDENT(new President());

  private Object holdedObject;

  private SingletonsHolder(Object o) &#123;
          this.holdedObject = o;
  &#125;

  public Object getHoldedObject() &#123;
          return this.holdedObject;
  &#125;

&#125;

class President &#123;
&#125;
</code></pre>
<p>​        这个测试例子证明，只有一个由SingletonsHolder所持有的President实例。在Spring中，我们可以在bean工厂中找到单例应用的影子（例如在<strong>org.springframework.beans.factory.config.AbstractFactoryBean中</strong>）：</p>
<pre><code class="java">/**
 * Expose the singleton instance or create a new prototype instance.
 * @see #createInstance()
 * @see #getEarlySingletonInterfaces()
 */
@Override
public final T getObject() throws Exception &#123;
  if (isSingleton()) &#123;
    return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());
  &#125;
  else &#123;
    return createInstance();
  &#125;
&#125;
</code></pre>
<p>​        我们看到，当需求对象被视为单例时，它只被初始化一次，并且在每次使用同一个bean类的实例后返回。我们可以在给定的例子中看到，类似于我们以前看到的President情况。将测试bean定义为：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; /&gt;
</code></pre>
<p>测试用例如下所示：</p>
<pre><code class="java">public class SingletonSpringTest &#123;

  @Test
  public void test() &#123;
    // retreive two different contexts
    ApplicationContext firstContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);
    ApplicationContext secondContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);

    // prove that both contexts are loaded by the same class loader
    assertTrue(&quot;Class loaders for both contexts should be the same&quot;,
      firstContext.getClassLoader() == secondContext.getClassLoader());
    // compare the objects from different contexts
    ShoppingCart firstShoppingCart = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    ShoppingCart secondShoppingCart = (ShoppingCart) secondContext.getBean(&quot;shoppingCart&quot;);
    assertFalse(&quot;ShoppingCart instances got from different application context shouldn&#39;t be the same&quot;,
      firstShoppingCart == secondShoppingCart);

    // compare the objects from the same context
    ShoppingCart firstShoppingCartBis = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;ShoppingCart instances got from the same application context should be the same&quot;,
      firstShoppingCart == firstShoppingCartBis);
  &#125;
&#125;
</code></pre>
<p>​        这个测试案例显示了Spring单例模式与纯粹的单例设计模式的主要区别。尽管使用相同的类加载器来加载两个应用程序上下文，但是ShoppingCart的实例是不一样的。但是，当我们比较两次创建并属于相同上下文的实例时，我们认为它们是相等的。</p>
<p>​        也正因为有了单例，Spring可以控制在每个应用程序上下文中只有一个这样指定的bean的实例可用。因为适配器，Spring可以决定使用由谁来处理<code>JBoss servlet</code>容器中的加载时编织,也可以实现<code>ConfigurableListableBeanFactory</code>的相应实例。第三种设计模式，装饰器，用于向Cache对象添加同步功能，还有Springboot的容器初始化。</p>
<p>​        其实对于适配器和装饰者确实有太多的相似的地方，一个是运行时选择，一个是加料组合产生新的化学效应，还有从看待事物的角度不同得到不同的行为，适配适配，更注重面向接口的实现，而内部又根据不同情况调用面向一套接口的多套实现的实例的相应方法来实现所要实现的具体功能，装饰者更注重添油加醋，通过组合一些其他对象实例来让自己的功能实现的更加华丽一些(达到1+1&gt;2的这种效果)。</p>
<h2 id="十五、命令模式"><a href="#十五、命令模式" class="headerlink" title="十五、命令模式"></a>十五、命令模式</h2><p>​        这篇文章描述的第一个行为设计模式是<strong>命令</strong>。它允许将请求封装在一个对象内并附加一个回调动作(每次遇到所所谓的回调大家就只需要理解为一个函数方法就好，省的去浪费那么多脑子)。请求被封装在命令对象之下，而请求的结果被发送到接收者。命令本身不是由调用者执行。为了直白了解其中的主要思想，想象一下管理服务器的情况(远程通过<code>ssh</code>操作<code>Linux</code>服务器)。管理员（<code>invoker</code>）在命令行（<code>commands</code>）中启动一些操作，将结果发送到服务器（接收器）。在这里,所有这一切都是由客户端的终端(也就是我们用的<code>xshell</code>)来完成的。搞个<code>Demo</code>来说明一下(对于命令，它的动作就是执行，对于管理员来讲，我们的动作其实就是一个回车，执不执行当然是管理员说的算了，执行交给命令对象了，服务器最后就是一个展示结果)：</p>
<pre><code class="java">public class CommandTest &#123;

  // This test method is a client
  @Test
  public void test() &#123;
    Administrator admin = new Administrator();
    Server server = new Server();

    // start Apache
    admin.setCommand(new StartApache(server));
    admin.typeEnter();

    // start Tomcat
    admin.setCommand(new StartTomcat(server));
    admin.typeEnter();

    // check executed commands
    int executed = server.getExecutedCommands().size();
    assertTrue(&quot;Two commands should be executed but only &quot;+
      executed+ &quot; were&quot;, executed == 2);
  &#125;

&#125;

// commands
abstract class ServerCommand &#123;

  protected Server server;

  public ServerCommand(Server server) &#123;
    this.server = server;
  &#125;

  public abstract void execute();
&#125;

class StartTomcat extends ServerCommand &#123;

  public StartTomcat(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service tomcat7 start&quot;);
  &#125;
&#125;

class StartApache extends ServerCommand &#123;

  public StartApache(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service apache2 start&quot;);
  &#125;
&#125;

// invoker
class Administrator &#123;

  private ServerCommand command;

  public void setCommand(ServerCommand command) &#123;
    this.command = command;
  &#125;

  public void typeEnter() &#123;
    this.command.execute();
  &#125;

&#125;

// receiver
class Server &#123;

  // as in common terminals, we store executed commands in history
  private List&lt;String&gt; executedCommands = new ArrayList&lt;String&gt;();

  public void launchCommand(String command) &#123;
    System.out.println(&quot;Executing: &quot;+command+&quot; on server&quot;);
    this.executedCommands.add(command);
  &#125;

  public List&lt;String&gt; getExecutedCommands() &#123;
    return this.executedCommands;
  &#125;

&#125;
</code></pre>
<p>测试应通过并打印两个命令：</p>
<pre><code class="java">Executing: sudo service apache2 start on server
Executing: sudo service tomcat7 start on server
</code></pre>
<p>​        命令模式不仅允许封装请求（ServerCommand）并将其传输到接收器（Server），而且还可以更好地处理给定的请求。在这里，这种更好的处理是通过存储命令的执行历史。在Spring中，我们在beanFactory后置处理器的特性中来找到指令设计模式的原理。要通过快速对它们进行定义，应用程序上下文会启动后置处理器，并可以用来对创建的bean进行一些操作（这里不打算细说了，具体的我后面会专门写一篇这方面的文章，来分析其中的源码细节）。</p>
<p>​        当我们将先前Demo里呈现的命令逻辑转换并对比到<code>Spring bean工厂后处理器</code>时，我们可以区分以下<code>actors</code>：<strong>后置处理器bean</strong>(是指实现<code>BeanFactoryPostProcessor</code>接口)是命令，<strong>org.springframework.context.support.PostProcessorRegistrationDelegate</strong>是调用者(它执行<code>postProcessBeanFactory</code>方法注册所有的后置处理器bean，此处看下面第二段代码)和接收器<strong>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</strong>可以在元素（bean）构造初始化之前修改它们（例如：在初始化bean之前可以更改属性）。</p>
<p>​        另外，回顾下上面的那个Demo，和我们的Demo中的命令历史管理一样。<code>PostProcessorRegistrationDelegate</code>包含一个内部类<code>BeanPostProcessorChecker</code>，它可以记录当一个bean不符合处理条件的情况。</p>
<p>​        可以观察<code>PostProcessorRegistrationDelegate</code>中的两段代码:</p>
<pre><code class="java">/**
     * BeanPostProcessor that logs an info message when a bean is created during
     * BeanPostProcessor instantiation, i.e. when a bean is not eligible for
     * getting processed by all BeanPostProcessors.
     */
    private static class BeanPostProcessorChecker implements BeanPostProcessor &#123;

        private static final Log logger = LogFactory.getLog(BeanPostProcessorChecker.class);

        private final ConfigurableListableBeanFactory beanFactory;

        private final int beanPostProcessorTargetCount;

        public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) &#123;
            this.beanFactory = beanFactory;
            this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
        &#125;

        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;
            return bean;
        &#125;

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) &#123;
            if (bean != null &amp;&amp; !(bean instanceof BeanPostProcessor) &amp;&amp; !isInfrastructureBean(beanName) &amp;&amp;
                    this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount) &#123;
                if (logger.isInfoEnabled()) &#123;
                    logger.info(&quot;Bean &#39;&quot; + beanName + &quot;&#39; of type [&quot; + bean.getClass() +
                            &quot;] is not eligible for getting processed by all BeanPostProcessors &quot; +
                            &quot;(for example: not eligible for auto-proxying)&quot;);
                &#125;
            &#125;
            return bean;
        &#125;

        private boolean isInfrastructureBean(String beanName) &#123;
            if (beanName != null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName)) &#123;
                BeanDefinition bd = this.beanFactory.getBeanDefinition(beanName);
                return RootBeanDefinition.ROLE_INFRASTRUCTURE == bd.getRole();
            &#125;
            return false;
        &#125;
    &#125;
</code></pre>
<p>​        定义后的调用,用的就是<code>ConfigurableListableBeanFactory</code>的实例(看<code>BeanPostProcessorChecker</code>注释):</p>
<pre><code class="java">public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  //BeanPostProcessorChecker
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                    internalPostProcessors.add(pp);
                &#125;
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        sortPostProcessors(beanFactory, orderedPostProcessors);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(beanFactory, internalPostProcessors);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    &#125;
</code></pre>
<blockquote>
<p>总结一个过程就是，我要BeanFactory里面得到对象(也就是为了得到一个命令的执行结果)，那么，想要在得到对象的时候就已经实现了一些对其修改的想法，那么就通过后置处理器，也是就实现了后置处理器接口的beans(命令里可以通过传入不同的参数来得到不同结果，或者对命令的脚本进行修改)，然后还需要一个执行者(我们在做自动化运维的时候，不止操作一个脚本，这里的<code>PostProcessorRegistrationDelegate</code>就是集中来管理这些的)，最后得到的结果就由<code>BeanFactory</code>来展示咯。</p>
</blockquote>
<h2 id="十六、访问者模式"><a href="#十六、访问者模式" class="headerlink" title="十六、访问者模式"></a>十六、访问者模式</h2><p>​        接下来要介绍的一个行为设计模式是<strong>Visitor</strong>:抽象一点就是通过另一种类型的对象来使一个对象访问。在这个简短定义中，使用这个设计模式中的对象将被视为访问者或对象可被访问。第一个访问者要有可访问支持。这个模式的一个现实的例子可以是一个汽车质检员，他们检查一些汽车零件，比如轮子，制动器和发动机，以判断汽车质量是否合格。我们来做个JUnit测试用例：</p>
<pre><code class="java">public class VisitorTest &#123;

  @Test
  public void test() &#123;
    CarComponent car = new Car();
    Mechanic mechanic = new QualifiedMechanic();
    car.accept(mechanic);
    assertTrue(&quot;After qualified mechanics visit, the car should be broken&quot;,
      car.isBroken());
    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();
    car.accept(nonqualifiedMechanic);
    assertFalse(&quot;Car shouldn&#39;t be broken becase non qualified mechanic &quot; +
      &quot; can&#39;t see breakdowns&quot;, car.isBroken());
  &#125;

&#125;

// visitor
interface Mechanic &#123;
  public void visit(CarComponent element);
  public String getName();
&#125;

class QualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;qualified&quot;;
  &#125;
&#125;

class NonQualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;unqualified&quot;;
  &#125;
&#125;

// visitable
abstract class CarComponent &#123;
  protected boolean broken;

  public abstract void accept(Mechanic mechanic);

  public void setBroken(boolean broken) &#123;
    this.broken = broken;
  &#125;

  public boolean isBroken() &#123;
    return this.broken;
  &#125;
&#125;

class Car extends CarComponent &#123;

  private boolean broken = false;
  private CarComponent[] components;

  public Car() &#123;
    components = new CarComponent[] &#123;
      new Wheels(), new Engine(), new Brake()
    &#125;;
  &#125;

  @Override
  public void accept(Mechanic mechanic) &#123;
    this.broken = false;
    if (mechanic.getName().equals(&quot;qualified&quot;)) &#123;
      int i = 0;
      while (i &lt; components.length &amp;&amp; this.broken == false) &#123;
        CarComponent component = components[i];
        mechanic.visit(component);
        this.broken = component.isBroken();
        i++;
      &#125;
    &#125;
    // if mechanic isn&#39;t qualified, we suppose that
    // he isn&#39;t able to see breakdowns and so
    // he considers the car as no broken
    // (even if the car is broken)
  &#125;

  @Override
  public boolean isBroken() &#123;
          return this.broken;
  &#125;
&#125;

class Wheels extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Engine extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Brake extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;
</code></pre>
<p>​        在这个例子中，我们可以看到他们有两个机制(访问者,其实就是免检和不免检)：合格和不合格。暴露于他们的可见对象是汽车。通过其接受方式，决定哪个角色应该适用于被访问者(通过代码<code>mechanic.getName().equals(&quot;qualified&quot;)</code>来判断)。当访问者合格时，Car让他分析所有组件。如果访问者不合格，Car认为其干预是无用的，并且在方法<code>isBroken()</code>中直接返回<code>false</code>(其实就是为了达到一个免检的效果)。<code>Spring在beans配置中实现了访问者设计模式</code>。为了观察，我们可以看看<strong>org.springframework.beans.factory.config.BeanDefinitionVisitor</strong>对象，该对象用于<code>解析bean元数据</code>并将其解析为<code>String</code>（例如：具有作用域或工厂方法名称的XML属性）或<code>Object</code>（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的<code>BeanDefinition</code>实例中进行判断设置。具体的源码请看<code>BeanDefinitionVisitor</code>的代码片段：</p>
<pre><code class="java">/**
 * Traverse the given BeanDefinition object and the MutablePropertyValues
 * and ConstructorArgumentValues contained in them.
 * @param beanDefinition the BeanDefinition object to traverse
 * @see #resolveStringValue(String)
 */
public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;
  visitParentName(beanDefinition);
  visitBeanClassName(beanDefinition);
  visitFactoryBeanName(beanDefinition);
  visitFactoryMethodName(beanDefinition);
  visitScope(beanDefinition);
  visitPropertyValues(beanDefinition.getPropertyValues());
  ConstructorArgumentValues cas = beanDefinition.
    getConstructorArgumentValues();
  visitIndexedArgumentValues(cas.
    getIndexedArgumentValues());
  visitGenericArgumentValues(cas.
    getGenericArgumentValues());
&#125;

protected void visitParentName(BeanDefinition beanDefinition) &#123;
  String parentName = beanDefinition.getParentName();
  if (parentName != null) &#123;
    String resolvedName = resolveStringValue(parentName);
    if (!parentName.equals(resolvedName)) &#123;
      beanDefinition.setParentName(resolvedName);
    &#125;
  &#125;
&#125;
</code></pre>
<p>​        在这种情况下，他们只是访问方式，没有对访问者做任何补充的控制(在Demo里对car的质检员做了控制)。这里访问包括分析给定<code>BeanDefinition</code>的参数，并将其替换为已解析对象。</p>
<p>在这篇关于Spring中设计模式的文章中，我们发现了2种行为模式：<code>用于处理bean工厂的后置处理的命令模式</code>和<code>用于将定义的bean参数转换为面向对象（String或Object的实例）参数的访问者模式</code>。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#879cff>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/">
        <h2>
            SpringBoot整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h1><h2 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h2><h3 id="1-1、选择项目所需要的依赖"><a href="#1-1、选择项目所需要的依赖" class="headerlink" title="1.1、选择项目所需要的依赖"></a>1.1、选择项目所需要的依赖</h3><p><img src="https://img-blog.csdn.net/20180926174507971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="1-2、pom-xml"><a href="#1-2、pom-xml" class="headerlink" title="1.2、pom.xml"></a>1.2、pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;demo&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
 
    &lt;name&gt;demo&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
 
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
 
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
 
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
 
 
&lt;/project&gt;
</code></pre>
<h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>​        本文不使用application.properties文件 而使用更加简洁的application.yml文件。将resource文件夹下原有的application.properties文件删除，创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties），本文创建了两个yml文件（application.yml和application-dev.yml），分别来看一下内容</p>
<ul>
<li>application.yml</li>
</ul>
<pre><code class="yml">spring:
  profiles:
    active: dev
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8080
 
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
</code></pre>
<p>​        两个文件的意思是：</p>
<blockquote>
<p>在项目中配置多套环境的配置方法。<br>因为现在一个项目有好多环境，开发环境，测试环境，准生产环境，生产环境，每个环境的参数不同，所以我们就可以把每个环境的参数配置到yml文件中，这样在想用哪个环境的时候只需要在主配置文件中将用的配置文件写上就行如application.yml</p>
<p>笔记：在Spring Boot中多环境配置文件名需要满足application-{profile}.yml的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.yml：开发环境<br>application-test.yml：测试环境<br>application-prod.yml：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.yml文件中通过<strong>spring.profiles.active属性</strong>来设置，其值对应{profile}值。</p>
</blockquote>
<p>​        还有配置文件中最好不要有中文注释，会报错。</p>
<p>​        接下来把启动文件移到com.example下，而且springboot的启动类不能放在java目录下！！！必须要个包将它包进去</p>
<p>​        否则会报错误：</p>
<pre><code class="java">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.
</code></pre>
<p>​        这个原因值得注意就是因为有时候很难在IDEA中的项目目录认出来这个错误并且还容易扫描不到一些类</p>
<h2 id="二、创建类"><a href="#二、创建类" class="headerlink" title="二、创建类"></a>二、创建类</h2><p>​        创建包controller、entity、mapper、service。resources下创建mapping文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。下面直接贴代码</p>
<h3 id="2-1、创建实体类"><a href="#2-1、创建实体类" class="headerlink" title="2.1、创建实体类"></a>2.1、创建实体类</h3><h4 id="2-1-1、数据库表结构"><a href="#2-1-1、数据库表结构" class="headerlink" title="2.1.1、数据库表结构"></a>2.1.1、数据库表结构</h4><pre><code class="sql">CREATE TABLE `user` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `userName` varchar(32) NOT NULL,
  `passWord` varchar(50) NOT NULL,
  `realName` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre>
<p><img src="https://img-blog.csdn.net/20180927092715962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>entity.java</li>
</ul>
<pre><code class="java">package com.example.entity;
 
@Data
public class User &#123;
    private Integer id;
    private String userName;
    private String passWord;
    private String realName;
&#125;
</code></pre>
<ul>
<li>UserController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
@RequestMapping(&quot;/testBoot&quot;)
public class UserController &#123;
 
    @Autowired
    private UserService userService;
 
    @RequestMapping(&quot;getUser/&#123;id&#125;&quot;)
    public String GetUser(@PathVariable int id)&#123;
        return userService.Sel(id).toString();
    &#125;
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
&#125;
</code></pre>
<ul>
<li>UserMappering.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;com.example.entity.User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
&lt;/mapper&gt;
</code></pre>
<p>最终框架结构</p>
<p><img src="https://img-blog.csdn.net/20180927095234881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>启动类</li>
</ul>
<pre><code class="java">package com.example;
 
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
 
@MapperScan(&quot;com.example.mapper&quot;) //扫描的mapper
@SpringBootApplication
public class DemoApplication &#123;
 
    public static void main(String[] args) &#123;
        SpringApplication.run(DemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="三、注册、登录以及拦截器配置"><a href="#三、注册、登录以及拦截器配置" class="headerlink" title="三、注册、登录以及拦截器配置"></a>三、注册、登录以及拦截器配置</h2><ul>
<li>添加依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8888
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    prefix: classpath:/templates/
    suffix: .html
    encoding: utf-8
    mode: html5
    servlet:
      content-type: text/html
</code></pre>
<ul>
<li>register.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;form action=&quot;/user/register&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Register&quot;/&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot; type=&quot;text/css&quot; /&gt;--&gt;
&lt;form action=&quot;/user/loginUser&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;
    &lt;a href=&quot;/user/toRegister&quot;&gt;--注册--&lt;/a&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>welcome.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
注册或登录后才能看到的界面
 
&lt;a href=&quot;/user/outUser&quot;&gt;退出登录&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>LoginController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController &#123;
    @Autowired
    private UserService userService;
 
    //跳转首页（登录页）
    @RequestMapping(&quot;/toIndex&quot;)
    public String show()&#123;
        return &quot;index&quot;;
    &#125;
 
    //登录操作
    @ResponseBody
    @RequestMapping(&quot;/loginUser&quot;)
    public String login(User user, HttpServletRequest request)&#123;
        String userName = user.getUserName();
        String passWord = user.getPassWord();
        User u1 =userService.login(userName,passWord);
        if (u1==null)&#123;
            return &quot;用户名或密码错误&quot;;
        &#125;else&#123;
            request.getSession().setAttribute(&quot;session_user&quot;,user);//登录成功后将用户放入session中，用于拦截
            return &quot;登录成功&quot;;
        &#125;
    &#125;
 
    //跳转注册页
    @RequestMapping(&quot;/toRegister&quot;)
    public String toRegister()&#123;
        return &quot;register&quot;;
    &#125;
 
    //注册操作
    @RequestMapping(&quot;/register&quot;)
    public String register(User user)&#123;
        int su = userService.register(user);
        if(su==0)&#123;
            System.out.println(&quot;----&quot;);
        &#125;
        return &quot;welcome&quot;;
    &#125;
 
    //测试未登陆拦截页面
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome()&#123;
        return &quot;welcome&quot;;
    &#125;
 
    //退出登录
    @RequestMapping(&quot;/outUser&quot;)
    public void outUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        request.getSession().removeAttribute(&quot;session_user&quot;);
        response.sendRedirect(&quot;/user/toIndex&quot;);
    &#125;
 
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
 
    public User login(String userName, String passWord) &#123;
        return userMapper.login(userName,passWord);
    &#125;
 
    public int register(User user) &#123;
        return userMapper.register(user);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
 
    User login(String userName,String passWord);
 
    int register(User user);
&#125;
</code></pre>
<ul>
<li>UserMapping.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
    &lt;select id=&quot;login&quot; resultType=&quot;User&quot;&gt;
        SELECT * FROM user where userName = #&#123;param1&#125; and passWord = #&#123;param2&#125;
    &lt;/select&gt;
 
    &lt;insert id=&quot;register&quot; parameterType=&quot;User&quot;&gt;
        INSERT INTO user (userName, passWord) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>其实注册登录也诶逻辑也很简单，就不多赘述了，接下来讲讲实现拦截器功能（敲黑板，本章的重点）</p>
<p>首先在com.example下新建intercetor包，然后新建UserIntercetor.java实现HandlerInterceptor接口并重写方法，更多介绍都写在里面注释了</p>
<ul>
<li>UserIntercetor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import com.example.entity.User;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Component
public class UserInterceptor implements HandlerInterceptor &#123;
 
    /*
     * 进入controller层之前拦截请求
     * 返回值：表示是否将当前的请求拦截下来  false：拦截请求，请求别终止。true：请求不被拦截，继续执行
     * Object obj:表示被拦的请求的目标对象（controller中方法）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;
        System.out.println(&quot;执行到了preHandle方法&quot;);
        System.out.println(handler);
        User user = (User) request.getSession().getAttribute(&quot;session_user&quot;);
        if (user==null)&#123;
            response.sendRedirect(request.getContextPath()+&quot;/user/toIndex&quot;);//拦截后跳转的方法
            System.out.println(&quot;已成功拦截并转发跳转&quot;);
            return false;
        &#125;
        System.out.println(&quot;合格不需要拦截，放行&quot;);
        return true;
    &#125;
 
    /*
     * 处理请求完成后视图渲染之前的处理操作
     * 通过ModelAndView参数改变显示的视图，或发往视图的方法
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;
        System.out.println(&quot;执行了postHandle方法&quot;);
    &#125;
 
    /*
     * 视图渲染之后的操作
     */
    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;
        System.out.println(&quot;执行到了afterCompletion方法&quot;);
    &#125;
 
&#125;
</code></pre>
<p>新建类SessionInterceptor实现WebMvcConfigurer接口来注册拦截器</p>
<ul>
<li>SessionInterceptor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
import java.util.ArrayList;
import java.util.List;

@Configuration
public class SessionInterceptor implements WebMvcConfigurer &#123;
 
    /**
     * 自定义拦截器，添加拦截路径和排除拦截路径
     * addPathPatterns():添加需要拦截的路径
     * excludePathPatterns():添加不需要拦截的路径
     */
    //注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        List list = new ArrayList();
        list.add(&quot;/user/toIndex&quot;);
        list.add(&quot;/user/loginUser&quot;);
        list.add(&quot;/user/toRegister&quot;);
        list.add(&quot;/user/register&quot;);
        registry.addInterceptor(new UserInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(list);
 
    &#125;
&#125;
</code></pre>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>4.1、application.yml文件中文注释乱码</p>
<pre><code class="yml">server:
  port: 8080
  servlet:
    jsp:
      init-parameters:
        # jsp修改之后立即生效
        development: true
</code></pre>
<p><img src="https://img-blog.csdn.net/20180908114638271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4ODcwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot" style=color:#1bccbc>
                SpringBoot
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/">
        <h2>
            SpringMVC使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringMVC使用详解"><a href="#SpringMVC使用详解" class="headerlink" title="SpringMVC使用详解"></a>SpringMVC使用详解</h1><h2 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h2><h3 id="1-1、什么是-SpringMVC"><a href="#1-1、什么是-SpringMVC" class="headerlink" title="1.1、什么是 SpringMVC"></a>1.1、什么是 SpringMVC</h3><p>​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架</p>
<h3 id="1-2、为什么学习-SpringMVC"><a href="#1-2、为什么学习-SpringMVC" class="headerlink" title="1.2、为什么学习 SpringMVC"></a>1.2、为什么学习 SpringMVC</h3><p>​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定大于配置，能够进行简单的 junit 测试，支持 Restful 风格，异常处理，本地化，国际化，数据验证，类型转换，拦截器，等等</p>
<h3 id="1-3、SpringMVC-的特点"><a href="#1-3、SpringMVC-的特点" class="headerlink" title="1.3、SpringMVC 的特点"></a>1.3、SpringMVC 的特点</h3><ul>
<li>简单好学</li>
<li>高效（基于请求相应的 MVC 框架）</li>
<li>与 Spring 无缝集成，兼容性好</li>
<li>约定大于配置</li>
<li>功能强大（Restful、数据验证、格式化、本地化、类型转换、等等）</li>
<li>简洁灵活</li>
</ul>
<h2 id="二、中心控制器"><a href="#二、中心控制器" class="headerlink" title="二、中心控制器"></a>二、中心控制器</h2><p>​        Spring 的 web 框架围绕 DispatcherServlet 设计。<strong>DispatcherServlet 的作用是将请求分发到不同的处理器</strong>。从 Spring 2.5 开始，使用 Java 5 或者以上版本的用户可以采用基于注解的 controller 声明方式。</p>
<p>​        Spring MVC 框架像许多其他 MVC 框架一样, 以请求为驱动 , 围绕一个中心 Servlet 分派请求及提供其他功能，DispatcherServlet 是一个实际的 Servlet (它继承自 HttpServlet 基类)。</p>
<p><img src="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        SpringMVC的原理如下图所示：</p>
<ul>
<li>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</li>
</ul>
<h2 id="三、SpringMVC原理"><a href="#三、SpringMVC原理" class="headerlink" title="三、SpringMVC原理"></a>三、SpringMVC原理</h2><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringMVC执行原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet 表示前置控制器，是整个 SpringMVC 的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。</p>
<p>​        我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p>​        如上 url 拆分成三部分：</p>
<ul>
<li><p> <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 服务器域名</p>
</li>
<li><p> SpringMVC 部署在服务器上的 web 站点</p>
</li>
<li><p>hello 表示控制器</p>
</li>
</ul>
<p> 通过分析，如上 url 表示为：请求位于服务器 localhost:8080上的Spring MVC站点的 hello 控制器。</p>
</li>
<li><p>HandlerMapping 为处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</p>
</li>
<li><p>HandlerExecution 表示具体的Handler，其主要作用是根据 url 查找控制器，如上 url 被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution 将解析后的信息传递给 DispatcherServlet，如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行 Handler。</p>
</li>
<li><p>Handler 让具体的 Controller 执行。</p>
</li>
<li><p>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</p>
</li>
<li><p>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="四、HelloSpringMVC"><a href="#四、HelloSpringMVC" class="headerlink" title="四、HelloSpringMVC"></a>四、HelloSpringMVC</h2><h3 id="4-1、配置版"><a href="#4-1、配置版" class="headerlink" title="4.1、配置版"></a>4.1、配置版</h3><p><strong>步骤：</strong></p>
<ol>
<li>新建一个 项目，添加 web 支持</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件（springmvc-service.xml）</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
</ol>
<pre><code class="xml">&lt;!--配置DispatchServlet：这个是SpringMVC的核心：请求分发器，前端控制器--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--DispatchServlet要绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-service.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--
    在Spring中，/ 与 /* 的区别
    /:只匹配所有的请求，不会去匹配jsp
    /*：匹配所有请求，包括jsp页面
--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>继续配置 SpringMVC 的配置文件（springmvc-servlet.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>添加 <strong>处理映射器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>处理器适配器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>视图解析器</strong></li>
</ul>
<pre><code class="xml">&lt;!--视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="6">
<li>编写操作业务的 Controller</li>
</ol>
<ul>
<li>要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图</li>
</ul>
<pre><code class="java">public class HelloController implements Controller &#123;
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //业务代码
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC！&quot;);
        
        //视图解释
        mv.setViewName(&quot;hello&quot;);//需要拼接的视图名称，参考视图解析器的代码实际地址就是（/WEB-INF/jsp/hello.jsp）
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>注册 bean（将 HelloController 这个类交给 Spring 容器【IOC】）</li>
</ol>
<pre><code class="xml">&lt;!--BeanNameUrlHandlerMapping:匹配的id(Handler)--&gt;
&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.aze.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="8">
<li>编写跳转页面，显示 ModelandView 存放的数据，以及我们编写的页面</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><strong>大多数都会遇到的问题！</strong></p>
<p>即使你的代码正确，但是却一直报出 404 错误！</p>
<ul>
<li><p>问题原因可能就在于 IDEA 项目发布中，缺少了 springMVC 相关的 jar 包</p>
</li>
<li><p>解决办法：</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>在 WEB-INF 下创建一个 lib 目录，在这个目录下存放 相关的 jar 包</p>
<p><img src="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将所有的<strong>包</strong>导入，点击 ok</p>
</li>
</ul>
</li>
</ul>
<p>​                </p>
<p><img src="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2、注解版（-）"><a href="#4-2、注解版（-）" class="headerlink" title="4.2、注解版（*）"></a>4.2、注解版（*）</h3><p>步骤：</p>
<ol>
<li>新建一个项目，添加 web 支持</li>
<li>解决 Maven 可能存在资源过滤的问题</li>
</ol>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ol start="3">
<li><p>在 pom.xml 文件引入相关的依赖：主要有 Spring 框架核心库、Spring MVC、servlet , JSTL 等</p>
</li>
<li><p>配置 web.xml</p>
</li>
</ol>
<pre><code class="xml">&lt;!--这是使用注解开发时固定的配置--&gt;
&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--初始化Spring配置文件的位置--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动顺序，数字越小，启动越早--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--所有的请求都会被SpringMVC拦截--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>编写 springmvc-servlet.xml 配置文件</li>
</ol>
<ul>
<li>配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能</li>
<li>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问<ul>
<li>让IOC的注解生效（context:component-scan base-package=””）</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …（mvc:default-servlet-handler）</li>
<li>MVC的注解驱动（mvc:annotation-driven）</li>
<li>配置视图解析器（开发中，程序员只需要配置这一步，其他的都是死的，CV 就可以）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
    &lt;!--这也是固定配置，需要修改的只有需要注入IOC的包--&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="6">
<li>编写一个 Java 控制类 HelloController.java</li>
</ol>
<ul>
<li>@Controller 是为了让 Spring IOC 容器初始化时自动扫描到；</li>
<li>@RequestMapping 是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是 /hello/hi；</li>
<li>方法中声明 Model 类型的参数是为了把 Action 中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称 hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</li>
</ul>
<pre><code class="java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    //类上注册了@RequestMapping方法就自动下移，实际地址：项目名/hello/hi
    @RequestMapping(&quot;/hi&quot;)
    public String sayHello(Model model)&#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVCAnnotatiom!&quot;);
        //web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>编写视图层 hello.jsp</li>
</ol>
<ul>
<li>视图可以直接取出并展示从 Controller 带回的信息；</li>
<li>可以通过 EL 表示取出 Model 中存放的值，或者对象</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h3 id="4-3、结论"><a href="#4-3、结论" class="headerlink" title="4.3、结论"></a>4.3、结论</h3><p>实现步骤：</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
<li><p>编写 web.xml , 注册 DispatcherServlet</p>
</li>
<li><p>编写 springmvc 配置文件</p>
</li>
<li><p>接下来就是去创建对应的控制类 , controller</p>
</li>
<li><p>最后完善前端视图和 controller 之间的对应</p>
</li>
<li><p>测试运行调试.</p>
</li>
</ol>
<p><strong>使用springMVC必须配置的三大件：</strong></p>
<ul>
<li><p>处理器映射器</p>
</li>
<li><p>处理器适配器</p>
</li>
<li><p>视图解析器</p>
</li>
</ul>
<p>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。</p>
<h2 id="五、注解"><a href="#五、注解" class="headerlink" title="五、注解"></a>五、注解</h2><h3 id="5-1、Controller"><a href="#5-1、Controller" class="headerlink" title="5.1、Controller"></a>5.1、Controller</h3><p>Controller 控制器</p>
<p>负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
<p>负责解析用户的请求并将其转换为一个模型。</p>
<p>在 Spring MVC 中一个控制器类可以包含多个方法</p>
<p>在 Spring MVC 中，对于 Controller 的配置方式有很多种</p>
<h4 id="5-1-1、实现-Controller-接口"><a href="#5-1-1、实现-Controller-接口" class="headerlink" title="5.1.1、实现 Controller 接口"></a>5.1.1、实现 Controller 接口</h4><p>Controller是一个接口</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p>步骤：（上面 HelloSpringMVC 的配置版就是 实现 Controller 接口）</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入 SpringMVC 的依赖</p>
</li>
<li><p>创建 SpringMVC 的配置文件（springmvc-service.xml）</p>
<ul>
<li>删掉 HelloController</li>
<li>只留下 视图解析器！</li>
</ul>
</li>
<li><p>配置 web.xml，注册 DispatcherServlet</p>
</li>
<li><p>编写一个 Controller 类</p>
</li>
<li><p>编写完毕后，去 Spring 配置文件中注册请求的 bean</p>
<ul>
<li>name 对应请求路径</li>
<li>class 对应处理请求的类</li>
</ul>
</li>
<li><p>编写前端 hello.jsp</p>
<ul>
<li>注意：在 WEB-INF/jsp 目录下编写，对应我们的视图解析器</li>
</ul>
</li>
<li><p>配置 Tomcat 运行测试<br>注意：实现接口 Controller 定义控制器是较老的办法<br>缺点：</p>
<ul>
<li>一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</li>
<li>定义的方式比较麻烦；</li>
</ul>
</li>
</ol>
<h4 id="5-1-2、注解-Controller"><a href="#5-1-2、注解-Controller" class="headerlink" title="5.1.2、注解 @Controller"></a>5.1.2、注解 @Controller</h4><ul>
<li>@Controller 注解类型用于声明 Spring 类的实例是一个控制器（<ul>
<li><strong>@Controller：</strong>用于controller</li>
<li><strong>@Component：</strong>用于组件</li>
<li><strong>@Repository：</strong>用于 dao</li>
<li><strong>@Service：</strong>用于 service</li>
</ul>
</li>
<li>Spring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证 Spring 能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<p>步骤：（4.2 注解版就是用注解 @Controller）</p>
<ol>
<li>新建一个 web 项目</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
<li>编写一个 Controller 类</li>
<li>使用注解（）</li>
<li>编写前端 hello.jsp</li>
<li>配置 Tomcat 运行测试</li>
</ol>
<h3 id="5-2、RequestMapping"><a href="#5-2、RequestMapping" class="headerlink" title="5.2、RequestMapping"></a>5.2、RequestMapping</h3><ul>
<li>@RequestMapping<pre><code>+ @RequestMapping 注解用于映射 url 到控制器类或一个特定的处理程序方法。
</code></pre>
可用于类或方法上<ul>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<ul>
<li>用于方法上，方法的响应请求是该地址</li>
</ul>
</li>
</ul>
<strong>建议：</strong>类上不要使用此注解</li>
</ul>
<h2 id="六、RestFul风格"><a href="#六、RestFul风格" class="headerlink" title="六、RestFul风格"></a>六、RestFul风格</h2><h3 id="6-1、什么是-RestFul"><a href="#6-1、什么是-RestFul" class="headerlink" title="6.1、什么是 RestFul"></a>6.1、什么是 RestFul</h3><p>Restful 就是一个资源定位及资源操作的风格。</p>
<ul>
<li>不是标准也不是协议，只是一种风格</li>
<li>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
</ul>
<h3 id="6-2、RestFul-功能"><a href="#6-2、RestFul-功能" class="headerlink" title="6.2、RestFul 功能"></a>6.2、RestFul 功能</h3><p>资源：互联网所有的事物都可以被抽象为资源</p>
<ul>
<li><p>资源操作：使用 POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
</li>
<li><p>分别对应 添加、 删除、修改、查询。</p>
</li>
</ul>
<p><strong>传统方式操作资源 ：</strong>通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源 ：</strong>可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<h3 id="6-3、测试-RestFul-风格"><a href="#6-3、测试-RestFul-风格" class="headerlink" title="6.3、测试 RestFul 风格"></a>6.3、测试 RestFul 风格</h3><h4 id="6-3-1、使用-RequestMapping"><a href="#6-3-1、使用-RequestMapping" class="headerlink" title="6.3.1、使用 @RequestMapping"></a>6.3.1、使用 @RequestMapping</h4><p>步骤：</p>
<ol>
<li><p>新建一个 Controller 类，用于测试 RestFul 风格</p>
</li>
<li><p>在 Spring MVC 中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
</li>
</ol>
<pre><code class="java">@Controller
public class RestFulTest &#123;

    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;
        int result = a + b;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;hello&quot;;
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>修改下对应的参数类型，再次测试</li>
</ol>
<pre><code class="java">// 将 int b，改为 String b
@PathVariable int a, @PathVariable String b
    
// 对应的 result 也需要改为 String
String result = a+b;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="6-3-2、使用注解变体"><a href="#6-3-2、使用注解变体" class="headerlink" title="6.3.2、使用注解变体"></a>6.3.2、使用注解变体</h4><p>使用method属性指定请求类型：</p>
<ul>
<li>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE 等</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<p>问题？</p>
<p>​        这样写，代码量就会变多，这时候，注解变体他来了！<br>注解变体：（方法级别）</p>
<ul>
<li>@GetMapping：GET 类型</li>
<li>@PostMapping：POST 类型</li>
<li>@PutMapping：PUT 类型</li>
<li>@DeleteMapping：DELETE 类型</li>
<li>@PatchMapping：PATCH 类型</li>
</ul>
<pre><code class="java">// 使用注解变体
@GetMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
// 等价于 @RequestMapping(value = &quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<h3 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h3><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。（注意！！！）</p>
<p><strong>@GetMapping 是一个组合注解</strong>，平时使用的会比较多！</p>
<p>使用浏览器地址栏进行访问默认是 Get 请求，会报错 405</p>
<p>解决办法：将 POST 修改为 GET 就好了</p>
<h2 id="七、转发与重定向"><a href="#七、转发与重定向" class="headerlink" title="七、转发与重定向"></a>七、转发与重定向</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置 ModelAndView 对象 , 根据 view 的名称 , 和视图解析器跳到指定的页面 .</p>
<ul>
<li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li>
</ul>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>controller 类</li>
</ul>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>这是 JavaWeb 中学习到的用法：</p>
<ul>
<li>通过设置 ServletAPI，不需要视图解析器 .<ol>
<li>通过 HttpServletResponse 进行输出</li>
</ol>
</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/test1&quot;)
public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
&#125;
</code></pre>
<p>​        2. 通过 HttpServletResponse 实现重定向（重定向）</p>
<pre><code class="java">@RequestMapping(&quot;test2&quot;)
public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.sendRedirect(&quot;/index.jsp&quot;);
&#125;
</code></pre>
<ol start="3">
<li>通过 HttpServletResponse 实现转发（请求转发）</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/test3&quot;)
public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
    // 转发
    req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
    req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
&#125;
</code></pre>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><h4 id="7-3-1、无视图解析器"><a href="#7-3-1、无视图解析器" class="headerlink" title="7.3.1、无视图解析器"></a>7.3.1、无视图解析器</h4><pre><code class="java">@RequestMapping(&quot;/rsm/t1&quot;)
public String test1()&#123;
    // 默认就是转发
    return &quot;/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t2&quot;)
public String test2()&#123;
    // 也可以显示定义转发
    return &quot;forward:/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t3&quot;)
public String test3()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
<h4 id="7-3-2、有视图解析器"><a href="#7-3-2、有视图解析器" class="headerlink" title="7.3.2、有视图解析器"></a>7.3.2、有视图解析器</h4><p>​        重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方 , 所以注意路径问题.</p>
<pre><code class="java">@RequestMapping(&quot;/rsm2/t1&quot;)
public String test1()&#123;
    // 转发：默认就是转发
    return &quot;test&quot;;
&#125;

@RequestMapping(&quot;/rsm2/t2&quot;)
public String test2()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
    // return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
&#125;
</code></pre>
<h2 id="八、数据处理"><a href="#八、数据处理" class="headerlink" title="八、数据处理"></a>八、数据处理</h2><h3 id="8-1、处理提交数据"><a href="#8-1、处理提交数据" class="headerlink" title="8.1、处理提交数据"></a>8.1、处理提交数据</h3><ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数名不一致，就需要使用注解 @RequestParam 来解决</li>
</ol>
<pre><code class="java">// @RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<ul>
<li>实体类</li>
</ul>
<pre><code class="java">// 这里使用的是 Lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private int age;
&#125;
</code></pre>
<ul>
<li>Controller 类</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<h3 id="8-2、数据显示到前端"><a href="#8-2、数据显示到前端" class="headerlink" title="8.2、数据显示到前端"></a>8.2、数据显示到前端</h3><ol>
<li>通过 ModelAndView</li>
</ol>
<pre><code class="java">public class ControllerTest implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>通过ModelMap</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>通过 Model</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<p>区别：</p>
<ul>
<li><p>Model：只有寥寥几个方法只适合用于储存数据，简化了新手对于 Model 对象的操作和理解</p>
</li>
<li><p>ModelMap：继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView：可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<h2 id="九、中文乱码问题"><a href="#九、中文乱码问题" class="headerlink" title="九、中文乱码问题"></a>九、中文乱码问题</h2><p>解决办法：</p>
<ol>
<li>自我编写一个过滤器，再注册到 web.xml 文件中</li>
</ol>
<pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;

    // 初始化：web 服务器启动，就已经初始化了，随时等待过滤对象的出现
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    // 销毁：web 服务器关闭时，过滤器会销毁
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用 SpringMVC 自带的过滤器</li>
</ol>
<ul>
<li>导入相关依赖后，直接配置 web.xml 即可</li>
</ul>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="3">
<li>使用大佬配置的过滤器</li>
</ol>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                                       .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
<p>​        以上都不行可能是你的 Tomcat 没有配置好！去修改 tomcat 配置文件 ：设置编码</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<h2 id="十、Json"><a href="#十、Json" class="headerlink" title="十、Json"></a>十、Json</h2><ul>
<li>JSON（JavaScript Object Notation, JS 对象标记） 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。（前后端分离）</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<h3 id="10-1、JSON-与-JavaScript"><a href="#10-1、JSON-与-JavaScript" class="headerlink" title="10.1、JSON 与 JavaScript"></a>10.1、JSON 与 JavaScript</h3><p>在 JavaScript 语言中，一切都是对象。因此，任何 JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li><p>对象表示为键值对，数据由逗号分隔</p>
</li>
<li><p>花括号保存对象</p>
</li>
<li><p>方括号保存数组</p>
</li>
</ul>
<p>​        <strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值（ {“键” : “值”} ）。</p>
<p>​        JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br><strong>JSON 和 JavaScript 对象互转：</strong></p>
<ul>
<li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法</li>
</ul>
<pre><code class="java">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);
</code></pre>
<ul>
<li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法</li>
</ul>
<pre><code class="java">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
<h3 id="10-2、Controller-返回-JSON-数据"><a href="#10-2、Controller-返回-JSON-数据" class="headerlink" title="10.2、Controller 返回 JSON 数据"></a>10.2、Controller 返回 JSON 数据</h3><ul>
<li>Jackson 应该是目前比较好的 json 解析工具了</li>
<li>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</li>
<li>这里使用的是 Jackson，使用它需要导入它的 jar 包；</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>web.xml 配置 SpringMVC 需要的配置<ul>
<li>servlet 注册 SpringMVC</li>
<li>filter 注册字符过滤器</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ul>
<li>编写 springmvc-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>编写一个实体类 User，去测试<ul>
<li>需要导入 lombok 的 jar 包</li>
</ul>
</li>
</ul>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<ul>
<li>编写 UserController<ul>
<li>@ResponseBody：将 java 对象转化为 json</li>
<li>ObjectMapper：创建一个 jackson 的对象映射器，用来解析数据</li>
</ul>
</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置 Tomcat</li>
<li>配置 Artifacts</li>
</ul>
<p>问题：乱码问题</p>
<p><img src="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center" alt="在这里插入图片描述"></p>
<p>解决办法：通过 @RequestMaping 的 produces 属性来实现</p>
<pre><code class="java">// produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
<h3 id="10-3、Controller-返回-JSON-数据代码优化"><a href="#10-3、Controller-返回-JSON-数据代码优化" class="headerlink" title="10.3、Controller 返回 JSON 数据代码优化"></a>10.3、Controller 返回 JSON 数据代码优化</h3><h4 id="10-3-1、将乱码问题统一解决"><a href="#10-3-1、将乱码问题统一解决" class="headerlink" title="10.3.1、将乱码问题统一解决"></a>10.3.1、将乱码问题统一解决</h4><p>上面解决乱码的方法在项目请求多的情况下就不适用了</p>
<p>就可以使用 Spring 配置统一指定返回类型和编码，等等</p>
<ul>
<li>在 spring-mvc 的配置文件上添加一段消息<ul>
<li>StringHttpMessageConverter 转换配置</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<h4 id="10-3-2、统一解决返回为-json-字符串问题"><a href="#10-3-2、统一解决返回为-json-字符串问题" class="headerlink" title="10.3.2、统一解决返回为 json 字符串问题"></a>10.3.2、统一解决返回为 json 字符串问题</h4><p>如果类中有所有的方法都需要返回 json 字符串，那么所有的方法都需要标识注释 @ResponseBody，这将会特别麻烦</p>
<ul>
<li>所以直接在类上使用 @RestController 来标注这个类的所有方法返回的都是 json 字符串<ul>
<li>这样就不用再每个方法上写 @ResponseBody</li>
<li>前后端分离开发中，一般都会使用 @RestController ，十分便捷</li>
</ul>
</li>
</ul>
<h3 id="10-4、测试集合的输出"><a href="#10-4、测试集合的输出" class="headerlink" title="10.4、测试集合的输出"></a>10.4、测试集合的输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
public String json2() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();

    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛逼1&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼2&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼3&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼4&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼5&quot;,18,&quot;男&quot;));

    return mapper.writeValueAsString(userList);
&#125;
</code></pre>
<h3 id="10-5、测试时间对象输出"><a href="#10-5、测试时间对象输出" class="headerlink" title="10.5、测试时间对象输出"></a>10.5、测试时间对象输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();
    Date date = new Date();
    // 默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式
    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<p>默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式：</p>
<ul>
<li>取消 timestamps（时间戳）形式，自定义时间格式</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();

    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<h3 id="10-6、将重复代码抽取为工具类"><a href="#10-6、将重复代码抽取为工具类" class="headerlink" title="10.6、将重复代码抽取为工具类"></a>10.6、将重复代码抽取为工具类</h3><p>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中</p>
<pre><code class="java">public class JsonUtils &#123;
    public static String getJson(Object object)&#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat)&#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>使用工具类后的代码量</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    return JsonUtils.getJson(new Date());
&#125;
</code></pre>
<h3 id="10-7、FastJson"><a href="#10-7、FastJson" class="headerlink" title="10.7、FastJson"></a>10.7、FastJson</h3><p>fastjson.jar 是阿里开发的一款专门用于 Java 开发的包，可以方便的实现多种转换，最后的实现结果都是一样的。</p>
<ul>
<li><p>实现 json 对象与 JavaBean 对象的转换</p>
</li>
<li><p>实现 JavaBean 对象与 json 字符串的转换</p>
</li>
<li><p>实现 json 对象与 json 字符串的转换。实现 son的 转换方法很多</p>
</li>
</ul>
<p><strong>fastjson 的 pom 依赖：</strong></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.78&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject 实现了 Map 接口, 猜想 JSONObject 底层操作是由 Map 实现的。</li>
<li>JSONObject 对应 json对 象，通过各种形式的 get() 方法可以获取 json 对象中的数据，也可利用诸如 size()，isEmpty() 等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有 List 接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON 代表 JSONObject 和 JSONArray 的转化</strong></p>
<ul>
<li>JSON 类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现 json 对象，json 对象数组，javabean 对象，json 字符串之间的相互转化。</li>
</ul>
<p>代码测试：</p>
<pre><code class="java">@RequestMapping(&quot;/json6&quot;)
public String json6()&#123;
    //创建一个对象
    User user1 = new User(&quot;1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    userList.add(user4);

    System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
    String str1 = JSON.toJSONString(userList);
    System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
    String str2 = JSON.toJSONString(user1);
    System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

    System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
    User jp_user1=JSON.parseObject(str2,User.class);
    System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

    System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
    JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
    System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

    System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
    User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
    System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    
    return JSON.toJSONString(userList);
&#125;
</code></pre>
<h2 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h2><h3 id="11-1、什么是-Ajax"><a href="#11-1、什么是-Ajax" class="headerlink" title="11.1、什么是 Ajax"></a>11.1、什么是 Ajax</h3><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML。</li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
<li>传统的网页（即不用 ajax 技术的网页），想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</li>
</ul>
<h3 id="11-2、Ajax-原理"><a href="#11-2、Ajax-原理" class="headerlink" title="11.2、Ajax 原理"></a>11.2、Ajax 原理</h3><p><img src="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="11-3、伪造-Ajax"><a href="#11-3、伪造-Ajax" class="headerlink" title="11.3、伪造 Ajax"></a>11.3、伪造 Ajax</h3><ol>
<li>新建一个项目，导入 web 支持</li>
<li>编写一个 前端页面，使用 iframe 进行测试</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function x() &#123;
            var url =  document.getElementById(&#39;url&#39;).value;
            document.getElementById(&#39;iframePosition&#39;).src = url;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;p&gt;请输入地址：&lt;/p&gt;
    &lt;p&gt;
        &lt;input id=&quot;url&quot; type=&quot;text&quot; placeholder=&quot;网页地址&quot;/&gt;
        &lt;input type=&quot;button&quot; value=&quot;前往&quot; onclick=&quot;x()&quot;&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 666px&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-4、jQuery-操作-ajax"><a href="#11-4、jQuery-操作-ajax" class="headerlink" title="11.4、jQuery 操作 ajax"></a>11.4、jQuery 操作 ajax</h3><ul>
<li>使用jquery提供的，方便，有兴趣的可以自己去了解下 JS 原生 XMLHttpRequest ！<ul>
<li>Ajax 的核心是 XMLHttpRequest 对象（XHR）。XHR 为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
</ul>
</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="js">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<h3 id="11-5、原始的-HttpServletResponse-实现"><a href="#11-5、原始的-HttpServletResponse-实现" class="headerlink" title="11.5、原始的 HttpServletResponse 实现"></a>11.5、原始的 HttpServletResponse 实现</h3><ol>
<li>配置 web.xml</li>
</ol>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="2">
<li>springmvc 配置文件（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li><p>静态资源过滤和注解驱动配置（我的父工程已经配置了，所以这就不配了）</p>
</li>
<li><p>编写 Controller 类</p>
</li>
</ol>
<pre><code class="java">@RestController
public class UserController &#123;

    @RequestMapping(&quot;/a&quot;)
    public void ajax(String name, HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().write(&quot;true&quot;);
        &#125;else &#123;
            response.getWriter().write(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>导入 jQuery</p>
</li>
<li><p>编写前端页面</p>
</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ajaxTest&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function a1()&#123;
        $.post(&#123;
          url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
          data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
          success:function (data,status) &#123;
            alert(data);
            alert(status);
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; οnblur=&quot;a1()&quot;/&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="11-6、SpringMVC-实现异步加载数据"><a href="#11-6、SpringMVC-实现异步加载数据" class="headerlink" title="11.6、SpringMVC 实现异步加载数据"></a>11.6、SpringMVC 实现异步加载数据</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛&quot;,10,&quot;男&quot;));
    userList.add(new User(&quot;中牛&quot;,11,&quot;女&quot;));
    userList.add(new User(&quot;小牛&quot;,12,&quot;男&quot;));
    return userList;
&#125;
</code></pre>
<ol start="2">
<li>在 index 中增加内容</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;取得信息&quot;&gt;
  &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">$(function () &#123;
    $(&quot;#btn&quot;).click(function () &#123;
        $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
            console.log(data)
            var html=&quot;&quot;;
            for (let i = 0; i &lt; data.length ; i++) &#123;
                html+= &quot;&lt;tr&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;/tr&gt;&quot;
            &#125;
            $(&quot;#content&quot;).html(html);
        &#125;);
    &#125;)
&#125;)
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-7、注册提示效果"><a href="#11-7、注册提示效果" class="headerlink" title="11.7、注册提示效果"></a>11.7、注册提示效果</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String oldPwd,String newPwd, String newPwd2)&#123;
    String msg = &quot;&quot;;
    if (name != null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;用户名不存在&quot;;
        &#125;
    &#125;
    if (oldPwd != null)&#123;
        if (&quot;123456&quot;.equals(oldPwd))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;旧密码有误&quot;;
        &#125;
    &#125;
    return msg;
&#125;
</code></pre>
<ol start="2">
<li>编写前端</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;name&quot; οnblur=&quot;a3_1()&quot;&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
    旧密码：&lt;input type=&quot;password&quot; id=&quot;oldPwd&quot; οnblur=&quot;a3_2()&quot;&gt;
    &lt;span id=&quot;oldPwdInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function a3_1() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;name&quot;:$(&#39;#name&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#userInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
function a3_2() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;oldPwd&quot;:$(&#39;#oldPwd&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#oldPwdInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
</code></pre>
<ol start="3">
<li>解决乱码问题（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<h2 id="十二、拦截器"><a href="#十二、拦截器" class="headerlink" title="十二、拦截器"></a>十二、拦截器</h2><h3 id="12-1、什么是拦截器"><a href="#12-1、什么是拦截器" class="headerlink" title="12.1、什么是拦截器"></a>12.1、什么是拦截器</h3><p>​        SpringMVC 的处理器、拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<ul>
<li><p>过滤器</p>
<ul>
<li>servlet 规范中的一部分，任何 java web工程都可以使用</li>
<li>在 url-pattern 中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是 jsp、html、css、image、js 是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="12-2、自定义拦截器"><a href="#12-2、自定义拦截器" class="headerlink" title="12.2、自定义拦截器"></a>12.2、自定义拦截器</h3><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>配置 web.xml 和 applicationContext.xml</p>
</li>
<li><p>编写一个拦截器</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在 springmvc 配置文件中配置拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class TestController &#123;

    @RequestMapping(&quot;/t1&quot;)
    public String test()&#123;
        System.out.println(&quot;控制器方法执行！&quot;);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="12-3、验证用户是否登录（认证用户）"><a href="#12-3、验证用户是否登录（认证用户）" class="headerlink" title="12.3、验证用户是否登录（认证用户）"></a>12.3、验证用户是否登录（认证用户）</h3><p><strong>测试思路：</strong></p>
<ul>
<li>有一个登陆页面，需要写一个 controller 访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在 controller 中处理。判断用户名密码是否正确。如果正确，向 session 中写入用户信息。返回登陆成功。</li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>编写登录页面（login.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;

    &lt;h1&gt;登录页面&lt;/h1&gt;
    &lt;hr&gt;

    &lt;body&gt;
        &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt;
            用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;br&gt;
            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; required&gt; &lt;br&gt;
            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>编写 Controller 类处理请求</li>
</ol>
<pre><code class="java">package com.aze.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>编写登录成功页面（success.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;登录成功页面&lt;/h1&gt;
        &lt;hr&gt;

        $&#123;user&#125;
        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>编写首页，来测试页面跳转（index.jsp）</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 16:29
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
  &lt;/div&gt;

  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;hr&gt;
    &lt;%--登录--%&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>编写用户登录拦截器</li>
</ol>
<pre><code class="java">package com.aze.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;url: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>在 springmvc 配置文件中注册拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.aze.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="7">
<li><p>配置 Tomcat</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="13、文件上传和下载"><a href="#13、文件上传和下载" class="headerlink" title="13、文件上传和下载"></a>13、文件上传和下载</h2><h3 id="13-1、准备测试"><a href="#13-1、准备测试" class="headerlink" title="13.1、准备测试"></a>13.1、准备测试</h3><p>​        文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是 SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用 Spring 的文件上传功能，则需要在上下文中配置 MultipartResolver。</p>
<p>​        前端表单要求：为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p>对表单中的 enctype 属性做个详细的说明：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>​        一旦设置了 enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的 HTTP 响应。在2003年，Apache Software Foundation 发布了开源的 Commons FileUpload 组件，其很快成为 Servlet/JSP 程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0 规范已经提供方法来处理文件上传，但这种上传需要在 Servlet中完成。</li>
<li>而 Spring MVC 则提供了更简单的封装。</li>
<li>Spring MVC 为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver 实现的。</li>
<li>Spring MVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。</li>
<li>因此，SpringMVC 的文件上传还需要依赖 Apache Commons FileUpload 的组件。</li>
</ul>
<h3 id="13-2、文件上传"><a href="#13-2、文件上传" class="headerlink" title="13.2、文件上传"></a>13.2、文件上传</h3><ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
</ol>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--文件上传--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet-api导入高版本的--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--统一的解决乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>在 applicationContext.xml 中添加 bean 配置</li>
</ol>
<ul>
<li><strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong></li>
</ul>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 17:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;form action=&quot;/upload2&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class FileController &#123;
    
&#125;
</code></pre>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="java">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
//批量上传CommonsMultipartFile则为数组即可
@RequestMapping(&quot;/upload&quot;)
public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

    //获取文件名 : file.getOriginalFilename();
    String uploadFileName = file.getOriginalFilename();

    //如果文件名为空，直接回到首页！
    if (&quot;&quot;.equals(uploadFileName))&#123;
        return &quot;redirect:/index.jsp&quot;;
    &#125;
    System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    //如果路径不存在，创建一个
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    InputStream is = file.getInputStream(); //文件输入流
    OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

    //读取写出
    int len=0;
    byte[] buffer = new byte[1024];
    while ((len=is.read(buffer))!=-1)&#123;
        os.write(buffer,0,len);
        os.flush();
    &#125;
    os.close();
    is.close();
    return &quot;success&quot;;
&#125;
</code></pre>
<ul>
<li>方式二：采用 file.Transto 来保存上传的文件</li>
</ul>
<pre><code class="java">/*
    * 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;success&quot;;
&#125;
</code></pre>
<p>7.配置 Tomcat</p>
<ol start="8">
<li>测试</li>
</ol>
<h3 id="13-3、文件下载"><a href="#13-3、文件下载" class="headerlink" title="13.3、文件下载"></a>13.3、文件下载</h3><p>步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>Controller 类添加</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;baidu.png&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端添加</p>
<pre><code class="html">&lt;div&gt;
  &lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
&lt;/div&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringMVC" style=color:#1bccbc>
                SpringMVC
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            Shuyan
        </div>
        <div class="descriptions">
            
            <div class="description">
                正しさなんてもの
            </div>
            
            <div class="description">
                人のモノサシによって変わる
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://en.korilin.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://jp.korilin.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>