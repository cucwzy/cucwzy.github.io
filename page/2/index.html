
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Stay Hungry, Stay Foolish</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Shuyan</h1>
                <h3>Stay Hungry, Stay Foolish</h3>
                <h5>ShuyanCoding......</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/">
        <h2>
            Mybaits知识点
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、概念、使用方法向的问题"><a href="#一、概念、使用方法向的问题" class="headerlink" title="一、概念、使用方法向的问题"></a>一、概念、使用方法向的问题</h2><h3 id="1-1、Mybaits介绍"><a href="#1-1、Mybaits介绍" class="headerlink" title="1.1、Mybaits介绍"></a>1.1、Mybaits介绍</h3><p>​        （1）Mybatis是一个<strong>半ORM框架</strong>，它<strong>内部封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>​        （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后<u>由mybatis框架执行sql并将结果映射为java对象并返回</u>。</p>
<h3 id="1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</h3><p>​        <strong>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。</strong>Hibernate是个完整的ORM框架，而MyBatis只完成了<strong>关系-&gt;对象</strong>，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>​        （1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>​        （2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询。</p>
<p>​        （3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3、-Mybaits的优点"><a href="#1-3、-Mybaits的优点" class="headerlink" title="1.3、 Mybaits的优点?"></a><strong>1.3、 Mybaits的优点?</strong></h3><p>​        （1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>​        （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>​        （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>​        （4）能够与Spring很好的集成；</p>
<p>​        （5）<strong>提供映射标签</strong>，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-、MyBatis框架的缺点"><a href="#1-4-、MyBatis框架的缺点" class="headerlink" title="1.4 、MyBatis框架的缺点?"></a>1.4 、MyBatis框架的缺点?</h3><p>​        （1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>​        （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5、-和-的区别"><a href="#1-5、-和-的区别" class="headerlink" title="1.5、 #{}和${}的区别?"></a>1.5、 #{}和${}的区别?</h3><p>​        （1）**${}<strong>是properties文件中的</strong>变量占位符**，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>​        （2）**#{}<strong>是sql的</strong>参数占位符<strong>，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。</strong>使用#{}可以有效的防止 SQL 注入**，提高系统安全性。</p>
<pre><code class="sql">$&#123;param&#125;传递的参数会被当成sql语句中的一部分，
举例：
order by $&#123;param&#125;
则解析成的sql为：
order by id


#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，
举例：
select * from table where name = #&#123;param&#125;，
则解析成的sql为：
select * from table where name = &quot;id&quot;
</code></pre>
<h3 id="1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</h3><p>​        （1）通过在查询的sql语句中定义字段名的<strong>别名</strong>，使字段名的别名和实体类的属性名一致</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; parameterType=&quot;java.lang.Integer&quot; resultetype=&quot;com.en.entity.user&quot;&gt;
    select user_id as id, user_no as no from test where user_id = #&#123;id&#125;;
&lt;/select&gt;
</code></pre>
<p>​        （2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<pre><code class="xml">&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;
    &lt;!–用id标签来映射主键字段–&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&gt;
        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;
        &lt;result property=&quot;no&quot; column=&quot;user_no&quot;/&gt;
    &lt;/id&gt;
&lt;/reslutMap&gt;
</code></pre>
<h3 id="1-7、-如何在mapper中传递多个参数"><a href="#1-7、-如何在mapper中传递多个参数" class="headerlink" title="1.7、 如何在mapper中传递多个参数?"></a>1.7、 如何在mapper中传递多个参数?</h3><p>​        （1）使用 <a target="_blank" rel="noopener" href="https://github.com/param">@param</a> 注解：</p>
<pre><code class="java">user selectUser(@param(&quot;username&quot;) string username,@param(&quot;password&quot;) string password);
</code></pre>
<p>​        （2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap();
map.put(&quot;start&quot;, start);
map.put(&quot;end&quot;, end);
sqlSession.selectList(&quot;student.selectUser&quot;, map);
</code></pre>
<h3 id="1-8、-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8、-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8、 MyBatis的接口绑定有哪些实现方式？"></a>1.8、 MyBatis的接口绑定有哪些实现方式？</h3><p>​        <strong>接口绑定</strong>有两种实现方式：</p>
<p>​        （1）一种是<strong>通过注解绑定</strong>，就是在接口的方法上面加上<a target="_blank" rel="noopener" href="https://github.com/Select">@Select</a>、<a target="_blank" rel="noopener" href="https://github.com/Update">@Update</a>等注解里面包含Sql语句来绑定。</p>
<pre><code class="java">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)
@Results(
         id = &quot;distTypeMap&quot;,
         value =&#123;
            @Result(id =true,property=&quot;id&quot;,column=&quot;ID&quot;)，
            @Result(property=&quot;code&quot;,column=&quot;CODE&quot;)，
            @Result(property=&quot;name&quot;,column=&quot;NAME&quot;)，
            @Result(
                property = &quot;dictDtos&quot; ,
                column = &quot;ID&quot;,
                many = @Many(
                    select = &quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,
                    fetchType = FetchType.EAGER
                )
            )
        &#125;
)
List&lt;SysDictTypeDto&gt; getAllDist();
</code></pre>
<p>​        （2）另外一种就是<strong>通过xml里面写SQL来绑定</strong>，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<pre><code class="java">&lt;mapper namespace=&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;&gt;
&lt;select id=&quot;queryFileDisposeInfo&quot; parameterType=&quot;FileDisposeVo&quot; resultMap=&quot;illegalcollection-map&quot;&gt;
   SELECT 
        BATCH_NUMBER,
        FINISH_DATE,
        FILE_NAME,
        FILE_SIZE,
        DATA_SIZE,
        FILE_TYPE,
        ORG_CODE
   FROM 
        T_FILE_DISPOSE
&lt;/select&gt;
</code></pre>
<h3 id="1-9、-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9、-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9、 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9、 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>​        （1）Mapper接口<strong>方法名</strong>和mapper.xml中定义的每个<strong>sql的id</strong>相同；<br>​        （2）Mapper接口方法的<strong>输入参数类型</strong>和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>​        （3）Mapper接口方法的<strong>输出参数类型</strong>和mapper.xml中定义的每个sql的resultType的类型相同；<br>​        （4）Mapper.xml文件中的namespace即是mapper接口的<strong>类路径</strong>;</p>
<h2 id="二、源码向的问题"><a href="#二、源码向的问题" class="headerlink" title="二、源码向的问题"></a>二、源码向的问题</h2><h3 id="2-1、-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1、-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1、 解释下MyBatis面向Mapper编程工作原理？"></a>2.1、 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>​        Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的<strong>动态代理</strong>，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2、 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2、 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>​        在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了<strong>接口全限名+方法名</strong>的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<pre><code class="java">id = applyCurrentNamespace(id, false);
public String applyCurrentNamespace(String base, boolean isReference) &#123;
   ...
   // 返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)
   return currentNamespace + &quot;.&quot; + base;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200920171405540.png" alt="img"></p>
<h3 id="2-3、-Mybatis动态sql执行原理"><a href="#2-3、-Mybatis动态sql执行原理" class="headerlink" title="2.3、 Mybatis动态sql执行原理?"></a>2.3、 Mybatis动态sql执行原理?</h3><p>​        （1）<strong>初始化阶段：</strong>通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>​        （2）<strong>代理阶段：</strong>先从Configuration配置类的MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>​        （3）<strong>数据读写阶段：</strong>通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4、-Mybatis的一级、二级缓存实现原理"><a href="#2-4、-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4、 Mybatis的一级、二级缓存实现原理?"></a>2.4、 Mybatis的一级、二级缓存实现原理?</h3><p>​        （1）<strong>一级缓存：</strong> 基于 PerpetualCache 的 HashMap 本地缓存，<strong>其存储作用域为 Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092018550771.png" alt="img"></p>
<p>​        （2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于<strong>其存储作用域为 Mapper(Namespace)级别</strong>。</p>
<p>​        Mybatis默认不打开二级缓存，可以在config文件中xml<code> &lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920190114946.png" alt="img"></p>
<p>​        （3）对于<strong>缓存数据更新机制</strong>，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-、Mybatis是如何进行分页的？"><a href="#2-5-、Mybatis是如何进行分页的？" class="headerlink" title="2.5 、Mybatis是如何进行分页的？"></a>2.5 、Mybatis是如何进行分页的？</h3><p>​        （1）<strong>SQL分页</strong>(物理分页)：</p>
<pre><code class="xml">&lt;select id=&quot;queryStudentsBySql&quot; parameterType=&quot;map&quot; resultMap=&quot;studentmapper&quot;&gt; 
    select * from student limit #&#123;start&#125; , #&#123;end&#125;
&lt;/select&gt;
</code></pre>
<p>​        （2）使用<strong>RowBounds</strong>实现分页(逻辑分页)：</p>
<pre><code class="java">Service:
    publicList queryRolesByPage(String roleName,int start,int limit) &#123;
        returnroleDao.queryRolesByPage(roleName,new RowBounds(start, limit));
    &#125;


Dao:
    public List queryUsersByPage(String userName, RowBounds rowBounds);
</code></pre>
<p>​        （3）使用<strong>分页插件PageHelper</strong>：</p>
<p>​        添加依赖：</p>
<pre><code class="xml">&lt;!--分页--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        在mybatis-config.xml中配置PageInterceptor拦截器:</p>
<pre><code class="xml">&lt;!--2.配置分页插件，此插件必须配置在typeAliases后面--&gt;
&lt;plugins&gt;
     &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
&lt;!--分页合理化参数，默认文false；pageNum&lt;=0，查询第一页；pageNum&gt;总页数，查询最后一页--&gt;
         &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<pre><code class="java">public Json queryByPage(User userParam,Integer pageNum,Integer pageSize) &#123;
    PageHelper.startPage(pageNum, pageSize);
    List&lt;User&gt; userList = userMapper.queryByPage(userParam);
    Json json = new Json();
    return json;
&#125;
</code></pre>
<h3 id="2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>Executor</strong>是mybatis中的<strong>执行器接口</strong>:</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>BaseExecutor（基础执行器）：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了<strong>缓存管理和事务管理</strong>的能力，使用了<strong>模板模式</strong>，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现。BaseExecutor的一级缓存是会话级别的，增、删、改都会清空一级缓存；而CachingExecutor的二级缓存是应用级的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>CachingExecutor（缓存执行器）：</strong>直接实现Executor接口，使用装饰器模式<strong>提供二级缓存能力</strong>。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200705191437604.png"></p>
<p>​        <strong>BatchExecutor（批处理执行器）：</strong>BaseExecutor具体子类实现，在doUpdate方法中，<strong>提供批量执行多条SQL语句的能力</strong>；</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​        <strong>SimpleExecutor（简单执行器）：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor（可重用执行器）：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p><img src="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-7、-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7、-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7、 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7、 Mybatis中如何指定使用哪一种Executor执行器？</h3><p>​        在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920183713811.png" alt="img"></p>
<blockquote>
<p>&lt;class=”reference-link”&gt;</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200920183657317.png" alt="img"></p>
<h3 id="2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092018294130.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200920183022252.png" alt="img"></p>
<p>​        Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9、-Mybatis中用到了哪些设计模式？"><a href="#2-9、-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9、 Mybatis中用到了哪些设计模式？"></a>2.9、 Mybatis中用到了哪些设计模式？</h3><p>​        日志模块：代理模式、适配器模式</p>
<p>​        数据源模块：代理模式、工厂模式</p>
<p>​        缓存模块：装饰器模式</p>
<p>​        初始化阶段：建造者模式</p>
<p>​        代理阶段：策略模式</p>
<p>​        数据读写阶段：模板模式</p>
<p>​        插件化开发：责任链模式</p>
<h2 id="三、Mybaits源码结构"><a href="#三、Mybaits源码结构" class="headerlink" title="三、Mybaits源码结构"></a>三、Mybaits源码结构</h2><h3 id="3-1-、源码包功能模块图"><a href="#3-1-、源码包功能模块图" class="headerlink" title="3.1 、源码包功能模块图"></a>3.1 、源码包功能模块图</h3><p><img src="https://img-blog.csdnimg.cn/20200830162428980.png" alt="img"></p>
<h3 id="3-2-、各包详细功能解析"><a href="#3-2-、各包详细功能解析" class="headerlink" title="3.2 、各包详细功能解析"></a>3.2 、各包详细功能解析</h3><p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                包含所有mapper 接口中用到的注解</p>
<p>​        <strong>org.apache.ibatis.binding：</strong></p>
<p>​                生成mapper 接口的动态代理并进行管理</p>
<p>​        <strong>org.apache.ibatis.builder：</strong></p>
<p>​                1、包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</p>
<p>​                2、BaseBuilder 构建器基类</p>
<p>​                3、XMLConfigBuilder 解析configuration.xml配置文件</p>
<p>​                4、XMLMapperBuilder 解析Mapper.xml配置文件</p>
<p>​                5、XMLStatementBuilder 解析selectupdatedelete 标签MapperAnnotationBuilder 注解式Mapper</p>
<p>​        <strong>org.apache.ibatis.cache：</strong></p>
<p>​                1、缓存功能实现、包含各种缓存装饰器</p>
<p>​                2、TransactionalCache 二级缓存功能实现</p>
<p>​        <strong>org.apache.ibatis.cursor：</strong></p>
<p>​                实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p>​        <strong>org.apache.ibatis.datasource：</strong></p>
<p>​                数据源 包括jndi数据源、连接池功能</p>
<p>​        <strong>org.apache.ibatis.executor：</strong></p>
<p>​                1、包含SQL语句执行器，核心功能包</p>
<p>​                2、功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</p>
<p>​        <strong>org.apache.ibatis.exceptions：</strong></p>
<p>​                框架异常，常见异常：TooManyResultsException</p>
<p>​        <strong>org.apache.ibatis.io：</strong></p>
<p>​                资源文件读取</p>
<p>​        <strong>org.apache.ibatis.jdbc：</strong></p>
<p>​                1、JDBC一些操作</p>
<p>​                2、SqlRunner SQL执行</p>
<p>​                3、ScriptRunner 脚本执行，可以执行建库语句</p>
<p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                1、日志功能，实现多种日志框架的对接</p>
<p>​                2、org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</p>
<p>​        <strong>org.apache.ibatis.mapping：</strong></p>
<p>​                配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p>​        <strong>org.apache.ibatis.parsing：</strong></p>
<p>​                1、解析工具包</p>
<p>​                2、GenericTokenParser：解析#{} ${} 这种占位符</p>
<p>​                3、XPathParser：XPath形式解析XML</p>
<p>​                4、PropertyParser: properties解析器</p>
<p>​        <strong>org.apache.ibatis.scripting：</strong></p>
<p>​                动态SQL语言实现，配置文件中<code>&lt;if&gt; &lt;where&gt; &lt;set&gt; &lt;foreach&gt; &lt;choose&gt; </code>功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p>​        <strong>org.apache.ibatis.session：</strong></p>
<p>​                1、主要实现SqlSession功能，非常核心包</p>
<p>​                2、官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</p>
<p>​        <strong>org.apache.ibatis.transaction：</strong></p>
<p>​                事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p>​        <strong>org.apache.ibatis.type：</strong></p>
<p>​                类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="四、MyBatis初始化阶段"><a href="#四、MyBatis初始化阶段" class="headerlink" title="四、MyBatis初始化阶段"></a>四、MyBatis初始化阶段</h2><p>​        前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是<strong>将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级</strong>。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li>加载配置文件</li>
<li>解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li>根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="4-1、加载配置文件"><a href="#4-1、加载配置文件" class="headerlink" title="4.1、加载配置文件"></a>4.1、<strong>加载配置文件</strong></h3><p>​        下面我们来看一段经典查询操作：</p>
<pre><code class="java">String resouce = &quot;config/mybatis/mybatis-config.xml&quot;;
InputStream is = Resources.getResourceAsStream(resouce);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
SqlSession session = sqlSessionFactory.openSession();
user = session.selectOne(&quot;com.luoxn28.dao.UserDao.getById&quot;, 1);
</code></pre>
<p>​        以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="4-2、解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#4-2、解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="4.2、解析配置文件、将配置文件中的信息装载到Configuration中"></a>4.2、解析配置文件、将配置文件中的信息装载到Configuration中</h3><p>​        让我们来看一下梦开始的地方：</p>
<pre><code class="java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
</code></pre>
<p>​        跟进**build()**方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<pre><code class="java">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;
    try &#123;
      // 创建XMLConfigBuilder对象解析XML配置
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      // 将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory
      return build(parser.parse());
    &#125; 
    ....
&#125;
</code></pre>
<p>​        跟进<strong>parse()<strong>方法，我们可以看到parser.evalNode(“/configuration”)，</strong>evalNode</strong>为xml结点解析器，可以解析指定参数结点的信息，而”**/configuration**”则是mybatis.xml的根节点：</p>
<pre><code class="java">public Configuration parse() &#123;
    ...
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
&#125;
</code></pre>
<p>​        看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p>​        <strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p>​        <strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p>​        <strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200915222654319.png" alt="img"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img"></p>
<p>​        Configuration类的源码实在太多，可以先了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p>​        <strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br>​        <strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br>​        <strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br>​        <strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>​        接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<pre><code class="java">parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
</code></pre>
<pre><code class="java">private void parseConfiguration(XNode root) &#123;
    try &#123;
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>​        点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915223612191.png" alt="img"></p>
<p>​        在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<pre><code class="java">XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>
<pre><code class="java">private void configurationElement(XNode context) &#123;
    try &#123;
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      ...
      builderAssistant.setCurrentNamespace(namespace);
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      cacheElement(context.evalNode(&quot;cache&quot;));
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    &#125; catch (Exception e) &#123;
      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);
    &#125;
  &#125;
</code></pre>
<p>一一对应官网提供的节点信息进行解析</p>
<p><img src="https://img-blog.csdnimg.cn/20200915224121930.png" alt="img"></p>
<p>​        下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<pre><code class="java">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;
    for (XNode context : list) &#123;
      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
      try &#123;
        statementParser.parseStatementNode();
      &#125; catch (IncompleteElementException e) &#123;
        configuration.addIncompleteStatement(statementParser);
      &#125;
    &#125;
  &#125;
</code></pre>
<p>​        继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="4-3、根据Configuration创建SqlSessionFactory并返回"><a href="#4-3、根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="4.3、根据Configuration创建SqlSessionFactory并返回"></a>4.3、根据Configuration创建SqlSessionFactory并返回</h3><p>​        第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<pre><code class="java">public class SqlSessionFactoryBuilder &#123;
   ...
   public SqlSessionFactory build(Configuration config) &#123;
      return new DefaultSqlSessionFactory(config);
   &#125;
&#125;
</code></pre>
<p>​        此工厂内封装了Configuration对象：</p>
<pre><code class="java">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;
  private final Configuration configuration;
  public DefaultSqlSessionFactory(Configuration configuration) &#123;
    this.configuration = configuration;
  &#125;
  ...
&#125;
</code></pre>
<p>​        初始化阶段图解：</p>
<p><img src="https://img-blog.csdnimg.cn/20200915225840294.png" alt="img"></p>
<p>​        至此，MyBatis初始化阶段完成。</p>
<h2 id="五、MyBatis代理阶段（binding模块分析）"><a href="#五、MyBatis代理阶段（binding模块分析）" class="headerlink" title="五、MyBatis代理阶段（binding模块分析）"></a>五、MyBatis代理阶段（binding模块分析）</h2><h3 id="5-1、MyBatis是如何做到面向Mapper接口编程？"><a href="#5-1、MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="5.1、MyBatis是如何做到面向Mapper接口编程？"></a>5.1、MyBatis是如何做到面向Mapper接口编程？</h3><p>​        只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User uer = userMapper.selectByPrimarKey(1);
</code></pre>
<p>​        MyBatis动态代理后执行的为下面这段代码：</p>
<pre><code class="java">SqlSession sqlSession = sqlSessionFactory.openSession();
User uer = sqlSession.selectOne(&quot;com.en.iot.mapper.&quot;+&quot;UserMapper.selectByPrimarKey&quot;,1);
</code></pre>
<p>​        我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p>​        <strong>1、找到Session中对应的方法执行</strong></p>
<p>​        <strong>2、找到命名空间和方法名</strong></p>
<p>​        <strong>3、传递参数</strong></p>
<p>​        这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200916211402947.png" alt="img"></p>
<p>​        <strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<pre><code class="java">public class MapperRegistry &#123;
   private final Configuration config;
   //mapper接口和对应的代理对象工厂之间的关系
   private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
   ...
&#125;
</code></pre>
<p>​        <strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<pre><code class="java">public class MapperProxyFactory&lt;T&gt; &#123;
  ...
  //key为mapper接口中的某个方法的method对象，value为对应的MapperMethod
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
  ...
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);
  &#125;
&#125;
</code></pre>
<p>​        <strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214700706.png" alt="img"></p>
<p>​        接着跟进**cachedInvoker(method).invoke(proxy, method, args, sqlSession)**方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200916213826490.png" alt="img"></p>
<p>​        我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214239389.png" alt="img"></p>
<p>​        那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916214959863.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215029787.png" alt="img"></p>
<p>​        通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916215442588.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215556263.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200916215523383.png" alt="img"></p>
<h3 id="5-2、代理阶段流程梳理"><a href="#5-2、代理阶段流程梳理" class="headerlink" title="5.2、代理阶段流程梳理"></a>5.2、代理阶段流程梳理</h3><p>​        1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>​        2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>​        3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h2 id="六、MyBatis数据读写阶段"><a href="#六、MyBatis数据读写阶段" class="headerlink" title="六、MyBatis数据读写阶段"></a>六、MyBatis数据读写阶段</h2><h3 id="6-1、MyBatis是怎样的封装jdbc操作的"><a href="#6-1、MyBatis是怎样的封装jdbc操作的" class="headerlink" title="6.1、MyBatis是怎样的封装jdbc操作的"></a>6.1、MyBatis是怎样的封装jdbc操作的</h3><p>​        我们先来回忆一下jdbc代码：</p>
<pre><code class="java">//1.加载驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     
//2.获取连接conn
Connection con=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123&quot;);
//3.创建查询接口
Statement sta= con.createStatement();
//4.执行SQL，返回结果集
ResultSet rs= sta.executeQuery(&quot;SELECT * FROM `user`&quot;);
//5.对结果集数据进行操作
User user = new User();
user.setUserName(String.valueOf(rs.getObject(1)));
</code></pre>
<p>​        其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203050838.png" alt="img"></p>
<p>​        可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img"></p>
<p>​        <strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p>​        <strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p>​        <strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p>​        <strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>​        一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205236272.png" alt="img"></p>
<p>​        可以看到只有BaseExecutor和CachingExecutor两个类重写了**query()**方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<code>&lt;cache&gt;</code>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917205454850.png" alt="img"></p>
<p>​        好的我们继续跟进BaseExecutor的**query()**方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210415293.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200917210606702.png" alt="img"></p>
<p>​        可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917210831277.png" alt="img"></p>
<p>​        我们跟进默认实现SimpleExecutor的**doQuery()**方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211035123.png" alt="img"></p>
<p>​        这段代码有两点值得我们注意，一个是**prepareStatement(handler, ms.getStatementLog())**这个方法，我们跟进去会发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211124589.png" alt="img"></p>
<p>​        <strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919104808424.png" alt="img"></p>
<p>​        <strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p>​        <strong>CallableStatementHandler：</strong>调用存储过程</p>
<p>​        <strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p>​        <strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p>​        <strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>​        RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211725203.png" alt="img"></p>
<p>​        接上文调用SimpleStatementHandler的query方法:</p>
<p><img src="https://img-blog.csdnimg.cn/20200917211854628.png" alt="img"></p>
<p>​        <strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200919110111271.png" alt="img"></p>
<p>​        处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li>创建multipleResults集合，保存最终返回的结果。</li>
<li>取出第一个结果集</li>
<li>获取对应的resultMap</li>
<li>根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</li>
<li>resultset.close()关闭结果集，将multipleResults集合返回</li>
</ol>
<h3 id="6-2、sqlSession查询流程图和Executor内部调用流程图"><a href="#6-2、sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="6.2、sqlSession查询流程图和Executor内部调用流程图"></a>6.2、sqlSession查询流程图和Executor内部调用流程图</h3><h4 id="6-2-1、sqlSession查询流程图："><a href="#6-2-1、sqlSession查询流程图：" class="headerlink" title="6.2.1、sqlSession查询流程图："></a>6.2.1、sqlSession查询流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911381497.png" alt="img"></p>
<h4 id="6-2-2、Executor内部调用流程图："><a href="#6-2-2、Executor内部调用流程图：" class="headerlink" title="6.2.2、Executor内部调用流程图："></a>6.2.2、Executor内部调用流程图：</h4><p><img src="https://img-blog.csdnimg.cn/2020091911204922.png" alt="img"></p>
<p>此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#ffa2c4>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Mybaits知识点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/">
        <h2>
            Mybaits使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="MyBaits使用详解"><a href="#MyBaits使用详解" class="headerlink" title="MyBaits使用详解"></a>MyBaits使用详解</h1><blockquote>
<p> 环境说明：</p>
</blockquote>
<ul>
<li>jdk 8 +</li>
<li>MySQL 5.7.19</li>
<li>maven-3.6.1</li>
<li>IDEA</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1、Mybaits简介"><a href="#1-1、Mybaits简介" class="headerlink" title="1.1、Mybaits简介"></a>1.1、Mybaits简介</h3><ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</li>
<li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到<strong>Github</strong> .</li>
<li>Mybatis官方文档 : <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li>
<li>GitHub : <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li>
</ul>
<h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p>
<ul>
<li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
<li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li>
</ul>
<p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p>
<ul>
<li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li>
<li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p><strong>什么是持久层？</strong></p>
<ul>
<li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li>
<li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li>
<li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li>
<li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li>
</ul>
<h3 id="1-4、Mybaits功能"><a href="#1-4、Mybaits功能" class="headerlink" title="1.4、Mybaits功能"></a>1.4、Mybaits功能</h3><ul>
<li><p>Mybatis就是帮助程序员将数据存入数据库中 , 和从数据库中取数据 .</p>
</li>
<li><p>传统的jdbc操作 , 有很多重复代码块 。比如：数据取出时的封装 , 数据库的建立连接等等，通过框架可以减少重复代码，提高开发效率 。</p>
</li>
<li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p>
</li>
<li><p>MyBatis的优点</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
</ul>
<ul>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<h3 id="1-5、Mybaits程序"><a href="#1-5、Mybaits程序" class="headerlink" title="1.5、Mybaits程序"></a>1.5、Mybaits程序</h3><h4 id="1-5-1、数据库搭建"><a href="#1-5-1、数据库搭建" class="headerlink" title="1.5.1、数据库搭建"></a>1.5.1、数据库搭建</h4><pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
`id` int(20) NOT NULL,
`name` varchar(30) DEFAULT NULL,
`pwd` varchar(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) 
values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);
</code></pre>
<h4 id="1-5-2、导入依赖"><a href="#1-5-2、导入依赖" class="headerlink" title="1.5.2、导入依赖"></a>1.5.2、导入依赖</h4><pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1-5-3、核心配置文件"><a href="#1-5-3、核心配置文件" class="headerlink" title="1.5.3、核心配置文件"></a>1.5.3、核心配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
   &lt;!-- 配置环境 --&gt;
   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
               &lt;property name=&quot;url&quot; 
                         value=&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;amp;
                                useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
    
   &lt;!-- 加载映射地址 --&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="1-5-4、Mybaits工具类"><a href="#1-5-4、Mybaits工具类" class="headerlink" title="1.5.4、Mybaits工具类"></a>1.5.4、Mybaits工具类</h4><pre><code class="java">import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils &#123;

    /**
     * 禁止外界通过new方法创建
         private MybatisUtil()&#123;&#125;
     */
    
   private static SqlSessionFactory sqlSessionFactory;

   static &#123;
       try &#123;
           String resource = &quot;mybatis-config.xml&quot;;
           // 加载核心配置文件
           InputStream inputStream = Resources.getResourceAsStream(resource);
           // 创建sqlsession工厂 --&gt;相当于connection
           sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
      &#125; catch (IOException e) &#123;
           e.printStackTrace();
      &#125;
  &#125;

   //获取SqlSession连接 --&gt;相当于执行sql语句对象
   public static SqlSession getSession()&#123;
       
       /*       
           //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象为空
            if(sqlSession == null)&#123;
                //在SqlSessionFactory非空的情况下，获取SqlSession对象
                sqlSession = sqlSessionFactory.openSession();
                //将SqlSession对象与当前线程绑定在一起
                threadLocal.set(sqlSession);
            &#125;       
       */
       
       return sqlSessionFactory.openSession();
  &#125;
    
   /**
     * 
          关闭SqlSession与当前线程分开
           public static void closeSqlSession()&#123;
            //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象非空
            if(sqlSession != null)&#123;
                //关闭SqlSession对象
                sqlSession.close();
                //分开当前线程与SqlSession对象的关系，目的是让GC尽早回收
                threadLocal.remove();
            &#125;
        &#125;
     
     */
  

&#125;
</code></pre>
<p><strong>MybatisUtil工具类的作用</strong>:</p>
<ul>
<li>在静态初始化块中加载mybatis配置文件和StudentMapper.xml文件一次</li>
<li>使用ThreadLocal对象让当前线程与SqlSession对象绑定在一起</li>
<li>获取当前线程中的SqlSession对象，如果没有的话，从SqlSessionFactory对象中获取SqlSession对象</li>
<li>获取当前线程中的SqlSession对象，再将其关闭，释放其占用的资源</li>
</ul>
<h4 id="1-5-5、实体类"><a href="#1-5-5、实体类" class="headerlink" title="1.5.5、实体类"></a>1.5.5、实体类</h4><pre><code class="java">@Data
public class User &#123;
   
   private int id;  //id
   private String name;   //姓名
   private String pwd;   //密码
   
&#125;
</code></pre>
<h4 id="1-5-6、Mapper接口类"><a href="#1-5-6、Mapper接口类" class="headerlink" title="1.5.6、Mapper接口类"></a>1.5.6、Mapper接口类</h4><pre><code class="java">import com.kuang.pojo.User;
import java.util.List;

public interface UserMapper &#123;
   List&lt;User&gt; selectUser();
&#125;
</code></pre>
<h4 id="1-5-7、Mapper-xml配置文件"><a href="#1-5-7、Mapper-xml配置文件" class="headerlink" title="1.5.7、Mapper.xml配置文件"></a>1.5.7、Mapper.xml配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;
 &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
  select * from user
 &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="1-5-8、测试类"><a href="#1-5-8、测试类" class="headerlink" title="1.5.8、测试类"></a>1.5.8、测试类</h4><pre><code class="java">public class MyTest &#123;
   @Test
   public void selectUser() &#123;
       SqlSession session = MybatisUtils.getSession();
       //方法一:
       List&lt;User&gt; users1 = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);
       
       for (User user: users1)&#123;
           System.out.println(user);
      &#125;    
       
       
       //方法二:
       UserMapper mapper = session.getMapper(UserMapper.class);
       List&lt;User&gt; users2 = mapper.selectUser();
   
       for (User user: users2)&#123;
           System.out.println(user);
      &#125;
       session.close();
  &#125;
&#125;
</code></pre>
<h3 id="1-6、问题说明"><a href="#1-6、问题说明" class="headerlink" title="1.6、问题说明"></a>1.6、问题说明</h3><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/resources&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="二、CUDR操作及配置解析"><a href="#二、CUDR操作及配置解析" class="headerlink" title="二、CUDR操作及配置解析"></a>二、CUDR操作及配置解析</h2><h3 id="2-1、namespace"><a href="#2-1、namespace" class="headerlink" title="2.1、namespace"></a>2.1、namespace</h3><ol>
<li>将上面案例中的UserMapper接口改名为 UserDao；</li>
<li>将UserMapper.xml中的namespace改为为UserDao的路径 ；</li>
<li>再次测试</li>
</ol>
<p><strong>结论：</strong></p>
<p>​        <strong>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名，必须一致！</strong></p>
<h3 id="2-2、CUDR操作"><a href="#2-2、CUDR操作" class="headerlink" title="2.2、CUDR操作"></a>2.2、CUDR操作</h3><h4 id="2-2-1、select操作"><a href="#2-2-1、select操作" class="headerlink" title="2.2.1、select操作"></a>2.2.1、select操作</h4><ul>
<li><p>select标签是mybatis中最常用的标签之一</p>
</li>
<li><p>select语句有很多属性可以详细配置每一条SQL语句</p>
</li>
<li><ul>
<li>SQL语句返回值类型。【完整的类名或者别名】</li>
<li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li>
<li>命名空间中唯一的标识符</li>
<li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li>
<li>id</li>
<li>parameterType</li>
<li>resultType</li>
</ul>
</li>
</ul>
<p><strong>需求一：根据id查询用户</strong></p>
<p>1、在UserMapper中添加对应方法</p>
<pre><code class="java">public interface UserMapper &#123;
   //查询全部用户
   List&lt;User&gt; selectUser();
   //根据id查询用户
   User selectUserById(int id);
&#125;
</code></pre>
<p>2、在UserMapper.xml中添加Select语句</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>select参数：</p>
<p>1). id：</p>
<p>2). <strong>parametweType：</strong>传递的参数</p>
<p>3). <strong>resultType：</strong>是SQL映射文件中定义返回值类型，返回值有基本类型，对象类型，List类型，Map类型等。</p>
<ul>
<li>基本类型：resultType=基本类型</li>
<li>List类型：resultType=<strong>List中元素的类型</strong></li>
<li>Map类型  <ul>
<li>单条记录：resultType=map</li>
<li>多条记录：resultType =Map中value的类型</li>
</ul>
</li>
</ul>
<p><strong>注：</strong>为什么是使用map而不是Map呢？</p>
<p>刚刚配置中的**resultType=”map”**，为什么是map，不是Map呢？</p>
<p>如果想写Map，需要写成全限定类名，即：<strong>resultType = “java.util.Map”</strong> map是java.util.Map的一个简写，还有其他的简写可以参考下方表格：</p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M1.png"></p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M2.png"></p>
<p>3、测试类中测试</p>
<pre><code class="java">@Test
public void tsetSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   System.out.println(user);
   
   session.close();
&#125;
</code></pre>
<p><strong>需求二：根据密码和名字查询用户</strong></p>
<p><strong>思路一：直接在方法中传递参数</strong></p>
<p>1、在接口方法的参数前加 @Param属性</p>
<p>2、Sql语句编写的时候，直接取**@Param中设置的值**即可，不需要单独设置参数类型</p>
<pre><code class="java">//通过密码和名字查询用户
User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);
</code></pre>
<p>3、Mapper.xml配置文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p><strong>思路二：使用Map</strong></p>
<p>1、在接口方法中，参数直接传递Map；</p>
<pre><code class="java">User selectUserByNP2(Map&lt;String,Object&gt; map);
</code></pre>
<p>2、编写sql语句的时候，需要传递参数类型，参数类型为map</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p>3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put(&quot;username&quot;,&quot;小明&quot;);
map.put(&quot;pwd&quot;,&quot;123456&quot;);
User user = mapper.selectUserByNP2(map);
</code></pre>
<p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可.</p>
<h4 id="2-2-2、insert操作"><a href="#2-2-2、insert操作" class="headerlink" title="2.2.2、insert操作"></a>2.2.2、insert操作</h4><p><strong>需求：给数据库增加一个用户</strong></p>
<p>1、在UserMapper接口中添加对应的方法</p>
<pre><code class="java">//添加一个用户
int addUser(User user);
</code></pre>
<p>2、在UserMapper.xml中添加insert语句</p>
<pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
&lt;/insert&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);
   int i = mapper.addUser(user);
   System.out.println(i);
   
   // 提交事务，将事务提交到数据库
   session.commit(); 
   session.close();
&#125;
</code></pre>
<p>​    <strong>注：</strong>增、删、改操作需要提交事务！</p>
<h4 id="2-2-3、update操作"><a href="#2-2-3、update操作" class="headerlink" title="2.2.3、update操作"></a>2.2.3、update操作</h4><p><strong>需求：修改用户的信息</strong></p>
<p>1、同理，编写接口方法</p>
<pre><code class="java">//修改一个用户
int updateUser(User user);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   user.setPwd(&quot;asdfgh&quot;);
   int i = mapper.updateUser(user);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-4、delete操作"><a href="#2-2-4、delete操作" class="headerlink" title="2.2.4、delete操作"></a>2.2.4、delete操作</h4><p><strong>需求：根据id删除一个用户</strong></p>
<p>1、编写接口方法</p>
<pre><code class="java">//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from user where id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   int i = mapper.deleteUser(5);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-5、模糊查询like语句"><a href="#2-2-5、模糊查询like语句" class="headerlink" title="2.2.5、模糊查询like语句"></a>2.2.5、模糊查询like语句</h4><p>方法一：在Java代码中添加sql通配符。</p>
<pre><code class="java">string wildcardname = “%smi%”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like #&#123;value&#125;
&lt;/select&gt;
</code></pre>
<p>方法二：在sql语句中拼接通配符，会引起sql注入</p>
<pre><code class="java">string wildcardname = “smi”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
&lt;/select&gt;
</code></pre>
<h4 id="2-4-6、小结"><a href="#2-4-6、小结" class="headerlink" title="2.4.6、小结"></a>2.4.6、小结</h4><ul>
<li>所有的增删改操作都需要提交事务！</li>
<li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li>
<li>有时候根据业务的需求，可以考虑使用map传递参数！</li>
<li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li>
</ul>
<h3 id="2-3、配置解析"><a href="#2-3、配置解析" class="headerlink" title="2.3、配置解析"></a>2.3、配置解析</h3><h4 id="2-3-1、核心配置文件"><a href="#2-3-1、核心配置文件" class="headerlink" title="2.3.1、核心配置文件"></a>2.3.1、核心配置文件</h4><ul>
<li>mybatis-config.xml 系统核心配置文件</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
<li>能配置的内容如下：</li>
</ul>
<pre><code class="xml">configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;
</code></pre>
<p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p>
<h4 id="2-3-2、environments元素"><a href="#2-3-2、environments元素" class="headerlink" title="2.3.2、environments元素"></a>2.3.2、environments元素</h4><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;

        &lt;!-- 事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<ul>
<li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p>
</li>
<li><p>子元素节点：<strong>environment</strong></p>
<ul>
<li>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</li>
</ul>
<ul>
<li><p>数据源是必须配置的。</p>
</li>
<li><p>有三种内建的数据源类型</p>
</li>
</ul>
</li>
</ul>
<pre><code class="xml">type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）
</code></pre>
<ul>
<li><p><strong>unpooled：</strong>这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
</li>
<li><p><strong>JNDI：</strong>这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
<li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p>
</li>
<li><p>详情：点击查看官方文档</p>
</li>
<li><p>这两种事务管理器类型都不需要设置任何属性。</p>
</li>
<li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p>
</li>
<li><p>子元素节点：transactionManager - [ 事务管理器 ]</p>
</li>
</ul>
<pre><code class="xml">&lt;!-- 语法 --&gt;
&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;
</code></pre>
<ul>
<li>子元素节点：<strong>数据源（dataSource）</strong></li>
</ul>
<h4 id="2-3-3、mappers元素"><a href="#2-3-3、mappers元素" class="headerlink" title="2.3.3、mappers元素"></a>2.3.3、mappers元素</h4><p><strong>mappers</strong></p>
<ul>
<li><strong>映射器 :</strong> 定义映射SQL语句文件</li>
<li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用<strong>相对于类路径的资源引用</strong>， 或<strong>完全限定资源定位符</strong>（包括 <code>file:///</code> 的 URL），或类名和包名等。</li>
<li>映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li>
</ul>
<p><strong>引入资源方式</strong></p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
    使用映射器接口实现类的完全限定类名
    需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Mapper文件</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
   
&lt;/mapper&gt;
</code></pre>
<ul>
<li><p>namespace中文意思：命名空间，作用如下：</p>
<ul>
<li>namespace的命名必须跟某个接口同名</li>
</ul>
<ul>
<li>接口中的方法与映射文件中sql语句id应该一一对应<ul>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p>
<h4 id="2-3-4、Properties优化"><a href="#2-3-4、Properties优化" class="headerlink" title="2.3.4、Properties优化"></a>2.3.4、Properties优化</h4><p>​        数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<p>​        第一步 ; 在资源目录下新建一个<strong>db.properties</strong></p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
username=root
password=123456
</code></pre>
<p>​        第二步 : 将文件导入properties 配置文件</p>
<pre><code class="xml">&lt;configuration&gt;
   &lt;!--导入properties文件--&gt;
   &lt;properties resource=&quot;db.properties&quot;/&gt;

   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
               &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>更多操作，可以查看官方文档！【演示带领学习】</p>
<ul>
<li>配置文件优先级问题</li>
<li>新特性：使用占位符</li>
</ul>
<h4 id="2-4-5、typeAliases优化"><a href="#2-4-5、typeAliases优化" class="headerlink" title="2.4.5、typeAliases优化"></a>2.4.5、typeAliases优化</h4><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<pre><code class="xml">&lt;!--配置别名,注意顺序--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p>
<pre><code class="xml">&lt;typeAliases&gt;
   &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p>
<p>若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class User &#123;
  ...
&#125;
</code></pre>
<p>去官网查看一下Mybatis默认的一些类型别名！</p>
<h4 id="2-4-6、其他浏览设置"><a href="#2-4-6、其他浏览设置" class="headerlink" title="2.4.6、其他浏览设置"></a>2.4.6、其他浏览设置</h4><ul>
<li><p>设置（settings）相关 =&gt; 查看帮助文档</p>
<ul>
<li>懒加载</li>
</ul>
<ul>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li><p>一个配置完整的 settings 元素的示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;!--该配置影响的所有映射器中配置的缓存的全局开关--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态--&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--是否允许单一语句返回多结果集（需要兼容驱动）。--&gt;
    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。--&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。--&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。--&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
   
    &lt;!----&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    
    &lt;!--配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。--&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
   
    &lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。--&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
   
    &lt;!--Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.--&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    
    &lt;!--允许在嵌套语句中使用分页（RowBounds）。--&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
   
    &lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。--&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。--&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    
    &lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。--&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    
    &lt;!--指定哪个对象的方法触发一次延迟加载。--&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;

    &lt;!--指定动态 SQL 生成的默认语言。--&gt;
    &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver&quot;/&gt;

    &lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。--&gt;
    &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;

    &lt;!--定 MyBatis 增加到日志名称的前缀。--&gt;
    &lt;setting name=&quot;logPrefix&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 MyBatis 所用日志的具体实现，未指定时将自动查找。--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。--&gt;
    &lt;setting name=&quot;proxyFactory&quot; value=&quot;JAVASSIST&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
</ul>
<p><strong>类型处理器</strong></p>
<ul>
<li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li>
<li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li>
</ul>
<p><strong>对象工厂</strong></p>
<ul>
<li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li>
<li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li>
<li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li>
</ul>
<h4 id="2-4-7、生命周期和作用域"><a href="#2-4-7、生命周期和作用域" class="headerlink" title="2.4.7、生命周期和作用域"></a>2.4.7、生命周期和作用域</h4><p>​        理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>作用域理解</strong></p>
<ul>
<li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li>
<li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li>
<li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li>
<li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li>
<li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li>
<li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、ResultMap以及分页"><a href="#三、ResultMap以及分页" class="headerlink" title="三、ResultMap以及分页"></a>三、ResultMap以及分页</h2><h3 id="3-1、查询为null"><a href="#3-1、查询为null" class="headerlink" title="3.1、查询为null"></a>3.1、查询为null</h3><h4 id="3-1-1、属性名和字段名不一致问题"><a href="#3-1-1、属性名和字段名不一致问题" class="headerlink" title="3.1.1、属性名和字段名不一致问题"></a>3.1.1、属性名和字段名不一致问题</h4><p>环境：新建一个项目，将之前的项目拷贝过来</p>
<p>1、查看之前的数据库的字段名</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KdXPq6whFkfHe43CtgZMJrr62lCnbfxl25aQ4ZDwlU4JiaMZHs3nqAoNxFsJYZRC4Cm11uSH0USNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、Java中的实体类设计</p>
<pre><code class="java">@Data
public class User &#123;

   private int id;  //id
   private String name;   //姓名
   private String password;   //密码和数据库不一样！
   
&#125;
</code></pre>
<p>3、接口</p>
<pre><code class="java">//根据id查询用户
User selectUserById(int id);
</code></pre>
<p>4、mapper映射文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   System.out.println(user);
   session.close();
&#125;
</code></pre>
<p><strong>结果:</strong></p>
<ul>
<li>User{id=1, name=’狂神’, password=’null’}</li>
<li>查询出来发现 password 为空 . 说明出现了问题！</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li><p>select * from user where id = #{id} 可以看做</p>
<p>select  id,name,pwd  from user where id = #{id}</p>
</li>
<li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p>
</li>
</ul>
<h4 id="3-1-2、解决方案"><a href="#3-1-2、解决方案" class="headerlink" title="3.1.2、解决方案"></a>3.1.2、解决方案</h4><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;
    select id , name , pwd as password 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>方案二：使用结果集映射——-&gt;ResultMap</strong> 【推荐】</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
    select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;

&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!-- id为主键 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="3-2、ResultMap"><a href="#3-2、ResultMap" class="headerlink" title="3.2、ResultMap"></a>3.2、ResultMap</h3><p><strong>自动映射</strong></p>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li>
<li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li>
<li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li>
</ul>
<p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;
    select id , name , pwd
    from user
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p>
<p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p>
<p><strong>手动映射</strong></p>
<p>1、返回值类型为resultMap</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
  select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>2、编写resultMap，实现手动映射！</p>
<pre><code class="xml">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
   &lt;!-- id为主键 --&gt;
   &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
   &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
   &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<p>​        数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p>
<h3 id="3-3、分页"><a href="#3-3、分页" class="headerlink" title="3.3、分页"></a>3.3、分页</h3><h4 id="3-3-1、日志工厂"><a href="#3-3-1、日志工厂" class="headerlink" title="3.3.1、日志工厂"></a>3.3.1、日志工厂</h4><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p>
<p>​        如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p>
<p>​        对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p>
<p>​        Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>​        具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p>
<p><strong>标准日志实现</strong></p>
<p>​        指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p>
<pre><code class="xml">&lt;settings&gt;
       &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>​        测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p>
<h4 id="3-3-2、Log4j简介："><a href="#3-3-2、Log4j简介：" class="headerlink" title="3.3.2、Log4j简介："></a>3.3.2、Log4j<strong>简介：</strong></h4><ul>
<li>Log4j是Apache的一个开源项目</li>
<li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p><strong>使用步骤：</strong></p>
<p>1、导入log4j的包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置文件编写</p>
<pre><code class="properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
<p>3、setting设置日志实现</p>
<pre><code class="xml">&lt;settings&gt;
   &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>4、在程序中使用Log4j进行输出！</p>
<pre><code class="java">//注意导包：org.apache.log4j.Logger
static Logger logger = Logger.getLogger(MyTest.class);

@Test
public void selectUser() &#123;
   logger.info(&quot;info：进入selectUser方法&quot;);
   logger.debug(&quot;debug：进入selectUser方法&quot;);
   logger.error(&quot;error: 进入selectUser方法&quot;);
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   List&lt;User&gt; users = mapper.selectUser();
   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<p>5、测试，看控制台输出！</p>
<ul>
<li>使用Log4j 输出日志</li>
<li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</li>
</ul>
<h4 id="3-3-3、limit实现分页"><a href="#3-3-3、limit实现分页" class="headerlink" title="3.3.3、limit实现分页"></a>3.3.3、limit实现分页</h4><p><strong>思考：为什么需要分页？</strong></p>
<p>​        在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p>
<p><strong>使用Limit实现分页</strong></p>
<pre><code class="sql">#语法
SELECT * FROM table LIMIT stratIndex，pageSize

SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  

#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   
SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  

#如果只给定一个参数，它表示返回最大的记录行数目：   
SELECT * FROM table LIMIT 5; //检索前 5 个记录行  

#换句话说，LIMIT n 等价于 LIMIT 0,n。 
</code></pre>
<p><strong>步骤：</strong></p>
<p>1、修改Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;
    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>
<p>2、Mapper接口，参数为map</p>
<pre><code class="java">//选择全部用户实现分页
List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);
</code></pre>
<p>3、在测试类中传入参数测试</p>
<ul>
<li>推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li>
</ul>
<pre><code class="java">//分页查询 , 两个参数startIndex , pageSize
@Test
public void testSelectUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   int currentPage = 1;  //第几页
   int pageSize = 2;  //每页显示几个
   Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();
   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);
   map.put(&quot;pageSize&quot;,pageSize);

   List&lt;User&gt; users = mapper.selectUser(map);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<blockquote>
<p>RowBounds分页</p>
</blockquote>
<p>​        我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p>
<p><strong>步骤：</strong></p>
<p>1、mapper接口</p>
<pre><code class="java">//选择全部用户RowBounds实现分页
List&lt;User&gt; getUserByRowBounds();
</code></pre>
<p>2、mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<p>在这里，我们需要使用RowBounds类</p>
<pre><code class="java">@Test
public void testUserByRowBounds() &#123;
   SqlSession session = MybatisUtils.getSession();

   int currentPage = 2;  //第几页
   int pageSize = 2;  //每页显示几个
   RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);

   //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]
   List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<h4 id="3-3-4、PageHelper"><a href="#3-3-4、PageHelper" class="headerlink" title="3.3.4、PageHelper"></a>3.3.4、PageHelper</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<h2 id="四、注解开发"><a href="#四、注解开发" class="headerlink" title="四、注解开发"></a>四、注解开发</h2><h3 id="4-1、面向接口编程"><a href="#4-1、面向接口编程" class="headerlink" title="4.1、面向接口编程"></a>4.1、面向接口编程</h3><ul>
<li><strong>根本原因 :  解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<h4 id="4-1-1、关于接口的理解"><a href="#4-1-1、关于接口的理解" class="headerlink" title="4.1.1、关于接口的理解"></a>4.1.1、关于接口的理解</h4><ul>
<li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p>
</li>
<li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p>
</li>
<li><p>接口应有两类：</p>
<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； </li>
</ul>
<ul>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li>
</ul>
</li>
<li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p>
</li>
</ul>
<h4 id="4-1-2、三个面向区别"><a href="#4-1-2、三个面向区别" class="headerlink" title="4.1.2、三个面向区别"></a>4.1.2、三个面向区别</h4><ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</li>
</ul>
<h3 id="4-2、利用注解开发"><a href="#4-2、利用注解开发" class="headerlink" title="4.2、利用注解开发"></a>4.2、利用注解开发</h3><ul>
<li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p>
</li>
<li><p>sql 类型主要分成 :</p>
<ul>
<li>@select () </li>
</ul>
<ul>
<li>@update ()</li>
<li>@Insert ()</li>
<li>@delete ()</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>利用注解开发就不需要mapper.xml映射文件了 .</p>
<p>1、我们在我们的接口中添加注解</p>
<pre><code class="java">//查询全部用户
@Select(&quot;select id,name,pwd password from user&quot;)
public List&lt;User&gt; getAllUser();
</code></pre>
<p>2、在mybatis的核心配置文件中注入</p>
<pre><code class="xml">&lt;!--使用class绑定接口--&gt;
&lt;mappers&gt;
   &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>3、我们去进行测试</p>
<pre><code class="java">@Test
public void testGetAllUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   //本质上利用了jvm的动态代理机制
   UserMapper mapper = session.getMapper(UserMapper.class);

   List&lt;User&gt; users = mapper.getAllUser();
   for (User user : users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<p>4、利用Debug查看本质</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNnMiahVkdvictXZkDDWHQCwob9rMlKtxnhiaQee5Kxa6K0BCbHH2ibRERibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、本质上利用了jvm的动态代理机制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNeukjWMleICg2Jsm8hTI63hvVLiarGmD7zT1CmgXlUXSUbmdhialeIjpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>6、Mybatis详细的执行流程</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="4-3、注解增删改"><a href="#4-3、注解增删改" class="headerlink" title="4.3、注解增删改"></a>4.3、注解增删改</h3><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。</p>
<pre><code class="java">//获取SqlSession连接
public static SqlSession getSession()&#123;
    return getSession(true); //事务自动提交
&#125;

public static SqlSession getSession(boolean flag)&#123;
    return sqlSessionFactory.openSession(flag);
&#125;
</code></pre>
<p>【注意】确保实体类和数据库字段对应</p>
<p><strong>查询：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id查询用户
@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
User selectUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.selectUserById(1);
   System.out.println(user);

   session.close();
&#125;
</code></pre>
<p><strong>新增：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//添加一个用户
@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)
int addUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;);
   mapper.addUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>修改：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//修改一个用户
@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)
int updateUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);
   mapper.updateUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>删除：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id删除用
@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
int deleteUser(@Param(&quot;id&quot;)int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   mapper.deleteUser(6);
   
   session.close();
&#125;
</code></pre>
<p>【注意点：增删改一定记得对事务的处理】</p>
<h3 id="4-4、关于-Param"><a href="#4-4、关于-Param" class="headerlink" title="4.4、关于@Param"></a>4.4、关于@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p>
<ul>
<li>在方法只接受一个参数的情况下，可以不使用@Param。</li>
<li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li>
<li>如果参数是 JavaBean ， 则不能使用@Param。</li>
<li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li>
</ul>
<h3 id="4-5、-与-的区别"><a href="#4-5、-与-的区别" class="headerlink" title="4.5、#与$的区别"></a>4.5、#与$的区别</h3><ul>
<li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (#&#123;name&#125;);
INSERT INTO user (name) VALUES (?);
</code></pre>
</li>
<li><p>${} 的作用是直接进行字符串替换</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);
INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);
</code></pre>
</li>
</ul>
<h2 id="五、一对多处理与多对一处理"><a href="#五、一对多处理与多对一处理" class="headerlink" title="五、一对多处理与多对一处理"></a>五、一对多处理与多对一处理</h2><h3 id="5-1、多对一处理"><a href="#5-1、多对一处理" class="headerlink" title="5.1、多对一处理"></a>5.1、多对一处理</h3><h4 id="5-1-1、数据库设计"><a href="#5-1-1、数据库设计" class="headerlink" title="5.1.1、数据库设计"></a>5.1.1、数据库设计</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LPbib5To6slfFhMArq5QvCjofjccx37cuQgKsWEHibax0bDiaicU6ojNfEzWrj3TibFsX3MJju4sAp5Pg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="sql">CREATE TABLE `teacher` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);

CREATE TABLE `student` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
`tid` INT(10) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `fktid` (`tid`),
CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
</code></pre>
<h4 id="5-1-2、搭建测试环境"><a href="#5-1-2、搭建测试环境" class="headerlink" title="5.1.2、搭建测试环境"></a>5.1.2、搭建测试环境</h4><p>1、IDEA安装Lombok插件</p>
<p>2、引入Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.16.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、在代码中增加注解</p>
<pre><code class="java">@Data //GET,SET,ToString，有参，无参构造
public class Teacher &#123;
   private int id;
   private String name;
&#125;
@Data
public class Student &#123;
   private int id;
   private String name;
   //多个学生可以是同一个老师，即多对一
   private Teacher teacher;
&#125;
</code></pre>
<p>4、编写实体类对应的Mapper接口 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="java">public interface StudentMapper &#123;
&#125;
public interface TeacherMapper &#123;
&#125;
</code></pre>
<p>5、编写Mapper接口对应的 mapper.xml配置文件 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

&lt;/mapper&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="5-1-3、按查询嵌套处理"><a href="#5-1-3、按查询嵌套处理" class="headerlink" title="5.1.3、按查询嵌套处理"></a>5.1.3、按查询嵌套处理</h4><p>1、给StudentMapper接口增加方法</p>
<pre><code class="java">//获取所有学生及对应老师的信息
public List&lt;Student&gt; getStudents();
</code></pre>
<p>2、编写对应的Mapper文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

   &lt;!--
   需求：获取所有学生及对应老师的信息
   思路：
       1. 获取所有学生的信息
       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息
       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？
           1. 做一个结果集映射：StudentTeacher
           2. StudentTeacher结果集的类型为 Student
           3. 学生中老师的属性为teacher，对应数据库中为tid。
              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多
           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询
   --&gt;
   &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
   &lt;/select&gt;
   &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
       &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
       &lt;association property=&quot;teacher&quot;  column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
   &lt;/resultMap&gt;
   &lt;!--
   这里传递过来的id，只有一个属性的时候，下面可以写任何值
   association中column多参数配置：
       column=&quot;&#123;key=value,key=value&#125;&quot;
       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
      select * from teacher where id = #&#123;id&#125;
   &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p>
<p>4、注意点说明：</p>
<pre><code class="xml">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
   &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
   &lt;association property=&quot;teacher&quot;  column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
这里传递过来的id，只有一个属性的时候，下面可以写任何值
association中column多参数配置：
   column=&quot;&#123;key=value,key=value&#125;&quot;
   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
--&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testGetStudents()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<h4 id="5-1-4、按结果嵌套处理"><a href="#5-1-4、按结果嵌套处理" class="headerlink" title="5.1.4、按结果嵌套处理"></a>5.1.4、按结果嵌套处理</h4><p>我们还可以按照结果进行嵌套处理；</p>
<p>1、接口方法编写</p>
<pre><code class="java">public List&lt;Student&gt; getStudents2();
</code></pre>
<p>2、编写对应的mapper文件</p>
<pre><code class="xml">&lt;!--
按查询结果嵌套处理
思路：
   1. 直接查询出结果，进行结果集的映射
--&gt;
&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;
  select s.id sid, s.name sname , t.name tname
  from student s,teacher t
  where s.tid = t.id
&lt;/select&gt;

&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
   &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
   &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
   &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;
   &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
       &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
   &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<p>3、去mybatis-config文件中注入【此处应该处理过了】</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetStudents2()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents2();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>按照查询进行嵌套处理就像SQL中的子查询</p>
<p>按照结果进行嵌套处理就像SQL中的联表查询</p>
<h3 id="5-2、一对多处理"><a href="#5-2、一对多处理" class="headerlink" title="5.2、一对多处理"></a>5.2、一对多处理</h3><h4 id="5-2-1、实体类编写"><a href="#5-2-1、实体类编写" class="headerlink" title="5.2.1、实体类编写"></a>5.2.1、实体类编写</h4><pre><code class="java">@Data
public class Student &#123;
   private int id;
   private String name;
   private int tid;
&#125;

@Data
public class Teacher &#123;
   private int id;
   private String name;
   //一个老师多个学生
   private List&lt;Student&gt; students;
&#125;
</code></pre>
<h4 id="5-2-2、按结果嵌套"><a href="#5-2-2、按结果嵌套" class="headerlink" title="5.2.2、按结果嵌套"></a>5.2.2、按结果嵌套</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">//获取指定老师，及老师下的所有学生
public Teacher getTeacher(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

   &lt;!--
   思路:
       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名
       2. 对查询出来的操作做结果集映射
           1. 集合的话，使用collection！
               JavaType和ofType都是用来指定对象类型的
               JavaType是用来指定pojo中属性的类型
               ofType指定的是映射到list集合属性中pojo的类型。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
      select s.id sid, s.name sname , t.name tname, t.id tid
      from student s,teacher t
      where s.tid = t.id and t.id=#&#123;id&#125;
   &lt;/select&gt;

   &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
       &lt;result  property=&quot;name&quot; column=&quot;tname&quot;/&gt;
       &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
           &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;
           &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;
           &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;
       &lt;/collection&gt;
   &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<pre><code class="xml">&lt;mappers&gt;
   &lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<h4 id="5-2-3、按查询嵌套处理"><a href="#5-2-3、按查询嵌套处理" class="headerlink" title="5.2.3、按查询嵌套处理"></a>5.2.3、按查询嵌套处理</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">public Teacher getTeacher2(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;
    select * from teacher where id = #&#123;id&#125;
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher2()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher2(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、关联-association</p>
<p>2、集合-collection</p>
<p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p>
<p>4、JavaType和ofType都是用来指定对象类型的</p>
<ul>
<li>JavaType是用来指定pojo中属性的类型</li>
<li>ofType指定的是映射到list集合属性中pojo的类型。</li>
</ul>
<p><strong>注意说明：</strong></p>
<p>1、保证SQL的可读性，尽量通俗易懂</p>
<p>2、根据实际要求，尽量编写性能更高的SQL语句</p>
<p>3、注意属性名和字段不一致的问题</p>
<p>4、注意一对多和多对一 中：字段和属性对应的问题</p>
<p>5、尽量使用Log4j，通过日志来查看自己的错误</p>
<h2 id="六、动态SQL"><a href="#六、动态SQL" class="headerlink" title="六、动态SQL"></a>六、动态SQL</h2><h3 id="6-1、动态SQL简介"><a href="#6-1、动态SQL简介" class="headerlink" title="6.1、动态SQL简介"></a>6.1、动态SQL简介</h3><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p>
<pre><code>官网描述：
MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。
虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。
动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

  -------------------------------
  - if
  - choose (when, otherwise)
  - trim (where, set)
  - foreach
  -------------------------------
</code></pre>
<p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p>
<p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p>
<h3 id="6-2、搭建环境"><a href="#6-2、搭建环境" class="headerlink" title="6.2、搭建环境"></a>6.2、搭建环境</h3><h4 id="6-2-1、数据库"><a href="#6-2-1、数据库" class="headerlink" title="6.2.1、数据库"></a>6.2.1、数据库</h4><pre><code class="sql">CREATE TABLE `blog` (
`id` varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,
`author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
`create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
`views` int(30) NOT NULL COMMENT &#39;浏览量&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<h4 id="6-2-2、创建Mybaits基础工程"><a href="#6-2-2、创建Mybaits基础工程" class="headerlink" title="6.2.2、创建Mybaits基础工程"></a>6.2.2、创建Mybaits基础工程</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JISvrLfLvE3e9Wv1kpFL9qzPPOq4EuoibKKLvGve4vEicLpXeEHfz1flqX3ribyzpbjDlOGzziapTsIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、IDutil工具类</p>
<pre><code class="java">public class IDUtil &#123;

   public static String genId()&#123;
       return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);
  &#125;

&#125;
</code></pre>
<p>3、实体类编写  【注意set方法作用】</p>
<pre><code class="java">import java.util.Date;

public class Blog &#123;

   private String id;
   private String title;
   private String author;
   private Date createTime;
   private int views;
   //set，get....
&#125;
</code></pre>
<p>4、编写Mapper接口及xml文件</p>
<pre><code class="java">public interface BlogMapper &#123;
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<p>5、mybatis核心配置文件，下划线驼峰自动转换</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
&lt;!--注册Mapper.xml--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>6、插入初始数据</p>
<p>编写接口</p>
<pre><code class="java">//新增一个博客
int addBlog(Blog blog);
</code></pre>
<p>sql配置文件</p>
<pre><code class="xml">&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;
  insert into blog (id, title, author, create_time, views)
  values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);
&lt;/insert&gt;
</code></pre>
<p>初始化博客方法</p>
<pre><code class="java">@Test
public void addInitBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   Blog blog = new Blog();
   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Mybatis如此简单&quot;);
   blog.setAuthor(&quot;狂神说&quot;);
   blog.setCreateTime(new Date());
   blog.setViews(9999);

   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Java如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Spring如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;微服务如此简单&quot;);
   mapper.addBlog(blog);

   session.close();
&#125;
</code></pre>
<p>初始化数据完毕！</p>
<h3 id="6-3、if语句"><a href="#6-3、if语句" class="headerlink" title="6.3、if语句"></a>6.3、if语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p>
<p>1、编写接口类</p>
<pre><code class="java">//需求1
List&lt;Blog&gt; queryBlogIf(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询
select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;
--&gt;
&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog where
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogIf()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！</p>
<h3 id="6-4、Where语句"><a href="#6-4、Where语句" class="headerlink" title="6.4、Where语句"></a>6.4、Where语句</h3><p>修改上面的SQL语句；</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;if test=&quot;title != null&quot;&gt;
          title = #&#123;title&#125;
       &lt;/if&gt;
       &lt;if test=&quot;author != null&quot;&gt;
          and author = #&#123;author&#125;
       &lt;/if&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p>
<h3 id="6-5、Set语句"><a href="#6-5、Set语句" class="headerlink" title="6.5、Set语句"></a>6.5、Set语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p>
<p>1、编写接口方法</p>
<pre><code class="java">int updateBlog(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;!--注意set是用的逗号隔开--&gt;
&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;
  update blog
     &lt;set&gt;
         &lt;if test=&quot;title != null&quot;&gt;
            title = #&#123;title&#125;,
         &lt;/if&gt;
         &lt;if test=&quot;author != null&quot;&gt;
            author = #&#123;author&#125;
         &lt;/if&gt;
     &lt;/set&gt;
  where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;动态SQL&quot;);
   map.put(&quot;author&quot;,&quot;秦疆&quot;);
   map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);

   mapper.updateBlog(map);


   session.close();
&#125;
</code></pre>
<h3 id="6-6、choose语句"><a href="#6-6、choose语句" class="headerlink" title="6.6、choose语句"></a>6.6、choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>1、编写接口方法</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogChoose(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;choose&gt;
           &lt;when test=&quot;title != null&quot;&gt;
                title = #&#123;title&#125;
           &lt;/when&gt;
           &lt;when test=&quot;author != null&quot;&gt;
              and author = #&#123;author&#125;
           &lt;/when&gt;
           &lt;otherwise&gt;
              and views = #&#123;views&#125;
           &lt;/otherwise&gt;
       &lt;/choose&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void testQueryBlogChoose()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   map.put(&quot;views&quot;,9999);
   List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<h3 id="6-7、SQL片段"><a href="#6-7、SQL片段" class="headerlink" title="6.7、SQL片段"></a>6.7、SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p>
<p><strong>提取SQL片段：</strong></p>
<pre><code class="xml">&lt;sql id=&quot;if-title-author&quot;&gt;
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<p><strong>引用SQL片段：</strong></p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;
       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>注意：</p>
<p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p>
<p>②、在 sql 片段中不要包括 where</p>
<h3 id="6-8、Foreach"><a href="#6-8、Foreach" class="headerlink" title="6.8、Foreach"></a>6.8、Foreach</h3><p>将数据库中前三个数据的id修改为1,2,3；</p>
<p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p>
<p>1、编写接口</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogForeach(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!--
       collection:指定输入对象中的集合属性
       item:每次遍历生成的对象
       open:开始遍历时的拼接字符串
       close:结束时拼接的字符串
       separator:遍历对象之间需要拼接的字符串
       select * from blog where 1=1 and (id=1 or id=2 or id=3)
     --&gt;
       &lt;foreach collection=&quot;ids&quot;  item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
          id=#&#123;id&#125;
       &lt;/foreach&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogForeach()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap map = new HashMap();
   List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
   ids.add(1);
   ids.add(2);
   ids.add(3);
   map.put(&quot;ids&quot;,ids);

   List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。</p>
<h2 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h2><h3 id="7-1、缓存简介"><a href="#7-1、缓存简介" class="headerlink" title="7.1、缓存简介"></a>7.1、缓存简介</h3><h4 id="7-1-1、缓存"><a href="#7-1-1、缓存" class="headerlink" title="7.1.1、缓存"></a>7.1.1、缓存</h4><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
<h4 id="7-1-2、Mybaits缓存"><a href="#7-1-2、Mybaits缓存" class="headerlink" title="7.1.2、Mybaits缓存"></a>7.1.2、Mybaits缓存</h4><ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p>
</li>
<li><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="7-2、一级缓存"><a href="#7-2、一级缓存" class="headerlink" title="7.2、一级缓存"></a>7.2、一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<h4 id="7-2-1、测试"><a href="#7-2-1、测试" class="headerlink" title="7.2.1、测试"></a>7.2.1、测试</h4><p>1、在mybatis中加入日志，方便测试结果</p>
<p>2、编写接口方法</p>
<pre><code class="java">//根据id查询用户
User queryUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>3、接口对应的Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
  select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>5、结果分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="7-2-2、一级缓存失效情况"><a href="#7-2-2、一级缓存失效情况" class="headerlink" title="7.2.2、一级缓存失效情况"></a>7.2.2、一级缓存失效情况</h4><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
   session2.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！</p>
<p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(2);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！很正常的理解</p>
<p>结论：<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<pre><code class="java">//修改用户
int updateUser(Map map);
</code></pre>
<p>编写SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;
  update user set name = #&#123;name&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   HashMap map = new HashMap();
   map.put(&quot;name&quot;,&quot;kuangshen&quot;);
   map.put(&quot;id&quot;,4);
   mapper.updateUser(map);

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：查询在中间执行了增删改操作后，重新执行了</p>
<p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   session.clearCache();//手动清除缓存

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>一级缓存就是一个map</p>
<h3 id="7-3、二级缓存"><a href="#7-3、二级缓存" class="headerlink" title="7.3、二级缓存"></a>7.3、二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、开启全局缓存 【mybatis-config.xml】</p>
<pre><code class="xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<pre><code class="xml">&lt;cache/&gt;

官方示例=====&gt;查看官方文档
&lt;cache
 eviction=&quot;FIFO&quot;
 flushInterval=&quot;60000&quot;
 size=&quot;512&quot;
 readOnly=&quot;true&quot;/&gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
</code></pre>
<p>3、代码测试</p>
<ul>
<li>所有的实体类先实现序列化接口</li>
<li>测试代码</li>
</ul>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();

   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   session.close();

   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session2.close();
&#125;
</code></pre>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<h3 id="7-4、缓存原理图"><a href="#7-4、缓存原理图" class="headerlink" title="7.4、缓存原理图"></a>7.4、缓存原理图</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-5、EhCache"><a href="#7-5、EhCache" class="headerlink" title="7.5、EhCache"></a>7.5、EhCache</h3><p>第三方缓存实现–EhCache: 查看百度百科</p>
<p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p>
<p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
   &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在mapper.xml中使用对应的缓存即可</p>
<pre><code class="xml">&lt;mapper namespace = “org.acme.FooMapper” &gt;
   &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;
&lt;/mapper&gt;
</code></pre>
<p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&gt;
   &lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      user.home – 用户主目录
      user.dir – 用户当前工作目录
      java.io.tmpdir – 默认临时文件路径
    --&gt;
   &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
   
   &lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

   &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
   &lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
   &lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&gt;

&lt;/ehcache&gt;
</code></pre>
<p>合理的使用缓存，可以让我们程序的性能大大提升！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#1bccbc>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/MyBaits使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/">
        <h2>
            Spring整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、Mybaits-Spring包"><a href="#一、Mybaits-Spring包" class="headerlink" title="一、Mybaits-Spring包"></a>一、Mybaits-Spring包</h2><p>MyBatis-Spring 会帮助我们将 MyBatis 代码无缝地整合到 Spring 中，MyBatis-Spring 需要以下版本：</p>
<pre><code class="java">| MyBatis-Spring | MyBatis | Spring 框架 | Spring Batch | Java   |
| -------------- | ------- | --------- | ------------ | ------- |
| 2.0            | 3.5+    | 5.0+      | 4.0+         | Java 8+ |
| 1.3            | 3.4+    | 3.2.2+    | 2.1+         | Java 6+ |
</code></pre>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>​        要和 Spring 一起使用 MyBatis，首先需要<code>SqlSessionFactory</code>，在MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>,配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>注</strong>：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 <code>DataSource</code>，只需要和配置其它 Spring 数据库连接一样配置它就可以了</p>
<p><strong><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。</strong></p>
<p>作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。<code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
<p>可以使用 <code>SqlSessionFactory</code> 作为构造方法的参数来创建 <code>SqlSessionTemplate</code> 对象。</p>
<pre><code class="xml">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样:</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
  private SqlSession sqlSession;
  public void setSqlSession(SqlSession sqlSession) &#123;
    this.sqlSession = sqlSession;
  &#125;
  public User getUser(String userId) &#123;
    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);
  &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;
  &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="二、Spring整个Mybaits"><a href="#二、Spring整个Mybaits" class="headerlink" title="二、Spring整个Mybaits"></a>二、Spring整个Mybaits</h2><h3 id="2-1、user数据表："><a href="#2-1、user数据表：" class="headerlink" title="2.1、user数据表："></a>2.1、<strong>user数据表：</strong></h3><pre><code class="sql">CREATE TABLE user(
    id INT NOT NULL,
    &#39;name&#39; VARCHAR(20) NOT NULL,
    &#39;pwd&#39; VARCHAR(20) NOT NULL,
    PRIMARY KEY(id)
)ENGINE=InnoDB DEFAULT CHARSET=utf-8; 
</code></pre>
<h3 id="2-2、实体类"><a href="#2-2、实体类" class="headerlink" title="2.2、实体类"></a>2.2、<strong>实体类</strong></h3><pre><code class="java">@Data
@ALLArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
<h3 id="2-3、导包"><a href="#2-3、导包" class="headerlink" title="2.3、导包"></a>2.3、<strong>导包</strong></h3><ul>
<li>mybatis-spring整合包 【最重要】</li>
<li>mybaits</li>
<li>mysql驱动的</li>
<li>junit</li>
<li>spring-core</li>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-jdbc 【数据源】</li>
<li>spring-tx 【事务】</li>
<li>…</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--mybaits--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--mysql连接驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.9&lt;/version&gt;
        &lt;/dependency&gt;
    
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"><a href="#2-4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件" class="headerlink" title="2.4、配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件"></a>2.4、<strong>配置mybatis文件，只需要写一些简单的设置，别名，mapper映射文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.westos.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/westos/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="2-5、编写Spring配置文件"><a href="#2-5、编写Spring配置文件" class="headerlink" title="2.5、编写Spring配置文件"></a>2.5、<strong>编写Spring配置文件</strong></h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!--1.配置数据源,我们使用的是spring的数据源，还可以使用第三方的数据源
        dbcp,c3p0
        com.mchange.v2.c3p0.ComboPooledDataSource
        org.apache.commons.dbcp.BasicDataSource
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--2.配置SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--关联mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--3.创建selSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="2-6、接口实现类增加一个属性：sqlSession"><a href="#2-6、接口实现类增加一个属性：sqlSession" class="headerlink" title="2.6、接口实现类增加一个属性：sqlSession"></a>2.6、<strong>接口实现类增加一个属性：sqlSession</strong></h3><pre><code class="java">import org.apache.ibatis.session.SqlSession;
import org.westos.pojo.User;
import java.util.List;

public class UserMapperImpl implements UserMapper &#123;
    private SqlSession sqlSession;
    public void setSqlSession(SqlSession sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;
    public List&lt;User&gt; getUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
    &#125;
&#125;
</code></pre>
<h3 id="2-7、将接口的实现类交给spring来管理"><a href="#2-7、将接口的实现类交给spring来管理" class="headerlink" title="2.7、将接口的实现类交给spring来管理"></a>2.7、<strong>将接口的实现类交给spring来管理</strong></h3><pre><code class="xml">&lt;!--4.接口实现类注入sqlSession--&gt;
&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.westos.dao.UserMapperImpl&quot;&gt;
   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2-8、测试类"><a href="#2-8、测试类" class="headerlink" title="2.8、测试类"></a>2.8、<strong>测试类</strong></h3><pre><code class="java">import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.westos.pojo.User;
import java.util.List;

public class TestUserMapper &#123;
    
    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapperImpl userMapperImpl = (UserMapperImpl) context.getBean(&quot;UserMapperImpl&quot;);
        List&lt;User&gt; users = userMapperImpl.getUser();
        for (User user : users) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="三、整合Druid并开启监控"><a href="#三、整合Druid并开启监控" class="headerlink" title="三、整合Druid并开启监控"></a>三、整合Druid并开启监控</h2><h3 id="3-1、整合Druid"><a href="#3-1、整合Druid" class="headerlink" title="3.1、整合Druid"></a>3.1、整合Druid</h3><h4 id="3-1-1-导入starter"><a href="#3-1-1-导入starter" class="headerlink" title="3.1.1 导入starter"></a>3.1.1 导入starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.1.2、配置yaml</p>
<pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    type: com.alibaba.druid.pool.DruidDataSource
    
    #连接池配置(可选)
    # 连接池的配置信息初始化大小，最小，最大
    name: testDruidDataSource
    initial-size: 5    #初始化连接大小
    max-active: 20    #最大连接数
    min-idle: 5        #最小空闲连接数
    max-wait: 60000   # 配置获取连接等待超时的时间
    
    #######监控配置  说明请参考Druid Wiki
    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙
    filters: stat,wall
    #配置 Web Stat Filter
    web-stat-filter:
      enabled: true
      url-pattern: /*
      exclusions: /druid/*,*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico
      session-stat-enable: true
      session-stat-max-count: 10
      principal-session-name: session_name
      principal-cookie-name: cookie_name
      profile-enable:
      
    # Stat View Servlet 配置  配置默认false
    stat-view-servlet:
      enabled: true
      url-pattern: /druid/*
      reset-enable: false   #禁用HTML页面上的“Reset All”功能
      login-username: admin  #监控页面登录的用户名
      login-password: 123  #监控页面登录的密码
      #IP白名单(没有配置或者为空，则允许所有访问)
      allow:
      #IP黑名单 (存在共同时，deny优先于allow)
      deny:
</code></pre>
<p><strong>由于springboot默认的是hikari，号称最快的数据源，这里我们换成了阿里巴巴的数据源，druid最强大的则是监控功能</strong></p>
<pre><code class="java">class com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper
com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@3f866f50
</code></pre>
<h3 id="3-2、整合Mybaits"><a href="#3-2、整合Mybaits" class="headerlink" title="3.2、整合Mybaits"></a>3.2、整合Mybaits</h3><h4 id="3-2-1、导包"><a href="#3-2-1、导包" class="headerlink" title="3.2.1、导包"></a>3.2.1、导包</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="3-2-2、实体类"><a href="#3-2-2、实体类" class="headerlink" title="3.2.2、实体类"></a>3.2.2、实体类</h4><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student &#123;
    private int id;
    private String name;
    private int tid;
&#125;
</code></pre>
<h4 id="3-2-3、StudentMapper"><a href="#3-2-3、StudentMapper" class="headerlink" title="3.2.3、StudentMapper"></a>3.2.3、StudentMapper</h4><pre><code class="java">@Mapper
@Repository
public interface StudentMapper &#123;
     List&lt;Student&gt; selectAllStudent();
&#125;
</code></pre>
<h4 id="3-2-4、StudentMapper-xml"><a href="#3-2-4、StudentMapper-xml" class="headerlink" title="3.2.4、StudentMapper .xml"></a>3.2.4、StudentMapper .xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.kexing.mapper.StudentMapper&quot;&gt;
    &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt;
        select * from student
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="3-2-5、配置数据源、实体别名、mapper地址"><a href="#3-2-5、配置数据源、实体别名、mapper地址" class="headerlink" title="3.2.5、配置数据源、实体别名、mapper地址"></a>3.2.5、配置数据源、实体别名、mapper地址</h4><pre><code class="yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student?serverTimezone=UTC
    username: root
    password: 123
    
mybatis:
  type-aliases-package: site.kexing.pojo
  mapper-locations: classpath:mapper/*.xml
</code></pre>
<h4 id="3-2-6、测试输出"><a href="#3-2-6、测试输出" class="headerlink" title="3.2.6、测试输出"></a>3.2.6、测试输出</h4><pre><code class="java">@RestController
public class StudentController &#123;
    @Autowired
    StudentMapper studentMapper;
    @RequestMapping(&quot;/selectall&quot;)
    public List&lt;Student&gt; selectAllStudent()&#123;
        List&lt;Student&gt; students = studentMapper.selectAllStudent();
        return students;
    &#125;
&#125;
</code></pre>
<pre><code class="java">[&#123;
    &quot;id&quot;:1,&quot;name&quot;:&quot;小明&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:2,&quot;name&quot;:&quot;小红&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:3,&quot;name&quot;:&quot;小张&quot;,&quot;tid&quot;:2&#125;,&#123;
    &quot;id&quot;:4,&quot;name&quot;:&quot;小李&quot;,&quot;tid&quot;:1&#125;,&#123;
    &quot;id&quot;:5,&quot;name&quot;:&quot;旺旺&quot;,&quot;tid&quot;:1&#125;]
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Mybaits" style=color:#1bccbc>
                Mybaits
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Mybaits/Spring与Mybaits整合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/">
        <h2>
            SpringBoot整合Mybaits
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h1><h2 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h2><h3 id="1-1、选择项目所需要的依赖"><a href="#1-1、选择项目所需要的依赖" class="headerlink" title="1.1、选择项目所需要的依赖"></a>1.1、选择项目所需要的依赖</h3><p><img src="https://img-blog.csdn.net/20180926174507971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="1-2、pom-xml"><a href="#1-2、pom-xml" class="headerlink" title="1.2、pom.xml"></a>1.2、pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;demo&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
 
    &lt;name&gt;demo&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
 
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
 
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
 
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
 
 
&lt;/project&gt;
</code></pre>
<h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>​        本文不使用application.properties文件 而使用更加简洁的application.yml文件。将resource文件夹下原有的application.properties文件删除，创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties），本文创建了两个yml文件（application.yml和application-dev.yml），分别来看一下内容</p>
<ul>
<li>application.yml</li>
</ul>
<pre><code class="yml">spring:
  profiles:
    active: dev
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8080
 
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
</code></pre>
<p>​        两个文件的意思是：</p>
<blockquote>
<p>在项目中配置多套环境的配置方法。<br>因为现在一个项目有好多环境，开发环境，测试环境，准生产环境，生产环境，每个环境的参数不同，所以我们就可以把每个环境的参数配置到yml文件中，这样在想用哪个环境的时候只需要在主配置文件中将用的配置文件写上就行如application.yml</p>
<p>笔记：在Spring Boot中多环境配置文件名需要满足application-{profile}.yml的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.yml：开发环境<br>application-test.yml：测试环境<br>application-prod.yml：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.yml文件中通过<strong>spring.profiles.active属性</strong>来设置，其值对应{profile}值。</p>
</blockquote>
<p>​        还有配置文件中最好不要有中文注释，会报错。</p>
<p>​        接下来把启动文件移到com.example下，而且springboot的启动类不能放在java目录下！！！必须要个包将它包进去</p>
<p>​        否则会报错误：</p>
<pre><code class="java">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.
</code></pre>
<p>​        这个原因值得注意就是因为有时候很难在IDEA中的项目目录认出来这个错误并且还容易扫描不到一些类</p>
<h2 id="二、创建类"><a href="#二、创建类" class="headerlink" title="二、创建类"></a>二、创建类</h2><p>​        创建包controller、entity、mapper、service。resources下创建mapping文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。下面直接贴代码</p>
<h3 id="2-1、创建实体类"><a href="#2-1、创建实体类" class="headerlink" title="2.1、创建实体类"></a>2.1、创建实体类</h3><h4 id="2-1-1、数据库表结构"><a href="#2-1-1、数据库表结构" class="headerlink" title="2.1.1、数据库表结构"></a>2.1.1、数据库表结构</h4><pre><code class="sql">CREATE TABLE `user` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `userName` varchar(32) NOT NULL,
  `passWord` varchar(50) NOT NULL,
  `realName` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre>
<p><img src="https://img-blog.csdn.net/20180927092715962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>entity.java</li>
</ul>
<pre><code class="java">package com.example.entity;
 
@Data
public class User &#123;
    private Integer id;
    private String userName;
    private String passWord;
    private String realName;
&#125;
</code></pre>
<ul>
<li>UserController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
@RequestMapping(&quot;/testBoot&quot;)
public class UserController &#123;
 
    @Autowired
    private UserService userService;
 
    @RequestMapping(&quot;getUser/&#123;id&#125;&quot;)
    public String GetUser(@PathVariable int id)&#123;
        return userService.Sel(id).toString();
    &#125;
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
&#125;
</code></pre>
<ul>
<li>UserMappering.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;com.example.entity.User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
&lt;/mapper&gt;
</code></pre>
<p>最终框架结构</p>
<p><img src="https://img-blog.csdn.net/20180927095234881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>启动类</li>
</ul>
<pre><code class="java">package com.example;
 
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
 
@MapperScan(&quot;com.example.mapper&quot;) //扫描的mapper
@SpringBootApplication
public class DemoApplication &#123;
 
    public static void main(String[] args) &#123;
        SpringApplication.run(DemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="三、注册、登录以及拦截器配置"><a href="#三、注册、登录以及拦截器配置" class="headerlink" title="三、注册、登录以及拦截器配置"></a>三、注册、登录以及拦截器配置</h2><ul>
<li>添加依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>application-dev.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8888
 
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.entity
#showSql
logging:
  level:
    com:
      example:
        mapper : debug
spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    prefix: classpath:/templates/
    suffix: .html
    encoding: utf-8
    mode: html5
    servlet:
      content-type: text/html
</code></pre>
<ul>
<li>register.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;form action=&quot;/user/register&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Register&quot;/&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot; type=&quot;text/css&quot; /&gt;--&gt;
&lt;form action=&quot;/user/loginUser&quot; method=&quot;post&quot;&gt;
    请输入用户名--：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;br&gt;
    请你输入密码--：&lt;input type=&quot;password&quot; name=&quot;passWord&quot; id=&quot;passWord&quot;/&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;
    &lt;a href=&quot;/user/toRegister&quot;&gt;--注册--&lt;/a&gt;
&lt;/form&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>welcome.html</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
注册或登录后才能看到的界面
 
&lt;a href=&quot;/user/outUser&quot;&gt;退出登录&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>LoginController.java</li>
</ul>
<pre><code class="java">package com.example.controller;
 
import com.example.entity.User;
import com.example.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController &#123;
    @Autowired
    private UserService userService;
 
    //跳转首页（登录页）
    @RequestMapping(&quot;/toIndex&quot;)
    public String show()&#123;
        return &quot;index&quot;;
    &#125;
 
    //登录操作
    @ResponseBody
    @RequestMapping(&quot;/loginUser&quot;)
    public String login(User user, HttpServletRequest request)&#123;
        String userName = user.getUserName();
        String passWord = user.getPassWord();
        User u1 =userService.login(userName,passWord);
        if (u1==null)&#123;
            return &quot;用户名或密码错误&quot;;
        &#125;else&#123;
            request.getSession().setAttribute(&quot;session_user&quot;,user);//登录成功后将用户放入session中，用于拦截
            return &quot;登录成功&quot;;
        &#125;
    &#125;
 
    //跳转注册页
    @RequestMapping(&quot;/toRegister&quot;)
    public String toRegister()&#123;
        return &quot;register&quot;;
    &#125;
 
    //注册操作
    @RequestMapping(&quot;/register&quot;)
    public String register(User user)&#123;
        int su = userService.register(user);
        if(su==0)&#123;
            System.out.println(&quot;----&quot;);
        &#125;
        return &quot;welcome&quot;;
    &#125;
 
    //测试未登陆拦截页面
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome()&#123;
        return &quot;welcome&quot;;
    &#125;
 
    //退出登录
    @RequestMapping(&quot;/outUser&quot;)
    public void outUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        request.getSession().removeAttribute(&quot;session_user&quot;);
        response.sendRedirect(&quot;/user/toIndex&quot;);
    &#125;
 
&#125;
</code></pre>
<ul>
<li>UserService.java</li>
</ul>
<pre><code class="java">package com.example.service;
 
import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
 
    public User login(String userName, String passWord) &#123;
        return userMapper.login(userName,passWord);
    &#125;
 
    public int register(User user) &#123;
        return userMapper.register(user);
    &#125;
&#125;
</code></pre>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="java">package com.example.mapper;
 
import com.example.entity.User;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
 
@Repository
public interface UserMapper &#123;
 
    User Sel(int id);
 
    User login(String userName,String passWord);
 
    int register(User user);
&#125;
</code></pre>
<ul>
<li>UserMapping.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
 
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;
        &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot; /&gt;
        &lt;result column=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;passWord&quot; /&gt;
        &lt;result column=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;select id=&quot;Sel&quot; resultType=&quot;User&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
 
    &lt;select id=&quot;login&quot; resultType=&quot;User&quot;&gt;
        SELECT * FROM user where userName = #&#123;param1&#125; and passWord = #&#123;param2&#125;
    &lt;/select&gt;
 
    &lt;insert id=&quot;register&quot; parameterType=&quot;User&quot;&gt;
        INSERT INTO user (userName, passWord) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>其实注册登录也诶逻辑也很简单，就不多赘述了，接下来讲讲实现拦截器功能（敲黑板，本章的重点）</p>
<p>首先在com.example下新建intercetor包，然后新建UserIntercetor.java实现HandlerInterceptor接口并重写方法，更多介绍都写在里面注释了</p>
<ul>
<li>UserIntercetor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import com.example.entity.User;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Component
public class UserInterceptor implements HandlerInterceptor &#123;
 
    /*
     * 进入controller层之前拦截请求
     * 返回值：表示是否将当前的请求拦截下来  false：拦截请求，请求别终止。true：请求不被拦截，继续执行
     * Object obj:表示被拦的请求的目标对象（controller中方法）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;
        System.out.println(&quot;执行到了preHandle方法&quot;);
        System.out.println(handler);
        User user = (User) request.getSession().getAttribute(&quot;session_user&quot;);
        if (user==null)&#123;
            response.sendRedirect(request.getContextPath()+&quot;/user/toIndex&quot;);//拦截后跳转的方法
            System.out.println(&quot;已成功拦截并转发跳转&quot;);
            return false;
        &#125;
        System.out.println(&quot;合格不需要拦截，放行&quot;);
        return true;
    &#125;
 
    /*
     * 处理请求完成后视图渲染之前的处理操作
     * 通过ModelAndView参数改变显示的视图，或发往视图的方法
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;
        System.out.println(&quot;执行了postHandle方法&quot;);
    &#125;
 
    /*
     * 视图渲染之后的操作
     */
    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;
        System.out.println(&quot;执行到了afterCompletion方法&quot;);
    &#125;
 
&#125;
</code></pre>
<p>新建类SessionInterceptor实现WebMvcConfigurer接口来注册拦截器</p>
<ul>
<li>SessionInterceptor.java</li>
</ul>
<pre><code class="java">package com.example.interceptor;
 
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
import java.util.ArrayList;
import java.util.List;

@Configuration
public class SessionInterceptor implements WebMvcConfigurer &#123;
 
    /**
     * 自定义拦截器，添加拦截路径和排除拦截路径
     * addPathPatterns():添加需要拦截的路径
     * excludePathPatterns():添加不需要拦截的路径
     */
    //注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        List list = new ArrayList();
        list.add(&quot;/user/toIndex&quot;);
        list.add(&quot;/user/loginUser&quot;);
        list.add(&quot;/user/toRegister&quot;);
        list.add(&quot;/user/register&quot;);
        registry.addInterceptor(new UserInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(list);
 
    &#125;
&#125;
</code></pre>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>4.1、application.yml文件中文注释乱码</p>
<pre><code class="yml">server:
  port: 8080
  servlet:
    jsp:
      init-parameters:
        # jsp修改之后立即生效
        development: true
</code></pre>
<p><img src="https://img-blog.csdn.net/20180908114638271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4ODcwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot" style=color:#00bcd4>
                SpringBoot
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot整合Mybatis/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/">
        <h2>
            SSM整合
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SSM整合笔记"><a href="#SSM整合笔记" class="headerlink" title="SSM整合笔记"></a>SSM整合笔记</h1><h2 id="一、数据库环境"><a href="#一、数据库环境" class="headerlink" title="一、数据库环境"></a>一、数据库环境</h2><h3 id="1-1、创建数据库及数据表"><a href="#1-1、创建数据库及数据表" class="headerlink" title="1.1、创建数据库及数据表"></a>1.1、创建数据库及数据表</h3><pre><code class="sql">CREATE TABLE `books`(    
    `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,    
    `bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;, 
    `bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,    
    `detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,   
    KEY `bookId` (`bookId`)
) ENGINE=INNODB DEFAULT CHARSET=utf8; 

INSERT INTO books(`bookId`,`bookName`,`bookCounts`,`detail`) 
    VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;), (2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;), (3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);
</code></pre>
<h2 id="二、导入依赖"><a href="#二、导入依赖" class="headerlink" title="二、导入依赖"></a>二、导入依赖</h2><h3 id="2-1、导入jar包"><a href="#2-1、导入jar包" class="headerlink" title="2.1、导入jar包"></a>2.1、导入jar包</h3><p>​        创建一个maven工程，导入依赖和静态资源处理的配置。</p>
<pre><code class="xml">&lt;dependencies&gt;
    
    &lt;!--Junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--数据库驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.35&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--连接池--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--servlet--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jsp--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--JSTL--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;
   
    &lt;!--mybatis-spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--jdbc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--静态资源导出问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="2-2、建包："><a href="#2-2、建包：" class="headerlink" title="2.2、建包："></a>2.2、建包：</h3><p>​        连接数据库；    </p>
<p>​        在src/main/java下创建pojo、service、controller、dao、util。</p>
<p>​        在resource文件夹下创建mybatis-config.xml、applicationContext.xml、database.properties。</p>
<h3 id="2-3、修改resource下的配置文件："><a href="#2-3、修改resource下的配置文件：" class="headerlink" title="2.3、修改resource下的配置文件："></a>2.3、修改resource下的配置文件：</h3><h4 id="2-3-1、mybatis-config-xml"><a href="#2-3-1、mybatis-config-xml" class="headerlink" title="2.3.1、mybatis-config.xml"></a>2.3.1、mybatis-config.xml</h4><p>​        关联数据库文件源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--
        数据源配置交给spring做
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.example.pojo&quot;/&gt;
        &lt;/typeAliases&gt;
    --&gt;
    
    &lt;!--写一些mapper配置文件的注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<p>​        编写pojo文件夹下的实体类：Books；</p>
<p>​        编写dao文件夹下的接口：BookMapper；</p>
<p>​        编写BookMapper.xml</p>
<h4 id="2-3-2、applicationContext-xml"><a href="#2-3-2、applicationContext-xml" class="headerlink" title="2.3.2、applicationContext.xml"></a>2.3.2、applicationContext.xml</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--将其他三层的spring配置文件合在一起即可--&gt;
    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="2-3-3、database-properties"><a href="#2-3-3、database-properties" class="headerlink" title="2.3.3、database.properties"></a>2.3.3、database.properties</h4><p>​        数据库的配置文件    </p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
# 如果使用MySQL8.0，还需要增加一个时区的配置 &amp;serverTimezone=Asia/Shanghai
jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=123456
</code></pre>
<h2 id="三、Mybatis层的配置："><a href="#三、Mybatis层的配置：" class="headerlink" title="三、Mybatis层的配置："></a>三、Mybatis层的配置：</h2><h3 id="3-1、创建pojo对象"><a href="#3-1、创建pojo对象" class="headerlink" title="3.1、创建pojo对象"></a>3.1、创建pojo对象</h3><p>​    采用lombok依赖对这个pojo生成get、set方法等一系列方法。</p>
<pre><code class="xml">&lt;!--lombok--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    
    &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@Data       //get、set等方法
@AllArgsConstructor     //有参构造
@NoArgsConstructor      //无参构造
public class Book &#123;
    private Integer bookId;
    private String bookName;
    private Integer bookCounts;
    private String detail;
&#125;
</code></pre>
<h3 id="3-2、创建dao接口。"><a href="#3-2、创建dao接口。" class="headerlink" title="3.2、创建dao接口。"></a>3.2、创建dao接口。</h3><pre><code class="java">public interface BookMapper &#123;
    int addBook(Book book);
    int deleteBookById(@Param(&quot;id&quot;) Integer id);
    int updateBook(Book book);
    Book queryBookById(@Param(&quot;id&quot;) Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<h3 id="3-3、创建mapper配置文件"><a href="#3-3、创建mapper配置文件" class="headerlink" title="3.3、创建mapper配置文件"></a>3.3、创建mapper配置文件</h3><p>​        并在全局配置中进行注册</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.example.pojo.Book&quot;&gt;
        insert into books(`bookName`,`bookCounts`,`detail`) values
        (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;details&#125;)
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot;&gt;
        delete from books where bookId = #&#123;id&#125;
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot;&gt;
        update books set `bookName` = #&#123;bookName&#125;,`bookCounts` = #&#123;bookCounts&#125;,
        `detail` = #&#123;detail&#125; where `bookId` = #&#123;bookId&#125;
    &lt;/update&gt;

    &lt;select id=&quot;queryBookById&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books where `bookId` = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBooks&quot; resultType=&quot;com.example.pojo.Book&quot;&gt;
        select * from books
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="3-4、创建service业务。"><a href="#3-4、创建service业务。" class="headerlink" title="3.4、创建service业务。"></a>3.4、创建service业务。</h3><pre><code class="java">public interface BookService &#123;
    int addBook(Book book);
    int deleteBookById(Integer id);
    int updateBook(Book book);
    Book queryBookById(Integer id);
    List&lt;Book&gt; queryAllBooks();
&#125;
</code></pre>
<pre><code class="java">public class BookServiceImpl implements BookService&#123;
    // 之后用spring自动注入
    // service调dao层：组合Dao
    private BookMapper bookMapper;
    
    @Override
    public int addBook(Book book) &#123;
        return bookMapper.addBook(book);
    &#125;
    @Override
    public int deleteBookById(Integer id) &#123;
        return bookMapper.deleteBookById(id);
    &#125;
    @Override
    public int updateBook(Book book) &#123;
        return bookMapper.updateBook(book);
    &#125;
    @Override
    public Book queryBookById(Integer id) &#123;
        return bookMapper.queryBookById(id);
    &#125;
    @Override
    public List&lt;Book&gt; queryAllBooks() &#123;
        return bookMapper.queryAllBooks();
    &#125;
&#125;
</code></pre>
<h2 id="四、Spring层的配置："><a href="#四、Spring层的配置：" class="headerlink" title="四、Spring层的配置："></a>四、Spring层的配置：</h2><h3 id="4-1、创建一个新的spring配置文件去整合dao层"><a href="#4-1、创建一个新的spring配置文件去整合dao层" class="headerlink" title="4.1、创建一个新的spring配置文件去整合dao层"></a>4.1、创建一个新的spring配置文件去整合dao层</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--关联数据库配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;
    
    &lt;!--连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--绑定数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--绑定mybatis的配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
   
    &lt;!--配置dao接口扫描包，可以将dao接口注入到spring的容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描dao包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.example.dao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="4-2、创建一个新的spring配置文件去整合service层。"><a href="#4-2、创建一个新的spring配置文件去整合service层。" class="headerlink" title="4.2、创建一个新的spring配置文件去整合service层。"></a>4.2、创建一个新的spring配置文件去整合service层。</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service包--&gt;
    &lt;context:component-scan base-package=&quot;com.example.service&quot;/&gt;

    &lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--aop事务支持--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.example.dao.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="五、springMVC层配置："><a href="#五、springMVC层配置：" class="headerlink" title="五、springMVC层配置："></a>五、springMVC层配置：</h2><h3 id="5-1、添加web支持，创建web-xml"><a href="#5-1、添加web支持，创建web-xml" class="headerlink" title="5.1、添加web支持，创建web.xml"></a>5.1、添加web支持，创建web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    
    &lt;!--配置前端处理器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--绑定的是spring的全局配置文件--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;!--
            /  :
            /* :会过滤到jsp等资源
        --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;!--配置乱码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!--配置session--&gt;
    &lt;session-config&gt;
        &lt;!--配置session超时时间--&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="5-2、创建spring的mvc配置文件"><a href="#5-2、创建spring的mvc配置文件" class="headerlink" title="5.2、创建spring的mvc配置文件"></a>5.2、创建spring的mvc配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--注解驱动--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--扫描controller--&gt;
    &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt;
    &lt;!--视图解析器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="5-3、在WEB-INF下创建jsp目录。"><a href="#5-3、在WEB-INF下创建jsp目录。" class="headerlink" title="5.3、在WEB-INF下创建jsp目录。"></a>5.3、在WEB-INF下创建jsp目录。</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#ff7d73>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/SSM整合笔记/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot使用详解/">
        <h2>
            SpringBoot使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringBoot使用详解"><a href="#SpringBoot使用详解" class="headerlink" title="SpringBoot使用详解"></a>SpringBoot使用详解</h1><h2 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h2><p>​        什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p>
<p>​        所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p>
<p>​        这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p>
<p>​        随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p>
<p>​        Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置</strong>的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>
<p>​        简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p><strong>Spring Boot的主要优点：</strong></p>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<h2 id="二、HelloSpringBoot"><a href="#二、HelloSpringBoot" class="headerlink" title="二、HelloSpringBoot"></a>二、HelloSpringBoot</h2><h3 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h3><p><strong>环境准备：</strong></p>
<ul>
<li>java version “1.8.0_181”</li>
<li>Maven-3.6.1</li>
<li>SpringBoot 2.x 最新版</li>
</ul>
<h3 id="2-2、创建项目说明"><a href="#2-2、创建项目说明" class="headerlink" title="2.2、创建项目说明"></a>2.2、创建项目说明</h3><p>Spring官方提供了非常方便的工具让我们快速构建应用</p>
<p>Spring Initializr：<a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p><strong>项目创建方式一：</strong>使用Spring Initializr 的 Web页面创建项目</p>
<p>1、打开  <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p>2、填写项目信息</p>
<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>
<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>
<p><strong>项目创建方式二：</strong>使用 IDEA 直接创建项目</p>
<p>1、创建一个新项目</p>
<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>
<p>3、填写项目信息</p>
<p>4、选择初始化的组件（初学勾选 Web 即可）</p>
<p>5、填写项目路径</p>
<p>6、等待项目构建成功</p>
<p><strong>项目结构分析：</strong></p>
<p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p>
<p>1、程序的主启动类</p>
<p>2、一个 application.properties 配置文件</p>
<p>3、一个 测试类</p>
<p>4、一个 pom.xml</p>
<h3 id="2-3、搭建项目"><a href="#2-3、搭建项目" class="headerlink" title="2.3、搭建项目"></a>2.3、搭建项目</h3><p><strong>pom.xml分析</strong></p>
<pre><code class="xml">&lt;!-- 父依赖 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!-- web场景启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- springboot单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;!-- 剔除依赖 --&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 打包插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p><strong>http接口类</strong></p>
<p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p>
<p>2、在包中新建一个HelloController类</p>
<pre><code class="java">@RestController
public class HelloController &#123;

    @RequestMapping(&quot;/hello&quot;)
    public String hello() &#123;
        return &quot;Hello World&quot;;
    &#125;
    
&#125;
</code></pre>
<p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p>
<h3 id="2-4、打包项目"><a href="#2-4、打包项目" class="headerlink" title="2.4、打包项目"></a>2.4、打包项目</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZiczfno2TOQbfItia25xQzicMFnkicKh5pVD7IrHrUicb03y381CicrLFKXNMw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果遇到以上错误，可以配置打包时，跳过项目运行测试用例</p>
<pre><code class="xml">&lt;!--
    在工作中,很多情况下我们打包是不想执行测试用例的
    可能是测试用例不完事,或是测试用例会影响数据库数据
    跳过测试用例执
    --&gt;

&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;!--跳过项目运行测试用例--&gt;
        &lt;skipTests&gt;true&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>如果打包成功，则会在target目录下生成一个 jar 包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZic03vupvIqMbibWh4aIKyjiaQfwuvDWKo033g9kRvj6aXnJO4brKTdwnvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、SpringBoot运行原理"><a href="#三、SpringBoot运行原理" class="headerlink" title="三、SpringBoot运行原理"></a>三、SpringBoot运行原理</h2><h3 id="3-1、pom-xml"><a href="#3-1、pom-xml" class="headerlink" title="3.1、pom.xml"></a>3.1、pom.xml</h3><h4 id="3-1-1、父依赖"><a href="#3-1-1、父依赖" class="headerlink" title="3.1.1、父依赖"></a>3.1.1、父依赖</h4><p>​        其中它主要是依赖一个父项目，主要是<strong>管理项目的资源过滤及插件</strong>！</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>​        点进去，发现还有一个父依赖</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>​        这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的<strong>版本控制中心</strong>；</p>
<p>​        <strong>注</strong>：导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</p>
<h4 id="3-1-2、启动类-spring-boot-starter"><a href="#3-1-2、启动类-spring-boot-starter" class="headerlink" title="3.1.2、启动类 spring-boot-starter"></a>3.1.2、启动类 spring-boot-starter</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>​        SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h3 id="3-2、主启动类"><a href="#3-2、主启动类" class="headerlink" title="3.2、主启动类"></a>3.2、主启动类</h3><h4 id="3-2-1、默认的主启动类"><a href="#3-2-1、默认的主启动类" class="headerlink" title="3.2.1、默认的主启动类"></a>3.2.1、默认的主启动类</h4><pre><code class="java">//@SpringBootApplication 来标注一个主程序类
//说明这是一个Spring Boot应用

@SpringBootApplication
public class SpringbootApplication &#123;

   public static void main(String[] args) &#123;
     //以为是启动了一个方法，没想到启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   &#125;

&#125;
</code></pre>
<h4 id="3-2-2、-SpringBootApplication"><a href="#3-2-2、-SpringBootApplication" class="headerlink" title="3.2.2、@SpringBootApplication"></a>3.2.2、@SpringBootApplication</h4><p>​        作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<pre><code class="java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
public @interface SpringBootApplication &#123;
    // ......
&#125;
</code></pre>
<h4 id="3-2-3、-ComponentScan"><a href="#3-2-3、-ComponentScan" class="headerlink" title="3.2.3、@ComponentScan"></a>3.2.3、@ComponentScan</h4><p>​        这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>​        作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h4 id="3-2-4、-SpringBootConfiguration"><a href="#3-2-4、-SpringBootConfiguration" class="headerlink" title="3.2.4、@SpringBootConfiguration"></a>3.2.4、@SpringBootConfiguration</h4><p>​        作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>​        继续查看注解：</p>
<pre><code class="java">// 点进去得到下面的 @Component
@Configuration
public @interface SpringBootConfiguration &#123;&#125;

@Component
public @interface Configuration &#123;&#125;
</code></pre>
<p>​        这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>​        里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>​        我们回到 SpringBootApplication 注解中继续看。</p>
<h4 id="3-2-5、-EnableAutoConfiguration"><a href="#3-2-5、-EnableAutoConfiguration" class="headerlink" title="3.2.5、@EnableAutoConfiguration"></a>3.2.5、@EnableAutoConfiguration</h4><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>​        以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>​        点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<pre><code class="java">@Import(&#123;Registrar.class&#125;)
public @interface AutoConfigurationPackage &#123;
&#125;
</code></pre>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>​        Registrar.class 作用：<u>将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器</u> ；</p>
<p>​        这个分析完了，退到上一步，继续看</p>
<p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<p>​        AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<pre><code class="java">// 获得候选的配置
protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
    // 这里的getSpringFactoriesLoaderFactoryClass（）方法
    // 返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
&#125;
</code></pre>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！查看SpringFactoriesLoader类loadFactoryNames() 方法</p>
<pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;
    String factoryClassName = factoryClass.getName();
    //这里它又调用了 loadSpringFactories 方法
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
&#125;
</code></pre>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<pre><code class="ava">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;
    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) &#123;
        return result;
    &#125; else &#123;
        try &#123;
            //去获取一个资源 &quot;META-INF/spring.factories&quot;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            //将读取到的资源遍历，封装成为一个Properties
            while(urls.hasMoreElements()) &#123;
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) &#123;
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    &#125;
                &#125;
            &#125;

            cache.put(classLoader, result);
            return result;
        &#125; catch (IOException var13) &#123;
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、发现一个多次出现的文件：spring.factories，进行全局搜索</p>
<h4 id="3-2-6、spring-factories"><a href="#3-2-6、spring-factories" class="headerlink" title="3.2.6、spring.factories"></a>3.2.6、spring.factories</h4><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicEIZDCZKtTPxQrKTvEdxHFGsG824OkO8XN8CfP2x4OdpC8DwjHYwcFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicaV7UfSRiaRdCHNmHE1wS10QwbLEVZJLB2sN9ztcvjx7n2dKDJ0HrCmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>​        所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值；</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<h3 id="3-3、SpringApplication"><a href="#3-3、SpringApplication" class="headerlink" title="3.3、SpringApplication"></a>3.3、SpringApplication</h3><h4 id="3-3-1、不简单的方法"><a href="#3-3-1、不简单的方法" class="headerlink" title="3.3.1、不简单的方法"></a>3.3.1、不简单的方法</h4><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p>
<pre><code class="java">@SpringBootApplication
public class SpringbootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootApplication.class, args);
    &#125;
&#125;
</code></pre>
<p><strong>SpringApplication.run分析</strong></p>
<p>​        分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<h4 id="3-3-2、SpringApplication"><a href="#3-3-2、SpringApplication" class="headerlink" title="3.3.2、SpringApplication"></a>3.3.2、SpringApplication</h4><p><strong>这个类主要做了以下四件事情：</strong></p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
&#125;
</code></pre>
<h4 id="3-3-3、run方法流程分析"><a href="#3-3-3、run方法流程分析" class="headerlink" title="3.3.3、run方法流程分析"></a>3.3.3、run方法流程分析</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="四、yaml配置注入"><a href="#四、yaml配置注入" class="headerlink" title="四、yaml配置注入"></a>四、yaml配置注入</h2><h3 id="4-1、配置文件"><a href="#4-1、配置文件" class="headerlink" title="4.1、配置文件"></a>4.1、配置文件</h3><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li><p>application.properties</p>
</li>
<li><ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li><p>application.yml</p>
</li>
<li><ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<h3 id="4-2、使用yaml"><a href="#4-2、使用yaml" class="headerlink" title="4.2、使用yaml"></a>4.2、使用yaml</h3><h4 id="4-2-1、yaml概述"><a href="#4-2-1、yaml概述" class="headerlink" title="4.2.1、yaml概述"></a>4.2.1、yaml概述</h4><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p>
<p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p>
<h4 id="4-2-2、yaml基础语法"><a href="#4-2-2、yaml基础语法" class="headerlink" title="4.2.2、yaml基础语法"></a>4.2.2、yaml基础语法</h4><p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: “kuang \n shen”  输出 ：kuang  换行  shen</p>
</li>
<li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘kuang \n shen’  输出 ：kuang  \n  shen</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="yaml">#对象、Map格式
k: 
    v1:
    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="yaml">student:
    name: qinjiang
    age: 3
</code></pre>
<p>行内写法</p>
<pre><code class="yaml">student: &#123;name: qinjiang,age: 3&#125;
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="yaml">server:
  port: 8082
</code></pre>
<h3 id="4-3、注入配置文件"><a href="#4-3、注入配置文件" class="headerlink" title="4.3、注入配置文件"></a>4.3、注入配置文件</h3><h4 id="4-3-1、yaml注入配置文件"><a href="#4-3-1、yaml注入配置文件" class="headerlink" title="4.3.1、yaml注入配置文件"></a>4.3.1、yaml注入配置文件</h4><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="java">package com.kuang.springboot.pojo;
@Component  //注册bean到容器中
public class Dog &#123;    
    private String name;    
    private Integer age;        
    //有参无参构造、get、set方法、toString()方法  
&#125;
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="java">@Component //注册bean
public class Dog &#123;    
    @Value(&quot;阿黄&quot;)    
    private String name;    
    @Value(&quot;18&quot;)    
    private Integer age;
&#125;
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;
    @Autowired //将狗狗自动注入进来    
    Dog dog;
    @Test    
    public void contextLoads() &#123;                            System.out.println(dog); //打印看下狗狗对象    
    &#125;
&#125;
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYUjoO9N8358vr0uTf3KR0FP0C5QOC3uQOIrlcuy7v0jmkXw0PPM4U5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="java">@Component //注册bean到容器中
public class Person &#123;
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
&#125;
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="yaml">person:
  name: qinjiang
  age: 3
  happy: false
  birth: 2000/01/01
  maps: &#123;k1: v1,k2: v2&#125;
  lists:
   - code
   - girl
   - music
  dog:
    name: 旺财
    age: 1
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="java">/*
    @ConfigurationProperties作用：
    将配置文件中配置的每一个属性的值，映射到这个组件中；
    告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
    参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person &#123;
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
&#125;
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYFrPO6PAYI7eQAEVzql1Sfic03AbzpiboQLP9eWo5I2McfQ2dicibIibh0fw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYhxNnwKv6bDsrCvMS4OscxxV0EWU7ibUD9G0N164rxEUNfaT9NFTVU4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() &#123;
        System.out.println(person); //打印person信息
    &#125;

&#125;
</code></pre>
<p>结果：所有值全部注入成功！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYTwpS5awY7ja8vibH3ncyGbgj69gSkKc80UN2AFNvTqotgkYMbw5K6zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-2、加载指定的配置文件"><a href="#4-3-2、加载指定的配置文件" class="headerlink" title="4.3.2、加载指定的配置文件"></a>4.3.2、加载指定的配置文件</h4><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="properties">name=kuangshen
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person &#123;

    @Value(&quot;$&#123;name&#125;&quot;)
    private String name;

    ......  
&#125;
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYAyueVvGpddTEkyGqCwbKsJrfQCbkWrZAFdL3ibMwTYhLKE9GclVyQ7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-3、配置文件占位符"><a href="#4-3-3、配置文件占位符" class="headerlink" title="4.3.3、配置文件占位符"></a>4.3.3、配置文件占位符</h4><p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="yaml">person:
    name: qinjiang$&#123;random.uuid&#125; # 随机uuid
    age: $&#123;random.int&#125;  # 随机int
    happy: false
    birth: 2000/01/01
    maps: &#123;k1: v1,k2: v2&#125;
    lists:
      - code
      - girl
      - music
    dog:
      name: $&#123;person.hello:other&#125;_旺财
      age: 1
</code></pre>
<h4 id="4-3-4、回顾properties配置"><a href="#4-3-4、回顾properties配置" class="headerlink" title="4.3.4、回顾properties配置"></a>4.3.4、回顾properties配置</h4><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings–&gt;FileEncodings 中配置；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYAr9nCaBDe8o7JeMWACZicQkicqrVMeiaWFgrTamHjc668RNx4c4z8UcXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="java">@Component //注册bean
public class User &#123;
    private String name;
    private int age;
    private String sex;
&#125;
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="properties">user1.name=kuangshen
user1.age=18
user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User &#123;
    //直接使用@value
    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SPEL&#125; Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
&#125;
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="java">@SpringBootTest
class DemoApplicationTests &#123;

    @Autowired
    User user;

    @Test
    public void contextLoads() &#123;
        System.out.println(user);
    &#125;

&#125;
</code></pre>
<p>结果正常输出：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYxFwDQMxmyVQjVPt794RCuhfVOEbqDrpH2u84DT8y01xAhuQh47AFYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-3-4、对比"><a href="#4-3-4、对比" class="headerlink" title="4.3.4、对比"></a>4.3.4、对比</h4><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYjMibiaov73iaTsiaWEPoArDcAB1Ooibx9uR5JxtacIuicHblEtUI9SrySX2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
<h2 id="五、JSR303数据校验及多环境切换"><a href="#五、JSR303数据校验及多环境切换" class="headerlink" title="五、JSR303数据校验及多环境切换"></a>五、JSR303数据校验及多环境切换</h2><h3 id="5-1、JSR303数据校验"><a href="#5-1、JSR303数据校验" class="headerlink" title="5.1、JSR303数据校验"></a>5.1、JSR303数据校验</h3><h4 id="5-1-1、使用"><a href="#5-1-1、使用" class="headerlink" title="5.1.1、使用"></a>5.1.1、使用</h4><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<pre><code class="java">@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated  //数据校验
public class Person &#123;

    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式
    private String name;
&#125;
</code></pre>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDYdR5f05BDysj0YVJMxadN0psDJKzXe7zyTrL9wFpTEHoiba0MsM11Fw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>使用数据校验，可以保证数据的正确性；</strong> </p>
<h4 id="5-1-2、常见参数"><a href="#5-1-2、常见参数" class="headerlink" title="5.1.2、常见参数"></a>5.1.2、常见参数</h4><pre><code>@NotNull(message=&quot;名字不能为空&quot;)
private String userName;
@Max(value=120,message=&quot;年龄最大不能查过120&quot;)
private int age;
@Email(message=&quot;邮箱格式错误&quot;)
private String email;

空检查
@Null       验证对象是否为null
@NotNull    验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   检查约束元素是否为NULL或者是EMPTY.
    
Booelan检查
@AssertTrue     验证 Boolean 对象是否为 true  
@AssertFalse    验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) string is between min and max included.

日期检查
@Past       验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    验证 String 对象是否符合正则表达式的规则

.......等等
除此以外，我们还可以自定义一些数据校验规则
</code></pre>
<h3 id="5-2、多环境切换"><a href="#5-2、多环境切换" class="headerlink" title="5.2、多环境切换"></a>5.2、多环境切换</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<pre><code class="properties">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<h4 id="5-2-1、yaml的多文档块"><a href="#5-2-1、yaml的多文档块" class="headerlink" title="5.2.1、yaml的多文档块"></a>5.2.1、yaml的多文档块</h4><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<pre><code class="yaml">server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: prod

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<h4 id="5-2-2、配置文件加载位置"><a href="#5-2-2、配置文件加载位置" class="headerlink" title="5.2.2、配置文件加载位置"></a>5.2.2、配置文件加载位置</h4><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>官方外部配置文件说明参考文档</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDUoiazZ6ehegLG4doZK0uSJHribIqwVKiaNibSaYZSgjZf4kGzhLdGrkzzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<pre><code class="yaml">#配置项目的访问路径
server.servlet.context-path=/kuang
</code></pre>
<h4 id="5-2-3、运维小技巧"><a href="#5-2-3、运维小技巧" class="headerlink" title="5.2.3、运维小技巧"></a>5.2.3、运维小技巧</h4><p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<pre><code class="shell">java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
</code></pre>
<h2 id="六、自动配置原理"><a href="#六、自动配置原理" class="headerlink" title="六、自动配置原理"></a>六、自动配置原理</h2><h3 id="6-1、分析自动配置原理"><a href="#6-1、分析自动配置原理" class="headerlink" title="6.1、分析自动配置原理"></a>6.1、分析自动配置原理</h3><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<pre><code class="java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
@Configuration 

//启动指定类的ConfigurationProperties功能；
  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
  //并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) 

//Spring底层@Conditional注解
  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
  //如果不存在，判断也是成立的
  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = &#123;&quot;enabled&quot;&#125;,
    matchIfMissing = true
)

public class HttpEncodingAutoConfiguration &#123;
    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;
        this.properties = properties.getEncoding();
    &#125;
    
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() &#123;
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    &#125;
    //。。。。。。。
&#125;
</code></pre>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<pre><code class="java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;) 
public class HttpProperties &#123;
    // .....
&#125;
</code></pre>
<p>我们去配置文件里面试试前缀，看提示！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD4hfI8rrZuGnuFRBjKdaR8mvkyuGfHG1IxBPw0vcTP5LoXIJT9davlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="6-2、深入理解"><a href="#6-2、深入理解" class="headerlink" title="6.2、深入理解"></a>6.2、深入理解</h3><p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<h3 id="6-3、了解-Conditional"><a href="#6-3、了解-Conditional" class="headerlink" title="6.3、了解@Conditional"></a>6.3、了解@Conditional</h3><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDGcJRvdK3PtqHPAWYBBmpe1XBVjQJeiatU4vasEaxckHlOga1BV9RPaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<pre><code class="yaml">#开启springboot的调试类
debug=true
</code></pre>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
<h2 id="七、自定义Starter"><a href="#七、自定义Starter" class="headerlink" title="七、自定义Starter"></a>七、自定义Starter</h2><h3 id="7-1、说明"><a href="#7-1、说明" class="headerlink" title="7.1、说明"></a>7.1、说明</h3><p>启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库；</p>
<p><strong>命名归约：</strong></p>
<p>官方命名：</p>
<ul>
<li>前缀：spring-boot-starter-xxx</li>
<li>比如：spring-boot-starter-web….</li>
</ul>
<p>自定义命名：</p>
<ul>
<li>xxx-spring-boot-starter</li>
<li>比如：mybatis-spring-boot-starter</li>
</ul>
<h3 id="7-2、编写启动器"><a href="#7-2、编写启动器" class="headerlink" title="7.2、编写启动器"></a>7.2、编写启动器</h3><p>1、在IDEA中新建一个空项目 spring-boot-starter-diy</p>
<p>2、新建一个普通Maven模块：kuang-spring-boot-starter</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbD3ibDQhiaQib3L94Y8joxBzUfegDicVpSamYoysTZ54lMp3oXw0cprPIPQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDhebhQQvGxRRLX8FezGo8Qk3bGEQElY6K2SqeDazGUZ6XqLDMvq6RDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、点击apply即可，基本结构</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDTPIzxXJqk27EGiaIBJtSpic5NcibXFX2eHXMxezmURLbibFXahiaFk5uW4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、在我们的 starter 中 导入  autoconfigure 的依赖！</p>
<pre><code class="xml">&lt;!-- 启动器 --&gt;
&lt;dependencies&gt;
    &lt;!--  引入自动配置模块 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDNLrzEP3HC2HYHicHmmLGian64wdOw3wiauDttoUbQLMdX4XcFV2HqyVvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>7、我们编写一个自己的服务</p>
<pre><code class="java">package com.kuang;

public class HelloService &#123;

    HelloProperties helloProperties;

    public HelloProperties getHelloProperties() &#123;
        return helloProperties;
    &#125;

    public void setHelloProperties(HelloProperties helloProperties) &#123;
        this.helloProperties = helloProperties;
    &#125;

    public String sayHello(String name)&#123;
        return helloProperties.getPrefix() + name + helloProperties.getSuffix();
    &#125;

&#125;
</code></pre>
<p>8、编写HelloProperties 配置类</p>
<pre><code class="java">package com.kuang;

import org.springframework.boot.context.properties.ConfigurationProperties;

// 前缀 kuang.hello
@ConfigurationProperties(prefix = &quot;kuang.hello&quot;)
public class HelloProperties &#123;

    private String prefix;
    private String suffix;

    public String getPrefix() &#123;
        return prefix;
    &#125;

    public void setPrefix(String prefix) &#123;
        this.prefix = prefix;
    &#125;

    public String getSuffix() &#123;
        return suffix;
    &#125;

    public void setSuffix(String suffix) &#123;
        this.suffix = suffix;
    &#125;
&#125;
</code></pre>
<p>9、编写我们的自动配置类并注入bean，测试！</p>
<pre><code class="java">package com.kuang;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication //web应用生效
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration &#123;

    @Autowired
    HelloProperties helloProperties;

    @Bean
    public HelloService helloService()&#123;
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    &#125;

&#125;
</code></pre>
<p>10、在resources编写一个自己的 META-INF\spring.factories</p>
<pre><code class="xml"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.kuang.HelloServiceAutoConfiguration
</code></pre>
<p>11、编写完成后，可以安装到maven仓库中！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDmUxYwOTicxVZGSRD3H93l6SLJCEDGXiaxpO6ciaicUbwiaA9FmJiaQhnhicTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、测试启动器"><a href="#7-3、测试启动器" class="headerlink" title="7.3、测试启动器"></a>7.3、测试启动器</h3><p>1、新建一个SpringBoot 项目</p>
<p>2、导入我们自己写的启动器</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.kuang&lt;/groupId&gt;
    &lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写一个 HelloController  进行测试我们自己的写的接口！</p>
<pre><code class="java">
package com.kuang.controller;

@RestController
public class HelloController &#123;

    @Autowired
    HelloService helloService;

    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        return helloService.sayHello(&quot;zxc&quot;);
    &#125;

&#125;
</code></pre>
<p>4、编写配置文件 application.properties</p>
<pre><code class="properties">
kuang.hello.prefix=&quot;ppp&quot;
kuang.hello.suffix=&quot;sss&quot;
</code></pre>
<p>5、启动项目进行测试，结果成功 !</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IPEXZtUAUBhnSZvUmrPzbDTCQ0YaF3yVM8icJ1jKJ6frZibJuegdk4FwEfOUbia4tBABndicA9kV1efg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="八、整合JDBC"><a href="#八、整合JDBC" class="headerlink" title="八、整合JDBC"></a>八、整合JDBC</h2><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<p>Sping Data 官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p>
<p>数据库相关的启动器 ：可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>
<h3 id="8-1、测试数据源"><a href="#8-1、测试数据源" class="headerlink" title="8.1、测试数据源"></a>8.1、测试数据源</h3><p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuW0A5wz8gu4q4AMoBCoYic2Juyiate9VBZe4S0sgkCZVFV2lD6quLKVZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写yaml配置文件连接数据库；</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>
<pre><code class="java">@SpringBootTest
class SpringbootDataJdbcApplicationTests &#123;

    //DI注入数据源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException &#123;
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection =   dataSource.getConnection();
        System.out.println(connection);
        //关闭连接
        connection.close();
    &#125;
&#125;
</code></pre>
<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>
<p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p>
<pre><code class="java">@Import(
    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;
)
protected static class PooledDataSourceConfiguration &#123;
    protected PooledDataSourceConfiguration() &#123;
    &#125;
&#125;
</code></pre>
<p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p>
<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>
<p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p>
<p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>
<h3 id="8-2、JDBCTemplate"><a href="#8-2、JDBCTemplate" class="headerlink" title="8.2、JDBCTemplate"></a>8.2、JDBCTemplate</h3><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="8-3、测试"><a href="#8-3、测试" class="headerlink" title="8.3、测试"></a>8.3、测试</h3><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/jdbc&quot;)
public class JdbcController &#123;

    /**
     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate
     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作
     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接
     */
    @Autowired
    JdbcTemplate jdbcTemplate;

    //查询employee表中所有数据
    //List 中的1个 Map 对应数据库的 1行数据
    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值
    @GetMapping(&quot;/list&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;
        String sql = &quot;select * from employee&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);
        return maps;
    &#125;
    
    //新增一个用户
    @GetMapping(&quot;/add&quot;)
    public String addUser()&#123;
        //插入语句，注意时间问题
        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +
                &quot; values (&#39;狂神说&#39;,&#39;24736743@qq.com&#39;,1,101,&#39;&quot;+ new Date().toLocaleString() +&quot;&#39;)&quot;;
        jdbcTemplate.update(sql);
        //查询
        return &quot;addOk&quot;;
    &#125;

    //修改用户信息
    @GetMapping(&quot;/update/&#123;id&#125;&quot;)
    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;
        //插入语句
        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;
        //数据
        Object[] objects = new Object[2];
        objects[0] = &quot;秦疆&quot;;
        objects[1] = &quot;24736743@sina.com&quot;;
        jdbcTemplate.update(sql,objects);
        //查询
        return &quot;updateOk&quot;;
    &#125;

    //删除用户
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;
        //插入语句
        String sql = &quot;delete from employee where id=?&quot;;
        jdbcTemplate.update(sql,id);
        //查询
        return &quot;deleteOk&quot;;
    &#125;
    
&#125;
</code></pre>
<h2 id="九、整合Druid"><a href="#九、整合Druid" class="headerlink" title="九、整合Druid"></a>九、整合Druid</h2><h3 id="9-1、Druid简介"><a href="#9-1、Druid简介" class="headerlink" title="9.1、Druid简介"></a>9.1、Druid简介</h3><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p>
<p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeupdhDcaDPRLHgnULFbaJB5kPtC8n5QVLaUbbTRfa4ZyqficzZYrd2llA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeubiciawTdz0tg1EKDjZ1xaIgjRW9CZ4Apr4hvNz3iaQVQIKS3sXy629Lgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuaVD6mK3LJrtZ4B6fRKCLDgYicAVGzTUTzWdCNB5lF4tLpbcCT0uq1EA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="9-2、配置数据源"><a href="#9-2、配置数据源" class="headerlink" title="9.2、配置数据源"></a>9.2、配置数据源</h3><p>1、添加上 Druid 数据源依赖。</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.21&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源
</code></pre>
<p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuuxN8UrBxIAhgFpAvyQOgKyZLVbPXRhtvVO764zeJpXiaBFTX2e4cYVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
</code></pre>
<p>5、导入Log4j 的依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<pre><code class="java">package com.kuang.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DruidConfig &#123;

    /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效
       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中
     */
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druidDataSource() &#123;
        return new DruidDataSource();
    &#125;

&#125;
</code></pre>
<p>7、去测试类中测试一下；看是否成功！</p>
<pre><code class="java">@SpringBootTest
class SpringbootDataJdbcApplicationTests &#123;

    //DI注入数据源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException &#123;
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection =   dataSource.getConnection();
        System.out.println(connection);

        DruidDataSource druidDataSource = (DruidDataSource) dataSource;
        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());
        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());

        //关闭连接
        connection.close();
    &#125;
&#125;
</code></pre>
<p>输出结果 ：可见配置参数已经生效！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeu14qkV9vFaME5ficcLe7MqPFgOH4iaEicia05eNNkSvhoVhWodykDXMtUcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="9-3、配置Druid数据源监控"><a href="#9-3、配置Druid数据源监控" class="headerlink" title="9.3、配置Druid数据源监控"></a>9.3、配置Druid数据源监控</h3><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<pre><code class="java">//配置 Druid 监控管理后台的Servlet；
//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式
@Bean
public ServletRegistrationBean statViewServlet() &#123;
    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);

    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet 
    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号
    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码

    //后台允许谁可以访问
    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问
    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问
    initParams.put(&quot;allow&quot;, &quot;&quot;);
    //deny：Druid 后台拒绝谁访问
    //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问

    //设置初始化参数
    bean.setInitParameters(initParams);
    return bean;
&#125;
</code></pre>
<p>配置完毕后，我们可以选择访问 ：<a target="_blank" rel="noopener" href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeu5TbyjT1Hib2vCDW9988ibXicDcXEnvooGfvNbchJrZ7TUwe3wJm0ktooA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>进入之后</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LYLicOHVGnwu7ibGvbwXibYeuaibKTBtqpoSiaZib9WTRdZaZhIYBRLB8Em7a5aLGw88uKjR8UCian11yCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<pre><code class="java">//配置 Druid 监控 之  web 监控的 filter
//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计
@Bean
public FilterRegistrationBean webStatFilter() &#123;
    FilterRegistrationBean bean = new FilterRegistrationBean();
    bean.setFilter(new WebStatFilter());

    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);
    bean.setInitParameters(initParams);

    //&quot;/*&quot; 表示过滤所有请求
    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
    return bean;
&#125;
</code></pre>
<h2 id="十、整合Mybaits"><a href="#十、整合Mybaits" class="headerlink" title="十、整合Mybaits"></a>十、整合Mybaits</h2><p>官方文档：<a target="_blank" rel="noopener" href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>
<p>Maven仓库地址：<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</a></p>
<h3 id="10-1、整合"><a href="#10-1、整合" class="headerlink" title="10.1、整合"></a>10.1、整合</h3><p>1、导入 MyBatis 所需要的依赖</p>
<pre><code class="xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置数据库连接信息（不变）</p>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
</code></pre>
<p><strong>3、测试数据库是否连接成功！</strong></p>
<p><strong>4、创建实体类，导入 Lombok！</strong></p>
<p>Department.java</p>
<pre><code class="java">package com.kuang.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Department &#123;

    private Integer id;
    private String departmentName;

&#125;
</code></pre>
<p><strong>5、创建mapper目录以及对应的 Mapper 接口</strong></p>
<p>DepartmentMapper.java</p>
<pre><code class="java">//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface DepartmentMapper &#123;

    // 获取所有部门信息
    List&lt;Department&gt; getDepartments();

    // 通过id获得部门
    Department getDepartment(Integer id);

&#125;
</code></pre>
<p><strong>6、对应的Mapper映射文件</strong></p>
<p>DepartmentMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.DepartmentMapper&quot;&gt;

    &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt;
       select * from department;
    &lt;/select&gt;

    &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt;
       select * from department where id = #&#123;id&#125;;
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p><strong>7、maven配置资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<p><strong>8、编写部门的 DepartmentController 进行测试！</strong></p>
<pre><code class="java">@RestController
public class DepartmentController &#123;
    
    @Autowired
    DepartmentMapper departmentMapper;
    
    // 查询全部部门
    @GetMapping(&quot;/getDepartments&quot;)
    public List&lt;Department&gt; getDepartments()&#123;
        return departmentMapper.getDepartments();
    &#125;

    // 查询全部部门
    @GetMapping(&quot;/getDepartment/&#123;id&#125;&quot;)
    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return departmentMapper.getDepartment(id);
    &#125;
    
&#125;
</code></pre>
<h3 id="10-2、测试"><a href="#10-2、测试" class="headerlink" title="10.2、测试"></a>10.2、测试</h3><p>1、新建一个pojo类 Employee ；</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Employee &#123;

    private Integer id;
    private String lastName;
    private String email;
    //1 male, 0 female
    private Integer gender;
    private Integer department;
    private Date birth;

    private Department eDepartment; // 冗余设计

&#125;
</code></pre>
<p>2、新建一个 EmployeeMapper 接口</p>
<pre><code class="java">//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface EmployeeMapper &#123;

    // 获取所有员工信息
    List&lt;Employee&gt; getEmployees();

    // 新增一个员工
    int save(Employee employee);

    // 通过id获得员工信息
    Employee get(Integer id);

    // 通过id删除员工
    int delete(Integer id);

&#125;
</code></pre>
<p>3、编写 EmployeeMapper.xml 配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.EmployeeMapper&quot;&gt;

    &lt;resultMap id=&quot;EmployeeMap&quot; type=&quot;Employee&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;eid&quot;/&gt;
        &lt;result property=&quot;lastName&quot; column=&quot;last_name&quot;/&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
        &lt;result property=&quot;gender&quot; column=&quot;gender&quot;/&gt;
        &lt;result property=&quot;birth&quot; column=&quot;birth&quot;/&gt;
        &lt;association property=&quot;eDepartment&quot;  javaType=&quot;Department&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;did&quot;/&gt;
            &lt;result property=&quot;departmentName&quot; column=&quot;dname&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;getEmployees&quot; resultMap=&quot;EmployeeMap&quot;&gt;
        select e.id as eid,last_name,email,gender,birth,d.id as did,d.department_name as dname
        from department d,employee e
        where d.id = e.department
    &lt;/select&gt;

    &lt;insert id=&quot;save&quot; parameterType=&quot;Employee&quot;&gt;
        insert into employee (last_name,email,gender,department,birth)
        values (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;department&#125;,#&#123;birth&#125;);
    &lt;/insert&gt;

    &lt;select id=&quot;get&quot; resultType=&quot;Employee&quot;&gt;
        select * from employee where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt;
        delete from employee where id = #&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p>4、编写EmployeeController类进行测试</p>
<pre><code class="java">@RestController
public class EmployeeController &#123;

    @Autowired
    EmployeeMapper employeeMapper;

    // 获取所有员工信息
    @GetMapping(&quot;/getEmployees&quot;)
    public List&lt;Employee&gt; getEmployees()&#123;
        return employeeMapper.getEmployees();
    &#125;

    @GetMapping(&quot;/save&quot;)
    public int save()&#123;
        Employee employee = new Employee();
        employee.setLastName(&quot;kuangshen&quot;);
        employee.setEmail(&quot;qinjiang@qq.com&quot;);
        employee.setGender(1);
        employee.setDepartment(101);
        employee.setBirth(new Date());
        return employeeMapper.save(employee);
    &#125;

    // 通过id获得员工信息
    @GetMapping(&quot;/get/&#123;id&#125;&quot;)
    public Employee get(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return employeeMapper.get(id);
    &#125;

    // 通过id删除员工
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    public int delete(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return employeeMapper.delete(id);
    &#125;

&#125;
</code></pre>
<h2 id="十一、Web开发以及静态资源处理"><a href="#十一、Web开发以及静态资源处理" class="headerlink" title="十一、Web开发以及静态资源处理"></a>十一、Web开发以及静态资源处理</h2><h3 id="11-1、Web开发"><a href="#11-1、Web开发" class="headerlink" title="11.1、Web开发"></a>11.1、Web开发</h3><p>好的，同学们，那么接下来呢，我们开始学习SpringBoot与Web开发，从这一章往后，就属于我们实战部分的内容了；</p>
<p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。</p>
<p><strong>使用SpringBoot的步骤：</strong></p>
<p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p>
<p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p>
<p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p>
<p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p>
<p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p>
<ul>
<li>向容器中自动配置组件 ：*** Autoconfiguration</li>
<li>自动配置类，封装配置文件的内容：***Properties</li>
</ul>
<p>没事就找找类，看看自动装配原理！</p>
<p>我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！</p>
<h3 id="11-2、静态资源处理"><a href="#11-2、静态资源处理" class="headerlink" title="11.2、静态资源处理"></a>11.2、静态资源处理</h3><h4 id="11-2-1、静态资源映射规则"><a href="#11-2-1、静态资源映射规则" class="headerlink" title="11.2.1、静态资源映射规则"></a>11.2.1、静态资源映射规则</h4><p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<pre><code class="java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
    if (!this.resourceProperties.isAddMappings()) &#123;
        // 已禁用默认资源处理
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    &#125;
    // 缓存控制
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    // webjars 配置
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    &#125;
    // 静态资源配置
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    &#125;
&#125;
</code></pre>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h4 id="11-2-2、什么是webjars"><a href="#11-2-2、什么是webjars" class="headerlink" title="11.2.2、什么是webjars"></a>11.2.2、什么是webjars</h4><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：<a target="_blank" rel="noopener" href="https://www.webjars.org/">https://www.webjars.org</a> </p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<pre><code class="xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6wt4N51VrTR1uzYBRo97UEoMJSnY1I0475oCajSe50e3tW5j0SXVwRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6JzDrsHnyDZbfzsBxwR77xMoM2ia3ic9b8uyOngzt3aH8QztXugXM2jhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="11-2-3、第二种静态资源映射规则"><a href="#11-2-3、第二种静态资源映射规则" class="headerlink" title="11.2.3、第二种静态资源映射规则"></a>11.2.3、第二种静态资源映射规则</h4><p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<pre><code class="java">// 进入方法
public String[] getStaticLocations() &#123;
    return this.staticLocations;
&#125;
// 找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
// 找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
&#125;;
</code></pre>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<pre><code>&quot;classpath:/META-INF/resources/&quot;
&quot;classpath:/resources/&quot;
&quot;classpath:/static/&quot;
&quot;classpath:/public/&quot;
</code></pre>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 <a target="_blank" rel="noopener" href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h4 id="11-2-4、自定义静态资源路径"><a href="#11-2-4、自定义静态资源路径" class="headerlink" title="11.2.4、自定义静态资源路径"></a>11.2.4、自定义静态资源路径</h4><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<pre><code class="properties">spring.resources.static-locations=classpath:/coding/,classpath:/kuang/
</code></pre>
<p>spring.resources.static-locations=classpath:/coding/,classpath:/kuang/</p>
<h3 id="11-3、首页处理"><a href="#11-3、首页处理" class="headerlink" title="11.3、首页处理"></a>11.3、首页处理</h3><p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<pre><code class="java">
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                                                           FormattingConversionService mvcConversionService,
                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页
        this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
&#125;
点进去继续看

private Optional&lt;Resource&gt; getWelcomePage() &#123;
    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
    // ::是java8 中新引入的运算符
    // Class::function的时候function是属于Class的，应该是静态方法。
    // this::function的funtion是属于这个对象的。
    // 简而言之，就是一种语法糖而已，是一种简写
    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
&#125;
// 欢迎页就是一个location下的的 index.html 而已
private Resource getIndexHtml(String location) &#123;
    return this.resourceLoader.getResource(location + &quot;index.html&quot;);
&#125;
</code></pre>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p>
<p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a>  看结果！</p>
<p><strong>关于网站图标说明</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6ugmXIE9bON3P8hrtQAZDLnEaG1OPLNcGsuOZGGPibLGgLBuG5pqgibpQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<p>1、关闭SpringBoot默认图标</p>
<pre><code class="properties">
#关闭默认图标
spring.mvc.favicon.enabled=false
</code></pre>
<p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p>
<p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LheYVC0eZ6Rjt0MVjviaRZ6awkOYiaHoiatBZQrAeAO2MFRWC5kUuyWur0XMIXHAcV8ORgM90fIaVNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十二、Thymeleaf"><a href="#十二、Thymeleaf" class="headerlink" title="十二、Thymeleaf"></a>十二、Thymeleaf</h2><h3 id="12-1、模板引擎"><a href="#12-1、模板引擎" class="headerlink" title="12.1、模板引擎"></a>12.1、模板引擎</h3><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6V42bcomyzTYY0q6ic7AB8lvciaoicxyalNYQYZgslIrIjdXWLFNcOxUmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h3 id="12-2、引入Thymeleaf"><a href="#12-2、引入Thymeleaf" class="headerlink" title="12.2、引入Thymeleaf"></a>12.2、引入Thymeleaf</h3><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>Thymeleaf 在Github 的主页：<a target="_blank" rel="noopener" href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p>
<p>Spring官方文档：找到我们对应的版本</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> </p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<pre><code class="xml">
&lt;!--thymeleaf--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6o4dAJHKh0872nmgaPYMaQDJ8KWfHJYWyoMXHW2pmVOtLVnREViaTziaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="12-3、Thymeleaf分析"><a href="#12-3、Thymeleaf分析" class="headerlink" title="12.3、Thymeleaf分析"></a>12.3、Thymeleaf分析</h3><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<pre><code class="java">
@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties &#123;
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = &quot;classpath:/templates/&quot;;
    private String suffix = &quot;.html&quot;;
    private String mode = &quot;HTML&quot;;
    private Charset encoding;
&#125;
</code></pre>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<h3 id="12-4、测试"><a href="#12-4、测试" class="headerlink" title="12.4、测试"></a>12.4、测试</h3><p>1、编写一个TestController</p>
<pre><code class="java">
@Controller
public class TestController &#123;
    
    @RequestMapping(&quot;/t1&quot;)
    public String test1()&#123;
        //classpath:/templates/test.html
        return &quot;test&quot;;
    &#125;
    
&#125;
</code></pre>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<pre><code class="xml">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目请求测试</p>
<h3 id="12-5、Thymeleaf-语法学习"><a href="#12-5、Thymeleaf-语法学习" class="headerlink" title="12.5、Thymeleaf 语法学习"></a>12.5、Thymeleaf 语法学习</h3><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<pre><code class="java">
@RequestMapping(&quot;/t1&quot;)
public String test1(Model model)&#123;
    //存入数据
    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
    //classpath:/templates/test.html
    return &quot;test&quot;;
&#125;
</code></pre>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<pre><code class="xml">
 xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>3、我们去编写下前端页面</p>
<pre><code class="xml">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;狂神说&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;
&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、启动测试！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ia0fYFrNsXdHekjLfPlq4ZMpF0rtPzFRBTWsw6K8zic3ywna1LgcM6Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6fGYIwv043icVDYuybRJDCGTSNTMEibFzzMdlKS4t07TQoicQJKQAe0slQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2、我们能写哪些表达式呢？</strong></p>
<pre><code>Simple expressions:（表达式语法）
Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：#18
         #ctx : the context object.
         #vars: the context variables.
         #locale : the context locale.
         #request : (only in Web Contexts) the HttpServletRequest object.
         #response : (only in Web Contexts) the HttpServletResponse object.
         #session : (only in Web Contexts) the HttpSession object.
         #servletContext : (only in Web Contexts) the ServletContext object.

    3）、内置的一些工具对象：
　　　　　　#execInfo : information about the template being processed.
　　　　　　#uris : methods for escaping parts of URLs/URIs
　　　　　　#conversions : methods for executing the configured conversion service (if any).
　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
　　　　　　#numbers : methods for formatting numeric objects.
　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
　　　　　　#objects : methods for objects in general.
　　　　　　#bools : methods for boolean evaluation.
　　　　　　#arrays : methods for arrays.
　　　　　　#lists : methods for lists.
　　　　　　#sets : methods for sets.
　　　　　　#maps : methods for maps.
　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
==================================================================================

  Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；
  Message Expressions: #&#123;...&#125;：获取国际化内容
  Link URL Expressions: @&#123;...&#125;：定义URL；
  Fragment Expressions: ~&#123;...&#125;：片段引用表达式

Literals（字面量）
      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
      
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is $&#123;name&#125;|
    
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
    
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
    
Special tokens:
    No-Operation: _
</code></pre>
<h4 id="12-5-2、测试"><a href="#12-5-2、测试" class="headerlink" title="12.5.2、测试"></a>12.5.2、测试</h4><p>1、 我们编写一个Controller，放一些数据</p>
<pre><code class="java">
@RequestMapping(&quot;/t2&quot;)
public String test2(Map&lt;String,Object&gt; map)&#123;
    //存入数据
    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);
    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));
    //classpath:/templates/test.html
    return &quot;test&quot;;
&#125;
</code></pre>
<p>2、测试页面取出数据</p>
<pre><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;狂神说&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;
&lt;!--不转义--&gt;
&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;

&lt;!--遍历数据--&gt;
&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;
&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;

&lt;h4&gt;
    &lt;!--行内写法：官网#12--&gt;
    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;
&lt;/h4&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目测试！</p>
<h2 id="十三、MVC自动配置原理"><a href="#十三、MVC自动配置原理" class="headerlink" title="十三、MVC自动配置原理"></a>十三、MVC自动配置原理</h2><h3 id="13-1、官网阅读"><a href="#13-1、官网阅读" class="headerlink" title="13.1、官网阅读"></a>13.1、官网阅读</h3><p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<pre><code>Spring MVC Auto-configuration
// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
// 自动配置在Spring默认设置的基础上添加了以下功能：
The auto-configuration adds the following features on top of Spring’s defaults:
// 包含视图解析器
Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
// 支持静态资源文件夹的路径，以及webjars
Support for serving static resources, including support for WebJars 
// 自动注册了Converter：
// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型
// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】
Automatic registration of Converter, GenericConverter, and Formatter beans.
// HttpMessageConverters
// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；
Support for HttpMessageConverters (covered later in this document).
// 定义错误代码生成规则的
Automatic registration of MessageCodesResolver (covered later in this document).
// 首页定制
Static index.html support.
// 图标定制
Custom Favicon support (covered later in this document).
// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！
Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).

/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h3 id="13-2、ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#13-2、ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="13.2、ContentNegotiatingViewResolver 内容协商视图解析器"></a>13.2、<strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h3><p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<pre><code class="java">
@Bean
@ConditionalOnBean(ViewResolver.class)
@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)
public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;
    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级
    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return resolver;
&#125;
</code></pre>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<pre><code class="java">@Nullable // 注解说明：@Nullable 即参数可为null
public View resolveViewName(String viewName, Locale locale) throws Exception &#123;
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) &#123;
        // 获取候选的视图对象
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        // 选择一个最适合的视图对象，然后把这个对象返回
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) &#123;
            return bestView;
        &#125;
    &#125;
    // .....
&#125;
</code></pre>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<pre><code class="java">
Iterator var5 = this.viewResolvers.iterator();
</code></pre>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong> </p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<pre><code class="java">
protected void initServletContext(ServletContext servletContext) &#123;
    // 这里它是从beanFactory工具中获取容器中的所有视图解析器
    // ViewRescolver.class 把所有的视图解析器来组合的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;
    if (this.viewResolvers == null) &#123;
        this.viewResolvers = new ArrayList(matchingBeans.size());
    &#125;
    // ...............
&#125;
</code></pre>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<pre><code class="java">
@Bean //放到bean中
public ViewResolver myViewResolver()&#123;
    return new MyViewResolver();
&#125;

//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口
private static class MyViewResolver implements ViewResolver&#123;
    @Override
    public View resolveViewName(String s, Locale locale) throws Exception &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6QBbBv34R87hGpeWiaPnuYhBG1FlfdhtZxlIKicA2Y4kHy9XqRicibmQkWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；</p>
<p>找到this</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6NnU4IPDPs8jKYRjDJGia7t3C5YgjCSHuiaxlpthKpBwGh9m6icsF5zuow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找到视图解析器，我们看到我们自己定义的就在这里了；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp67xW1M2s2aOnolP1tAedrqAtUuBHRjz7ALePedpHkpz9MXVyLwe6wYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h3 id="13-3、转换器和格式化器"><a href="#13-3、转换器和格式化器" class="headerlink" title="13.3、转换器和格式化器"></a>13.3、转换器和格式化器</h3><p>找到格式化转换器：</p>
<pre><code class="java">
@Bean
@Override
public FormattingConversionService mvcConversionService() &#123;
    // 拿到配置文件中的格式化规则
    WebConversionService conversionService = 
        new WebConversionService(this.mvcProperties.getDateFormat());
    addFormatters(conversionService);
    return conversionService;
&#125;
</code></pre>
<p>点进去：</p>
<pre><code class="java">
public String getDateFormat() &#123;
    return this.dateFormat;
&#125;

/**
* Date format to use. For instance, `dd/MM/yyyy`. 默认的
 */
private String dateFormat;
</code></pre>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6zdySrKJPkADN9jtsIpz6QPOyC2nI04l0EiaAOMuU47pwiaPq2RrhUdaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="13-4、修改SpringBoot的默认配置"><a href="#13-4、修改SpringBoot的默认配置" class="headerlink" title="13.4、修改SpringBoot的默认配置"></a>13.4、修改SpringBoot的默认配置</h3><p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<pre><code class="java">
//应为类型要求为WebMvcConfigurer，所以我们实现其接口
//可以使用自定义类扩展MVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer &#123;

    @Override
    public void addViewControllers(ViewControllerRegistry registry) &#123;
        // 浏览器发送/test ， 就会跳转到test页面；
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);
    &#125;
&#125;
</code></pre>
<p>我们去浏览器访问一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6smNnW3fpooPSQpiaoMajpXYGDoH0aQnv8awIibPa9eKkJhewdMrTtLTg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<pre><code class="java">
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    
  // 从容器中获取所有的webmvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;
        if (!CollectionUtils.isEmpty(configurers)) &#123;
            this.configurers.addWebMvcConfigurers(configurers);
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<pre><code class="java">
protected void addViewControllers(ViewControllerRegistry registry) &#123;
    this.configurers.addViewControllers(registry);
&#125;
</code></pre>
<p>5、我们点进去看一下</p>
<pre><code class="java">
public void addViewControllers(ViewControllerRegistry registry) &#123;
    Iterator var2 = this.delegates.iterator();

    while(var2.hasNext()) &#123;
        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
        delegate.addViewControllers(registry);
    &#125;

&#125;
</code></pre>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h3 id="13-5、全面接管SpringMVC"><a href="#13-5、全面接管SpringMVC" class="headerlink" title="13.5、全面接管SpringMVC"></a>13.5、全面接管SpringMVC</h3><p>官方文档：</p>
<pre><code>
If you want to take complete control of Spring MVC
you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ic2wzwiaMd6YwOHuK1fcn3ibhuXD60XiarS9NLdTIDJJicFZJt1wQ0ibuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>给配置类加上注解：@EnableWebMvc</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp68kRH4rPKMyhAdkIL46HW90qsSoyMcNibRxDbfu7iboWM6AMRr5tFSicPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<pre><code class="java">
@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)
public @interface EnableWebMvc &#123;
&#125;
</code></pre>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<pre><code class="java">
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;
  // ......
&#125;
</code></pre>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<pre><code class="java">
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
    ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;
    
&#125;
</code></pre>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<h2 id="十四、国际化"><a href="#十四、国际化" class="headerlink" title="十四、国际化"></a>十四、国际化</h2><h3 id="14-1、准备工作"><a href="#14-1、准备工作" class="headerlink" title="14.1、准备工作"></a>14.1、准备工作</h3><p>先在IDEA中统一设置properties的编码问题！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETgrgicvxqgYPVvcBGBcyId5qbK4pZ6iaFW6DU8DaTibNOqwybhxvvBiapZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h3 id="14-2、配置文件编写"><a href="#14-2、配置文件编写" class="headerlink" title="14.2、配置文件编写"></a>14.2、配置文件编写</h3><p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETBiaXib28mib2iaUyqOTW1VXCLK6b55N9Jy2AbA96KRSyQjCkgCibhDaWung/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们可以在这上面去新建一个文件；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETozDglSZ32ZAdIRzuqn8NicymJyZQUMXIq0icYPwzNstBJdO3dXL1CbRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>弹出如下页面：我们再添加一个英文的；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETv0bcvSfWDIdiaTYIoPL7BhLRb8wb0vAbNmMCpxrkAibibAwVtAJV55tEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETMSkXZicouLDxJiaUbyWRTB3Vib2UBxJWEIqxL5reXbkXT8iaYNQOn2M9Bg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETp6raySXNEHanXLFuq4OsCJOQ0DBKibQyohPUDen5OUYsfYIPD9tFjBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETru2CdF5btNFhLdCCkusK5VkJRIfnBic8iaScfKkkKfFcBQ90pexU05Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们添加一下首页的内容！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETRPAF4T1brBr2pBydUuNjlkkUtThqlJCKN4lQ2rCN0BXrn957u3CdlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后依次添加其他页面内容即可！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETA91ZDRtZ4hBZ1dtn7CLZ9xzlwfDpUhqT8sTQmCncsLYEH5r0fIFF9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<pre><code>login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>英文：</p>
<pre><code>
login.btn=Sign in
login.password=Password
login.remember=Remember me
login.tip=Please sign in
login.username=Username
</code></pre>
<p>中文：</p>
<pre><code>
login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<h3 id="14-3、配置文件生效探究"><a href="#14-3、配置文件生效探究" class="headerlink" title="14.3、配置文件生效探究"></a>14.3、配置文件生效探究</h3><p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<pre><code class="java">// 获取 properties 传递过来的值进行判断
@Bean
public MessageSource messageSource(MessageSourceProperties properties) &#123;
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) &#123;
        // 设置国际化文件的基础名（去掉语言国家代码的）
        messageSource.setBasenames(
            StringUtils.commaDelimitedListToStringArray(
                                       StringUtils.trimAllWhitespace(properties.getBasename())));
    &#125;
    if (properties.getEncoding() != null) &#123;
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    &#125;
    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) &#123;
        messageSource.setCacheMillis(cacheDuration.toMillis());
    &#125;
    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
&#125;
</code></pre>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<pre><code class="xml">
spring.messages.basename=i18n.login
</code></pre>
<h3 id="14-4、配置页面国际化值"><a href="#14-4、配置页面国际化值" class="headerlink" title="14.4、配置页面国际化值"></a>14.4、配置页面国际化值</h3><p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETbj7aBK25N5G2NGibmb9LmHGySYic9myjX0pZ7EOcBfYC03c1yBFEBxfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IliczmpA1zCRu0ia5micU55ETN9iagOo88CAiaDf4d09lGGBsEhzdpsz2libgVuHdeBdWPc6QUMZficxFJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="14-5、配置国际化解析"><a href="#14-5、配置国际化解析" class="headerlink" title="14.5、配置国际化解析"></a>14.5、配置国际化解析</h3><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<pre><code class="java">
@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() &#123;
    // 容器中没有就自己配，有的话就用用户配置的
    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    &#125;
    // 接收头国际化分解
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
&#125;
</code></pre>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<pre><code class="java">
public Locale resolveLocale(HttpServletRequest request) &#123;
    Locale defaultLocale = this.getDefaultLocale();
    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123;
        return defaultLocale;
    &#125; else &#123;
        Locale requestLocale = request.getLocale();
        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();
        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123;
            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);
            if (supportedLocale != null) &#123;
                return supportedLocale;
            &#125; else &#123;
                return defaultLocale != null ? defaultLocale : requestLocale;
            &#125;
        &#125; else &#123;
            return requestLocale;
        &#125;
    &#125;
&#125;
</code></pre>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<pre><code class="xml">
&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;/a&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;en_US&#39;)&#125;&quot;&gt;English&lt;/a&gt;
</code></pre>
<p>我们去写一个处理的组件类！</p>
<pre><code class="java">package com.kuang.component;

import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

//可以在链接上携带区域信息
public class MyLocaleResolver implements LocaleResolver &#123;

    //解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest request) &#123;

        String language = request.getParameter(&quot;l&quot;);
        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的
        //如果请求链接不为空
        if (!StringUtils.isEmpty(language))&#123;
            //分割请求参数
            String[] split = language.split(&quot;_&quot;);
            //国家，地区
            locale = new Locale(split[0],split[1]);
        &#125;
        return locale;
    &#125;

    @Override
    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;

    &#125;
&#125;
</code></pre>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean；</p>
<pre><code class="java">
@Bean
public LocaleResolver localeResolver()&#123;
    return new MyLocaleResolver();
&#125;
</code></pre>
<h2 id="十五、集成Swagger"><a href="#十五、集成Swagger" class="headerlink" title="十五、集成Swagger"></a>十五、集成Swagger</h2><h3 id="15-1、Swagger简介"><a href="#15-1、Swagger简介" class="headerlink" title="15.1、Swagger简介"></a>15.1、Swagger简介</h3><p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a target="_blank" rel="noopener" href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h3 id="15-2、SpringBoot整合Swagger"><a href="#15-2、SpringBoot整合Swagger" class="headerlink" title="15.2、SpringBoot整合Swagger"></a>15.2、SpringBoot整合Swagger</h3><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong>Springfox-swagger2</strong></li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<pre><code class="java">@Configuration //配置类
@EnableSwagger2// 开启Swagger2的自动配置
public class SwaggerConfig &#123;  
&#125;
</code></pre>
<p>5、访问测试 ：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZzSgcwYhS2RhtRXv0Wfg9OkiaE6xDEQibt8TSJTt9OHzFzeq9NrQCJNZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-3、配置Swagger"><a href="#15-3、配置Swagger" class="headerlink" title="15.3、配置Swagger"></a>15.3、配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<pre><code>@Bean //配置docket以配置Swagger具体参数
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2);
&#125;
</code></pre>
<p>2、可以通过apiInfo()属性配置文档信息</p>
<pre><code>//配置文档信息
private ApiInfo apiInfo() &#123;
   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);
   return new ApiInfo(
           &quot;Swagger学习&quot;, // 标题
           &quot;学习演示如何配置Swagger&quot;, // 描述
           &quot;v1.0&quot;, // 版本
           &quot;http://terms.service.url/组织链接&quot;, // 组织链接
           contact, // 联系人信息
           &quot;Apach 2.0 许可&quot;, // 许可
           &quot;许可链接&quot;, // 许可连接
           new ArrayList&lt;&gt;()// 扩展
  );
&#125;
</code></pre>
<p>3、Docket 实例关联上 apiInfo()</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
&#125;
</code></pre>
<p>4、重启项目，访问测试 <a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h3 id="15-4、配置扫描接口"><a href="#15-4、配置扫描接口" class="headerlink" title="15.4、配置扫描接口"></a>15.4、配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
      .build();
&#125;
</code></pre>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<pre><code>any() // 扫描所有，项目中的所有接口都会被扫描到
none() // 不扫描接口
// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求
withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)
// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口
withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)
basePackage(final String basePackage) // 根据包路径扫描接口
</code></pre>
<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>5、这里的可选值还有</p>
<pre><code>any() // 任何请求都扫描
none() // 任何请求都不扫描
regex(final String pathRegex) // 通过正则表达式控制
ant(final String antPattern) // 通过ant()控制
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zbja0VwsQkjaNVC5GWsge3SlQeg0jmxdjBMLOoOsqqD6gc6jshv4Qdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-5、配置Swagger开关"><a href="#15-5、配置Swagger开关" class="headerlink" title="15.5、配置Swagger开关"></a>15.5、配置Swagger开关</h3><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<pre><code>@Bean
public Docket docket() &#123;
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<pre><code>@Bean
public Docket docket(Environment environment) &#123;
   // 设置要显示swagger的环境
   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);
   // 判断当前是否处于该环境
   // 通过 enable() 接收此参数判断是否要显示
   boolean b = environment.acceptsProfiles(of);
   
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))
      .build();
&#125;
</code></pre>
<p>3、可以在项目中增加一个dev的配置文件查看效果！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zf87yQGBYZKyqCsjP79C67S0NgdOmrQWJ7tkpPsdkrWQeQiaIZia7VD8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-6、配置API分组"><a href="#15-6、配置API分组" class="headerlink" title="15.6、配置API分组"></a>15.6、配置API分组</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Z7k4Y8iaVnHtPd78o82ff8hItej9Cyf0wvbG8u8KgXic7gVh77NoZw4RQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<pre><code>@Bean
public Docket docket(Environment environment) &#123;
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
      .groupName(&quot;hello&quot;) // 配置分组
       // 省略配置....
&#125;
</code></pre>
<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<pre><code>@Bean
public Docket docket1()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);
&#125;
@Bean
public Docket docket2()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);
&#125;
@Bean
public Docket docket3()&#123;
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);
&#125;
</code></pre>
<p>4、重启项目查看即可</p>
<h3 id="15-7、实体配置"><a href="#15-7、实体配置" class="headerlink" title="15.7、实体配置"></a>15.7、实体配置</h3><p>1、新建一个实体类</p>
<pre><code>@ApiModel(&quot;用户实体&quot;)
public class User &#123;
   @ApiModelProperty(&quot;用户名&quot;)
   public String username;
   @ApiModelProperty(&quot;密码&quot;)
   public String password;
&#125;
</code></pre>
<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<pre><code>@RequestMapping(&quot;/getUser&quot;)
public User getUser()&#123;
   return new User();
&#125;
</code></pre>
<p>3、重启查看测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZS0qBoaXrHX5r42ic5kUDzv5gaiaVqVeMBne4TDe5JLRPqRShgY3WiaQPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="15-8、常用注解"><a href="#15-8、常用注解" class="headerlink" title="15.8、常用注解"></a>15.8、常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody></table>
<p>我们也可以给请求的接口配置一些注释</p>
<pre><code>@ApiOperation(&quot;狂神的接口&quot;)
@PostMapping(&quot;/kuang&quot;)
@ResponseBody
public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;
   return username;
&#125;
</code></pre>
<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="15-9、拓展"><a href="#15-9、拓展" class="headerlink" title="15.9、拓展"></a>15.9、拓展</h3><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<p>1、默认的  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZrYUroibnsmILAYo1PyuaSDAkrqUvlNibxW9S9niaRomPFd9rrD6SY4wjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、bootstrap-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
   &lt;version&gt;1.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZxQ9fXkPFt9TtX6PiaPDWWFSCJQK6H0ibiagM2w2f99zqHuOJffyRycCIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、Layui-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;
   &lt;version&gt;1.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZYA6g5VyspYIqFMokAGg7dbx47P2ibC8Z80saA7XdrByPFhgmrduSHbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、mg-ui  <strong>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;
   &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZBJPCcHFicV2dklg3l88IuYia3OIFNfNVbWZXpppPS93jghTUJiaeJQx6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十六、异步、定时、邮件任务"><a href="#十六、异步、定时、邮件任务" class="headerlink" title="十六、异步、定时、邮件任务"></a>十六、异步、定时、邮件任务</h2><h3 id="16-1、异步任务"><a href="#16-1、异步任务" class="headerlink" title="16.1、异步任务"></a>16.1、异步任务</h3><p>1、创建一个service包</p>
<p>2、创建一个类AsyncService</p>
<p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
<p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<pre><code>@Service
public class AsyncService &#123;

   public void hello()&#123;
       try &#123;
           Thread.sleep(3000);
      &#125; catch (InterruptedException e) &#123;
           e.printStackTrace();
      &#125;
       System.out.println(&quot;业务进行中....&quot;);
  &#125;
&#125;
</code></pre>
<p>3、编写controller包</p>
<p>4、编写AsyncController类</p>
<p>我们去写一个Controller测试一下</p>
<pre><code>@RestController
public class AsyncController &#123;

   @Autowired
   AsyncService asyncService;

   @GetMapping(&quot;/hello&quot;)
   public String hello()&#123;
       asyncService.hello();
       return &quot;success&quot;;
  &#125;

&#125;
</code></pre>
<p>5、访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C3%E7%A7%92%E5%90%8E%E5%87%BA%E7%8E%B0success%EF%BC%8C%E8%BF%99%E6%98%AF%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a></p>
<p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p>
<p>6、给hello方法添加@Async注解；</p>
<pre><code>//告诉Spring这是一个异步方法
@Async
public void hello()&#123;
   try &#123;
       Thread.sleep(3000);
  &#125; catch (InterruptedException e) &#123;
       e.printStackTrace();
  &#125;
   System.out.println(&quot;业务进行中....&quot;);
&#125;
</code></pre>
<p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<pre><code>@EnableAsync //开启异步注解功能
@SpringBootApplication
public class SpringbootTaskApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(SpringbootTaskApplication.class, args);
  &#125;

&#125;
</code></pre>
<p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p>
<h3 id="16-2、定时任务"><a href="#16-2、定时任务" class="headerlink" title="16.2、定时任务"></a>16.2、定时任务</h3><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling</li>
<li>@Scheduled</li>
</ul>
<p><strong>cron表达式：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMKLnW0ibMAiaR5yXOER51iaH9WTkrLhr0rSAnAJxJUM9c8eTGaCWXuYOibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMfyibiaXGFm87zic2Ng3ICjicp4tlAia8MXDafQXZ9UZ7bsreJoTU9VWaBXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>测试步骤：</strong></p>
<p>1、创建一个ScheduledService</p>
<p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p>
<pre><code>@Service
public class ScheduledService &#123;
   
   //秒   分   时     日   月   周几
   //0 * * * * MON-FRI
   //注意cron表达式的用法；
   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)
   public void hello()&#123;
       System.out.println(&quot;hello.....&quot;);
  &#125;
&#125;
</code></pre>
<p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<pre><code>@EnableAsync //开启异步注解功能
@EnableScheduling //开启基于注解的定时任务
@SpringBootApplication
public class SpringbootTaskApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(SpringbootTaskApplication.class, args);
  &#125;

&#125;
</code></pre>
<p>3、我们来详细了解下cron表达式；</p>
<p><a target="_blank" rel="noopener" href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a></p>
<p>4、常用的表达式</p>
<pre><code>（1）0/2 * * * * ?   表示每2秒 执行任务
（1）0 0/2 * * * ?   表示每2分钟 执行任务
（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务
（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业
（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作
（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点
（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时
（6）0 0 12 ? * WED   表示每个星期三中午12点
（7）0 0 12 * * ?   每天中午12点触发
（8）0 15 10 ? * *   每天上午10:15触发
（9）0 15 10 * * ?     每天上午10:15触发
（10）0 15 10 * * ?   每天上午10:15触发
（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发
（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发
（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发
（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发
（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发
（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发
（18）0 15 10 15 * ?   每月15日上午10:15触发
（19）0 15 10 L * ?   每月最后一日的上午10:15触发
（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发
（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发
（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
</code></pre>
<h3 id="16-3、邮件任务"><a href="#16-3、邮件任务" class="headerlink" title="16.3、邮件任务"></a>16.3、邮件任务</h3><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<p><strong>测试：</strong></p>
<p>1、引入pom依赖</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>看它引入的依赖，可以看到 jakarta.mail</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;
   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;
   &lt;version&gt;1.6.4&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、查看自动配置类：MailSenderAutoConfiguration</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMquaTFVg62FCj7M1T6e08TIF0rhlffjxhTZ1C6Q43eDiceibia600KwoZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个类中存在bean，JavaMailSenderImpl</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMJsstibaMQuMsAKmickRKVlc1dsicbp7PR8aaFOdwaVukjBoiaqhyJDrZKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们去看下配置文件</p>
<pre><code>@ConfigurationProperties(
   prefix = &quot;spring.mail&quot;
)
public class MailProperties &#123;
   private static final Charset DEFAULT_CHARSET;
   private String host;
   private Integer port;
   private String username;
   private String password;
   private String protocol = &quot;smtp&quot;;
   private Charset defaultEncoding;
   private Map&lt;String, String&gt; properties;
   private String jndiName;
&#125;
</code></pre>
<p>3、配置文件：</p>
<pre><code>spring.mail.username=24736743@qq.com
spring.mail.password=你的qq授权码
spring.mail.host=smtp.qq.com
# qq需要配置ssl
spring.mail.properties.mail.smtp.ssl.enable=true
</code></pre>
<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LUziamJeeiaLFt7YwxJtAgSMx85j2ATOfy0GUeO3l8bLvWaOX0FrY39NljleEIyPOyrgV8gEaLCwbw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>4736743@qq.com&quot;);
   mailSender.send(message);
&#125;

@Test
public void contextLoads2() throws MessagingException &#123;
   //邮件设置2：一个复杂的邮件
   MimeMessage mimeMessage = mailSender.createMimeMessage();
   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

   helper.setSubject(&quot;通知-明天来狂神这听课&quot;);
   helper.setText(&quot;&lt;b style=&#39;color:red&#39;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);

   //发送附件
   helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));
   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));

   helper.setTo(&quot;24736743@qq.com&quot;);
   helper.setFrom(&quot;24736743@qq.com&quot;);

   mailSender.send(mimeMessage);
&#125;
</code></pre>
<p>查看邮箱，邮件接收成功！</p>
<p>我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！</p>
<h2 id="十七、富文本编辑器"><a href="#十七、富文本编辑器" class="headerlink" title="十七、富文本编辑器"></a>十七、富文本编辑器</h2><h3 id="17-1、简介"><a href="#17-1、简介" class="headerlink" title="17.1、简介"></a>17.1、简介</h3><p>市面上有许多非常成熟的富文本编辑器，比如：</p>
<ul>
<li><p><strong>Editor.md</strong>——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a></li>
</ul>
</li>
<li><p><strong>wangEditor</strong>——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="http://www.wangeditor.com/">http://www.wangeditor.com/</a></li>
</ul>
</li>
<li><p><strong>TinyMCE</strong>——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://www.tiny.cloud/docs/demo/full-featured/">https://www.tiny.cloud/docs/demo/full-featured/</a></li>
<li>博客园</li>
</ul>
</li>
<li><p><strong>百度ueditor</strong>——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://ueditor.baidu.com/website/onlinedemo.html">https://ueditor.baidu.com/website/onlinedemo.html</a></li>
</ul>
</li>
<li><p><strong>kindeditor</strong>——界面经典。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="http://kindeditor.net/demo.php">http://kindeditor.net/demo.php</a></li>
</ul>
</li>
<li><p><strong>Textbox</strong>——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://textbox.io/">https://textbox.io/</a></li>
</ul>
</li>
<li><p><strong>CKEditor</strong>——国外的，界面美观。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://ckeditor.com/ckeditor-5/demo/">https://ckeditor.com/ckeditor-5/demo/</a></li>
</ul>
</li>
<li><p><strong>quill</strong>——功能强大，还可以编辑公式等</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://quilljs.com/">https://quilljs.com/</a></li>
</ul>
</li>
<li><p><strong>simditor</strong>——界面美观，功能较全。</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://simditor.tower.im/">https://simditor.tower.im/</a></li>
</ul>
</li>
<li><p><strong>summernote</strong>——UI好看，精美</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://summernote.org/">https://summernote.org/</a></li>
</ul>
</li>
<li><p><strong>jodit</strong>——功能齐全</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://xdsoft.net/jodit/">https://xdsoft.net/jodit/</a></li>
</ul>
</li>
<li><p><strong>froala Editor</strong>——界面非常好看，功能非常强大，非常好用（非免费）</p>
</li>
<li><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://www.froala.com/wysiwyg-editor">https://www.froala.com/wysiwyg-editor</a></li>
</ul>
</li>
</ul>
<h3 id="17-2、Editor-md"><a href="#17-2、Editor-md" class="headerlink" title="17.2、Editor.md"></a>17.2、Editor.md</h3><p>我们可以在官网下载它：<a target="_blank" rel="noopener" href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a> ， 得到它的压缩包！</p>
<p>解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！</p>
<p>我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！</p>
<h4 id="17-2-1、基础工程搭建"><a href="#17-2-1、基础工程搭建" class="headerlink" title="17.2.1、基础工程搭建"></a>17.2.1、基础工程搭建</h4><blockquote>
<p>数据库设计</p>
</blockquote>
<p>article：文章表</p>
<table>
<thead>
<tr>
<th>字段</th>
<th></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>文章的唯一ID</td>
</tr>
<tr>
<td>author</td>
<td>varchar</td>
<td>作者</td>
</tr>
<tr>
<td>title</td>
<td>varchar</td>
<td>标题</td>
</tr>
<tr>
<td>content</td>
<td>longtext</td>
<td>文章的内容</td>
</tr>
</tbody></table>
<p>建表SQL：</p>
<pre><code>CREATE TABLE `article` (
`id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#39;int文章的唯一ID&#39;,
`author` varchar(50) NOT NULL COMMENT &#39;作者&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;标题&#39;,
`content` longtext NOT NULL COMMENT &#39;文章的内容&#39;,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<blockquote>
<p>基础项目搭建</p>
</blockquote>
<p>1、建一个SpringBoot项目配置</p>
<pre><code>spring:
datasource:
  username: root
  password: 123456
  #?serverTimezone=UTC解决时区的报错
  url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
  driver-class-name: com.mysql.cj.jdbc.Driver
&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;true&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<p>2、实体类：</p>
<pre><code>//文章类
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Article implements Serializable &#123;

   private int id; //文章的唯一ID
   private String author; //作者名
   private String title; //标题
   private String content; //文章的内容

&#125;
</code></pre>
<p>3、mapper接口：</p>
<pre><code>@Mapper
@Repository
public interface ArticleMapper &#123;
   //查询所有的文章
   List&lt;Article&gt; queryArticles();

   //新增一个文章
   int addArticle(Article article);

   //根据文章id查询文章
   Article getArticleById(int id);

   //根据文章id删除文章
   int deleteArticleById(int id);

&#125;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.ArticleMapper&quot;&gt;

   &lt;select id=&quot;queryArticles&quot; resultType=&quot;Article&quot;&gt;
      select * from article
   &lt;/select&gt;
   
   &lt;select id=&quot;getArticleById&quot; resultType=&quot;Article&quot;&gt;
      select * from article where id = #&#123;id&#125;
   &lt;/select&gt;
   
   &lt;insert id=&quot;addArticle&quot; parameterType=&quot;Article&quot;&gt;
      insert into article (author,title,content) values (#&#123;author&#125;,#&#123;title&#125;,#&#123;content&#125;);
   &lt;/insert&gt;
   
   &lt;delete id=&quot;deleteArticleById&quot; parameterType=&quot;int&quot;&gt;
      delete from article where id = #&#123;id&#125;
   &lt;/delete&gt;
   
&lt;/mapper&gt;
</code></pre>
<p><strong>既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置</strong></p>
<pre><code>mybatis:
mapper-locations: classpath:com/kuang/mapper/*.xml
type-aliases-package: com.kuang.pojo
</code></pre>
<p>编写一个Controller测试下，是否ok；</p>
<h4 id="17-2-2、文章编辑整合"><a href="#17-2-2、文章编辑整合" class="headerlink" title="17.2.2、文章编辑整合"></a>17.2.2、文章编辑整合</h4><p>1、导入 editor.md 资源 ，删除多余文件</p>
<p>2、编辑文章页面 editor.html、需要引入 jQuery；</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html class=&quot;x-admin-sm&quot; lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;

&lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;秦疆&#39;Blog&lt;/title&gt;
   &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi&quot; /&gt;
   &lt;!--Editor.md--&gt;
   &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.css&#125;&quot;/&gt;
   &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://pandao.github.io/editor.md/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div class=&quot;layui-fluid&quot;&gt;
   &lt;div class=&quot;layui-row layui-col-space15&quot;&gt;
       &lt;div class=&quot;layui-col-md12&quot;&gt;
           &lt;!--博客表单--&gt;
           &lt;form name=&quot;mdEditorForm&quot;&gt;
               &lt;div&gt;
                  标题：&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;
               &lt;/div&gt;
               &lt;div&gt;
                  作者：&lt;input type=&quot;text&quot; name=&quot;author&quot;&gt;
               &lt;/div&gt;
               &lt;div id=&quot;article-content&quot;&gt;
                   &lt;textarea name=&quot;content&quot; id=&quot;content&quot; style=&quot;display:none;&quot;&gt; &lt;/textarea&gt;
               &lt;/div&gt;
           &lt;/form&gt;

       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;!--editormd--&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
   var testEditor;

   //window.onload = function()&#123; &#125;
   $(function() &#123;
       testEditor = editormd(&quot;article-content&quot;, &#123;
           width : &quot;95%&quot;,
           height : 400,
           syncScrolling : &quot;single&quot;,
           path : &quot;../editormd/lib/&quot;,
           saveHTMLToTextarea : true,    // 保存 HTML 到 Textarea
           emoji: true,
           theme: &quot;dark&quot;,//工具栏主题
           previewTheme: &quot;dark&quot;,//预览主题
           editorTheme: &quot;pastel-on-dark&quot;,//编辑主题
           tex : true,                   // 开启科学公式TeX语言支持，默认关闭
           flowChart : true,             // 开启流程图支持，默认关闭
           sequenceDiagram : true,       // 开启时序/序列图支持，默认关闭,
           //图片上传
           imageUpload : true,
           imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;],
           imageUploadURL : &quot;/article/file/upload&quot;,
           onload : function() &#123;
               console.log(&#39;onload&#39;, this);
          &#125;,
           /*指定需要显示的功能按钮*/
           toolbarIcons : function() &#123;
               return [&quot;undo&quot;,&quot;redo&quot;,&quot;|&quot;,
                   &quot;bold&quot;,&quot;del&quot;,&quot;italic&quot;,&quot;quote&quot;,&quot;ucwords&quot;,&quot;uppercase&quot;,&quot;lowercase&quot;,&quot;|&quot;,
                   &quot;h1&quot;,&quot;h2&quot;,&quot;h3&quot;,&quot;h4&quot;,&quot;h5&quot;,&quot;h6&quot;,&quot;|&quot;,
                   &quot;list-ul&quot;,&quot;list-ol&quot;,&quot;hr&quot;,&quot;|&quot;,
                   &quot;link&quot;,&quot;reference-link&quot;,&quot;image&quot;,&quot;code&quot;,&quot;preformatted-text&quot;,
                   &quot;code-block&quot;,&quot;table&quot;,&quot;datetime&quot;,&quot;emoji&quot;,&quot;html-entities&quot;,&quot;pagebreak&quot;,&quot;|&quot;,
                   &quot;goto-line&quot;,&quot;watch&quot;,&quot;preview&quot;,&quot;fullscreen&quot;,&quot;clear&quot;,&quot;search&quot;,&quot;|&quot;,
                   &quot;help&quot;,&quot;info&quot;,&quot;releaseIcon&quot;, &quot;index&quot;]
          &#125;,

           /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/
           toolbarIconTexts : &#123;
               releaseIcon : &quot;&lt;span bgcolor=\&quot;gray\&quot;&gt;发布&lt;/span&gt;&quot;,
               index : &quot;&lt;span bgcolor=\&quot;red\&quot;&gt;返回首页&lt;/span&gt;&quot;,
          &#125;,

           /*给自定义按钮指定回调函数*/
           toolbarHandlers:&#123;
               releaseIcon : function(cm, icon, cursor, selection) &#123;
                   //表单提交
                   mdEditorForm.method = &quot;post&quot;;
                   mdEditorForm.action = &quot;/article/addArticle&quot;;//提交至服务器的路径
                   mdEditorForm.submit();
              &#125;,
               index : function()&#123;
                   window.location.href = &#39;/&#39;;
              &#125;,
          &#125;
      &#125;);
  &#125;);
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<p>3、编写Controller，进行跳转，以及保存文章</p>
<pre><code>@Controller
@RequestMapping(&quot;/article&quot;)
public class ArticleController &#123;

   @GetMapping(&quot;/toEditor&quot;)
   public String toEditor()&#123;
       return &quot;editor&quot;;
  &#125;
   
   @PostMapping(&quot;/addArticle&quot;)
   public String addArticle(Article article)&#123;
       articleMapper.addArticle(article);
       return &quot;editor&quot;;
  &#125;
   
&#125;
</code></pre>
<blockquote>
<p>图片上传问题</p>
</blockquote>
<p>1、前端js中添加配置</p>
<pre><code>//图片上传
imageUpload : true,
imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;],
imageUploadURL : &quot;/article/file/upload&quot;, // //这个是上传图片时的访问地址
</code></pre>
<p>2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！</p>
<pre><code>//博客图片上传问题
@RequestMapping(&quot;/file/upload&quot;)
@ResponseBody
public JSONObject fileUpload(@RequestParam(value = &quot;editormd-image-file&quot;, required = true) MultipartFile file, HttpServletRequest request) throws IOException &#123;
   //上传路径保存设置

   //获得SpringBoot当前项目的路径：System.getProperty(&quot;user.dir&quot;)
   String path = System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;;

   //按照月份进行分类：
   Calendar instance = Calendar.getInstance();
   String month = (instance.get(Calendar.MONTH) + 1)+&quot;月&quot;;
   path = path+month;

   File realPath = new File(path);
   if (!realPath.exists())&#123;
       realPath.mkdir();
  &#125;

   //上传文件地址
   System.out.println(&quot;上传文件保存地址：&quot;+realPath);

   //解决文件名字问题：我们使用uuid;
   String filename = &quot;ks-&quot;+UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
   //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
   file.transferTo(new File(realPath +&quot;/&quot;+ filename));

   //给editormd进行回调
   JSONObject res = new JSONObject();
   res.put(&quot;url&quot;,&quot;/upload/&quot;+month+&quot;/&quot;+ filename);
   res.put(&quot;success&quot;, 1);
   res.put(&quot;message&quot;, &quot;upload success!&quot;);

   return res;
&#125;
</code></pre>
<p>3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！</p>
<pre><code>@Configuration
public class MyMvcConfig implements WebMvcConfigurer &#123;

   // 文件保存在真实目录/upload/下，
   // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。
   @Override
   public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
       registry.addResourceHandler(&quot;/upload/**&quot;)
          .addResourceLocations(&quot;file:&quot;+System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;);
  &#125;

&#125;
</code></pre>
<blockquote>
<p>表情包问题</p>
</blockquote>
<p>自己手动下载，emoji 表情包，放到图片路径下：</p>
<p>修改editormd.js文件</p>
<pre><code>// Emoji graphics files url path
editormd.emoji     = &#123;
   path : &quot;../editormd/plugins/emoji-dialog/emoji/&quot;,
   ext   : &quot;.png&quot;
&#125;;
</code></pre>
<h3 id="文章展示"><a href="#文章展示" class="headerlink" title="文章展示"></a>文章展示</h3><p>1、Controller 中增加方法</p>
<pre><code>@GetMapping(&quot;/&#123;id&#125;&quot;)
public String show(@PathVariable(&quot;id&quot;) int id,Model model)&#123;
   Article article = articleMapper.getArticleById(id);
   model.addAttribute(&quot;article&quot;,article);
   return &quot;article&quot;;
&#125;
</code></pre>
<p>2、编写页面 article.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
   &lt;title th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
   &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt;
   &lt;h2 style=&quot;margin: auto 0&quot; th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/h2&gt;
  作者：&lt;span style=&quot;float: left&quot; th:text=&quot;$&#123;article.author&#125;&quot;&gt;&lt;/span&gt;
   &lt;!--文章主体内容--&gt;
   &lt;div id=&quot;doc-content&quot;&gt;
       &lt;textarea style=&quot;display:none;&quot; placeholder=&quot;markdown&quot; th:text=&quot;$&#123;article.content&#125;&quot;&gt;&lt;/textarea&gt;
   &lt;/div&gt;

&lt;/div&gt;

&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.preview.css&#125;&quot; /&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/marked.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/prettify.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/raphael.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/underscore.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/sequence-diagram.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
   var testEditor;
   $(function () &#123;
       testEditor = editormd.markdownToHTML(&quot;doc-content&quot;, &#123;//注意：这里是上面DIV的id
           htmlDecode: &quot;style,script,iframe&quot;,
           emoji: true,
           taskList: true,
           tocm: true,
           tex: true, // 默认不解析
           flowChart: true, // 默认不解析
           sequenceDiagram: true, // 默认不解析
           codeFold: true
      &#125;);&#125;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>重启项目，访问进行测试！大功告成！</p>
<p>小结：</p>
<p>有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！</p>
<h2 id="十八、Dubbo和Zookeeoer集成"><a href="#十八、Dubbo和Zookeeoer集成" class="headerlink" title="十八、Dubbo和Zookeeoer集成"></a>十八、Dubbo和Zookeeoer集成</h2><h3 id="18-1、分布式理论"><a href="#18-1、分布式理论" class="headerlink" title="18.1、分布式理论"></a>18.1、分布式理论</h3><h4 id="18-1-1、什么是分布式系统？"><a href="#18-1-1、什么是分布式系统？" class="headerlink" title="18.1.1、什么是分布式系统？"></a>18.1.1、什么是分布式系统？</h4><p>在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p>
<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是<strong>利用更多的机器，处理更多的数据</strong>。</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p>
<h4 id="18-1-2、Dubbo文档"><a href="#18-1-2、Dubbo文档" class="headerlink" title="18.1.2、Dubbo文档"></a>18.1.2、Dubbo文档</h4><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<p>在Dubbo的官网文档有这样一张图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshLkKFz4W9TBHVg7cBtxDPTFkU2b9C13K1CHPyLApFyAFFlbjnpcWibIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-1-3、单一应用架构"><a href="#18-1-3、单一应用架构" class="headerlink" title="18.1.3、单一应用架构"></a>18.1.3、单一应用架构</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshw2ITicetDcFsg41kISOhuyojGB1Z8ics61xtqnicJTXDk7Qw41dkeXK2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<p><strong>缺点：</strong></p>
<p>1、性能扩展比较难</p>
<p>2、协同开发问题</p>
<p>3、不利于升级维护</p>
<h4 id="18-1-4、垂直应用架构"><a href="#18-1-4、垂直应用架构" class="headerlink" title="18.1.4、垂直应用架构"></a>18.1.4、垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshG4FicWRMjbfStG0Ojr1H9cL1jQ1SbZ0s7rsbsc7w8f3usmdSJog7pHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点：公用模块无法重复利用，开发性的浪费</p>
<h4 id="18-1-5、分布式服务架构"><a href="#18-1-5、分布式服务架构" class="headerlink" title="18.1.5、分布式服务架构"></a>18.1.5、分布式服务架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshwIkic8EicmCwYGRibdWohmDazEDhonhTeJfVx0dfBNlW4dGGxvOMOk0Gg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-1-6、流动计算架构"><a href="#18-1-6、流动计算架构" class="headerlink" title="18.1.6、流动计算架构"></a>18.1.6、流动计算架构</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshxoCosFhoMzIcbBzjCt6ia9Gr7atHlwNHhL0po4YhyE8WkHXnnpN8Ddg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="18-2、RPC简介"><a href="#18-2、RPC简介" class="headerlink" title="18.2、RPC简介"></a>18.2、RPC简介</h3><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>
<p>推荐阅读文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2accc2840a1b">https://www.jianshu.com/p/2accc2840a1b</a></p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshVx3xhf4RyUVtia7Tvo4BBs70SFKRonhrPrNsiap2rEAQCn4IWUoS3HZA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>步骤解析：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshDCibUnIYkolqibQRy7Qlpm9vNibK9IDaFibJoLpIM5pWLe7Yqly7PheYsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RPC两个核心模块：通讯，序列化。</p>
<h3 id="18-3、搭建测试环境"><a href="#18-3、搭建测试环境" class="headerlink" title="18.3、搭建测试环境"></a>18.3、搭建测试环境</h3><h4 id="18-3-1、Dubbo"><a href="#18-3-1、Dubbo" class="headerlink" title="18.3.1、Dubbo"></a>18.3.1、Dubbo</h4><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>dubbo官网 <a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/index.html">http://dubbo.apache.org/zh-cn/index.html</a></p>
<p>1.了解Dubbo的特性</p>
<p>2.查看官方文档</p>
<p><strong>dubbo基本概念</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshLSMRQe7NJpvDFrQMChLxI3BqIYQXrZvfs28iadQ1dDB4p84ydyb3KtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p><strong>调用关系说明</strong></p>
<p>l 服务容器负责启动，加载，运行服务提供者。</p>
<p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h4 id="18-3-2、Dubbo环境搭建"><a href="#18-3-2、Dubbo环境搭建" class="headerlink" title="18.3.2、Dubbo环境搭建"></a>18.3.2、Dubbo环境搭建</h4><p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p>
<p>什么是zookeeper呢？可以查看官方文档</p>
<h4 id="18-3-3、Window下安装zookeeper"><a href="#18-3-3、Window下安装zookeeper" class="headerlink" title="18.3.3、Window下安装zookeeper"></a>18.3.3、Window下安装zookeeper</h4><p>1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper</p>
<p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p>
<p>可能遇到问题：闪退 !</p>
<p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshERcBbh6aAYOxnI1yFCMJ6ia2jsJzW3mIhF9ZUicsOQ2AclNAb2eUCFCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshQM9ha9wq0nRMhQicxYEyI89HCXwVIxZzPthrPHFDur3VbwtFia6GeAicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、修改zoo.cfg配置文件</p>
<p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./  临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181  zookeeper的端口号</p>
<p>修改完成后再次启动zookeeper</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshzuNFWROxUoicw96U1SpicxJNJFedhL6dPzcgpedqIE2XgxZHUpicTYDMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根下保存的所有节点</p>
<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 4] ls /
[zookeeper]
</code></pre>
<p>create –e /kuangshen 123：创建一个kuangshen节点，值为123</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshmI79TweJ88IvdkKgNxduic3xgVpYeDGHN10Wp27u0dIJoTRa3e7Z9TA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>get /kuangshen：获取/kuangshen节点的值</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshpsqHHO1fsq3ucpfWQdqyYkOAxxO6mbD7YiczFdyklEG41cuMomRpUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们再来查看一下节点</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshjRW6icsrmFYiavJaLYBa1UXl2FrQtCvxpqdXTtSwyZpcZvqoFnmae7QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="18-3-4、window下安装dubbo-admin"><a href="#18-3-4、window下安装dubbo-admin" class="headerlink" title="18.3.4、window下安装dubbo-admin"></a>18.3.4、window下安装dubbo-admin</h4><p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p>
<p>我们这里来安装一下：</p>
<p><strong>1、下载dubbo-admin</strong></p>
<p>地址 ：<a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p>
<p><strong>2、解压进入目录</strong></p>
<p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p>
<pre><code>server.port=7001
spring.velocity.cache=false
spring.velocity.charset=UTF-8
spring.velocity.layout-url=/templates/default.vm
spring.messages.fallback-to-system-locale=false
spring.messages.basename=i18n/message
spring.root.password=root
spring.guest.password=guest

dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3、在项目目录下</strong>打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true
</code></pre>
<p><strong>第一次打包的过程有点慢，需要耐心等待！直到成功！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshho9bzkKPPgVQRh3x35ueIYFGEDfygiaXKjOQQFuC2bxc1ImffuOsH2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>【注意：zookeeper的服务一定要打开！】</p>
<p>执行完毕，我们去访问一下 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p>
<p>登录成功后，查看界面</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshjHbZUAW6UOLfJhknMjgemFYgr2hz27iaBE4tiaKA86ZqIhOjd3vttV5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>安装完成！</p>
<h3 id="18-4、SpringBoot-Dubbo-zookeeper"><a href="#18-4、SpringBoot-Dubbo-zookeeper" class="headerlink" title="18.4、SpringBoot + Dubbo + zookeeper"></a>18.4、SpringBoot + Dubbo + zookeeper</h3><h4 id="18-4-1、框架搭建"><a href="#18-4-1、框架搭建" class="headerlink" title="18.4.1、框架搭建"></a>18.4.1、框架搭建</h4><p><strong>1. 启动zookeeper ！</strong></p>
<p><strong>2. IDEA创建一个空项目；</strong></p>
<p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p>
<p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p>
<p>编写接口</p>
<pre><code>package com.kuang.provider.service;

public interface TicketService &#123;
   public String getTicket();
&#125;
</code></pre>
<p>编写实现类</p>
<pre><code>package com.kuang.provider.service;

public class TicketServiceImpl implements TicketService &#123;
   @Override
   public String getTicket() &#123;
       return &quot;《狂神说Java》&quot;;
  &#125;
&#125;
</code></pre>
<p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p>
<p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p>
<p>编写service</p>
<pre><code>package com.kuang.consumer.service;

public class UserService &#123;
   //我们需要去拿去注册中心的服务
&#125;
</code></pre>
<p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p>
<h4 id="18-4-2、服务提供者"><a href="#18-4-2、服务提供者" class="headerlink" title="18.4.2、服务提供者"></a>18.4.2、服务提供者</h4><p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p>
<p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p>
<pre><code>&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;    
</code></pre>
<p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p>
<pre><code>&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p>
<pre><code>#当前应用名字
dubbo.application.name=provider-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
#扫描指定包下服务
dubbo.scan.base-packages=com.kuang.provider.service
</code></pre>
<p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p>
<pre><code>import org.apache.dubbo.config.annotation.Service;
import org.springframework.stereotype.Component;

@Service //将服务发布出去
@Component //放在容器中
public class TicketServiceImpl implements TicketService &#123;
   @Override
   public String getTicket() &#123;
       return &quot;《狂神说Java》&quot;;
  &#125;
&#125;
</code></pre>
<p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p>
<h4 id="18-4-3、服务消费者"><a href="#18-4-3、服务消费者" class="headerlink" title="18.4.3、服务消费者"></a>18.4.3、服务消费者</h4><p><strong>1、导入依赖，和之前的依赖一样；</strong></p>
<pre><code>&lt;!--dubbo--&gt;
&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--zookeeper--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、<strong>配置参数</strong></p>
<pre><code>#当前应用名字
dubbo.application.name=consumer-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshCZQj2L99hIN2HFHNQSzkSQMaUrbib6H4LJiabJur5V7icM0cq7ib8sK0gA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>4. 完善消费者的服务类</strong></p>
<pre><code>package com.kuang.consumer.service;

import com.kuang.provider.service.TicketService;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.stereotype.Service;

@Service //注入到容器中
public class UserService &#123;

   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名
   TicketService ticketService;

   public void bugTicket()&#123;
       String ticket = ticketService.getTicket();
       System.out.println(&quot;在注册中心买到&quot;+ticket);
  &#125;

&#125;
</code></pre>
<p><strong>5. 测试类编写；</strong></p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class ConsumerServerApplicationTests &#123;

   @Autowired
   UserService userService;

   @Test
   public void contextLoads() &#123;

       userService.bugTicket();

  &#125;

&#125;
</code></pre>
<h4 id="18-4-4、启动测试"><a href="#18-4-4、启动测试" class="headerlink" title="18.4.4、启动测试"></a>18.4.4、启动测试</h4><p><strong>1. 开启zookeeper</strong></p>
<p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p>
<p><strong>3. 开启服务者</strong></p>
<p><strong>4. 消费者消费测试，结果：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshU2j95r3eBhJlZLBEgpoVVHDb8Vm9EU0XB4ZW0xxwhs2q4blguwGcibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>监控中心 ：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60rensh4rC1ED2BCl07c81gxj3uKN5PtDZXDquz8gWS2yJmib46kib1C0SF3ycw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="十九、集成SpringSecurity"><a href="#十九、集成SpringSecurity" class="headerlink" title="十九、集成SpringSecurity"></a>十九、集成SpringSecurity</h2><h3 id="一、安全简介"><a href="#一、安全简介" class="headerlink" title="一、安全简介"></a>一、安全简介</h3><p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h3 id="19-2、实战测试"><a href="#19-2、实战测试" class="headerlink" title="19.2、实战测试"></a>19.2、实战测试</h3><h4 id="19-2-1、实验环境搭建"><a href="#19-2-1、实验环境搭建" class="headerlink" title="19.2.1、实验环境搭建"></a>19.2.1、实验环境搭建</h4><p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<pre><code>welcome.html
|views
|level1
1.html
2.html
3.html
|level2
1.html
2.html
3.html
|level3
1.html
2.html
3.html
Login.html
</code></pre>
<p>3、controller跳转！</p>
<pre><code>package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouterController &#123;

   @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)
   public String index()&#123;
       return &quot;index&quot;;
  &#125;

   @RequestMapping(&quot;/toLogin&quot;)
   public String toLogin()&#123;
       return &quot;views/login&quot;;
  &#125;

   @RequestMapping(&quot;/level1/&#123;id&#125;&quot;)
   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level1/&quot;+id;
  &#125;

   @RequestMapping(&quot;/level2/&#123;id&#125;&quot;)
   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level2/&quot;+id;
  &#125;

   @RequestMapping(&quot;/level3/&#123;id&#125;&quot;)
   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;
       return &quot;views/level3/&quot;+id;
  &#125;

&#125;
</code></pre>
<p>4、测试实验环境是否OK！</p>
<h4 id="19-2-2、认识SpringSecurity"><a href="#19-2-2、认识SpringSecurity" class="headerlink" title="19.2.2、认识SpringSecurity"></a>19.2.2、认识SpringSecurity</h4><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p> <strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h4 id="19-2-3、认证和授权"><a href="#19-2-3、认证和授权" class="headerlink" title="19.2.3、认证和授权"></a>19.2.3、认证和授权</h4><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> </p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>  #servlet-applications 8.16.4</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXheImAPwVia7gtcx2cNCUXAXbCJpst1geQCOElXLQMMvAibMLmYNqXF5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、编写基础配置类</p>
<pre><code>package com.kuang.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity // 开启WebSecurity模式
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;

   @Override
   protected void configure(HttpSecurity http) throws Exception &#123;
       
  &#125;
&#125;
</code></pre>
<p>4、定制请求的授权规则</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception &#123;
   // 定制请求的授权规则
   // 首页所有人可以访问
   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);
&#125;
</code></pre>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<pre><code>// 开启自动配置的登录功能
// /login 请求来到登录页
// /login?error 重定向到这里表示登录失败
http.formLogin();
</code></pre>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXMBrh9xGQDQjlW4EpV2DscJbUzAMwjqIGGgw8fqWET4swGIue9mbwwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<pre><code>//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
   
   //在内存中定义，也可以在jdbc中去拿....
   auth.inMemoryAuthentication()
          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);
&#125;
</code></pre>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXSHnC5kd7W2DeryMuzoSOx3evDWoqlVIoGxBA3TEjAF54s4cRQsld0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<pre><code>//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
   //在内存中定义，也可以在jdbc中去拿....
   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
   //spring security 官方推荐的是使用bcrypt加密方式。
   
   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);
&#125;
</code></pre>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h4 id="19-2-4、权限控制和注销"><a href="#19-2-4、权限控制和注销" class="headerlink" title="19.2.4、权限控制和注销"></a>19.2.4、权限控制和注销</h4><p>1、开启自动配置的注销的功能</p>
<pre><code>//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception &#123;
   //....
   //开启自动配置的注销的功能
      // /logout 注销请求
   http.logout();
&#125;
</code></pre>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<pre><code>&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
&lt;/a&gt;
</code></pre>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<pre><code>// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>7、修改我们的 前端页面</p>
<ol>
<li><p>导入命名空间</p>
</li>
<li><pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;
</code></pre>
</li>
<li><p>修改导航栏，增加认证判断</p>
</li>
<li><pre><code>&lt;!--登录注销--&gt;
&lt;div class=&quot;right menu&quot;&gt;

   &lt;!--如果未登录--&gt;
   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;!--如果已登录--&gt;
   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;
          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;
          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
       &lt;/a&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<pre><code>http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<pre><code>&lt;!-- sec:authorize=&quot;hasRole(&#39;vip1&#39;)&quot; --&gt;
&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip1&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip2&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#39;vip3&#39;)&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h4 id="19-2-5、记住我"><a href="#19-2-5、记住我" class="headerlink" title="19.2.5、记住我"></a>19.2.5、记住我</h4><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<pre><code>//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception &#123;
//。。。。。。。。。。。
   //记住我
   http.rememberMe();
&#125;
</code></pre>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXqDg8FodHRKUM8K5z79zEghbybrKD6WtqO0B9JBkD6FQNQ6dhARQsTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXS8kt9d3jGhJPZGNa5V97ZKVBIUNdHmtPibNia7U59tbfQyzla4mHFtYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h4 id="19-2-6、定制登录页"><a href="#19-2-6、定制登录页" class="headerlink" title="19.2.6、定制登录页"></a>19.2.6、定制登录页</h4><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<pre><code>http.formLogin().loginPage(&quot;/toLogin&quot;);
</code></pre>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<pre><code>&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
&lt;/a&gt;
</code></pre>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<p>在 loginPage()源码中的注释上有写明：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JolV3xA4rEtxSCgbN76QbXCxA0YjyGXDmBHOMYfpwolJ5yZxvMAINJRvTx7HBwyTtO4azI2QuqdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Username&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;
           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Password&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;
&lt;/form&gt;
</code></pre>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<pre><code>http.formLogin()
  .usernameParameter(&quot;username&quot;)
  .passwordParameter(&quot;password&quot;)
  .loginPage(&quot;/toLogin&quot;)
  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求
</code></pre>
<p>5、在登录页增加记住我的多选框</p>
<pre><code>&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我
</code></pre>
<p>6、后端验证处理！</p>
<pre><code>//定制记住我的参数！
http.rememberMe().rememberMeParameter(&quot;remember&quot;);
</code></pre>
<p>7、测试，OK</p>
<h3 id="19-3、完整配置代码"><a href="#19-3、完整配置代码" class="headerlink" title="19.3、完整配置代码"></a>19.3、完整配置代码</h3><pre><code>package com.kuang.config;

import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;

   //定制请求的授权规则
   @Override
   protected void configure(HttpSecurity http) throws Exception &#123;

       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);


       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！
           // /login 请求来到登录页
           // /login?error 重定向到这里表示登录失败
       http.formLogin()
          .usernameParameter(&quot;username&quot;)
          .passwordParameter(&quot;password&quot;)
          .loginPage(&quot;/toLogin&quot;)
          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求

       //开启自动配置的注销的功能
           // /logout 注销请求
           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页

       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
       http.logout().logoutSuccessUrl(&quot;/&quot;);

       //记住我
       http.rememberMe().rememberMeParameter(&quot;remember&quot;);
  &#125;

   //定义认证规则
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
       //在内存中定义，也可以在jdbc中去拿....
       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
       //spring security 官方推荐的是使用bcrypt加密方式。

       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);
  &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringBoot" style=color:#879cff>
                SpringBoot
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringBoot/SpringBoot使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/">
        <h2>
            Spring整合Log4j
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Sping整合Log4j"><a href="#Sping整合Log4j" class="headerlink" title="Sping整合Log4j"></a>Sping整合Log4j</h1><h2 id="一、log4j日志简介"><a href="#一、log4j日志简介" class="headerlink" title="一、log4j日志简介"></a>一、log4j日志简介</h2><p>​        Log4j是Apache的一个开放源代码项目，通过使用Log4j，控制日志信息输送的目的地可以为控制台、文件、数据库、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；可以控制每一条日志的信息内容和信息输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；甚至还可以在不需要修改业务逻辑代码、重启web服务，只需要通过一个修改配置文件就可以实现控制项目的日志动作。</p>
<p>​        Log4j由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p>
<h2 id="二、定义配置文件"><a href="#二、定义配置文件" class="headerlink" title="二、定义配置文件"></a>二、定义配置文件</h2><p>​        其实您也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件（键=值）。下面我们介绍使用Java特性文件做为配置文件的方法：</p>
<h3 id="2-1、配置根Logger"><a href="#2-1、配置根Logger" class="headerlink" title="2.1、配置根Logger"></a>2.1、配置根Logger</h3><pre><code class="java">log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre>
<p>​        其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p>
<p>eg：</p>
<pre><code class="properties">### set log levels ###  
log4j.rootLogger = debug,stdout,D,E  
 
log4j.appender.stdout = org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.Target = System.out  
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout  
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  
 
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.D.File = F://logs/log.log  
log4j.appender.D.Append = true  
log4j.appender.D.Threshold = DEBUG   
log4j.appender.D.layout = org.apache.log4j.PatternLayout  
log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n  
 
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender  
log4j.appender.E.File =F://logs/error.log   
log4j.appender.E.Append = true  
log4j.appender.E.Threshold = ERROR   
log4j.appender.E.layout = org.apache.log4j.PatternLayout  
log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n
</code></pre>
<h3 id="2-2、配置日志信息输出目的地Appender"><a href="#2-2、配置日志信息输出目的地Appender" class="headerlink" title="2.2、配置日志信息输出目的地Appender"></a>2.2、配置日志信息输出目的地Appender</h3><pre><code class="properties">log4j.appender.appenderName = fully.qualified.name.of.appender.class
 
log4j.appender.appenderName.option1 = value1
 
…
 
log4j.appender.appenderName.option = valueN
</code></pre>
<p>​        其中，Log4j提供的appender有以下几种：</p>
<pre><code class="properties">org.apache.log4j.ConsoleAppender（控制台），
 
org.apache.log4j.FileAppender（文件），
 
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），
 
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
 
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre>
<h3 id="2-3、配置日志信息的格式（布局）"><a href="#2-3、配置日志信息的格式（布局）" class="headerlink" title="2.3、配置日志信息的格式（布局）"></a>2.3、配置日志信息的格式（布局）</h3><pre><code class="properties">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
 
log4j.appender.appenderName.layout.option1 = value1
 
…
 
log4j.appender.appenderName.layout.option = valueN
</code></pre>
<p>​        其中，Log4j提供的layout有以e几种：</p>
<pre><code class="css">org.apache.log4j.HTMLLayout（以HTML表格形式布局），
 
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
 
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
 
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre>
<p>​        Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息</p>
<pre><code class="properties">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  
%r 输出自应用启动到输出该log信息耗费的毫秒数  
%c 输出所属的类目，通常就是所在类的全名  
%t 输出产生该日志事件的线程名  
%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  
%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  
%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)
</code></pre>
<p>首先，日志的级别有：OFF 、FATAL 、ERROR、WARN、INFO、DEBUG、TRACE 、ALL 等等。</p>
<ul>
<li><p>OFF：关闭了日志信息  </p>
</li>
<li><p>FATAL：可能导致应用中止的严重事件错误  </p>
</li>
<li><p>ERROR：严重错误 主要是程序的错误  </p>
</li>
<li><p>WARN：一般警告，比如session丢失  </p>
</li>
<li><p>INFO：一般要显示的信息，比如登录登出  </p>
</li>
<li><p>DEBUG：程序的调试信息  </p>
</li>
<li><p>TRACE：比DEBUG更细粒度的事件信息  </p>
</li>
<li><p>ALL：打开所有级别的日志</p>
</li>
</ul>
<p>log4j提供了一系列的Appender，允许将日志输送到不同的地方，如控制台、文件、数据库等：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.jdbc.JDBCAppender（数据库）</li>
<li>org.apache.log4j.net.SMTPAppender（邮件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h2 id="三、Spring框架整合log4j"><a href="#三、Spring框架整合log4j" class="headerlink" title="三、Spring框架整合log4j"></a>三、Spring框架整合log4j</h2><h3 id="3-1、pom-xml-引入log4j组件依赖包："><a href="#3-1、pom-xml-引入log4j组件依赖包：" class="headerlink" title="3.1、pom.xml 引入log4j组件依赖包："></a>3.1、pom.xml 引入log4j组件依赖包：</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："><a href="#3-2、web-xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：" class="headerlink" title="3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件："></a>3.2、web.xml里边配置servlet容器启动时，自动加载log4j配置并注入组件：</h3><pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:conf/log4j.properties&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;!-- 5000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; 
&lt;context-param&gt;
      &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;
      &lt;param-value&gt;5000&lt;/param-value&gt;
&lt;/context-param&gt;
 
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>​        首先是这个关于JavaWeb的工程的总配置位置。我们要在里面声明要使用Spring与Log4j。值得注意的Log4j的配置必须在Spring配置之前，否则如果先启动Spring，那个必须整合Log4j才不吐警告的Spring，由于Log4j还没有启动，找不到Spring，又会在任性地吐警告。当然，你设置那些什么优先级也行，不过，先启动的直接放前面，这个文件不是更好看吗？</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
    version=&quot;3.0&quot;&gt;
    &lt;!-- Log4j配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!-- 指定Log4j的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
    
    &lt;!-- Spring配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    
&lt;/web-app&gt;  
</code></pre>
<p>​        这里，我将log4j.properties配置文件存放到classpath的conf目录下，并启动一个watchdog线程每5秒扫描配置文件的变化，重新调整日志的策略，实现在不调整逻辑代码即可实现日志的策略变更。通过log4j.properties详细配置了日志的策略，如下：</p>
<pre><code class="properties"># +======================================================================+#
log4j.rootLogger=$&#123;log4j.log.level&#125;,$&#123;log4j.log.target&#125;
log4j.addivity.org.apache=true
# +======================================================================+#
# | [target] - Console
# +----------------------------------------------------------------------+#
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.CONSOLE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.CONSOLE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - FILE
# +----------------------------------------------------------------------+#
log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.Threshold=$&#123;log4j.log.level&#125;
log4j.appender.FILE.Encoding=$&#123;log4j.log.encoding&#125;
log4j.appender.FILE.File=$&#123;log4j.log.dir&#125;/runtime.log
log4j.appender.FILE.Append=true
log4j.appender.FILE.MaxFileSize=2048KB
log4j.appender.FILE.MaxBackupIndex=10
log4j.appender.FILE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.FILE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
# | [target] - DATABASE
# +----------------------------------------------------------------------+#
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.DATABASE.Threshold=ERROR
log4j.appender.DATABASE.URL=jdbc:mysql://127.0.0.1:3306/spring
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver
log4j.appender.DATABASE.user=root
log4j.appender.DATABASE.password=liuriqi
log4j.appender.DATABASE.layout=$&#123;log4j.log.layout&#125;
log4j.appender.DATABASE.sql=INSERT INTO tv_log4j(message)VALUES(&#39;$&#123;log4j.log.layout.pattern&#125;&#39;)
# +======================================================================+#
# | [target] - EMAIL
# +----------------------------------------------------------------------+#
log4j.appender.EMAIL=org.apache.log4j.net.SMTPAppender
log4j.appender.EMAIL.Threshold=FATAL
log4j.appender.EMAIL.BufferSize=10
log4j.appender.EMAIL.From=fromuser@gmail.com
log4j.appender.EMAIL.SMTPHost=localhost
log4j.appender.EMAIL.Subject=Log4J Message
log4j.appender.EMAIL.To=touser@gmail.com
log4j.appender.EMAIL.layout=$&#123;log4j.log.layout&#125;
log4j.appender.EMAIL.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;
# +======================================================================+#
上面配置相关的变量，我提取出来统一放到变量配置文件里边，如下：
 
# +======================================================================+#
# | log4j config
# +----------------------------------------------------------------------+#
log4j.log.dir=logs/
#log4j.log.level=ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF
log4j.log.level=DEBUG
#log4j.log.target=CONSOLE,FILE,DATABASE,EMAIL,SOCKET
log4j.log.target=CONSOLE,FILE
log4j.log.encoding=UTF-8
log4j.log.layout=org.apache.log4j.PatternLayout
log4j.log.layout.pattern=[%d %r] [%-5p] [%t] [%l] [%m]%n
# +======================================================================+#
</code></pre>
<p>​        通过以上配置，在项目启动的时候，会将DEBUG日志信息发送到控制台和文件日志中。</p>
<p>​        另一种配置方式：</p>
<pre><code class="properties">#log4j.rootLogger = [ level ] , appenderName, appenderName, ...
log4j.rootLogger = all, console, R

#Console
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] %m%n

#File
log4j.appender.R = org.apache.log4j.RollingFileAppender
log4j.appender.R.File = c:/log.txt
log4j.appender.R.MaxFileSize = 500KB
log4j.appender.R.MaxBackupIndex = 1
log4j.appender.R.layout = org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] - %m%n
</code></pre>
<p>​        首先第一部分是log4j的总配置部分，all代表debug,info,error,fatal四种类型的信息都会输出。一般不设置为all。因为那些debug,info信息对我们半点意义没有，还因为有很多系统内部的文件运行都会输出debug与info信息刷屏、刷版。关键是输出到磁盘的日志文件会极速递增，浪费磁盘空间。玩SQL Server的时候大家又不知道那个.ldb是多么恐怖？</p>
<p>​        因此第一部分，一般写成：</p>
<pre><code class="properties">log4j.rootLogger = ERROR, console, R
</code></pre>
<p>​        代表仅输出error与fatal错误。<br>​        之后的console，R分别代表在控制台与文件输出。同时在之后的代码必须配置好这个两输出。</p>
<p>​        第二部分控制台#Console<br>​        首先要使用log4j特定的包，这个没有什么好说，最后一句指明输出格式。一会儿大招对照输出结果就明白怎么回事了。</p>
<p>​        第三部分文件#File</p>
<p>​        log4j.appender.R.File=c:/log.txt是指这个Web工程错误日志皆输出到c:/log.txt。不要像网上那些大神输出一个什么.log后缀，关键是能够直接打开。</p>
<p>​        之后log4j.appender.R.MaxFileSize = 500KB指明这个log.txt文件大小最多为500KB，如果超过这个大小，自动开一个新文件，而log4j.appender.R.MaxBackupIndex=1指明此工程顶多只能有1个这个的日志文件。注：新内容覆盖旧内容。</p>
<p>​        最后，可以在应用程序中采用log4j自带的debug()、info()、warn()、error()方法来记录你想要记录的操作，至于如何存储日志及日志的目的地发送的工作就交给log4j好了。</p>
<p>​        最后一点说明的问题：配置较低级别的错误日志策略会记录高级的错误信息，配置高级的错误日志策略会忽略低级错误信息。如将错误日志的level配置为debug，则log4j组件会记录包含debug以上所有的级别日志如debug、info、warn、error、fatal等。加入你配置的为error级别，则不会记录error以下级别的日志信息如debug、info、warn等等。</p>
<pre><code class="java">import org.apache.log4j.Logger;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
@RestController
public class Log4jTest &#123;
     private static Logger logger =Logger.getLogger(Log4jTest.class);
     
     @RequestMapping(&quot;/log&quot;)
     public void writeLog() &#123;
            // 记录debug级别的信息    
            logger.debug(&quot;This is debug message.&quot;);    
            // 记录info级别的信息    
            logger.info(&quot;This is info message.&quot;);    
            // 记录error级别的信息    
            logger.error(&quot;This is error message.&quot;); 
     &#125;
     
&#125;
</code></pre>
<h2 id="四、Spring整合log4j2"><a href="#四、Spring整合log4j2" class="headerlink" title="四、Spring整合log4j2"></a>四、Spring整合log4j2</h2><p>4.1、pom.xml文件</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;!-- something --&gt;
 
        &lt;!-- log配置 --&gt;
        &lt;!-- 排除springboot原有的log依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 添加log4j2依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>4.2、log4j2.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 
&lt;!-- 日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL --&gt;
&lt;!-- status：设置log4j2本身的日志信息打印级别，可以不设置。当设置为info及以下级别时，在更改当前log4j2.xml文件后，自动检测功能发现xml文件有更改，将会打印更改日志，可以在console中看到。因此该status是log4j2.xml文件的日志设置。 --&gt;
&lt;!-- monitorInterval：设置间隔时间，单位为秒。Log4j2能够自动检测修改，并在monitorInterval设定的时间周期重新加载配置，无需重启应用 --&gt;
&lt;configuration status=&quot;info&quot; monitorInterval=&quot;5&quot;&gt;
    &lt;!-- 自定义属性 --&gt;
    &lt;Properties&gt;
        &lt;!-- 缺省配置（用于开发环境），配置日志文件输出目录和动态参数。其他环境需要在VM参数中指定； --&gt;
        &lt;!-- “sys:”表示：如果VM参数中没指定这个变量值，则使用本文件中定义的缺省全局变量值 --&gt;
        &lt;Property name=&quot;instance&quot;&gt;spring-boot-demo-log4j2&lt;/Property&gt;
        &lt;Property name=&quot;log.dir&quot;&gt;D:\log4j2&lt;/Property&gt;
    &lt;/Properties&gt;
    
    &lt;!-- 定义所有的appender --&gt;
    &lt;Appenders&gt;
        &lt;!--这个是输出控制台的配置--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT --&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!--输出日志的格式--&gt;
            &lt;!-- PatternLayout:输出格式，不设置默认为:%m%n --&gt;
            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%level] [%l] - %message%n&quot;/&gt;
            
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;accept&quot; onMismatch=&quot;deny&quot;/&gt;
            &lt;/Filters&gt;
        &lt;/Console&gt;
        
        &lt;!-- info及以上级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;
        &lt;!-- name:指定Appender的名字 --&gt;
        &lt;!-- fileName:指定输出日志的目的文件带全路径的文件名 --&gt;
        &lt;!-- filePattern:指定新建日志文件的名称格式 --&gt;
        &lt;RollingRandomAccessFile name=&quot;infoLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-info.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            
            &lt;!-- PatternLayout:日志输出格式，不设置默认为:%m%n --&gt;
            &lt;!-- &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%level][%class][%line]:%message%n&quot;/&gt; --&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;!-- 过滤器 --&gt;
            &lt;!-- 注意，这里要做一些特点说明： --&gt;
            &lt;!-- 等级大小关系为：OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL。 --&gt;
            &lt;!-- 在ThresholdFilter配置中，level属性是用来标识“匹配范围”的，且“被匹配（onMatch）范围”为该level及其以上的等级（例如level=&quot;WARN&quot;，那么onMatch范围为“OFF,FATAL,ERROR,WARN”），而“未匹配（onMismatch）范围”为所匹配途中剩下未被匹配的范围（例如level=&quot;WARN&quot;，那么onMismatch范围为“INFO,DEBUG,TRACE,ALL”）。 --&gt;
            &lt;!-- 需要注意，如果在一个&lt;Filters&gt;里面有多个&lt;ThresholdFilter&gt;，那么这些&lt;ThresholdFilter&gt;的书写是有上下关系的。 --&gt;
            &lt;!-- 写在上面的&lt;ThresholdFilter&gt;将通过level属性确定了已经匹配过的范围，那么，写在下面的&lt;ThresholdFilter&gt;的level必须在未被匹配的范围内选择，否则将无法生效（例如第一个&lt;ThresholdFilter&gt;中的level=&quot;WARN&quot;，那么第二个&lt;ThresholdFilter&gt;中的level属性值只能在“INFO、DEBUG、TRACE、ALL”里面选择）。 --&gt;
            &lt;!-- 因此，我们做一个规定： --&gt;
            &lt;!-- 在一个含有多个&lt;ThresholdFilter&gt;的&lt;Filters&gt;里面，在从上到下的&lt;ThresholdFilter&gt;列表顺序中，每一个&lt;ThresholdFilter&gt;中的level属性值我们规定必须由高等级至低等级填写。 --&gt;
            &lt;!-- 例如： --&gt;
            &lt;!-- 
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;XXX&quot; onMismatch=&quot;XXX&quot;/&gt;
            --&gt;
            &lt;Filters&gt;
                &lt;!-- onMatch=&quot;ACCEPT&quot; 表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;DENY&quot; 表示拒绝该级别及以上的日志 --&gt;
                &lt;!-- onMatch=&quot;NEUTRAL&quot; 表示中立，该级别及以上的日志的onMatch通过性，将由下一个ThresholdFilter的onMatch属性处理，如果当前ThresholdFilter是最后一个，则表示允许该级别及以上的日志 --&gt;
                &lt;!-- onMismatch=&quot;ACCEPT&quot; 表示允许该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;DENY&quot; 表示拒绝该级别以下的日志，同时不再往下检索ThresholdFilter，后面的ThresholdFilter将不会生效 --&gt;
                &lt;!-- onMismatch=&quot;NEUTRAL&quot; 表示中立，该级别以下的日志的onMismatch通过性，将由下一个ThresholdFilter的onMismatch属性处理，如果当前是最后一个，则允许该级别以下的日志--&gt;
                &lt;!-- level属性缺省，默认为level=&quot;ERROR&quot;，注意：缺省意思是没有该属性，而非level=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMatch属性缺省，默认为onMatch=&quot;accept&quot;，注意：缺省意思是没有该属性，而非onMatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;!-- onMismatch属性缺省，默认为onMismatch=&quot;deny&quot;，注意：缺省意思是没有该属性，而非onMismatch=&quot;&quot;，那是会报错的 --&gt;
                &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;!-- Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 --&gt;
            &lt;Policies&gt;
                &lt;!-- 基于时间的滚动策略 --&gt;
                &lt;!-- interval：表示历史日志封存间隔时间，单位为hour，默认是1 --&gt;
                &lt;!-- modulate：表示是否历史日志生成时间纠偏，纠偏以零点为基准进行。比如：17:30生成了$&#123;instance&#125;-info-2019032817.log.gz文件，那么纠偏后会在18:00生成$&#123;instance&#125;-info-2019032818.log.gz --&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;!-- 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小 --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
            
            &lt;!-- DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个(通过max属性定义)日志文件时开始删除最旧的，创建新的 --&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot;&gt;
                &lt;Delete basePath=&quot;$&#123;log.dir&#125;&quot; maxDepth=&quot;1&quot;&gt;
                    &lt;IfFileName glob=&quot;*.log.gz&quot; /&gt;
                    &lt;!-- 小时：H，天：d --&gt;
                    &lt;IfLastModified age=&quot;5d&quot; /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
 
        &lt;!-- warn级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;warnLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-warn.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- error级别的日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;errorLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-error.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
        
        &lt;!-- 测试日志信息 --&gt;
        &lt;RollingRandomAccessFile name=&quot;testLog&quot;
                                 fileName=&quot;$&#123;log.dir&#125;/$&#123;instance&#125;-test.log&quot;
                                 filePattern=&quot;$&#123;log.dir&#125;/%d&#123;yyyy-MM&#125;/$&#123;instance&#125;-test-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;
                                 append=&quot;true&quot;&gt;
            &lt;PatternLayout pattern=&quot;[%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%level] [%thread] [%l] - %message%n&quot;/&gt;
 
            &lt;Filters&gt;
                &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;deny&quot; onMismatch=&quot;accept&quot;/&gt;
            &lt;/Filters&gt;
 
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt;
            &lt;/Policies&gt;
        &lt;/RollingRandomAccessFile&gt;
    &lt;/Appenders&gt;
    
    &lt;!-- 用来配置Logger，包含一个root和若干个logger --&gt;
    &lt;!-- additivity指定是否同时输出当前logger的父类的日志，缺省为true --&gt;
    &lt;!-- 一个logger可以绑定多个不同的Appender。只有定义了logger并通过AppenderRef引入appender，该appender才会生效 --&gt;
    &lt;!-- &lt;logger&gt;可以不配置&lt;AppenderRef&gt;，这样可以控制指定的包在控制台的日志打印，而无需考虑日志文件的存储问题 --&gt;
    &lt;!--     （等效于在application.properties文件配置logging.level.xxx=LEVEL，xxx代指包名，如org.apache.kafka，LEVEL代指日志基本，如error等） --&gt;
    &lt;!--     （例如要屏蔽org.apache.kafka包下的所用日志打印，则可以这样写logging.level.org.apache.kafka=off） --&gt;
    &lt;Loggers&gt;
        &lt;!-- Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 --&gt;
        &lt;!-- additivity：这个属性的意思是需不需要打印此logger继承的父logger，默认为true，如果是false则只打印当前logger；如果是true则继续打印上一层的logger，直到root --&gt;
        &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- 屏蔽kafka的日志打印 --&gt;
        &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;off&quot;&gt;&lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.config&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;logger name=&quot;com.tgyjava.springbootdemo.log4j2.web&quot; level=&quot;debug&quot; additivity=&quot;true&quot;&gt;
            &lt;!-- &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;warnLog&quot;/&gt;
            &lt;AppenderRef ref=&quot;errorLog&quot;/&gt; --&gt;
            &lt;AppenderRef ref=&quot;testLog&quot;/&gt;
        &lt;/logger&gt;
 
        &lt;!-- Root节点用来指定项目的根日志，如果没有类似上面所配置的单独指定的logger，那么就会默认使用该Root日志输出 --&gt;
        &lt;!-- &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt; --&gt;
        &lt;Root level=&quot;ALL&quot; includeLocation=&quot;true&quot;&gt;
            &lt;!-- 用来指定该日志输出到哪个Appender --&gt;
            &lt;AppenderRef ref=&quot;Console&quot;/&gt;
        &lt;/Root&gt;
 
        &lt;!-- AsyncRoot - 异步记录日志 - 需要LMAXDisruptor的支持 --&gt;
        &lt;!--
        &lt;AsyncRoot level=&quot;info&quot; additivity=&quot;false&quot;&gt;
          &lt;AppenderRef ref=&quot;Console&quot;/&gt;
          &lt;AppenderRef ref=&quot;infoLog&quot;/&gt;
          &lt;AppenderRef ref=&quot;errorLog&quot;/&gt;
        &lt;/AsyncRoot&gt;
        --&gt;
    &lt;/Loggers&gt;
 
&lt;/configuration&gt;
</code></pre>
<p>参数说明</p>
<pre><code>    ********************************************************************************************************************
    参数        说明                                         举例                    输出显示媒介
    ********************************************************************************************************************
    %c          列出logger名字空间的全称，如果加上&#123;&lt;层数&gt;&#125;，   假设当前logger的命名空间是&quot;a.b.c&quot;
                则表示列出从最内层算起的指定层数的名字空间
                                                            %c                  a.b.c
                                                            %c&#123;2&#125;               b.c
                                                            %20c                （若名字空间长度小于20，则左边用空格填充）
                                                            %-20c               （若名字空间长度小于20，则右边用空格填充）
                                                            %.30c               （若名字空间长度超过30，截去多余字符）
                                                            %20.30c             （若名字空间长度小于20，则左边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
                                                            %-20.30c            （若名字空间长度小于20，则右边用空格填充；
                                                                                    若名字空间长度超过30，截去多余字符）
    ********************************************************************************************************************
    %C          列出调用logger的类的全名（包含包路径）         假设当前类是&quot;org.apache.xyz.SomeClass&quot;
                                                            %C                  org.apache.xyz.SomeClass
                                                            %C&#123;1&#125;               SomeClass
    %class
    ********************************************************************************************************************
    %d          显示日志记录时间，&#123;&lt;日期格式&gt;&#125;使用ISO8601定义的日期格式
                                                            %d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;     2005/10/12 22:23:30,117
                                                            %d&#123;ABSOLUTE&#125;        22:23:30,117
                                                            %d&#123;DATE&#125;            12 Oct 2005 22:23:30,117
                                                            %d&#123;ISO8601&#125;         2005-10-12 22:23:30,117
    ********************************************************************************************************************
    %F          显示调用logger的源文件名                     %F                   MyClass.java
    ********************************************************************************************************************
    %l          显示日志事件的发生位置，包含包路径、方法名、
                源文件名，以及在代码中的行数                  %l                   com.a.b.MyClass.main(MyClass.java:168)
    ********************************************************************************************************************
    %L          显示调用logger的代码行                       %L                   129
    %line                                                  %line                129
    ********************************************************************************************************************
    %level      显示该条日志的优先级                         %level               INFO
    %p                                                     %p                   INFO
    ********************************************************************************************************************
    %m          显示输出消息                                 %m                  This is a message for debug.
    %message                                                %message            This is a message for debug.
    ********************************************************************************************************************
    %M          显示调用logger的方法名                       %M                   main
    ********************************************************************************************************************
    %n          当前平台下的换行符                           %n                   Windows平台下表示rn，UNIX平台下表示n
    ********************************************************************************************************************
    %p          显示该条日志的优先级                         %p                   INFO
    %level                                                 %level               INFO
    ********************************************************************************************************************
    %r          显示从程序启动时到记录该条日志时已经经过的毫秒数  %r                 1215
    ********************************************************************************************************************
    %t          输出产生该日志事件的线程名                    %t                   http-nio-8080-exec-10
    %thread                                                 %thread              http-nio-8080-exec-10
    ********************************************************************************************************************
    %x          按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志           假设某程序调用顺序是MyApp调用com.foo.Bar
                                                            %c %x - %m%n        MyApp - Call com.foo.Bar.
                                                                                com.foo.Bar - Log in Bar
                                                                                MyApp - Return to MyApp.
    ********************************************************************************************************************
    %X          按MDC（Mapped Diagnostic Context，线程映射表）
                输出日志。通常用于多个客户端连接同一台服务器，
                方便服务器区分是那个客户端访问留下来的日志。     %X&#123;5&#125;             （记录代号为5的客户端的日志）
    ********************************************************************************************************************
    %%          显示一个百分号                               %%                  %
    ********************************************************************************************************************
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#00bcd4>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Sping整合Log4j/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/">
        <h2>
            Spring中Bean作用域
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><h2 id="一、Spring生命周期流程图"><a href="#一、Spring生命周期流程图" class="headerlink" title="一、Spring生命周期流程图"></a>一、Spring生命周期流程图</h2><p>下图描述的是从Spring容器初始化Bean开始直到Spring容器销毁Bean，所经历的关键节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20211208133748318.png" alt="file"></p>
<p>​        从上图可以看出，Spring Bean的生命周期管理的基本思路是：在Bean出现之前，先准备操作Bean的BeanFactory，然后操作完Bean，所有的Bean也还会交给BeanFactory进行管理。在所有Bean操作准备BeanPostProcessor作为回调。在Bean的完整生命周期管理过程中，经历了以下主要几个步骤：</p>
<h3 id="1-1-Bean创建前的准备阶段"><a href="#1-1-Bean创建前的准备阶段" class="headerlink" title="1.1 Bean创建前的准备阶段"></a>1.1 Bean创建前的准备阶段</h3><ul>
<li>步骤1： Bean容器在配置文件中找到Spring Bean的定义以及相关的配置，如init-method和destroy-method指定的方法。</li>
<li>步骤2： 实例化回调相关的后置处理器如BeanFactoryPostProcessor、BeanPostProcessor、InstantiationAwareBeanPostProcessor等</li>
</ul>
<h3 id="1-2-创建Bean的实例"><a href="#1-2-创建Bean的实例" class="headerlink" title="1.2 创建Bean的实例"></a>1.2 创建Bean的实例</h3><ul>
<li>步骤3： Srping 容器使用Java反射API创建Bean的实例。</li>
<li>步骤4：扫描Bean声明的属性并解析。</li>
</ul>
<h3 id="1-3-开始依赖注入"><a href="#1-3-开始依赖注入" class="headerlink" title="1.3 开始依赖注入"></a>1.3 开始依赖注入</h3><ul>
<li>步骤5：开始依赖注入，解析所有需要赋值的属性并赋值。</li>
<li>步骤6：如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。</li>
<li>步骤7：如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。</li>
<li>步骤8：如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。</li>
<li>步骤9：如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。</li>
</ul>
<h3 id="1-4-缓存到Spring容器"><a href="#1-4-缓存到Spring容器" class="headerlink" title="1.4 缓存到Spring容器"></a>1.4 缓存到Spring容器</h3><ul>
<li>步骤10： 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。</li>
<li>步骤11：如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。</li>
</ul>
<h3 id="1-5-销毁Bean的实例"><a href="#1-5-销毁Bean的实例" class="headerlink" title="1.5 销毁Bean的实例"></a>1.5 销毁Bean的实例</h3><ul>
<li>步骤12：如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。</li>
<li>步骤13：如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。</li>
</ul>
<h2 id="二、Bean的作用域"><a href="#二、Bean的作用域" class="headerlink" title="二、Bean的作用域"></a>二、Bean的作用域</h2><p>​        创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方”。把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域，分别阐述如下表。</p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton">singleton</a></td>
<td>默认的。一个bean定义，在一个IoC容器内只会产生一个对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype">prototype</a></td>
<td>一个bean定义会产生多个对象实例</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-request">request</a></td>
<td>一个bean定义产生的bean生命周期为一个HTTP请求；也就是，每一个HTTP请求都会根据bean定义产生一个对象实例。该作用域只有在Spring web ApplicationContext 上下文环境中才有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-session">session</a></td>
<td>产生的bean生命周期在HTTP 会话期间。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#beans-factory-scopes-application">application</a></td>
<td>将单个bean定义范围限定为ServletContext的生命周期。 该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope">websocket</a></td>
<td>将单个bean定义范围限定为WebSocket的生命周期。该作用域只有在Spring web ApplicationContext 上下文环境中才有效</td>
</tr>
</tbody></table>
<p>　    五种作用域中，request、session和global session三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<p>　　(1)当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>　　(2)当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
&lt;!--或者--&gt;
&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 
</code></pre>
<p>　　(3)当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>　　针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<p>　　(4)当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>　　针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<p>　　(5)当一个bean的作用域为Global Session，表示在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>　　global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p>
<h3 id="2-1-Spring中request请求作用域是什么？"><a href="#2-1-Spring中request请求作用域是什么？" class="headerlink" title="2.1 Spring中request请求作用域是什么？"></a>2.1 Spring中request请求作用域是什么？</h3><p>每个请求初始化具有此作用域的Bean注解。这听起来像是原型作用域的描述，但它们有一些差异。第一个区别是原型作用域在Spring的上下文中可用。而请求作用域仅适用于Web应用程序。第二个是原型bean根据需求进行初始化，而请求bean是在每个请求下构建的。需要说的是，request作用域bean在其作用域内有且仅有一个实例。而你可以拥有一个或多个原型作用域bean实例。</p>
<p>在以下代码中，你可以看到请求作用域bean的示例：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartRequest&quot; scope=&quot;request&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>当使用注解驱动组件或Java Config时，<code>@RequestScope</code>注解可以用于将一个组件分配给<code>request</code>作用域。</p>
<pre><code class="java">@RequestScope
@Component
public class ShoppingCartRequest &#123;
    // ...
&#125;
// request bean

// injection sample
@Controller
public class TestController &#123;
    @Autowired
    private ShoppingCartRequest shoppingCartRequest;

    @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)
    public String test(HttpServletRequest request) &#123;
        LOGGER.debug(&quot;shoppingCartRequest is :&quot;+shoppingCartRequest);
        // ...
    &#125;
&#125;
</code></pre>
<p>请注意<strong>定义内</strong>存在的**&lt;aop: scoped-proxy /&gt;**标签。这代表着使用代理对象。所以实际上，TestController持有的是代理对象的引用。我们所有的调用该对象都会转发到真正的<code>ShoppingCartRequest</code>对象。</p>
<p>有时我们需要使用<code>DispatcherServlet</code>的另一个<code>servlet</code>来处理请求。在这种情况下，我们必须确保Spring中所有请求都可用(否则可以抛出与下面类似的异常)。为此，我们需要在<code>web.xml</code>中定义一个监听器:</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>调用/测试URL后，你应该能在日志中的发现以下信息:</p>
<pre><code class="java">shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@2586b11c
shoppingCartRequest is :com.migo.scope.ShoppingCartRequest@3bd5b945
</code></pre>
<p>如果我们尝试在单例bean中使用request作用域的bean，则会在应用程序上下文加载阶段抛出一个<code>BeanCreationException</code>:</p>
<pre><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;testController&#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:700)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:381)
    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293)
    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)
    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4701)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5204)
    at org.apache.catalina.core.StandardContext$1.call(StandardContext.java:5199)
    at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source)
    at java.util.concurrent.FutureTask.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)
Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.migo.scope.ShoppingCartRequest com.migo.controller.TestController.shoppingCartRequest; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289)
    ... 21 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shoppingCartRequest&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1014)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:957)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480)
    ... 23 more
Caused by: java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet/DispatcherPortlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.
    at org.springframework.web.context.request.RequestContextHolder.currentRequestAttributes(RequestContextHolder.java:131)
    at org.springframework.web.context.request.AbstractRequestAttributesScope.get(AbstractRequestAttributesScope.java:41)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338)
    ... 28 more
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="2-2-什么是Spring的Session作用域？"><a href="#2-2-什么是Spring的Session作用域？" class="headerlink" title="2.2 什么是Spring的Session作用域？"></a>2.2 什么是Spring的Session作用域？</h3><p>Session作用域的bean与request 作用域的bean没有太大的不同。它们也与纯Web应用程序上下文相关联。注解为Session作用域的Bean对于每个用户的会话仅创建一次。他们在会话结束时被破坏销毁掉。</p>
<p>由Session作用域限制的Bean可以被认为是面向Web的单例，因为给定环境(用户会话)仅存在一个实例。但请记住，你无法在Web应用程序上下文中使用它们(说个好理解点的，就是一个函数内部自定义变量所在的作用域，函数执行完就销毁了，没有什么逃逸，关于此处更深入的理解请看我的博文<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2016/11/08/%E7%94%B1%E5%9F%9F%E8%81%94%E7%B3%BB%E5%88%B0%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">由域联系到的逃逸分析</a>)。</p>
<p>想知道Session作用域bean在Spring中的操作，我们需要在配置文件中定义一个bean:</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCartRequest&quot; class=&quot;com.migo.scope.ShoppingCartSession&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;
</code></pre>
<p>通过<code>@Autowired</code>注解，查找这个bean的方式与request 作用域的bean相同。可以看到以下结果:</p>
<pre><code class="java">shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@3876e5d
shoppingCartSession is :com.migo.scope.ShoppingCartSession@2f87fafc
</code></pre>
<p>你可以看到，前5个打印输出代表相同的对象。最后一个是不同的。这是什么意思 ?简单来说，这代表 着一个新的用户使用自动注入的Session作用域访问该页面。我们可以通过打开两个浏览器的测试页(/test)来观察它。每个都将初始化一个新的会话Session，因此也就创建新的<code>ShoppingCartSession bean</code>实例。</p>
<p>关于全局会话作用域(Global session scope)属于4.3x的范畴了，Spring5已经没有了，Spring5文档是去掉了因为4的存在所以还是说两句，它保留给portlet应用程序。 是不是一脸懵逼，so，来解释一下portlet是什么。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与servlet不同，每个portlet都有不同的会话。在这种情况下，Spring提供了一个名为<code>global-session</code>的作用域。通过它，一个bean可以通过应用程序中的多个portlet共享。</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;globalSession&quot;/&gt;
</code></pre>
<p>至此，我们解释了请求和面向会话的作用域。第一个的作用是在每个request请求上创建新的bean。第二个在Session会话开始的时候初始化bean。</p>
<h2 id="三、Bean的生命周期"><a href="#三、Bean的生命周期" class="headerlink" title="三、Bean的生命周期"></a>三、Bean的生命周期</h2><p>　Spring中Bean的实例化过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210510144229675.png" alt="img"></p>
<p>Bean的生命周期：</p>
<p><img src="https://img-blog.csdnimg.cn/2021051014425161.png" alt="img"></p>
<p>Bean实例生命周期的执行过程如下：</p>
<ul>
<li>Spring对bean进行实例化，默认bean是单例；</li>
<li>Spring对bean进行依赖注入；</li>
<li>如果bean实现了BeanNameAware接口，Spring将bean的名称传给setBeanName()方法；</li>
<li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory实例传进来；</li>
<li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization()方法将被调用；</li>
<li>如果bean中有方法添加了@PostConstruct注解，那么该方法将被调用；</li>
<li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li>
<li>如果在xml文件中通过<bean>标签的init-method元素指定了初始化方法，那么该方法将被调用；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization()接口方法将被调用；</li>
<li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>
<li>如果bean中有方法添加了@PreDestroy注解，那么该方法将被调用；</li>
<li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ul>
<p>　　这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。</p>
<p>　　其实很多时候我们并不会真的去实现上面所描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<h3 id="3-1-单例管理的对象"><a href="#3-1-单例管理的对象" class="headerlink" title="3.1 单例管理的对象"></a>3.1 单例管理的对象</h3><p>　　当scope=”singleton”，即默认情况下，会在启动容器时（即实例化容器时）时实例化。但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。如下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;serviceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p>
<pre><code class="xml">&lt;beans default-lazy-init=&quot;true&quot;&gt;
</code></pre>
<p>　　默认情况下，Spring在读取xml文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用init-method属性值中所指定的方法。对象在被销毁的时候，会调用destroy-method属性值中所指定的方法（例如调用Container.destroy()方法的时候）。写一个测试类，代码如下：</p>
<pre><code class="java">public class LifeBean &#123;
    private String name;  
    
    public LifeBean()&#123;  
        System.out.println(&quot;LifeBean()构造函数&quot;);  
    &#125;  
    public String getName() &#123;  
        return name;  
    &#125;  
  
    public void setName(String name) &#123;  
        System.out.println(&quot;setName()&quot;);  
        this.name = name;  
    &#125;  

    public void init()&#123;  
        System.out.println(&quot;this is init of lifeBean&quot;);  
    &#125;  
      
    public void destory()&#123;  
        System.out.println(&quot;this is destory of lifeBean &quot; + this);  
    &#125;  
&#125;
</code></pre>
<p>　　life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_singleton&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;singleton&quot; 
            init-method=&quot;init&quot; destroy-method=&quot;destory&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<p>　　测试代码如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = 
        new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life&quot;);
        System.out.println(life1);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<h3 id="2-2-非单例管理的对象"><a href="#2-2-非单例管理的对象" class="headerlink" title="2.2 非单例管理的对象"></a>2.2 非单例管理的对象</h3><p>　　当scope=”prototype”时，容器也会延迟初始化bean，Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。在第一次请求每一个prototype的bean时，Spring容器都会调用其构造器创建这个对象，然后调用init-method属性值中所指定的方法。对象销毁的时候，Spring容器不会帮我们调用任何方法，因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<p>　　为了测试prototype bean的生命周期life.xml配置如下：</p>
<pre><code class="xml">&lt;bean id=&quot;life_prototype&quot; class=&quot;com.bean.LifeBean&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;
</code></pre>
<p>　　测试程序如下：</p>
<pre><code class="java">public class LifeTest &#123;
    @Test 
    public void test() &#123;
        AbstractApplicationContext container = new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        LifeBean life1 = (LifeBean)container.getBean(&quot;life_singleton&quot;);
        System.out.println(life1);
        
        LifeBean life3 = (LifeBean)container.getBean(&quot;life_prototype&quot;);
        System.out.println(life3);
        container.close();
    &#125;
&#125;
</code></pre>
<p>　　运行结果如下：　</p>
<pre><code class="java">LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@573f2bb1
LifeBean()构造函数
this is init of lifeBean
com.bean.LifeBean@5ae9a829
……
this is destory of lifeBean com.bean.LifeBean@573f2bb1
</code></pre>
<p>　　可以发现，对于作用域为prototype的bean，其destroy方法并没有被调用。如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>　　Spring容器可以管理singleton作用域下bean的生命周期，在此作用域下，Spring能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的bean，Spring只负责创建，当容器创建了bean的实例后，bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<h3 id="2-3-引申"><a href="#2-3-引申" class="headerlink" title="2.3 引申"></a>2.3 引申</h3><p>　　在学习Spring IoC过程中发现，每次产生ApplicationContext工厂的方式是：</p>
<pre><code class="java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
<p>　　这样产生ApplicationContext就有一个弊端，每次访问加载bean的时候都会产生这个工厂，所以这里需要解决这个问题。</p>
<p>　　ApplicationContext是一个接口，它继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持。</p>
<p>　　解决问题的方法很简单，在web容器启动的时候将ApplicationContext转移到ServletContext中，因为在web应用中所有的Servlet都共享一个ServletContext对象。那么我们就可以利用ServletContextListener去监听ServletContext事件，当web应用启动的是时候，我们就将ApplicationContext装载到ServletContext中。 Spring容器底层已经为我们想到了这一点，在spring-web-xxx-release.jar包中有一个已经实现了ServletContextListener接口的类ContextLoader，其源码如下：</p>
<pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;
    private ContextLoader contextLoader;

    public ContextLoaderListener() &#123;

    &#125;

    public ContextLoaderListener(WebApplicationContext context) &#123;
        super(context);
    &#125;

    public void contextInitialized(ServletContextEvent event) &#123;
        this.contextLoader = createContextLoader();
        if (this.contextLoader == null) &#123;
            this.contextLoader = this;
        &#125;
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    &#125;

    @Deprecated
    protected ContextLoader createContextLoader() &#123;
        return null;
    &#125;

    @Deprecated
    public ContextLoader getContextLoader() &#123;
        return this.contextLoader;
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        if (this.contextLoader != null) &#123;
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
        &#125;
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    &#125;
&#125;
</code></pre>
<p>　　这里就监听到了servletContext的创建过程, 那么 这个类又是如何将applicationContext装入到serveletContext容器中的呢?</p>
<p>　　this.contextLoader.initWebApplicationContext(event.getServletContext())方法的具体实现中：</p>
<pre><code class="java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;
     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;
         throw new IllegalStateException(
                 &quot;Cannot initialize context because there is already a root application context present - &quot; +
                 &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
     &#125;

     Log logger = LogFactory.getLog(ContextLoader.class);
     servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
     if (logger.isInfoEnabled()) &#123;
         logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
     &#125;
     long startTime = System.currentTimeMillis();

     try &#123;
           // Store context in local instance variable, to guarantee that
          // it is available on ServletContext shutdown.
         if (this.context == null) &#123;
             this.context = createWebApplicationContext(servletContext);
         &#125;
         if (this.context instanceof ConfigurableWebApplicationContext) &#123;
             ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
             if (!cwac.isActive()) &#123;
                 // The context has not yet been refreshed -&gt; provide services such as
                 // setting the parent context, setting the application context id, etc
                 if (cwac.getParent() == null) &#123;
                     // The context instance was injected without an explicit parent -&gt;
                     // determine parent for root web application context, if any.
                     ApplicationContext parent = loadParentContext(servletContext);
                     cwac.setParent(parent);
                 &#125;
                 configureAndRefreshWebApplicationContext(cwac, servletContext);
             &#125;
         &#125;
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

         ClassLoader ccl = Thread.currentThread().getContextClassLoader();
         if (ccl == ContextLoader.class.getClassLoader()) &#123;
             currentContext = this.context;
         &#125;
         else if (ccl != null) &#123;
             currentContextPerThread.put(ccl, this.context);
         &#125;

         if (logger.isDebugEnabled()) &#123;
             logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
                     WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
         &#125;
         if (logger.isInfoEnabled()) &#123;
             long elapsedTime = System.currentTimeMillis() - startTime;
             logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
         &#125;

         return this.context;
     &#125;
     catch (RuntimeException ex) &#123;
         logger.error(&quot;Context initialization failed&quot;, ex);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
         throw ex;
     &#125;
     catch (Error err) &#123;
         logger.error(&quot;Context initialization failed&quot;, err);
         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
         throw err;
     &#125;
 &#125;
</code></pre>
<p>　　这里的重点是servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)，用key:WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE value: this.context的形式将applicationContext装载到servletContext中了。另外从上面的一些注释我们可以看出： WEB-INF/applicationContext.xml， 如果我们项目中的配置文件不是这么一个路径的话 那么我们使用ContextLoaderListener 就会出问题, 所以我们还需要在web.xml中配置我们的applicationContext.xml配置文件的路径。</p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>　　剩下的就是在项目中开始使用 servletContext中装载的applicationContext对象了： 那么这里又有一个问题，装载时的key是 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们在代码中真的要使用这个吗? 其实Spring为我们提供了一个工具类WebApplicationContextUtils，接着我们先看下如何使用，然后再去看下这个工具类的源码：</p>
<pre><code class="java">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());
</code></pre>
<p>　　接着来看下这个工具类的源码：</p>
<pre><code class="java">public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;
    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
&#125;
</code></pre>
<p>　　这里就能很直观清晰地看到 通过key值直接获取到装载到servletContext中的 applicationContext对象了。</p>
<p>　　ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，整个加载配置过程由ContextLoader来完成。</p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>​        理解spring中bean的生命周期，对于学习和使用spring很有帮助。本文将从两个角度对spring中bean的生命周期进行介绍，一是bean定义生成；二是bean在初始化、使用、销毁的生命周期中经历的阶段。</p>
<h3 id="4-2-bean定义生成"><a href="#4-2-bean定义生成" class="headerlink" title="4.2 bean定义生成"></a>4.2 bean定义生成</h3><p>​        bean定义生成主要分为三个步骤，即bean定义的获取、bean定义的注册。<br><strong>1、bean定义的获取</strong><br>​        bean的定义来源各种各样，如xml定义、java注解定义等。<br>​        spring对各种来源提供了统一的接口org.springframework.core.io.Resource，<br>​        Resource接口即也是对spring内的所有底层资源进行了抽象（如file、url、classpath）。<br>​        Resource接口相关的类结构图如下：<br><img src="https://img-blog.csdnimg.cn/20181114231111589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5hYmVzdGNoaW5h,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​        各类bean定义的加载请参数相应spring源码。<br><strong>2、bean定义的解析</strong><br>​        由于来源的不同，bean的解析也是各种各样的（如xml内标签的解析）。<br>​        spring对bean的定义仍然有公共的接口org.springframework.beans.factory.config.BeanDefinition。<br>​        具体解析请查看spring源码。<br><strong>3、bean的注册</strong><br>​        解析得到的bean，最终会注册到容器中，其实也就是ConcurrentHashMap，<br>​        即org.springframework.beans.factory.support.DefaultListableBeanFactory类中的实例变量</p>
<pre><code class="java">/** Map of bean definition objects, keyed by bean name */
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<p>​        此bean的加载完成</p>
<h3 id="4-3-spring的生命周期"><a href="#4-3-spring的生命周期" class="headerlink" title="4.3 spring的生命周期"></a>4.3 spring的生命周期</h3><p>​        spring生命周期中的阶段，包括初始化、使用、销毁。<br><strong>1、初始化阶段</strong><br>​        1）调用bean的构造函数，创建实例；<br>​        2）进行参数依赖注入；<br>​        3）若实现org.springframework.beans.BeanNameAware接口，则调用BeanNameAware的setBeanName()方法;<br>​        4）若实现org.springframework.beans.factory.BeanClassLoaderAware接口，则调用BeanClassLoaderAware的setBeanClassLoader()方法;<br>​        5）若实现org.springframework.context.ApplicationContextAware接口，则调用ApplicationContextAware的setApplicationContext()方法;<br>​        6）若使用了注解@PostConstruct，则调相应方法；<br>​        7）若实现org.springframework.beans.factory.InitializingBean接口，则调用InitializingBean接口的afterPropertiesSet方法;<br>​        8）若bean定义的使用了initMethod，则调相应方法；<br>​        9）若实现org.springframework.beans.factory.config.BeanPostProcessor接口，则调用BeanPostProcessor的postProcessBeforeInitialization()方法和postProcessAfterInitialization方法;<br><strong>2、使用阶段</strong><br>​        1）bean在项目的使用；<br><strong>3、销毁阶段</strong><br>​        1）若使用注解@PreDestroy，则调用相应方法；<br>​        2）若bean定义中配置了destroyMethod，则调用相应方法；<br>​        3）若实现org.springframework.beans.factory.DisposableBean接口，则调用DisposableBean接口的destroy方法; </p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>综合前面的代码和分析，现在我们用大白话描述下：</p>
<ol>
<li>Bean容器找到Spring配置文件中Bean的定义；</li>
<li>Bean容器利用java 反射机制实例化Bean；</li>
<li>Bean容器为实例化的Bean设置属性值；</li>
<li>如果Bean实现了BeanNameAware接口，则执行setBeanName方法；</li>
<li>如果Bean实现了BeanClassLoaderAware接口，则执行setBeanClassLoader方法；</li>
<li>如果Bean实现了BeanFactoryAware接口，则执行setBeanFactory方法；</li>
<li>如果 ……真的，到这我经常忘记，但前面三个Aware接口肯定能记住；</li>
<li>如果Bean实现了ApplicationContextAware接口，则执行setApplicationContext方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessBeforeInitialization方法；</li>
<li>如果Bean定义初始化方法（PostConstruct注解、配置init-method、实现了InitializingBean接口），则执行定义的初始化方法；</li>
<li>如果加载了BeanPostProcessor相关实现类，则执行postProcessAfterInitialization方法；</li>
<li>当要销毁这个Bean时，如果自定义了销毁方法（PreDestroy注解、配置destroy-method、实现了DisposableBean接口），则执行定义的销毁方法。</li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#00bcd4>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring中Bean的作用域/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/">
        <h2>
            Spring使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring使用详解"><a href="#Spring使用详解" class="headerlink" title="Spring使用详解"></a>Spring使用详解</h1><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><h3 id="1-1、Spring组成"><a href="#1-1、Spring组成" class="headerlink" title="1.1、Spring组成"></a>1.1、Spring组成</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF6KnNia5YDhfatibrMvAUAhxgF27g4HdJsBGl6Fae9yQlUQJc9Bf8uftw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFetRkkw19r7H3mHDibgs4RpRNHdG6CcIMdnxRCu2yYXNiano7ESCCMF0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <strong>BeanFactory</strong>，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式<strong>将应用程序的配置和依赖性规范与实际的应用程序代码分开</strong>。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架<strong>提供上下文信息</strong>。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象<strong>提供事务管理服务</strong>。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来<strong>管理异常处理和不同数据库供应商抛出的错误消息</strong>。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h3 id="1-2、拓展"><a href="#1-2、拓展" class="headerlink" title="1.2、拓展"></a>1.2、拓展</h3><p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li>
<li>Spring Cloud是基于Spring Boot实现的；</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
<li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFH5GFXM4YPUGrmA2JdpPic3FwYaI1JZHBZxibaUJVXWzzTFeCayk4XAIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="二、IOC讲解"><a href="#二、IOC讲解" class="headerlink" title="二、IOC讲解"></a>二、IOC讲解</h2><h3 id="2-1、IOC基础"><a href="#2-1、IOC基础" class="headerlink" title="2.1、IOC基础"></a>2.1、IOC基础</h3><p>新建一个空白的maven项目</p>
<blockquote>
<p>分析实现</p>
</blockquote>
<p>我们先用我们原来的方式写一段代码。</p>
<p>1、UserDao接口</p>
<pre><code class="java">public interface UserDao &#123;
    public void getUser();
&#125;
</code></pre>
<p>2、Dao的实现类</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>3、UserService接口</p>
<pre><code class="java">public interface UserService &#123;
    public void getUser();
&#125;
</code></pre>
<p>4、Service实现类</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>5、测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
    UserService service = new UserServiceImpl();
    service.getUser();
&#125;
</code></pre>
<blockquote>
<p>=========================接下来做一下修改=================================</p>
</blockquote>
<p>增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoMySqlImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;MySql获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao = new UserDaoMySqlImpl();

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>假设再增加一个Userdao的实现类</p>
<pre><code class="java">public class UserDaoOracleImpl implements UserDao &#123;
    @Override
    public void getUser() &#123;
        System.out.println(&quot;Oracle获取用户数据&quot;);
    &#125;
&#125;
</code></pre>
<p>​        那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现。假设我们的这种需求非常大 , 这种方式就根本不适用。这种设计的耦合性太高了, 牵一发而动全身。</p>
<p><strong>那我们如何去解决呢 ?</strong> </p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    
    // 利用set实现
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    @Override
    public void getUser() &#123;
        userDao.getUser();
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void test()&#123;
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
&#125;
</code></pre>
<p>​        这两者有着本质区别：以前的思路都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者。程序不用去管怎么创建,怎么实现了。 它只负责提供一个接口。</p>
<p>​        这种思想 , 从本质上解决了问题 , 程序员不再去管理对象的创建 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="2-2、IOC本质"><a href="#2-2、IOC本质" class="headerlink" title="2.2、IOC本质"></a>2.2、IOC本质</h3><p>​        <strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFuYibmavlBHq9e4cDqiclpYSG8VT4EicVsnqKp65yJKQeNibsVdTiahQibJSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        <strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>​        <u>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</u></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p>​        <strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="三、HelloSpring"><a href="#三、HelloSpring" class="headerlink" title="三、HelloSpring"></a>三、HelloSpring</h2><h3 id="3-1、helloSpring的创建"><a href="#3-1、helloSpring的创建" class="headerlink" title="3.1、helloSpring的创建"></a>3.1、helloSpring的创建</h3><blockquote>
<p>导入jar包依赖</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 但是利用maven会自动下载对应的依赖项。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="java">@Data
public class Hello &#123;
   private String name;

   public void show()&#123;
       System.out.println(&quot;Hello,&quot;+ name );
  &#125;
&#125;
</code></pre>
<p>2、编写spring的文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>其中，bean标签各个参数解释如下：</p>
<ul>
<li><strong>id：</strong>JavaBean在BeanFactory中唯一标识，代码中通过BeanFactory获取JavaBean实例时需要此参数作为索引名称</li>
<li>name：可以为Bean指定多个名称（起别名）</li>
<li><strong>class：</strong>JavaBean 类名</li>
<li><strong>scope：</strong>设定Bean的作用域<ul>
<li><strong>singleton</strong>：指定此Java Bean是否使用单例模式，如果设为“True”，则在BeanFactory作用范围内只维护此Java Bean的一个实例，代码通BeanFactory获取此javaBean实例的引用;反这如果设为“False”，则通过BeanFactory获取javaBean实例时，BeanFactory每次都将创建一个新的实例返回。</li>
<li><strong>Prototype：</strong>原型：表示通过IoC容器获取的Bean是不同的</li>
<li><strong>request：</strong>请求：表示在一次HTTP请求内有效</li>
<li><strong>session：</strong>会话：表示在一个用户会话内有效</li>
</ul>
</li>
<li><strong>init-method：</strong>初始化方法，此方法将在BeanFactory创建JavaBean实例之后，在向应用层返回引用之前执行。一般用于一些资源的初始化工作。</li>
<li>销毁方法：此方法将在BeanFactory销毁的时候执行，一般用于资源释放。</li>
<li><strong>depends-on：</strong>Bean依赖关系。一般情况下无需设定。Spring会根据情况组织各个依赖关系的构建工作（这里<br>示例中的depends-on属性非必须）。只有某些特殊情况下，如JavaBean中的某些静态变量需要进行初始化（这是一种Bad Smell，应该在设计上应该避免）。通过depends-on指定其依赖关系可保证在此Bean加载之前，首先对depends-on所指定的资源进行加载。</li>
<li><strong>value：</strong>通过<value/>节点可指定属性值。BeanFactory将自动根据Java Bean对应的属性类型加以匹配。注意<value></value>代表一个空字符串，如果需要将属性值设定为null，必须使用<null/>节点。</li>
<li><strong>ref：</strong>指定了属性对BeanFactory中其他Bean的引用关系。</li>
<li><strong>property：</strong>Bean的子元素，用来指定需要赋值的属性</li>
<li><strong>constructor-arg：</strong>用于有参构造的注入<ul>
<li>index：指定下标</li>
<li>value：赋值</li>
<li>type：参数类型</li>
<li>ref：将注入别的Bean</li>
</ul>
</li>
<li><strong>import：</strong>用于导入别的XML文件</li>
</ul>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   // 解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   // getBean : 参数即为spring配置文件中bean的id .
   Hello hello = (Hello) context.getBean(&quot;hello&quot;);
   // 调用对象hello的show方法
   hello.show();
&#125;
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  <ul>
<li>hello 对象是由Spring创建的</li>
</ul>
</li>
<li>Hello 对象的属性是怎么设置的 ?  <ul>
<li>hello 对象的属性是由Spring容器设置的</li>
</ul>
</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p><strong>依赖注入 :</strong> 就是利用set方法来进行注入的.</p>
<p>​         IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>​        可以通过newClassPathXmlApplicationContext去浏览一下底层源码 。</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>新增一个Spring配置文件beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
&#125;
</code></pre>
<p>​        OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p>
<h3 id="3-2、IOC创建对象方式"><a href="#3-2、IOC创建对象方式" class="headerlink" title="3.2、IOC创建对象方式"></a>3.2、IOC创建对象方式</h3><h4 id="3-2-1、通过无参构造方法创建"><a href="#3-2-1、通过无参构造方法创建" class="headerlink" title="3.2.1、通过无参构造方法创建"></a>3.2.1、通过无参构造方法创建</h4><p>1、User.java</p>
<pre><code class="java">public class User &#123;

    private String name;

    public User() &#123;
        System.out.println(&quot;user无参构造方法&quot;);
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
&#125;
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h4 id="3-2-2、通过有参构造方法创建"><a href="#3-2-2、通过有参构造方法创建" class="headerlink" title="3.2.2、通过有参构造方法创建"></a>3.2.2、通过有参构造方法创建</h4><p>1、UserT . java</p>
<pre><code class="java">public class UserT &#123;

    private String name;

    public UserT(String name) &#123;
        this.name = name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name );
    &#125;

&#125;
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- index指构造方法 , 下标从0开始 --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;!-- name指参数名 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testT()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    UserT user = (UserT) context.getBean(&quot;userT&quot;);
    user.show();
&#125;
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h3 id="3-3、Spring配置"><a href="#3-3、Spring配置" class="headerlink" title="3.3、Spring配置"></a>3.3、Spring配置</h3><h4 id="3-3-1、别名"><a href="#3-3-1、别名" class="headerlink" title="3.3.1、别名"></a>3.3.1、别名</h4><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h4 id="3-3-2、Bean的配置"><a href="#3-3-2、Bean的配置" class="headerlink" title="3.3.2、Bean的配置"></a>3.3.2、Bean的配置</h4><pre><code class="xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3-3-3、import"><a href="#3-3-3、import" class="headerlink" title="3.3.3、import"></a>3.3.3、import</h4><p>团队的合作通过import来实现 .</p>
<pre><code class="xml">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;
</code></pre>
<h2 id="四、依赖注入（DI）"><a href="#四、依赖注入（DI）" class="headerlink" title="四、依赖注入（DI）"></a>四、依赖注入（DI）</h2><h3 id="4-1、依赖注入"><a href="#4-1、依赖注入" class="headerlink" title="4.1、依赖注入"></a>4.1、依赖注入</h3><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p><strong>Address.java</strong></p>
<pre><code class="java"> public class Address &#123;
 
     private String address;
 
     public String getAddress() &#123;
         return address;
    &#125;
 
     public void setAddress(String address) &#123;
         this.address = address;
    &#125;
 &#125;
</code></pre>
<p><strong>Student.java</strong></p>
<pre><code class="java">@Data
public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbys;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;

    public void show()&#123;
        System.out.println(&quot;name=&quot;+ name
                           + &quot;,address=&quot;+ address.getAddress()
                           + &quot;,books=&quot;
                          );
        for (String book:books)&#123;
            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);
        &#125;
        System.out.println(&quot;\n爱好:&quot;+hobbys);

        System.out.println(&quot;card:&quot;+card);

        System.out.println(&quot;games:&quot;+games);

        System.out.println(&quot;wife:&quot;+wife);

        System.out.println(&quot;info:&quot;+info);

    &#125;
&#125;
</code></pre>
<h4 id="4-1-1、常量注入"><a href="#4-1-1、常量注入" class="headerlink" title="4.1.1、常量注入"></a>4.1.1、常量注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test01()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    Student student = (Student) context.getBean(&quot;student&quot;);

    System.out.println(student.getName());

&#125;
</code></pre>
<h4 id="4-1-2、Bean注入"><a href="#4-1-2、Bean注入" class="headerlink" title="4.1.2、Bean注入"></a>4.1.2、Bean注入</h4><p>注意点：这里的值是一个引用，ref</p>
<pre><code class="xml">&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-3、数组注入"><a href="#4-1-3、数组注入" class="headerlink" title="4.1.3、数组注入"></a>4.1.3、数组注入</h4><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;西游记&lt;/value&gt;
            &lt;value&gt;红楼梦&lt;/value&gt;
            &lt;value&gt;水浒传&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-1-4、List注入"><a href="#4-1-4、List注入" class="headerlink" title="4.1.4、List注入"></a>4.1.4、List注入</h4><pre><code class="xml">&lt;property name=&quot;hobbys&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;听歌&lt;/value&gt;
        &lt;value&gt;看电影&lt;/value&gt;
        &lt;value&gt;爬山&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-5、Map注入"><a href="#4-1-5、Map注入" class="headerlink" title="4.1.5、Map注入"></a>4.1.5、Map注入</h4><pre><code class="xml">&lt;property name=&quot;card&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt;
        &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-6、set注入"><a href="#4-1-6、set注入" class="headerlink" title="4.1.6、set注入"></a>4.1.6、set注入</h4><pre><code class="xml">&lt;property name=&quot;games&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;LOL&lt;/value&gt;
        &lt;value&gt;BOB&lt;/value&gt;
        &lt;value&gt;COC&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-7、Null注入"><a href="#4-1-7、Null注入" class="headerlink" title="4.1.7、Null注入"></a>4.1.7、Null注入</h4><pre><code class="xml">&lt;property name=&quot;wife&quot;&gt;
    &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<h4 id="4-1-9、Properties注入"><a href="#4-1-9、Properties注入" class="headerlink" title="4.1.9、Properties注入"></a>4.1.9、Properties注入</h4><pre><code class="xml">&lt;property name=&quot;info&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;
        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
<p>测试结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYGHEFnrCA8Jyr6ian5MWrUHtnKBpYYTTtysbp5UPYKQxSiaUHJibPKlicuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="4-1-10、p命名和c命名注入"><a href="#4-1-10、p命名和c命名注入" class="headerlink" title="4.1.10、p命名和c命名注入"></a>4.1.10、p命名和c命名注入</h4><p>User.java ：【注意：这里没有有参构造器！】</p>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>1、<strong>P命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;
</code></pre>
<p>2、<strong>c 命名空间注入 :</strong> 需要在头文件中加入约束文件</p>
<pre><code class="xml">&lt;!--导入约束 : --&gt;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;

&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;
</code></pre>
<p>​        发现问题：显示错误，代码标红</p>
<p>​        解决：把有参构造器加上，这里也能知道，c 就是所谓的<strong>构造器注入</strong>！</p>
<p>测试代码：</p>
<pre><code class="java">@Test
public void test02()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    System.out.println(user);
&#125;
</code></pre>
<h3 id="4-2、Bean的作用域"><a href="#4-2、Bean的作用域" class="headerlink" title="4.2、Bean的作用域"></a>4.2、Bean的作用域</h3><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYfmmAQF8hrnicY49FRXEkR5xkxD5A4H5pVUia3mFhrDdh4gBt183EiaFaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="4-2-1、Singleton"><a href="#4-2-1、Singleton" class="headerlink" title="4.2.1、Singleton"></a>4.2.1、Singleton</h4><p>​        <strong>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</strong>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="xml">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">@Test
public void test03()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    User user2 = (User) context.getBean(&quot;user&quot;);
    System.out.println(user==user2);
&#125;
</code></pre>
<h4 id="4-2-2、Prototype"><a href="#4-2-2、Prototype" class="headerlink" title="4.2.2、Prototype"></a>4.2.2、Prototype</h4><p>​        <strong>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。</strong>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="xml"> &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  
 或者
 &lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;
</code></pre>
<h4 id="4-2-3、Request"><a href="#4-2-3、Request" class="headerlink" title="4.2.3、Request"></a>4.2.3、Request</h4><p>​        <strong>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例</strong>；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>​        针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="4-2-4、Session"><a href="#4-2-4、Session" class="headerlink" title="4.2.4、Session"></a>4.2.4、Session</h4><p>​        <strong>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。</strong>该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="xml">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>​        针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<h2 id="五、自动装配"><a href="#五、自动装配" class="headerlink" title="五、自动装配"></a>五、自动装配</h2><h3 id="5-1、自动装配"><a href="#5-1、自动装配" class="headerlink" title="5.1、自动装配"></a>5.1、自动装配</h3><blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ul>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ul>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ul>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ul>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h4 id="5-1-1、测试环境搭建"><a href="#5-1-1、测试环境搭建" class="headerlink" title="5.1.1、测试环境搭建"></a>5.1.1、测试环境搭建</h4><p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="java">public class Cat &#123;
   public void shout() &#123;
       System.out.println(&quot;miao~&quot;);
  &#125;
&#125;
    
public class Dog &#123;
   public void shout() &#123;
       System.out.println(&quot;wang~&quot;);
  &#125;
&#125;
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="java">public class User &#123;
   private Cat cat;
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void testMethodAutowire() &#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  &#125;
&#125;
</code></pre>
<p>结果正常输出。</p>
<h4 id="5-1-2、byName"><a href="#5-1-2、byName" class="headerlink" title="5.1.2、byName"></a>5.1.2、byName</h4><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=”byName”</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<h4 id="5-1-3、byType"><a href="#5-1-3、byType" class="headerlink" title="5.1.3、byType"></a>5.1.3、byType</h4><p>​        <strong>autowire byType (按类型自动装配)</strong></p>
<p>​        使用autowire byType首先需要保证：<strong>同一类型的对象，在spring容器中唯一</strong>。如果不唯一，会报不唯一的异常。</p>
<pre><code class="xml">NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="5-2、使用注解"><a href="#5-2、使用注解" class="headerlink" title="5.2、使用注解"></a>5.2、使用注解</h3><blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;
</code></pre>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="java">public class User &#123;
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String str;

   public Cat getCat() &#123;
       return cat;
  &#125;
   public Dog getDog() &#123;
       return dog;
  &#125;
   public String getStr() &#123;
       return str;
  &#125;
&#125;
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【小狂神科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code class="java">//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;

@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p><strong>实体类</strong>：</p>
<pre><code class="java">public class User &#123;
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
&#125;
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="java">@Resource
private Cat cat;

@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<p><strong>小结</strong></p>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="六、使用注解开发"><a href="#六、使用注解开发" class="headerlink" title="六、使用注解开发"></a>六、使用注解开发</h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h3><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IzypAUHDfDEujP4ry6cHxWTvAS6qRS0qrmMCic3QqF9icGNcPj8IZwNo3R9VEgpAgWHrStBN1ya6Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="6-2、Bean的实现"><a href="#6-2、Bean的实现" class="headerlink" title="6.2、Bean的实现"></a>6.2、Bean的实现</h3><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   public String name = &quot;秦疆&quot;;
&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext applicationContext =
       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   User user = (User) applicationContext.getBean(&quot;user&quot;);
   System.out.println(user.name);
&#125;
</code></pre>
<h3 id="6-3、属性注入"><a href="#6-3、属性注入" class="headerlink" title="6.3、属性注入"></a>6.3、属性注入</h3><p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   @Value(&quot;秦疆&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   public String name;
&#125;
</code></pre>
<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<pre><code class="java">@Component(&quot;user&quot;)
public class User &#123;

   public String name;

   @Value(&quot;秦疆&quot;)
   public void setName(String name) &#123;
       this.name = name;
  &#125;
&#125;
</code></pre>
<h3 id="6-4、衍生注解"><a href="#6-4、衍生注解" class="headerlink" title="6.4、衍生注解"></a>6.4、衍生注解</h3><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User &#123;
   @Value(&quot;秦疆&quot;)
   public String name;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code>&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li><p>进行注解驱动注册，从而使注解生效</p>
</li>
<li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li><p>如果不扫描包，就需要手动配置bean</p>
</li>
<li><p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<h3 id="6-5、基于Java类进行配置"><a href="#6-5、基于Java类进行配置" class="headerlink" title="6.5、基于Java类进行配置"></a>6.5、基于Java类进行配置</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog &#123;
   public String name = &quot;dog&quot;;
&#125;
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig &#123;

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void test2()&#123;
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
&#125;
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="java">@Configuration  //代表这是一个配置类
public class MyConfig2 &#123;
&#125;
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="java">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig &#123;

   @Bean
   public Dog dog()&#123;
       return new Dog();
  &#125;

&#125;
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
<h2 id="七、静态-动态代理模式"><a href="#七、静态-动态代理模式" class="headerlink" title="七、静态/动态代理模式"></a>七、静态/动态代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p>
<p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>学习aop之前 , 我们要先了解一下代理模式！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLRnfS7LpO0Iic7fEEPFCgRs0ggNXCwf6IKo1tibjPmNSTEYeII5ro7YLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-1、静态代理"><a href="#7-1、静态代理" class="headerlink" title="7.1、静态代理"></a>7.1、静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li><p>抽象角色 : 一般使用接口或者抽象类来实现</p>
</li>
<li><p>真实角色 : 被代理的角色</p>
</li>
<li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p>
</li>
<li><p>客户  :  使用代理角色来进行一些操作 </p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>Proxy . java 即代理角色</p>
<pre><code class="java">//代理角色：中介
public class Proxy implements Rent &#123;

   private Host host;
   public Proxy() &#123; &#125;
   public Proxy(Host host) &#123;
       this.host = host;
  &#125;

   //租房
   public void rent()&#123;
       seeHouse();
       host.rent();
       fare();
  &#125;
   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;
&#125;
</code></pre>
<p>Client . java 即客户</p>
<pre><code class="java">//客户类，一般客户都会去找代理！
public class Client &#123;
   public static void main(String[] args) &#123;
       //房东要租房
       Host host = new Host();
       //中介帮助房东
       Proxy proxy = new Proxy(host);

       //你去找中介！
       proxy.rent();
  &#125;
&#125;
</code></pre>
<p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="7-2、静态代理再理解"><a href="#7-2、静态代理再理解" class="headerlink" title="7.2、静态代理再理解"></a>7.2、静态代理再理解</h3><p>练习步骤：</p>
<p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p>
<pre><code class="java">//抽象角色：增删改查业务
public interface UserService &#123;
   void add();
   void delete();
   void update();
   void query();
&#125;
</code></pre>
<p>2、我们需要一个真实对象来完成这些增删改查操作</p>
<pre><code class="java">//真实对象，完成增删改查操作的人
public class UserServiceImpl implements UserService &#123;

   public void add() &#123;
       System.out.println(&quot;增加了一个用户&quot;);
  &#125;

   public void delete() &#123;
       System.out.println(&quot;删除了一个用户&quot;);
  &#125;

   public void update() &#123;
       System.out.println(&quot;更新了一个用户&quot;);
  &#125;

   public void query() &#123;
       System.out.println(&quot;查询了一个用户&quot;);
  &#125;
&#125;
</code></pre>
<p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
<p>4、设置一个代理类来处理日志！代理角色</p>
<pre><code class="java">//代理角色，在这里面增加日志的实现
public class UserServiceProxy implements UserService &#123;
   private UserServiceImpl userService;

   public void setUserService(UserServiceImpl userService) &#123;
       this.userService = userService;
  &#125;

   public void add() &#123;
       log(&quot;add&quot;);
       userService.add();
  &#125;

   public void delete() &#123;
       log(&quot;delete&quot;);
       userService.delete();
  &#125;

   public void update() &#123;
       log(&quot;update&quot;);
       userService.update();
  &#125;

   public void query() &#123;
       log(&quot;query&quot;);
       userService.query();
  &#125;

   public void log(String msg)&#123;
       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>5、测试访问类：</p>
<pre><code class="java">public class Client &#123;
   public static void main(String[] args) &#123;
       //真实业务
       UserServiceImpl userService = new UserServiceImpl();
       //代理类
       UserServiceProxy proxy = new UserServiceProxy();
       //使用代理类实现日志功能！
       proxy.setUserService(userService);

       proxy.add();
  &#125;
&#125;
</code></pre>
<p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLJqcgicA5aEKtxYibgLPicNfDwicKIn9NlFl86rriaVRicKnEXlPNiacbHiaLibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-3、动态代理"><a href="#7-3、动态代理" class="headerlink" title="7.3、动态代理"></a>7.3、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLxvyvZMwn9gIEibuxjFwE3enJ4TgKO5PXxM5BPr6Bh7GQwExLvst4AsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code>Object invoke(Object proxy, 方法 method, Object[] args)；
//参数
//proxy - 调用该方法的代理实例
//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。
</code></pre>
<p>【Proxy  : 代理】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="java">//生成代理类
public Object getProxy()&#123;
   return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                 rent.getClass().getInterfaces(),this);
&#125;
</code></pre>
<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<pre><code class="java">//抽象角色：租房
public interface Rent &#123;
   public void rent();
&#125;
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="java">//真实角色: 房东，房东要出租房子
public class Host implements Rent&#123;
   public void rent() &#123;
       System.out.println(&quot;房屋出租&quot;);
  &#125;
&#125;
</code></pre>
<p>ProxyInvocationHandler. java 即代理角色</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Rent rent;

   public void setRent(Rent rent) &#123;
       this.rent = rent;
  &#125;

   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               rent.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.
   // 处理代理实例上的方法调用并返回结果
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       seeHouse();
       //核心：本质利用反射实现！
       Object result = method.invoke(rent, args);
       fare();
       return result;
  &#125;

   //看房
   public void seeHouse()&#123;
       System.out.println(&quot;带房客看房&quot;);
  &#125;
   //收中介费
   public void fare()&#123;
       System.out.println(&quot;收中介费&quot;);
  &#125;

&#125;
</code></pre>
<p>Client . java</p>
<pre><code class="java">//租客
public class Client &#123;

   public static void main(String[] args) &#123;
       //真实角色
       Host host = new Host();
       //代理实例的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setRent(host); //将真实角色放置进去！
       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！
       proxy.rent();
  &#125;

&#125;
</code></pre>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h3 id="7-4、深入理解"><a href="#7-4、深入理解" class="headerlink" title="7.4、深入理解"></a>7.4、深入理解</h3><p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<pre><code class="java">public class ProxyInvocationHandler implements InvocationHandler &#123;
   private Object target;

   public void setTarget(Object target) &#123;
       this.target = target;
  &#125;

   //生成代理类
   public Object getProxy()&#123;
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  &#125;

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  &#125;

   public void log(String methodName)&#123;
       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
  &#125;

&#125;
</code></pre>
<p>测试！</p>
<pre><code class="java">public class Test &#123;
   public static void main(String[] args) &#123;
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setTarget(userService); //设置要代理的对象
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       proxy.delete();
  &#125;
&#125;
</code></pre>
<p>测试，增删改查，查看结果！</p>
<blockquote>
<h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h2 id="八、AOP"><a href="#八、AOP" class="headerlink" title="八、AOP"></a>八、AOP</h2><h3 id="8-1、AOP简介"><a href="#8-1、AOP简介" class="headerlink" title="8.1、AOP简介"></a>8.1、AOP简介</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。<ul>
<li>前置通知：在某连接点之前执行的通知，这个通知不能组织连接点之前的执行流程</li>
<li>后置通知：在某连接点正常完成后执行的通知</li>
<li>异常通知：在方法抛出异常退出时执行的通知</li>
<li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li>
<li>环绕通知：保卫一个连接点的通知，如方法调用</li>
</ul>
</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="8-2、使用AOP"><a href="#8-2、使用AOP" class="headerlink" title="8.2、使用AOP"></a>8.2、使用AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="8-2-1、通过-Spring-API-实现"><a href="#8-2-1、通过-Spring-API-实现" class="headerlink" title="8.2.1、通过 Spring API 实现"></a>8.2.1、通过 Spring API 实现</h4><p>首先编写我们的业务接口和实现类</p>
<pre><code class="java">public interface UserService &#123;

   public void add();

   public void delete();

   public void update();

   public void search();

&#125;

public class UserServiceImpl implements UserService&#123;

   @Override
   public void add() &#123;
       System.out.println(&quot;增加用户&quot;);
  &#125;

   @Override
   public void delete() &#123;
       System.out.println(&quot;删除用户&quot;);
  &#125;

   @Override
   public void update() &#123;
       System.out.println(&quot;更新用户&quot;);
  &#125;

   @Override
   public void search() &#123;
       System.out.println(&quot;查询用户&quot;);
  &#125;
&#125;
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="java">public class Log implements MethodBeforeAdvice &#123;

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;
       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  &#125;
&#125;
public class AfterLog implements AfterReturningAdvice &#123;
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  &#125;
&#125;
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  &#125;
&#125;
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<h4 id="8-2-2、自定义类来实现Aop"><a href="#8-2-2、自定义类来实现Aop" class="headerlink" title="8.2.2、自定义类来实现Aop"></a>8.2.2、自定义类来实现Aop</h4><p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="java">public class DiyPointcut &#123;

   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;
   
&#125;
</code></pre>
<p>去spring中配置</p>
<pre><code class="xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">public class MyTest &#123;
   @Test
   public void test()&#123;
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  &#125;
&#125;
</code></pre>
<h4 id="8-2-3、使用注解实现"><a href="#8-2-3、使用注解实现" class="headerlink" title="8.2.3、使用注解实现"></a>8.2.3、使用注解实现</h4><p>第一步：编写一个注解实现的增强类</p>
<pre><code class="java">package com.kuang.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class AnnotationPointcut &#123;
   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void before()&#123;
       System.out.println(&quot;---------方法执行前---------&quot;);
  &#125;

   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void after()&#123;
       System.out.println(&quot;---------方法执行后---------&quot;);
  &#125;

   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable &#123;
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  &#125;
&#125;
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
<h2 id="九、声明式事务"><a href="#九、声明式事务" class="headerlink" title="九、声明式事务"></a>九、声明式事务</h2><h3 id="9-1、Spring的事务管理"><a href="#9-1、Spring的事务管理" class="headerlink" title="9.1、Spring的事务管理"></a>9.1、Spring的事务管理</h3><p>​        Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li><p>优点：将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p>
</li>
<li><p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li><p>一般情况下比编程式事务好用。</p>
</li>
<li><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p>
</li>
<li><p>将事务管理作为横切关注点，通过aop方法模块化。</p>
</li>
</ul>
<h3 id="9-2、通过Spring-AOP框架支持声明式事务管理"><a href="#9-2、通过Spring-AOP框架支持声明式事务管理" class="headerlink" title="9.2、通过Spring AOP框架支持声明式事务管理"></a>9.2、通过Spring AOP框架支持声明式事务管理</h3><p>​        使用Spring管理事务，注意<strong>头文件的约束导入 : tx</strong></p>
<pre><code class="xml">&lt;beans xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<h4 id="9-2-1、spring事务传播特性："><a href="#9-2-1、spring事务传播特性：" class="headerlink" title="9.2.1、spring事务传播特性："></a>9.2.1、spring事务传播特性：</h4><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<h4 id="9-2-2、配置AOP"><a href="#9-2-2、配置AOP" class="headerlink" title="9.2.2、配置AOP"></a>9.2.2、配置AOP</h4><p>导入aop的头文件！</p>
<pre><code class="xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#00bcd4>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/">
        <h2>
            Spring设计模式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><h2 id="一、解释器设计模式"><a href="#一、解释器设计模式" class="headerlink" title="一、解释器设计模式"></a>一、解释器设计模式</h2><p>​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用<strong>解释器设计模式</strong>来做。</p>
<p>​        此模式基于<strong>表达式和评估器</strong>部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个上下文中进行的。</p>
<p>​        Spring主要以<strong>Spring Expression Language</strong>（Spel）为例。</p>
<p>​        这里提个醒，SpEL是一种由Spring的<strong>org.springframework.expression.ExpressionParser</strong>实现分析和执行的语言。</p>
<p>​        这些实现使用作为字符串给出的Spel表达式，并将它们转换为<strong>org.springframework.expression.Expression的</strong>实例。上</p>
<p>​        下文组件由<strong>org.springframework.expression.EvaluationContext</strong>实现表示，例如：StandardEvaluationContext。</p>
<p>举个Spel的一个例子：</p>
<pre><code class="Java">Writer writer = new Writer();
writer.setName(&quot;Writer&#39;s name&quot;);
StandardEvaluationContext modifierContext = new StandardEvaluationContext(subscriberContext);
modifierContext.setVariable(&quot;name&quot;, &quot;Overriden writer&#39;s name&quot;);
parser.parseExpression(&quot;name = #name&quot;).getValue(modifierContext);
System.out.println(&quot;writer&#39;s name is : &quot; + writer.getName());
</code></pre>
<p>​        输出应打印“Overriden writer’s name”。如你所见，一个对象的属性是通过一个表达式<code>name = #name</code>进行修改的，这个表达式只有在<code>ExpressionParser</code>才能理解，因为提供了<code>context</code>（前面的样例中的<code>modifierContext</code>实例）。</p>
<h2 id="二、建设者模式"><a href="#二、建设者模式" class="headerlink" title="二、建设者模式"></a>二、建设者模式</h2><p>​        <strong>建设者设计模式</strong>是属于创建对象模式三剑客的第一种模式。<strong>该模式用于简化复杂对象的构造</strong>。要理解这个概念，想象一个说明程序员简历的对象。在这个对象中，我们想存储个人信息（名字，地址等）以及技术信息（知识语言，已实现的项目等）。该对象的构造可能如下所示：</p>
<pre><code class="Java">// with constructor
Programmer programmer = new Programmer(&quot;first name&quot;, &quot;last name&quot;, &quot;address Street 39&quot;, &quot;ZIP code&quot;, &quot;City&quot;, &quot;Country&quot;, birthDateObject, new String[] &#123;&quot;Java&quot;, &quot;PHP&quot;, &quot;Perl&quot;, &quot;SQL&quot;&#125;, new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);

// or with setters
Programmer programmer = new Programmer();
programmer.setName(&quot;first name&quot;);
programmer.setLastName(&quot;last name&quot;);
// ... multiple lines after
programmer.setProjects(new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);
</code></pre>
<p>​        Builder允许我们通过使用将值传递给父类的内部构建器对象来清楚地分解对象构造。所以对于我们这个程序员简历的对象的创建，构建器可以看起来像：</p>
<pre><code class="Java">public class BuilderTest &#123;

  @Test
  public void test() &#123;
    Programmer programmer = new Programmer.ProgrammerBuilder()
            .setFirstName(&quot;F&quot;)
            .setLastName(&quot;L&quot;)
            .setCity(&quot;City&quot;)
            .setZipCode(&quot;0000A&quot;)
            .setAddress(&quot;Street 39&quot;)
            .setLanguages(new String[] &#123;&quot;bash&quot;, &quot;Perl&quot;&#125;)
            .setProjects(new String[] &#123;&quot;Linux kernel&quot;&#125;).build();
    assertTrue(&quot;Programmer should be &#39;F L&#39; but was &#39;&quot;+ programmer+&quot;&#39;&quot;, programmer.toString().equals(&quot;F L&quot;));
  &#125;

&#125;

class Programmer &#123;
  private String firstName;
  private String lastName;
  private String address;
  private String zipCode;
  private String city;
  private String[] languages;
  private String[] projects;

  private Programmer(String fName, String lName, String addr, String zip, String city, String[] langs, String[] projects) &#123;
    this.firstName = fName;
    this.lastName = lName;
    this.address = addr;
    this.zipCode = zip;
    this.city = city;
    this.languages = langs;
    this.projects = projects;
  &#125;

  public static class ProgrammerBuilder &#123;
    private String firstName;
    private String lastName;
    private String address;
    private String zipCode;
    private String city;
    private String[] languages;
    private String[] projects;

    public ProgrammerBuilder setFirstName(String firstName) &#123;
      this.firstName = firstName;
      return this;
    &#125;

    public ProgrammerBuilder setLastName(String lastName) &#123;
      this.lastName = lastName;
      return this;
    &#125;

    public ProgrammerBuilder setAddress(String address) &#123;
      this.address = address;
      return this;
    &#125;

    public ProgrammerBuilder setZipCode(String zipCode) &#123;
      this.zipCode = zipCode;
      return this;
    &#125;

    public ProgrammerBuilder setCity(String city) &#123;
      this.city = city;
      return this;
    &#125;

    public ProgrammerBuilder setLanguages(String[] languages) &#123;
      this.languages = languages;
      return this;
    &#125;
    public ProgrammerBuilder setProjects(String[] projects) &#123;
      this.projects = projects;
      return this;
    &#125;

    public Programmer build() &#123;
      return new Programmer(firstName, lastName, address, zipCode, city, languages, projects);
    &#125;
  &#125;

  @Override
  public String toString() &#123;
    return this.firstName + &quot; &quot;+this.lastName;
  &#125;

&#125;
</code></pre>
<p>​        可以看出，构建器后面隐藏了对象构造的复杂性，内部静态类接受链接方法的调用。</p>
<p>​        在Spring中，我们可以在<strong>org.springframework.beans.factory.support.BeanDefinitionBuilder</strong>类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。我们可以在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/09/16/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84bean%E5%B7%A5%E5%8E%82%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">bean工厂后处理器的</a>文章中看到它，<code>BeanDefinitionBuilder</code>包含几个方法，它们为<strong>AbstractBeanDefinition</strong>抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：</p>
<pre><code class="java">public class BeanDefinitionBuilder &#123;
    /**
        * The &#123;@code BeanDefinition&#125; instance we are creating.
    */
    private AbstractBeanDefinition beanDefinition;

    // ... some not important methods for this article

    // Some of building methods
    /**
    * Set the name of the parent definition of this bean definition.
    */
    public BeanDefinitionBuilder setParentName(String parentName) &#123;
        this.beanDefinition.setParentName(parentName);
        return this;
    &#125;

    /**
    * Set the name of the factory method to use for this definition.
    */
    public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) &#123;
        this.beanDefinition.setFactoryMethodName(factoryMethod);
        return this;
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    * @deprecated since Spring 2.5, in favor of &#123;@link #addConstructorArgValue&#125;
    */
    @Deprecated
    public BeanDefinitionBuilder addConstructorArg(Object value) &#123;
        return addConstructorArgValue(value);
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    */
    public BeanDefinitionBuilder addConstructorArgValue(Object value) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
        this.constructorArgIndex++, value);
        return this;
    &#125;

    /**
    * Add a reference to a named bean as a constructor arg.
    * @see #addConstructorArgValue(Object)
    */
    public BeanDefinitionBuilder addConstructorArgReference(String beanName) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
            this.constructorArgIndex++, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Add the supplied property value under the given name.
    */
    public BeanDefinitionBuilder addPropertyValue(String name, Object value) &#123;
        this.beanDefinition.getPropertyValues().add(name, value);
        return this;
    &#125;

    /**
    * Add a reference to the specified bean name under the property specified.
    * @param name the name of the property to add the reference to
    * @param beanName the name of the bean being referenced
    */
    public BeanDefinitionBuilder addPropertyReference(String name, String beanName) &#123;
        this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Set the init method for this definition.
    */
    public BeanDefinitionBuilder setInitMethodName(String methodName) &#123;
        this.beanDefinition.setInitMethodName(methodName);
        return this;
    &#125;

    // Methods that can be used to construct BeanDefinition
    /**
    * Return the current BeanDefinition object in its raw (unvalidated) form.
    * @see #getBeanDefinition()
    */
    public AbstractBeanDefinition getRawBeanDefinition() &#123;
        return this.beanDefinition;
    &#125;

    /**
    * Validate and return the created BeanDefinition object.
    */
    public AbstractBeanDefinition getBeanDefinition() &#123;
        this.beanDefinition.validate();
        return this.beanDefinition;
    &#125;
&#125;
</code></pre>
<h2 id="三、工厂模式"><a href="#三、工厂模式" class="headerlink" title="三、工厂模式"></a>三、工厂模式</h2><p>​        创建对象模式三剑客的第二个成员是<strong>工厂方法设计模式</strong>。它完全适于使用<strong>动态环境</strong>作为Spring框架。实际上，<strong>这种模式允许通过公共静态方法对象进行初始化，称为工厂方法</strong>。在这个概念中，我们需要定义一个接口来创建对象。但是创建是由使用相关对象的类创建的。</p>
<p>​        但是在跳到Spring世界之前，让我们用Java代码做一个例子：</p>
<pre><code class="Java">public class FactoryMethodTest &#123;

    @Test
    public void test() &#123;
        Meal fruit = Meal.valueOf(&quot;banana&quot;);
        Meal vegetable = Meal.valueOf(&quot;carrot&quot;);
        assertTrue(&quot;Banana should be a fruit but is &quot;+fruit.getType(), fruit.getType().equals(&quot;fruit&quot;));
        assertTrue(&quot;Carrot should be a vegetable but is &quot;+vegetable.getType(),                                                     vegetable.getType().equals(&quot;vegetable&quot;));
    &#125;

&#125;

class Meal &#123;

    private String type;

    public Meal(String type) &#123;
        this.type = type;
    &#125;

    public String getType() &#123;
        return this.type;
    &#125;

    // Example of factory method - different object is created depending on current context
    public static Meal valueOf(String ingredient) &#123;
        if (ingredient.equals(&quot;banana&quot;)) &#123;
            return new Meal(&quot;fruit&quot;);
        &#125;
        return new Meal(&quot;vegetable&quot;);
    &#125;
&#125;
</code></pre>
<p>​        在Spring中，我们可以通过指定的工厂方法创建bean。该方法与以前代码示例中看到的valueOf方法完全相同。它是静态的，可以采取没有或多个参数。为了更好地了解案例，让我们来看一下实例。首先搞定下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;welcomerBean&quot; class=&quot;com.mysite.Welcomer&quot; factory-method=&quot;createWelcomer&quot;&gt;
    &lt;constructor-arg ref=&quot;messagesLocator&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messagesLocator&quot; class=&quot;com.mysite.MessageLocator&quot;&gt;
    &lt;property name=&quot;messages&quot; value=&quot;messages_file.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>​        现在请关注这个bean的初始化：</p>
<pre><code class="java">public class Welcomer &#123;
    private String message;

    public Welcomer(String message) &#123;
        this.message = message;
    &#125;

    public static Welcomer createWelcomer(MessageLocator messagesLocator) &#123;
        Calendar cal = Calendar.getInstance();
        String msgKey = &quot;welcome.pm&quot;;
        if (cal.get(Calendar.AM_PM) == Calendar.AM) &#123;
            msgKey = &quot;welcome.am&quot;;
        &#125;
        return new Welcomer(messagesLocator.getMessageByKey(msgKey));
    &#125;
&#125;
</code></pre>
<p>​        当Spring将构造welcomerBean时，它不会通过传统的构造函数，而是通过定义的静态工厂方法createWelcomer来实现。还要注意，这个方法接受一些参数（MessageLocator bean的实例包含所有可用的消息） 标签，通常保留给传统的构造函数。</p>
<h2 id="四、抽象工厂"><a href="#四、抽象工厂" class="headerlink" title="四、抽象工厂"></a>四、抽象工厂</h2><p>​        <strong>抽象的工厂设计模式</strong>，看起来类似于工厂方法。不同之处在于，我们可以将抽象工厂视为这个词的工业意义上的工厂，即。作为提供所需对象的东西。工厂部件有：抽象工厂，抽象产品，产品和客户。更准确地说，<strong>抽象工厂定义了构建对象的方法</strong>。抽象产品是这种结构的结果。产品是具有同样结构的具体结果。客户是要求创造产品来抽象工厂的人。</p>
<p>​        同样的，在进入Spring的细节之前，我们将首先通过示例Java代码说明这个概念：</p>
<pre><code class="java">public class FactoryTest &#123;

    // Test method which is the client
    @Test
    public void test() &#123;
        Kitchen factory = new KitchenFactory();
        KitchenMeal meal = factory.getMeal(&quot;P.1&quot;);
        KitchenMeal dessert = factory.getDessert(&quot;I.1&quot;);
        assertTrue(&quot;Meal&#39;s name should be &#39;protein meal&#39; and was &#39;&quot;+meal.getName()+&quot;&#39;&quot;, meal.getName().equals(&quot;protein meal&quot;));
        assertTrue(&quot;Dessert&#39;s name should be &#39;ice-cream&#39; and was &#39;&quot;+dessert.getName()+&quot;&#39;&quot;, dessert.getName().equals(&quot;ice-cream&quot;));
    &#125;

&#125;

// abstract factory
abstract class Kitchen &#123;
    public abstract KitchenMeal getMeal(String preferency);
    public abstract KitchenMeal getDessert(String preferency);
&#125;

// concrete factory
class KitchenFactory extends Kitchen &#123;
    @Override
    public KitchenMeal getMeal(String preferency) &#123;
        if (preferency.equals(&quot;F.1&quot;)) &#123;
            return new FastFoodMeal();
        &#125; else if (preferency.equals(&quot;P.1&quot;)) &#123;
            return new ProteinMeal();
        &#125;
        return new VegetarianMeal();
    &#125;

    @Override
    public KitchenMeal getDessert(String preferency) &#123;
        if (preferency.equals(&quot;I.1&quot;)) &#123;
            return new IceCreamMeal();
        &#125;
        return null;
    &#125;
&#125;

// abstract product
abstract class KitchenMeal &#123;
    public abstract String getName();
&#125;

// concrete products
class ProteinMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;protein meal&quot;;
    &#125;
&#125;

class VegetarianMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;vegetarian meal&quot;;
    &#125;
&#125;

class FastFoodMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;fast-food meal&quot;;
    &#125;
&#125;

class IceCreamMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;ice-cream&quot;;
    &#125;
&#125;
</code></pre>
<p>​        我们可以在这个例子中看到，<strong>抽象工厂封装了对象的创建</strong>。对象创建可以使用与经典构造函数一样使用的工厂方法模式。在Spring中，工厂的例子是<strong>org.springframework.beans.factory.BeanFactory</strong>。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，<strong>getBean</strong>方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。</p>
<p>​        在<code>BeanFactory</code>的实现中，我们可以区分：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>；</li>
<li><code>XmlWebApplicationContext</code>；</li>
<li><code>StaticWebApplicationContext</code>；</li>
<li><code>StaticPortletApplicationContext</code>；</li>
<li><code>GenericApplicationContext</code>；</li>
<li><code>StaticApplicationContext</code>。</li>
</ul>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;file:test-context.xml&quot;&#125;)
public class TestProduct &#123;

    @Autowired
    private BeanFactory factory;

    @Test
    public void test() &#123;
        System.out.println(&quot;Concrete factory is: &quot;+factory.getClass());
        assertTrue(&quot;Factory can&#39;t be null&quot;, factory != null);
        ShoppingCart cart = (ShoppingCart) factory.getBean(&quot;shoppingCart&quot;);
        assertTrue(&quot;Shopping cart object can&#39;t be null&quot;, cart != null);
        System.out.println(&quot;Found shopping cart bean:&quot;+cart.getClass());
    &#125;
&#125;
</code></pre>
<p>​        在这种情况下，抽象工厂由BeanFactory接口表示。</p>
<p>​        具体工厂是在第一个System.out中打印的，是<strong>org.springframework.beans.factory.support.DefaultListableBeanFactory</strong>的实例。它的抽象产物是一个对象。在我们的例子中，具体的产品就是被强转为ShoppingCart实例的抽象产品（Object）。</p>
<h2 id="五、代理模式"><a href="#五、代理模式" class="headerlink" title="五、代理模式"></a>五、代理模式</h2><p>​        面向对象编程（OOP）可能是编程中最流行的概念。然而，Spring引入了另一种编码规范，<strong>面向切面编程</strong>（AOP）。为了简化定义，AOP是面向系统特定点的一种编程，如：异常抛出，特定类别方法的执行等。AOP允许在执行这些特定点之前或之后执行补充动作。如何实现这种操作？它可以**通过监听器(listeners)**进行。但在这种情况下，我们应该在只要可能存在调用的地方都需要定义监听器来进行监听（比如在一个方法的开始的地方）。这就是为什么Spring不采用这个idea。相反，Spring实现了一种能够通过额外的方法调用完成任务的设计模式 - <strong>代理设计模式</strong>。</p>
<p>​        代理就像对象的镜像一样。也正因为如此，代理对象不仅可以覆盖真实对象，还可以扩展其功能。因此，对于只能在屏幕上打印一些文本的对象，我们可以添加另一个对象来过滤显示单词。可以通过代理来定义第二个对象的调用。代理是封装真实对象的对象。例如，如果您尝试调用Waiter bean，那么您将调用该Bean的代理，其行为方式完全相同。</p>
<p>​        代理设计模式的一个很好的例子是<strong>org.springframework.aop.framework.ProxyFactoryBean</strong>。该工厂根据Spring bean构建AOP代理。该类实现了定义**getObject()**方法的<code>FactoryBean</code>接口。此方法用于将需求<code>Bean</code>的实例返回给<code>bean factory</code>。在这种情况下，它不是返回的实例，而是<code>AOP代理</code>。在执行代理对象的方法之前，可以通过调用补充方法来进一步“修饰”代理对象(其实所谓的静态代理不过是在装饰模式上加了个要不要你来干动作行为而已，而不是装饰模式什么也不做就加了件衣服，其他还得由你来全权完成)。</p>
<p><code>ProxyFactory</code>的一个例子是：</p>
<pre><code class="java">public class TestProxyAop &#123;

    @Test
    public void test() &#123;
        ProxyFactory factory = new ProxyFactory(new House());
        factory.addInterface(Construction.class);
        factory.addAdvice(new BeforeConstructAdvice());
        factory.setExposeProxy(true);

        Construction construction = (Construction) factory.getProxy();
        construction.construct();
        assertTrue(&quot;Construction is illegal. &quot;
                   + &quot;Supervisor didn&#39;t give a permission to build &quot;
                   + &quot;the house&quot;, construction.isPermitted());
    &#125;

&#125;

interface Construction &#123;
    public void construct();
    public void givePermission();
    public boolean isPermitted();
&#125;

class House implements Construction&#123;

    private boolean permitted = false;

    @Override
    public boolean isPermitted() &#123;
        return this.permitted;
    &#125;

    @Override
    public void construct() &#123;
        System.out.println(&quot;I&#39;m constructing a house&quot;);
    &#125;

    @Override
    public void givePermission() &#123;
        System.out.println(&quot;Permission is given to construct a simple house&quot;);
        this.permitted = true;
    &#125;
&#125;

class BeforeConstructAdvice implements MethodBeforeAdvice &#123;

    @Override
    public void before(Method method, Object[] arguments, Object target) throws Throwable &#123;
        if (method.getName().equals(&quot;construct&quot;)) &#123;
            ((Construction) target).givePermission();
        &#125;
    &#125;

&#125;
</code></pre>
<p>​        这个测试应该通过，因为我们不直接在House实例上操作，而是代理它。代理调用第一个<code>BeforeConstructAdvice</code>的<code>before</code>方法（指向在执行目标方法之前执行，在我们的例子中为<code>construct()</code>）通过它，给出了一个“权限”来构造对象的字段（house）。代理层提供了一个额外新功能，因为它可以简单地分配给另一个对象。要做到这一点，我们只能在before方法之前修改过滤器。</p>
<h2 id="六、复合模式"><a href="#六、复合模式" class="headerlink" title="六、复合模式"></a>六、复合模式</h2><p>​        另一种结构模式是<strong>复合模式</strong>。在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/07/20/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)">Spring中设计模式</a>的第一篇文章中，我们使用构建器来构造复杂对象。另一种实现方法是使用复合模式。这种模式是<strong>基于具有共同行为的多个对象的存在</strong>，用于构建更大的对象。较大的对象仍然具有与最小对象相同的特征。那么用它来定义相同的行为。</p>
<p>​        复合对象的非Spring示例可以是一个写入HTML的文本对象，由包含span或em标签的段落组成：</p>
<pre><code class="java">public class CompositeTest &#123;

    @Test
    public void test() &#123;
        TextTagComposite composite = new PTag();
        composite.addTag(new SpanTag());
        composite.addTag(new EmTag());

        // sample client code
        composite.startWrite();
        for (TextTag leaf : composite.getTags()) &#123;
            leaf.startWrite();
            leaf.endWrite();
        &#125;
        composite.endWrite();
        assertTrue(&quot;Composite should contain 2 tags but it contains &quot;+composite.getTags().size(), composite.getTags().size() == 2);
    &#125;

&#125;

interface TextTag &#123;
    public void startWrite();
    public void endWrite();
&#125;

interface TextTagComposite extends TextTag &#123;
    public List&lt;TextTag&gt; getTags();
    public void addTag(TextTag tag);
&#125;

class PTag implements TextTagComposite &#123;
    private List&lt;TextTag&gt; tags = new ArrayList&lt;TextTag&gt;();

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;p&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/p&gt;&quot;);
    &#125;

    @Override
    public List&lt;TextTag&gt; getTags() &#123;
        return tags;
    &#125;

    @Override
    public void addTag(TextTag tag) &#123;
        tags.add(tag);
    &#125;
&#125;

class SpanTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;span&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/span&gt;&quot;);
    &#125;

&#125;

class EmTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;em&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/em&gt;&quot;);
    &#125;

&#125;
</code></pre>
<p>​        在这种情况下，可以看到一个复合对象。我们可以区分复合与非复合对象，因为第一个可以容纳一个或多个非复合对象（<code>PTag</code>类中的<code>private List tags</code>字段）。非复合对象称为<strong>叶子</strong>。<code>TextTag</code>接口被称为<strong>组件</strong>，因为它为两个对象类型提供了共同的行为规范(有点像<code>Linux</code>文件管理系统的有共同点的文件放在一个文件夹下进行管理，其实就是节点管理)。</p>
<p>​        在<code>Spring</code>世界中，我们检索复合对象的概念是<strong>org.springframework.beans.BeanMetadataElement</strong>接口，用于配置<code>bean</code>对象。它是所有继承对象的基本界面。</p>
<p>​        现在，在一方面，我们有一个叶子，由<strong>org.springframework.beans.factory.parsing.BeanComponentDefinition</strong>表示，另一边是复合<strong>org.springframework.beans.factory.parsing.CompositeComponentDefinition</strong>。</p>
<p>​        <code>CompositeComponentDefinition</code>类似于组件，因为它包含<strong>addNestedComponent（ComponentDefinition component）</strong>方法，它允许将叶子添加到私有final列表中<code>nestedComponents</code>。您可以看到，由于此列表，<code>BeanComponentDefinition</code>和<code>CompositeComponentDefinition</code>的组件是<strong>org.springframework.beans.factory.parsing.ComponentDefinition</strong>。</p>
<p><img src="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg" alt="img"></p>
<h2 id="七、策略模式"><a href="#七、策略模式" class="headerlink" title="七、策略模式"></a>七、策略模式</h2><p>​        <strong>策略设计模式</strong>。<strong>策略定义了通过不同方式完成相同事情的几个对象</strong>。完成任务的方式取决于采用的策略。举个例子说明，我们可以去一个国家。我们可以乘公共汽车，飞机，船甚至汽车去那里。所有这些方法将把我们运送到目的地国家。但是，我们将通过检查我们的银行帐户来选择最适应的方式。如果我们有很多钱，我们将采取最快的方式（可能是私人飞行）。如果我们没有足够的话，我们会采取最慢的（公车，汽车）。该银行账户作为确定适应策略的因素。</p>
<p>​        Spring在<strong>org.springframework.web.servlet.mvc.multiaction.MethodNameResolver</strong>类(过时，但不影响拿来研究)中使用策略设计模式。它是<code>MultiActionController</code>(同样过时)的参数化实现。在开始解释策略之前，我们需要了解MultiActionController的实用性。这个类允许同一个类处理几种类型的请求。</p>
<p>​        作为Spring中的每个控制器，MultiActionController执行方法来响应提供的请求。策略用于检测应使用哪种方法。解析过程在MethodNameResolver实现中实现，例如在同一个包中的<strong>ParameterMethodNameResolver中</strong>。方法可以通过多个条件解决：属性映射，HTTP请求参数或URL路径。</p>
<pre><code class="java">@Override
public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException &#123;
    String methodName = null;

    // Check parameter names where the very existence of each parameter
    // means that a method of the same name should be invoked, if any.
    if (this.methodParamNames != null) &#123;
        for (String candidate : this.methodParamNames) &#123;
            if (WebUtils.hasSubmitParameter(request, candidate)) &#123;
                methodName = candidate;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                                 &quot;&#39; based on existence of explicit request parameter of same name&quot;);
                &#125;
                break;
            &#125;
        &#125;
    &#125;

    // Check parameter whose value identifies the method to invoke, if any.
    if (methodName == null &amp;&amp; this.paramName != null) &#123;
        methodName = request.getParameter(this.paramName);
        if (methodName != null) &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                             &quot;&#39; based on value of request parameter &#39;&quot; + this.paramName + &quot;&#39;&quot;);
            &#125;
        &#125;
    &#125;

    if (methodName != null &amp;&amp; this.logicalMappings != null) &#123;
        // Resolve logical name into real method name, if appropriate.
        String originalName = methodName;
        methodName = this.logicalMappings.getProperty(methodName, methodName);
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Resolved method name &#39;&quot; + originalName + &quot;&#39; to handler method &#39;&quot; + methodName + &quot;&#39;&quot;);
        &#125;
    &#125;

    if (methodName != null &amp;&amp; !StringUtils.hasText(methodName)) &#123;
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Method name &#39;&quot; + methodName + &quot;&#39; is empty: treating it as no method name found&quot;);
        &#125;
        methodName = null;
    &#125;

    if (methodName == null) &#123;
        if (this.defaultMethodName != null) &#123;
            // No specific method resolved: use default method.
            methodName = this.defaultMethodName;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Falling back to default handler method &#39;&quot; + this.defaultMethodName + &quot;&#39;&quot;);
            &#125;
        &#125;
        else &#123;
            // If resolution failed completely, throw an exception.
            throw new NoSuchRequestHandlingMethodException(request);
        &#125;
    &#125;

    return methodName;
&#125;
</code></pre>
<p>​        正如我们在前面的代码中可以看到的，方法的名称通过提供的参数映射，URL中的预定义属性或参数存在来解决（默认情况下，该参数的名称是action）。</p>
<h2 id="八、模板模式"><a href="#八、模板模式" class="headerlink" title="八、模板模式"></a>八、模板模式</h2><p>​        <strong>模板方法</strong>。此模式定义了类行为的骨架，并将子步骤的某些步骤的延迟执行(具体就是下面例子中一个方法放在另一个方法中，只有调用另一方方法的时候这个方法才会执行,而且还可能会在其他行为方法之后按顺序执行)。其中写了一种方法(下面例子中的construct())，注意定义为final，起着同步器的角色。它以给定的顺序执行由子类定义的方法。在现实世界中，我们可以将模板方法与房屋建设进行比较。独立于建造房屋的公司，我们需要从建立基础开始，只有在我们完成之后才能做其他的工作。这个执行逻辑将被保存在一个我们不能改变的方法中。例如基础建设或刷墙会被作为一个模板方法中的方法，具体到建筑房屋的公司。我们可以在给定的例子中看到它：</p>
<pre><code class="java">public class TemplateMethod &#123;

  public static void main(String[] args) &#123;
    HouseAbstract house = new SeaHouse();
    house.construct();
  &#125;

&#125;

abstract class HouseAbstract &#123;
  protected abstract void constructFoundations();
  protected abstract void constructWall();

  // template method
  public final void construct() &#123;
    constructFoundations();
    constructWall();
  &#125;
&#125;

class EcologicalHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Making foundations with wood&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Making wall with wood&quot;);
  &#125;

&#125;

class SeaHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Constructing very strong foundations&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Constructing very strong wall&quot;);
  &#125;

&#125;
</code></pre>
<p>​        该代码应该输出：</p>
<pre><code class="java">Constructing very strong foundations
Constructing very strong wall
</code></pre>
<p>​        Spring在<strong>org.springframework.context.support.AbstractApplicationContext</strong>类中使用模板方法。他们不是一个模板方法（在我们的例子中是construct ），而是多个。例如，<strong>getsFreshBeanFactory</strong>返回内部<code>bean工厂</code>的新版本，调用两个抽象方法：<code>refreshBeanFactory</code>（刷新工厂bean）和<code>getBeanFactory</code>（以获取更新的工厂bean）。这个方法和其他一些方法一样，用在<strong>public void refresh()<strong>中，抛出</strong>构造应用程序上下文的BeansException，IllegalStateException</strong>方法(这里会在后面Spring中与应用程序上下文分析中再次提到)。</p>
<p>​        我们可以从同一个包中的GenericApplicationContext找到一些通过模板方法所实现的抽象方法的实现的例子(说的有点拗口，多读几遍就好):</p>
<pre><code class="java">/**
  * Do nothing: We hold a single internal BeanFactory and rely on callers
  * to register beans through our public methods (or the BeanFactory&#39;s).
  * @see #registerBeanDefinition
  */
@Override
protected final void refreshBeanFactory() throws IllegalStateException &#123;
  if (this.refreshed) &#123;
    throw new IllegalStateException(
      &quot;GenericApplicationContext does not support multiple refresh attempts: just call &#39;refresh&#39; once&quot;);
  &#125;
  this.beanFactory.setSerializationId(getId());
  this.refreshed = true;
&#125;

@Override
protected void cancelRefresh(BeansException ex) &#123;
  this.beanFactory.setSerializationId(null);
  super.cancelRefresh(ex);
&#125;

/**
  * Not much to do: We hold a single internal BeanFactory that will never
  * get released.
  */
@Override
protected final void closeBeanFactory() &#123;
  this.beanFactory.setSerializationId(null);
&#125;

/**
  * Return the single internal BeanFactory held by this context
  * (as ConfigurableListableBeanFactory).
  */
@Override
public final ConfigurableListableBeanFactory getBeanFactory() &#123;
  return this.beanFactory;
&#125;

/**
  * Return the underlying bean factory of this context,
  * available for registering bean definitions.
  * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; You need to call &#123;@link #refresh()&#125; to initialize the
  * bean factory and its contained beans with application context semantics
  * (autodetecting BeanFactoryPostProcessors, etc).
  * @return the internal bean factory (as DefaultListableBeanFactory)
  */
public final DefaultListableBeanFactory getDefaultListableBeanFactory() &#123;
  return this.beanFactory;
&#125;
</code></pre>
<p>​        经过上面这些可以让我们发现Spring如何通过使用行为和结构设计模式来更好地组织上下文（<strong>模板方法</strong>），并通过相应<strong>策略</strong>来解决执行方法。它使用两种结构设计模式，通过<strong>代理模式</strong>来简化AOP部分并通过<strong>复合模式</strong>来构造复杂对象。</p>
<h2 id="九、原型模式"><a href="#九、原型模式" class="headerlink" title="九、原型模式"></a>九、原型模式</h2><p>​        可以通过官方文档查找有关Spring作用域中的bean作用域的文章中介绍了类似的概念(<strong>prototype</strong>)。原型设计模式与有用相同名称的(<strong>prototype</strong>)作用域有点相似。此设计模式允许通过复制已存在的对象来创建一个对象的实例。副本应该是<strong>真正的副本</strong>。这意味着新对象的所有属性应与复制对象的属性相同。如果不清楚，比一个简单的<code>JUnit</code>案例更好的说明：</p>
<pre><code class="java">public class PrototypeTest &#123;

  @Test
  public void test() &#123;
    Robot firstRobot = new Robot(&quot;Droid#1&quot;);
    Robot secondRobot = (Robot) firstRobot.clone();
    assertTrue(&quot;Cloned robot&#39;s instance can&#39;t be the same as the&quot;
      +&quot; source robot instance&quot;,
      firstRobot != secondRobot);
    assertTrue(&quot;Cloned robot&#39;s name should be &#39;&quot;+firstRobot.getName()+&quot;&#39;&quot;
      +&quot; but was &#39;&quot;+secondRobot.getName()+&quot;&#39;&quot;,
      secondRobot.getName().equals(firstRobot.getName()));
  &#125;

&#125;


class Robot implements Cloneable &#123;
  private String name;

  public Robot(String name) &#123;
    this.name = name;
  &#125;

  public String getName() &#123;
    return this.name;
  &#125;

  protected Object clone() throws CloneNotSupportedException &#123;
    return super.clone();
  &#125;
&#125;
</code></pre>
<p>​        在<code>Spring</code>中，在<strong>org.springframework.beans.factory.support.AbstractBeanFactory</strong>中使用一种特定的原型设计模式，它将初始化<code>bean原型作用域</code>。新对象基于配置文件中的bean定义。我们可以看到，在给定的例子中：</p>
<pre><code class="java">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; scope=&quot;prototype&quot;&gt;
  &lt;property name=&quot;id&quot; value=&quot;9&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;applicationContext-test.xml&quot;&#125;)
public class SpringPrototypeTest &#123;

  @Autowired
  private BeanFactory beanFactory;

  @Test
  public void test() &#123;
    ShoppingCart cart1 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart1 should be 9 but was &quot;+cart1.getId(),
      cart1.getId() == 9);
    cart1.setId(100);
    ShoppingCart cart2 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart2 should be 9 but was &quot;+cart2.getId(),
      cart2.getId() == 9);
    assertTrue(&quot;Id of second cart (&quot;+cart2.getId()+&quot;) shouldn&#39;t be the same as the first one: &quot;+cart1.getId(),
      cart1.getId() != cart2.getId());
    cart2.setId(cart1.getId());
    assertTrue(&quot;Now (after cart2.setId(cart1.getId())), the id of second cart (&quot;+cart2.getId()+&quot;) should be the same as the first one: &quot;
      +cart1.getId(), cart1.getId() == cart2.getId());
    assertTrue(&quot;Both instance shouldn&#39;t be the same&quot;, cart1 != cart2);
  &#125;

&#125;
</code></pre>
<p>​        从前面的例子可以看出，<code>ShoppingCart</code>实例是直接从bean定义创建的。最初，<code>cart1</code>和<code>cart2</code>对象的<code>id</code>值为<code>9</code>.它在测试结束时被修改，以证明两个引用都属于两个不同的对象。</p>
<h2 id="十、对象池"><a href="#十、对象池" class="headerlink" title="十、对象池"></a>十、对象池</h2><p>​        <code>Spring</code>中使用的另一个模型是<strong>对象池设计模式</strong>。其主要目的在于在一个池中保存特定数量的对象，并根据需要重新使用。通过它，我们可以改善我们想要使用<code>巨型对象</code>的响应时间。<code>巨型</code>意味着这些对象的构造需要很多时间（例如：持有数据库连接的对象），最好重用已经存在的和未获取的对象，而不是创建新对象。</p>
<p>​        Spring还使用线程池来管理其调度部分。一些示例位于<strong>org.springframework.scheduling.concurrent中</strong>。我们检索数据库（<code>Spring JDBC</code>）项目中的对象池的想法。数据库连接池不是由<code>Spring</code>直接实现的，而是适用于<code>Spring</code>工作方式的项目，如<code>C3P0</code>或<code>Jakarta Commons DBCP</code>连接池。</p>
<h2 id="十一、观察者"><a href="#十一、观察者" class="headerlink" title="十一、观察者"></a>十一、观察者</h2><p>​        当一个或几个课程正在等待具体事件时可以使用它。观察者模式由一个科目和观察员名单组成。一个很好的例子就是<code>GUI界面</code>，其中点击按钮（按钮是主题）会引起听众（观察者）启动的一些操作(再说的直白点就是电影院一场电影这个<code>subject</code>,需要<code>观众</code>(也就是观察者咯),电影产生的一些画面产生的事件，比如恐怖 电影给男人女人带来的不同的感官的感受，传播到观察者也就是观众的眼里所带来的不一样的反应，这个中间一般会添加一个<code>事件传播者</code>，在后面解释<code>Spring</code>的例子的时候会说到)，例如：打开一个新页面这个动作。可以参考下面的例子：</p>
<pre><code class="java">public class ObserverTest &#123;

  @Test
  public void test() &#123;
    Observer pageOpener = new PageOpener();
    Observer register = new Register();
    Button btn = new Button();
    btn.addListener(pageOpener);
    btn.addListener(register);
    btn.clickOn();
    assertTrue(&quot;Button should be clicked but it wasn&#39;t&quot;,
      btn.wasClicked());
    assertTrue(&quot;Page opener should be informed about click but it wasn&#39;t&quot;,
      pageOpener.wasInformed());
    assertTrue(&quot;Register should be informed about click but it wasn&#39;t&quot;,
      register.wasInformed());
  &#125;

&#125;

class Button &#123;

  private boolean clicked;
  private List&lt;observer&gt; listeners;

  public List&lt;observer&gt; getListeners() &#123;
    if (this.listeners == null) &#123;
      this.listeners = new ArrayList&lt;observer&gt;();
    &#125;
    return this.listeners;
  &#125;

  public void addListener(Observer observer) &#123;
    getListeners().add(observer);
  &#125;

  public boolean wasClicked() &#123;
    return this.clicked;
  &#125;

  public void clickOn() &#123;
    this.clicked = true;
    informAll();
  &#125;

  private void informAll() &#123;
    for (Observer observer : getListeners()) &#123;
      observer.informAboutEvent();
    &#125;
  &#125;

&#125;

abstract class Observer &#123;
  protected boolean informed;

  public void informAboutEvent() &#123;
    this.informed = true;
  &#125;

  public boolean wasInformed() &#123;
    return this.informed;
  &#125;
&#125;

class PageOpener extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Preparing download of new page&quot;);
    super.informAboutEvent();
  &#125;

&#125;

class Register extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Adding the action to register&quot;);
    super.informAboutEvent();
  &#125;
&#125;
</code></pre>
<p>​        可以看到，关于我们的<code>Button</code>实例点击的事件被发送到所有的观察者对象。从这些对象开始下载页面内容，第二个将在事件的信息保存在注册表中。在<code>Spring</code>中，观察者设计模式用于将与应用程序上下文相关的事件传输到<strong>org.springframework.context.ApplicationListener的实现</strong>。要了解它们的实现方法，我们来看一下<code>AbstractApplicationContext</code>类(老版本的代码，新版本的请自行对照)：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader
  implements ConfigurableApplicationContext, DisposableBean &#123;
  /** Statically specified listeners */
  private Set&lt;applicationlistener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;applicationlistener&lt;?&gt;&gt;();

  // some other fields and methods
  @Override
  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;
    if (this.applicationEventMulticaster != null) &#123;
      this.applicationEventMulticaster.addApplicationListener(listener);
    &#125;
    else &#123;//新版本这里直接咔嚓掉，上面的applicationEventMulticaster一旦为空，就会报错的
      this.applicationListeners.add(listener);
    &#125;
  &#125;

  /**
    * Return the list of statically specified ApplicationListeners.
    */
  public Collection&lt;applicationlistener&lt;?&gt;&gt; getApplicationListeners() &#123;
    return this.applicationListeners;
  &#125;

  /**
    * Add beans that implement ApplicationListener as listeners.
    * Doesn&#39;t affect other listeners, which can be added without being beans.
    */
  protected void registerListeners() &#123;
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;
      getApplicationEventMulticaster().addApplicationListener(listener);
    &#125;
    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String lisName : listenerBeanNames) &#123;
      getApplicationEventMulticaster().addApplicationListenerBean(lisName);
    &#125;
  &#125;
&#125;java
</code></pre>
<p>​        在提供的代码中，监听器在内部添加到应用程序上下文类中，并且在<code>registerListeners()</code>方法之后，它们被注册到由接口<strong>org.springframework.context.event.ApplicationEventMulticaster</strong>表示的适当的事件多路广播器(因为有很多listeners)。<code>EventMulticaster</code>负责管理不同的<code>listener</code>和向他们发布事件。</p>
<pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;
    private Executor taskExecutor;
    private ErrorHandler errorHandler;

    public SimpleApplicationEventMulticaster() &#123;
    &#125;

    public SimpleApplicationEventMulticaster(BeanFactory beanFactory) &#123;
        this.setBeanFactory(beanFactory);
    &#125;

    public void setTaskExecutor(Executor taskExecutor) &#123;
        this.taskExecutor = taskExecutor;
    &#125;

    protected Executor getTaskExecutor() &#123;
        return this.taskExecutor;
    &#125;

    public void setErrorHandler(ErrorHandler errorHandler) &#123;
        this.errorHandler = errorHandler;
    &#125;

    protected ErrorHandler getErrorHandler() &#123;
        return this.errorHandler;
    &#125;

    public void multicastEvent(ApplicationEvent event) &#123;
        this.multicastEvent(event, this.resolveDefaultEventType(event));
    &#125;
    //发布事件:通过池执行任务的方式来做并发处理，这样就把之前的对象池模式给利用上了
    public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123;
        ResolvableType type = eventType != null?eventType:this.resolveDefaultEventType(event);
        Iterator var4 = this.getApplicationListeners(event, type).iterator();

        while(var4.hasNext()) &#123;
            final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();
            Executor executor = this.getTaskExecutor();
            if(executor != null) &#123;
                executor.execute(new Runnable() &#123;
                    public void run() &#123;
                        SimpleApplicationEventMulticaster.this.invokeListener(listener, event);
                    &#125;
                &#125;);
            &#125; else &#123;
                this.invokeListener(listener, event);
            &#125;
        &#125;

    &#125;
...
&#125;
</code></pre>
<p>​        这次我们讲3种设计模式:用于在同一个调用作用域内创建<code>bean的原型</code>，避免重新创建巨型对象的对象池，以及将应用程序的上下文事件分派给适当的监听器的观察者。</p>
<h2 id="十二、适配器"><a href="#十二、适配器" class="headerlink" title="十二、适配器"></a>十二、适配器</h2><p>​        当我们需要在给定场景下(也就是给定接口)想要不改变自身行为而又想做到一些事情的情况下(就是我给电也就是接口了，你来做事也就是各种电器)，使用<strong>适配器设计模式</strong>(这里再说一点，就相当于我们再一个规章制度的环境下，如何去适应并达到我们期待的效果，放在架构设计这里，可以拿一个php系统和一个Java系统来说，假如两者要互相调用对方的功能，我们可以设计一套对外的api来适配)。这意味着在调用此对象之前，我们将更改使用对象而不改变机制。拿一个现实中的例子进行说明，想象一下你想要用电钻来钻一个洞。要钻一个小洞，你会使用小钻头，钻一个大的需要用大钻头。可以看下面的代码：</p>
<pre><code class="java">public class AdapterTest &#123;

  public static void main(String[] args) &#123;
    HoleMaker maker = new HoleMakerImpl();
    maker.makeHole(1);
    maker.makeHole(2);
    maker.makeHole(30);
    maker.makeHole(40);
  &#125;
&#125;

interface HoleMaker &#123;
  public void makeHole(int diameter);
&#125;

interface DrillBit &#123;
  public void makeSmallHole();
  public void makeBigHole();
&#125;

// Two adaptee objects
class BigDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    // do nothing
  &#125;

  @Override
  public void makeBigHole() &#123;
    System.out.println(&quot;Big hole is made byt WallBigHoleMaker&quot;);
  &#125;
&#125;

class SmallDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    System.out.println(&quot;Small hole is made byt WallSmallHoleMaker&quot;);
  &#125;

  @Override
  public void makeBigHole() &#123;
    // do nothing
  &#125;
&#125;

// Adapter class
class Drill implements HoleMaker &#123;

  private DrillBit drillBit;

  public Drill(int diameter) &#123;
    drillBit = getMakerByDiameter(diameter);
  &#125;

  @Override
  public void makeHole(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            drillBit.makeSmallHole();
    &#125; else &#123;
            drillBit.makeBigHole();
    &#125;
  &#125;

  private DrillBit getMakerByDiameter(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            return new SmallDrillBit();
    &#125;
    return new BigDrillBit();
  &#125;

  private boolean isSmallDiameter(int diameter) &#123;
    return diameter &lt; 10;
  &#125;
&#125;

// Client class
class HoleMakerImpl implements HoleMaker &#123;

  @Override
  public void makeHole(int diameter) &#123;
    HoleMaker maker = new Drill(diameter);
    maker.makeHole(diameter);
  &#125;
&#125;
</code></pre>
<p>以上代码的结果如下:</p>
<pre><code class="java">Small hole is made byt SmallDrillBit
Small hole is made byt SmallDrillBit
Big hole is made byt BigDrillBit
Big hole is made byt BigDrillBit
</code></pre>
<p>​        可以看到，hole 是由所匹配的DrillBit对象制成的。如果孔的直径小于10，则使用SmallDrillBit。如果它更大，我们使用BigDrillBit。</p>
<p>​        思路就是，要打洞，那就要有打洞的工具，这里提供一个电钻接口和钻头。电钻就是用来打洞的，所以，它就一个接口方法即可，接下来定义钻头的接口，无非就是钻头的尺寸标准，然后搞出两个钻头实现类出来，接下来就是把钻头和电钻主机组装起来咯，也就是<code>Drill</code>类，里面有电钻接口+钻头(根据要钻的孔大小来确定用哪个钻头)，其实也就是把几个单一的东西组合起来拥有丰富的功能，最后我们进行封装下:<code>HoleMakerImpl</code>，这样只需要根据尺寸就可以打相应的孔了，对外暴露的接口极为简单，无须管内部逻辑是多么复杂</p>
<p>​        Spring使用适配器设计模式来处理不同servlet容器中的<strong>加载时编织</strong>(<strong>load-time-weaving</strong>)。在面向切面编程（AOP）中使用<strong>load-time-weaving</strong>，一种方式是在类加载期间将AspectJ的方面注入字节码。另一种方式是对类进行编译时注入或对已编译的类进行静态注入。</p>
<p>​        我们可以从关于Spring和JBoss的处理接口这里找到一个很好的例子，它包含在<strong>org.springframework.instrument.classloading.jboss</strong>包中。我们检索<code>JBossLoadTimeWeaver类</code>负责<code>JBoss容器</code>的编织管理。然而，类加载器对于<code>JBoss 6</code>（使用<code>JBossMCAdapter</code>实例）和<code>JBoss 7/8</code>（使用<code>JBossModulesAdapter</code>实例）是不同的。根据<code>JBoss</code>版本，我们在<code>JBossLoadTimeWeaver</code>构造函数中初始化相应的适配器（与我们示例中的<code>Drill</code>的构造函数完全相同）：</p>
<pre><code class="java">public JBossLoadTimeWeaver(ClassLoader classLoader) &#123;
  private final JBossClassLoaderAdapter adapter;

  Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
  if (classLoader.getClass().getName().startsWith(&quot;org.jboss.modules&quot;)) &#123;
    // JBoss AS 7 or WildFly 8
    this.adapter = new JBossModulesAdapter(classLoader);
  &#125;
  else &#123;
    // JBoss AS 6
    this.adapter = new JBossMCAdapter(classLoader);
  &#125;
&#125;
</code></pre>
<p>​        而且，此适配器所创建的实例用于根据运行的servlet容器版本进行编织操作：</p>
<pre><code class="java">@Override
public void addTransformer(ClassFileTransformer transformer) &#123;
  this.adapter.addTransformer(transformer);
&#125;

@Override
public ClassLoader getInstrumentableClassLoader() &#123;
  return this.adapter.getInstrumentableClassLoader();
&#125;
</code></pre>
<blockquote>
<p>总结：适配器模式，其实就是我们用第一人称的视角去看世界，我想拓展我自己的技能的时候，就实行拿来主义，就好比这里的我是电钻的视角，那么我想拥有钻大孔或者小孔的功能，那就把钻头拿到手组合起来就好。</p>
<p>和装饰模式的区别：装饰模式属于第三人称的视角，也就是上帝视角！我只需要把几个功能性的组件给拿到手，进行组合一下，实现一个更加<code>niubility</code>的功能这里提前说下，这样看下面的内容能好理解些。下面解释装饰模式</p>
</blockquote>
<h2 id="十三、装饰"><a href="#十三、装饰" class="headerlink" title="十三、装饰"></a>十三、装饰</h2><p>​        这里描述的第二种设计模式看起来类似于适配器。它是<strong>装饰模式</strong>。这种设计模式的主要作用是为给定的对象添加补充角色。举个现实的例子，就拿咖啡来讲。通常越黑越苦，你可以添加（<code>装饰</code>）糖和牛奶，使咖啡不那么苦。咖啡在这里被装饰的对象，糖与牛奶是用来装饰的。可以参考下面的例子：</p>
<pre><code class="java">public class DecoratorSample &#123;

  @Test
  public void test() &#123;
    Coffee sugarMilkCoffee=new MilkDecorator(new SugarDecorator(new BlackCoffee()));
    assertEquals(sugarMilkCoffee.getPrice(), 6d, 0d);
  &#125;
&#125;

// decorated
abstract class Coffee&#123;
  protected int candied=0;
  protected double price=2d;
  public abstract int makeMoreCandied();
  public double getPrice()&#123;
    return this.price;
  &#125;
  public void setPrice(double price)&#123;
    this.price+=price;
  &#125;
&#125;
class BlackCoffee extends Coffee&#123;
  @Override
  public int makeMoreCandied()&#123;
    return 0;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.price;
  &#125;
&#125;

// abstract decorator
abstract class CoffeeDecorator extends Coffee&#123;
  protected Coffee coffee;
  public CoffeeDecorator(Coffee coffee)&#123;
    this.coffee=coffee;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.coffee.getPrice();
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return this.coffee.makeMoreCandied();
  &#125;
&#125;

// concrete decorators
class MilkDecorator extends CoffeeDecorator&#123;
  public MilkDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+1d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
class SugarDecorator extends CoffeeDecorator&#123;
  public SugarDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+3d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
</code></pre>
<p>​        上面这个简单的装饰器的小例子是基于对父方法的调用，从而改变最后的属性（我们这里是指价格和加糖多少）。在Spring中，我们在处理与Spring管理缓存同步事务的相关类中可以 发现装饰器设计模式的例子。这个类是<strong>org.springframework.cache.transaction.TransactionAwareCacheDecorator</strong>。</p>
<p>​        这个类的哪些特性证明它是<strong>org.springframework.cache.Cache</strong>对象的装饰器？首先，与我们的咖啡示例一样，<code>TransactionAwareCacheDecorator</code>的构造函数接收参数装饰对象（Cache）：</p>
<pre><code class="java">private final Cache targetCache;
/**
 * Create a new TransactionAwareCache for the given target Cache.
 * @param targetCache the target Cache to decorate
 */
public TransactionAwareCacheDecorator(Cache targetCache) &#123;
  Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
  this.targetCache = targetCache;
&#125;
</code></pre>
<p>​        其次，通过这个对象，我们可以得到一个新的行为:为给定的目标缓存创建一个新的TransactionAwareCache。这个我们可以在<code>TransactionAwareCacheDecorator</code>的注释中可以阅读到，其主要目的是提供缓存和Spring事务之间的同步级别。这是通过<strong>org.springframework.transaction.support.TransactionSynchronizationManager</strong>中的两种缓存方法实现的：<code>put</code> 和 <code>evict</code>(其实最终不还是通过<code>targetCache</code>来实现的么)：</p>
<pre><code class="java">@Override
public void put(final Object key, final Object value) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
    TransactionSynchronizationManager.registerSynchronization(
      new TransactionSynchronizationAdapter() &#123;
        @Override
        public void afterCommit() &#123;
          targetCache.put(key, value);
        &#125;
    &#125;);
  &#125;
  else &#123;
    this.targetCache.put(key, value);
  &#125;
&#125;

@Override
public void evict(final Object key) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
          TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronizationAdapter() &#123;
              @Override
              public void afterCommit() &#123;
                targetCache.evict(key);
              &#125;
          &#125;);
  &#125;
  else &#123;
    this.targetCache.evict(key);
  &#125;
&#125;
</code></pre>
<p>​        这种模式看起来类似于适配器，对吧？但是，它们还是有区别的。我们可以看到，适配器将对象适配到运行时环境，即。如果我们在JBoss 6中运行，我们使用与JBoss 7不同的类加载器。Decorator每次使用相同的主对象（Cache）工作，并且仅向其添加新行为（与本例中的Spring事务同步），另外，可以通过我在解读这个设计模式之前的说法来区分二者。</p>
<p>​        我们再以springboot的初始化来举个例子的，这块后面会进行仔细的源码分析的，这里就仅仅用设计模式来说下的:</p>
<pre><code class="java">/**
 * Event published as early as conceivably possible as soon as a &#123;@link SpringApplication&#125;
 * has been started - before the &#123;@link Environment&#125; or &#123;@link ApplicationContext&#125; is
 * available, but after the &#123;@link ApplicationListener&#125;s have been registered. The source
 * of the event is the &#123;@link SpringApplication&#125; itself, but beware of using its internal
 * state too much at this early stage since it might be modified later in the lifecycle.
 *
 * @author Dave Syer
 */
@SuppressWarnings(&quot;serial&quot;)
public class ApplicationStartedEvent extends SpringApplicationEvent &#123;

    /**
     * Create a new &#123;@link ApplicationStartedEvent&#125; instance.
     * @param application the current application
     * @param args the arguments the application is running with
     */
    public ApplicationStartedEvent(SpringApplication application, String[] args) &#123;
        super(application, args);
    &#125;

&#125;
</code></pre>
<p>​        从注释可以看出 <code>ApplicationListener</code>要先行到位的，然后就是started的时候<code>Event published</code>走起，接着就是<code>Environment</code>配置好，<code>ApplicationContext</code>进行初始化完毕，那我们去看<code>ApplicationListener</code>的源码:</p>
<pre><code class="java">/**
 * Listener for the &#123;@link SpringApplication&#125; &#123;@code run&#125; method.
 * &#123;@link SpringApplicationRunListener&#125;s are loaded via the &#123;@link SpringFactoriesLoader&#125;
 * and should declare a public constructor that accepts a &#123;@link SpringApplication&#125;
 * instance and a &#123;@code String[]&#125; of arguments. A new
 * &#123;@link SpringApplicationRunListener&#125; instance will be created for each run.
 *
 * @author Phillip Webb
 * @author Dave Syer
 */
public interface SpringApplicationRunListener &#123;

    /**
     * Called immediately when the run method has first started. Can be used for very
     * early initialization.
     */
    void started();

    /**
     * Called once the environment has been prepared, but before the
     * &#123;@link ApplicationContext&#125; has been created.
     * @param environment the environment
     */
    void environmentPrepared(ConfigurableEnvironment environment);

    /**
     * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but
     * before sources have been loaded.
     * @param context the application context
     */
    void contextPrepared(ConfigurableApplicationContext context);

    /**
     * Called once the application context has been loaded but before it has been
     * refreshed.
     * @param context the application context
     */
    void contextLoaded(ConfigurableApplicationContext context);

    /**
     * Called immediately before the run method finishes.
     * @param context the application context or null if a failure occurred before the
     * context was created
     * @param exception any run exception or null if run completed successfully.
     */
    void finished(ConfigurableApplicationContext context, Throwable exception);

&#125;
</code></pre>
<p>​        看类注释我们可以知道，需要实现此接口内所定义的这几个方法，ok，来看个实现类:</p>
<pre><code class="java">/**
 * &#123;@link SpringApplicationRunListener&#125; to publish &#123;@link SpringApplicationEvent&#125;s.
 * &lt;p&gt;
 * Uses an internal &#123;@link ApplicationEventMulticaster&#125; for the events that are fired
 * before the context is actually refreshed.
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 */
public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;

    private final SpringApplication application;

    private final String[] args;

    private final ApplicationEventMulticaster initialMulticaster;

    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;
        this.application = application;
        this.args = args;
        this.initialMulticaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;
            this.initialMulticaster.addApplicationListener(listener);
        &#125;
    &#125;

    @Override
    public int getOrder() &#123;
        return 0;
    &#125;

    @Override
    public void started() &#123;
        this.initialMulticaster
                .multicastEvent(new ApplicationStartedEvent(this.application, this.args));
    &#125;

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) &#123;
        this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(
                this.application, this.args, environment));
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;

    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        for (ApplicationListener&lt;?&gt; listener : this.application.getListeners()) &#123;
            if (listener instanceof ApplicationContextAware) &#123;
                ((ApplicationContextAware) listener).setApplicationContext(context);
            &#125;
            context.addApplicationListener(listener);
        &#125;
        this.initialMulticaster.multicastEvent(
                new ApplicationPreparedEvent(this.application, this.args, context));
    &#125;

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;
        // Listeners have been registered to the application context so we should
        // use it at this point
        context.publishEvent(getFinishedEvent(context, exception));
    &#125;

    private SpringApplicationEvent getFinishedEvent(
            ConfigurableApplicationContext context, Throwable exception) &#123;
        if (exception != null) &#123;
            return new ApplicationFailedEvent(this.application, this.args, context,
                    exception);
        &#125;
        return new ApplicationReadyEvent(this.application, this.args, context);
    &#125;

&#125;
</code></pre>
<p>​        从上可以看出，<code>EventPublishingRunListener</code>里对接口功能的实现，主要是通过<code>SpringApplication</code> <code>ApplicationEventMulticaster</code> 来实现的，自己不干活，挂个虚名，从上帝模式的角度来看，这不就是应用了装饰模式来实现的么</p>
<h2 id="十四、单例模式"><a href="#十四、单例模式" class="headerlink" title="十四、单例模式"></a>十四、单例模式</h2><p>​        <strong>单例</strong>，我们最常用的设计模式。正如我们在很多Spring Framework中关于单例和原型bean的文章(网上太多了)中已经看到过的，单例是几个bean作用域中的中的一个。此作用域在每个应用程序上下文中仅创建一个给定bean的实例。与signleton设计模式有所区别的是，Spring将实例的数量限制的作用域在整个应用程序的上下文。而Singleton设计模式在Java应用程序中是将这些实例的数量限制在给定类加载器管理的整个空间中。这意味着我们可以为两个Spring的上下文(同一份配置文件起两个容器，也就是不同端口的容器实例)使用相同的类加载器，并检索两个单例作用域的bean。</p>
<p>​        在看Spring单例应用之前，让我们来看一个Java的单例例子：</p>
<pre><code class="java">public class SingletonTest &#123;

  @Test
  public void test() &#123;
    President president1 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    President president2 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    assertTrue(&quot;Both references of President should point to the same object&quot;, president1 == president2);
    System.out.println(&quot;president1 = &quot;+president1+&quot; and president2 = &quot;+president2);
    // sample output
    // president1 = com.migo.test.President@17414c8 and president2 = com.migo.test.President@17414c8

  &#125;

&#125;

enum SingletonsHolder &#123;

  PRESIDENT(new President());

  private Object holdedObject;

  private SingletonsHolder(Object o) &#123;
          this.holdedObject = o;
  &#125;

  public Object getHoldedObject() &#123;
          return this.holdedObject;
  &#125;

&#125;

class President &#123;
&#125;
</code></pre>
<p>​        这个测试例子证明，只有一个由SingletonsHolder所持有的President实例。在Spring中，我们可以在bean工厂中找到单例应用的影子（例如在<strong>org.springframework.beans.factory.config.AbstractFactoryBean中</strong>）：</p>
<pre><code class="java">/**
 * Expose the singleton instance or create a new prototype instance.
 * @see #createInstance()
 * @see #getEarlySingletonInterfaces()
 */
@Override
public final T getObject() throws Exception &#123;
  if (isSingleton()) &#123;
    return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());
  &#125;
  else &#123;
    return createInstance();
  &#125;
&#125;
</code></pre>
<p>​        我们看到，当需求对象被视为单例时，它只被初始化一次，并且在每次使用同一个bean类的实例后返回。我们可以在给定的例子中看到，类似于我们以前看到的President情况。将测试bean定义为：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; /&gt;
</code></pre>
<p>测试用例如下所示：</p>
<pre><code class="java">public class SingletonSpringTest &#123;

  @Test
  public void test() &#123;
    // retreive two different contexts
    ApplicationContext firstContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);
    ApplicationContext secondContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);

    // prove that both contexts are loaded by the same class loader
    assertTrue(&quot;Class loaders for both contexts should be the same&quot;,
      firstContext.getClassLoader() == secondContext.getClassLoader());
    // compare the objects from different contexts
    ShoppingCart firstShoppingCart = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    ShoppingCart secondShoppingCart = (ShoppingCart) secondContext.getBean(&quot;shoppingCart&quot;);
    assertFalse(&quot;ShoppingCart instances got from different application context shouldn&#39;t be the same&quot;,
      firstShoppingCart == secondShoppingCart);

    // compare the objects from the same context
    ShoppingCart firstShoppingCartBis = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;ShoppingCart instances got from the same application context should be the same&quot;,
      firstShoppingCart == firstShoppingCartBis);
  &#125;
&#125;
</code></pre>
<p>​        这个测试案例显示了Spring单例模式与纯粹的单例设计模式的主要区别。尽管使用相同的类加载器来加载两个应用程序上下文，但是ShoppingCart的实例是不一样的。但是，当我们比较两次创建并属于相同上下文的实例时，我们认为它们是相等的。</p>
<p>​        也正因为有了单例，Spring可以控制在每个应用程序上下文中只有一个这样指定的bean的实例可用。因为适配器，Spring可以决定使用由谁来处理<code>JBoss servlet</code>容器中的加载时编织,也可以实现<code>ConfigurableListableBeanFactory</code>的相应实例。第三种设计模式，装饰器，用于向Cache对象添加同步功能，还有Springboot的容器初始化。</p>
<p>​        其实对于适配器和装饰者确实有太多的相似的地方，一个是运行时选择，一个是加料组合产生新的化学效应，还有从看待事物的角度不同得到不同的行为，适配适配，更注重面向接口的实现，而内部又根据不同情况调用面向一套接口的多套实现的实例的相应方法来实现所要实现的具体功能，装饰者更注重添油加醋，通过组合一些其他对象实例来让自己的功能实现的更加华丽一些(达到1+1&gt;2的这种效果)。</p>
<h2 id="十五、命令模式"><a href="#十五、命令模式" class="headerlink" title="十五、命令模式"></a>十五、命令模式</h2><p>​        这篇文章描述的第一个行为设计模式是<strong>命令</strong>。它允许将请求封装在一个对象内并附加一个回调动作(每次遇到所所谓的回调大家就只需要理解为一个函数方法就好，省的去浪费那么多脑子)。请求被封装在命令对象之下，而请求的结果被发送到接收者。命令本身不是由调用者执行。为了直白了解其中的主要思想，想象一下管理服务器的情况(远程通过<code>ssh</code>操作<code>Linux</code>服务器)。管理员（<code>invoker</code>）在命令行（<code>commands</code>）中启动一些操作，将结果发送到服务器（接收器）。在这里,所有这一切都是由客户端的终端(也就是我们用的<code>xshell</code>)来完成的。搞个<code>Demo</code>来说明一下(对于命令，它的动作就是执行，对于管理员来讲，我们的动作其实就是一个回车，执不执行当然是管理员说的算了，执行交给命令对象了，服务器最后就是一个展示结果)：</p>
<pre><code class="java">public class CommandTest &#123;

  // This test method is a client
  @Test
  public void test() &#123;
    Administrator admin = new Administrator();
    Server server = new Server();

    // start Apache
    admin.setCommand(new StartApache(server));
    admin.typeEnter();

    // start Tomcat
    admin.setCommand(new StartTomcat(server));
    admin.typeEnter();

    // check executed commands
    int executed = server.getExecutedCommands().size();
    assertTrue(&quot;Two commands should be executed but only &quot;+
      executed+ &quot; were&quot;, executed == 2);
  &#125;

&#125;

// commands
abstract class ServerCommand &#123;

  protected Server server;

  public ServerCommand(Server server) &#123;
    this.server = server;
  &#125;

  public abstract void execute();
&#125;

class StartTomcat extends ServerCommand &#123;

  public StartTomcat(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service tomcat7 start&quot;);
  &#125;
&#125;

class StartApache extends ServerCommand &#123;

  public StartApache(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service apache2 start&quot;);
  &#125;
&#125;

// invoker
class Administrator &#123;

  private ServerCommand command;

  public void setCommand(ServerCommand command) &#123;
    this.command = command;
  &#125;

  public void typeEnter() &#123;
    this.command.execute();
  &#125;

&#125;

// receiver
class Server &#123;

  // as in common terminals, we store executed commands in history
  private List&lt;String&gt; executedCommands = new ArrayList&lt;String&gt;();

  public void launchCommand(String command) &#123;
    System.out.println(&quot;Executing: &quot;+command+&quot; on server&quot;);
    this.executedCommands.add(command);
  &#125;

  public List&lt;String&gt; getExecutedCommands() &#123;
    return this.executedCommands;
  &#125;

&#125;
</code></pre>
<p>测试应通过并打印两个命令：</p>
<pre><code class="java">Executing: sudo service apache2 start on server
Executing: sudo service tomcat7 start on server
</code></pre>
<p>​        命令模式不仅允许封装请求（ServerCommand）并将其传输到接收器（Server），而且还可以更好地处理给定的请求。在这里，这种更好的处理是通过存储命令的执行历史。在Spring中，我们在beanFactory后置处理器的特性中来找到指令设计模式的原理。要通过快速对它们进行定义，应用程序上下文会启动后置处理器，并可以用来对创建的bean进行一些操作（这里不打算细说了，具体的我后面会专门写一篇这方面的文章，来分析其中的源码细节）。</p>
<p>​        当我们将先前Demo里呈现的命令逻辑转换并对比到<code>Spring bean工厂后处理器</code>时，我们可以区分以下<code>actors</code>：<strong>后置处理器bean</strong>(是指实现<code>BeanFactoryPostProcessor</code>接口)是命令，<strong>org.springframework.context.support.PostProcessorRegistrationDelegate</strong>是调用者(它执行<code>postProcessBeanFactory</code>方法注册所有的后置处理器bean，此处看下面第二段代码)和接收器<strong>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</strong>可以在元素（bean）构造初始化之前修改它们（例如：在初始化bean之前可以更改属性）。</p>
<p>​        另外，回顾下上面的那个Demo，和我们的Demo中的命令历史管理一样。<code>PostProcessorRegistrationDelegate</code>包含一个内部类<code>BeanPostProcessorChecker</code>，它可以记录当一个bean不符合处理条件的情况。</p>
<p>​        可以观察<code>PostProcessorRegistrationDelegate</code>中的两段代码:</p>
<pre><code class="java">/**
     * BeanPostProcessor that logs an info message when a bean is created during
     * BeanPostProcessor instantiation, i.e. when a bean is not eligible for
     * getting processed by all BeanPostProcessors.
     */
    private static class BeanPostProcessorChecker implements BeanPostProcessor &#123;

        private static final Log logger = LogFactory.getLog(BeanPostProcessorChecker.class);

        private final ConfigurableListableBeanFactory beanFactory;

        private final int beanPostProcessorTargetCount;

        public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) &#123;
            this.beanFactory = beanFactory;
            this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
        &#125;

        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;
            return bean;
        &#125;

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) &#123;
            if (bean != null &amp;&amp; !(bean instanceof BeanPostProcessor) &amp;&amp; !isInfrastructureBean(beanName) &amp;&amp;
                    this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount) &#123;
                if (logger.isInfoEnabled()) &#123;
                    logger.info(&quot;Bean &#39;&quot; + beanName + &quot;&#39; of type [&quot; + bean.getClass() +
                            &quot;] is not eligible for getting processed by all BeanPostProcessors &quot; +
                            &quot;(for example: not eligible for auto-proxying)&quot;);
                &#125;
            &#125;
            return bean;
        &#125;

        private boolean isInfrastructureBean(String beanName) &#123;
            if (beanName != null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName)) &#123;
                BeanDefinition bd = this.beanFactory.getBeanDefinition(beanName);
                return RootBeanDefinition.ROLE_INFRASTRUCTURE == bd.getRole();
            &#125;
            return false;
        &#125;
    &#125;
</code></pre>
<p>​        定义后的调用,用的就是<code>ConfigurableListableBeanFactory</code>的实例(看<code>BeanPostProcessorChecker</code>注释):</p>
<pre><code class="java">public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  //BeanPostProcessorChecker
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                    internalPostProcessors.add(pp);
                &#125;
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        sortPostProcessors(beanFactory, orderedPostProcessors);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(beanFactory, internalPostProcessors);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    &#125;
</code></pre>
<blockquote>
<p>总结一个过程就是，我要BeanFactory里面得到对象(也就是为了得到一个命令的执行结果)，那么，想要在得到对象的时候就已经实现了一些对其修改的想法，那么就通过后置处理器，也是就实现了后置处理器接口的beans(命令里可以通过传入不同的参数来得到不同结果，或者对命令的脚本进行修改)，然后还需要一个执行者(我们在做自动化运维的时候，不止操作一个脚本，这里的<code>PostProcessorRegistrationDelegate</code>就是集中来管理这些的)，最后得到的结果就由<code>BeanFactory</code>来展示咯。</p>
</blockquote>
<h2 id="十六、访问者模式"><a href="#十六、访问者模式" class="headerlink" title="十六、访问者模式"></a>十六、访问者模式</h2><p>​        接下来要介绍的一个行为设计模式是<strong>Visitor</strong>:抽象一点就是通过另一种类型的对象来使一个对象访问。在这个简短定义中，使用这个设计模式中的对象将被视为访问者或对象可被访问。第一个访问者要有可访问支持。这个模式的一个现实的例子可以是一个汽车质检员，他们检查一些汽车零件，比如轮子，制动器和发动机，以判断汽车质量是否合格。我们来做个JUnit测试用例：</p>
<pre><code class="java">public class VisitorTest &#123;

  @Test
  public void test() &#123;
    CarComponent car = new Car();
    Mechanic mechanic = new QualifiedMechanic();
    car.accept(mechanic);
    assertTrue(&quot;After qualified mechanics visit, the car should be broken&quot;,
      car.isBroken());
    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();
    car.accept(nonqualifiedMechanic);
    assertFalse(&quot;Car shouldn&#39;t be broken becase non qualified mechanic &quot; +
      &quot; can&#39;t see breakdowns&quot;, car.isBroken());
  &#125;

&#125;

// visitor
interface Mechanic &#123;
  public void visit(CarComponent element);
  public String getName();
&#125;

class QualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;qualified&quot;;
  &#125;
&#125;

class NonQualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;unqualified&quot;;
  &#125;
&#125;

// visitable
abstract class CarComponent &#123;
  protected boolean broken;

  public abstract void accept(Mechanic mechanic);

  public void setBroken(boolean broken) &#123;
    this.broken = broken;
  &#125;

  public boolean isBroken() &#123;
    return this.broken;
  &#125;
&#125;

class Car extends CarComponent &#123;

  private boolean broken = false;
  private CarComponent[] components;

  public Car() &#123;
    components = new CarComponent[] &#123;
      new Wheels(), new Engine(), new Brake()
    &#125;;
  &#125;

  @Override
  public void accept(Mechanic mechanic) &#123;
    this.broken = false;
    if (mechanic.getName().equals(&quot;qualified&quot;)) &#123;
      int i = 0;
      while (i &lt; components.length &amp;&amp; this.broken == false) &#123;
        CarComponent component = components[i];
        mechanic.visit(component);
        this.broken = component.isBroken();
        i++;
      &#125;
    &#125;
    // if mechanic isn&#39;t qualified, we suppose that
    // he isn&#39;t able to see breakdowns and so
    // he considers the car as no broken
    // (even if the car is broken)
  &#125;

  @Override
  public boolean isBroken() &#123;
          return this.broken;
  &#125;
&#125;

class Wheels extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Engine extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Brake extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;
</code></pre>
<p>​        在这个例子中，我们可以看到他们有两个机制(访问者,其实就是免检和不免检)：合格和不合格。暴露于他们的可见对象是汽车。通过其接受方式，决定哪个角色应该适用于被访问者(通过代码<code>mechanic.getName().equals(&quot;qualified&quot;)</code>来判断)。当访问者合格时，Car让他分析所有组件。如果访问者不合格，Car认为其干预是无用的，并且在方法<code>isBroken()</code>中直接返回<code>false</code>(其实就是为了达到一个免检的效果)。<code>Spring在beans配置中实现了访问者设计模式</code>。为了观察，我们可以看看<strong>org.springframework.beans.factory.config.BeanDefinitionVisitor</strong>对象，该对象用于<code>解析bean元数据</code>并将其解析为<code>String</code>（例如：具有作用域或工厂方法名称的XML属性）或<code>Object</code>（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的<code>BeanDefinition</code>实例中进行判断设置。具体的源码请看<code>BeanDefinitionVisitor</code>的代码片段：</p>
<pre><code class="java">/**
 * Traverse the given BeanDefinition object and the MutablePropertyValues
 * and ConstructorArgumentValues contained in them.
 * @param beanDefinition the BeanDefinition object to traverse
 * @see #resolveStringValue(String)
 */
public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;
  visitParentName(beanDefinition);
  visitBeanClassName(beanDefinition);
  visitFactoryBeanName(beanDefinition);
  visitFactoryMethodName(beanDefinition);
  visitScope(beanDefinition);
  visitPropertyValues(beanDefinition.getPropertyValues());
  ConstructorArgumentValues cas = beanDefinition.
    getConstructorArgumentValues();
  visitIndexedArgumentValues(cas.
    getIndexedArgumentValues());
  visitGenericArgumentValues(cas.
    getGenericArgumentValues());
&#125;

protected void visitParentName(BeanDefinition beanDefinition) &#123;
  String parentName = beanDefinition.getParentName();
  if (parentName != null) &#123;
    String resolvedName = resolveStringValue(parentName);
    if (!parentName.equals(resolvedName)) &#123;
      beanDefinition.setParentName(resolvedName);
    &#125;
  &#125;
&#125;
</code></pre>
<p>​        在这种情况下，他们只是访问方式，没有对访问者做任何补充的控制(在Demo里对car的质检员做了控制)。这里访问包括分析给定<code>BeanDefinition</code>的参数，并将其替换为已解析对象。</p>
<p>在这篇关于Spring中设计模式的文章中，我们发现了2种行为模式：<code>用于处理bean工厂的后置处理的命令模式</code>和<code>用于将定义的bean参数转换为面向对象（String或Object的实例）参数的访问者模式</code>。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Spring" style=color:#ff7d73>
                Spring
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/Spring/Spring框架中的设计模式/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            Shuyan
        </div>
        <div class="descriptions">
            
            <div class="description">
                正しさなんてもの
            </div>
            
            <div class="description">
                人のモノサシによって変わる
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://en.korilin.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://jp.korilin.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>