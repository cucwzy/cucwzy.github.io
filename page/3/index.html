
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Stay Hungry, Stay Foolish</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Shuyan</h1>
                <h3>Stay Hungry, Stay Foolish</h3>
                <h5>ShuyanCoding......</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/">
        <h2>
            SpringMVC使用详解
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                JAVA
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="SpringMVC使用详解"><a href="#SpringMVC使用详解" class="headerlink" title="SpringMVC使用详解"></a>SpringMVC使用详解</h1><h2 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h2><h3 id="1-1、什么是-SpringMVC"><a href="#1-1、什么是-SpringMVC" class="headerlink" title="1.1、什么是 SpringMVC"></a>1.1、什么是 SpringMVC</h3><p>​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架</p>
<h3 id="1-2、为什么学习-SpringMVC"><a href="#1-2、为什么学习-SpringMVC" class="headerlink" title="1.2、为什么学习 SpringMVC"></a>1.2、为什么学习 SpringMVC</h3><p>​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定大于配置，能够进行简单的 junit 测试，支持 Restful 风格，异常处理，本地化，国际化，数据验证，类型转换，拦截器，等等</p>
<h3 id="1-3、SpringMVC-的特点"><a href="#1-3、SpringMVC-的特点" class="headerlink" title="1.3、SpringMVC 的特点"></a>1.3、SpringMVC 的特点</h3><ul>
<li>简单好学</li>
<li>高效（基于请求相应的 MVC 框架）</li>
<li>与 Spring 无缝集成，兼容性好</li>
<li>约定大于配置</li>
<li>功能强大（Restful、数据验证、格式化、本地化、类型转换、等等）</li>
<li>简洁灵活</li>
</ul>
<h2 id="二、中心控制器"><a href="#二、中心控制器" class="headerlink" title="二、中心控制器"></a>二、中心控制器</h2><p>​        Spring 的 web 框架围绕 DispatcherServlet 设计。<strong>DispatcherServlet 的作用是将请求分发到不同的处理器</strong>。从 Spring 2.5 开始，使用 Java 5 或者以上版本的用户可以采用基于注解的 controller 声明方式。</p>
<p>​        Spring MVC 框架像许多其他 MVC 框架一样, 以请求为驱动 , 围绕一个中心 Servlet 分派请求及提供其他功能，DispatcherServlet 是一个实际的 Servlet (它继承自 HttpServlet 基类)。</p>
<p><img src="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        SpringMVC的原理如下图所示：</p>
<ul>
<li>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</li>
</ul>
<h2 id="三、SpringMVC原理"><a href="#三、SpringMVC原理" class="headerlink" title="三、SpringMVC原理"></a>三、SpringMVC原理</h2><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringMVC执行原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet 表示前置控制器，是整个 SpringMVC 的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。</p>
<p>​        我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p>​        如上 url 拆分成三部分：</p>
<ul>
<li><p> <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 服务器域名</p>
</li>
<li><p> SpringMVC 部署在服务器上的 web 站点</p>
</li>
<li><p>hello 表示控制器</p>
</li>
</ul>
<p> 通过分析，如上 url 表示为：请求位于服务器 localhost:8080上的Spring MVC站点的 hello 控制器。</p>
</li>
<li><p>HandlerMapping 为处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</p>
</li>
<li><p>HandlerExecution 表示具体的Handler，其主要作用是根据 url 查找控制器，如上 url 被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution 将解析后的信息传递给 DispatcherServlet，如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行 Handler。</p>
</li>
<li><p>Handler 让具体的 Controller 执行。</p>
</li>
<li><p>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</p>
</li>
<li><p>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="四、HelloSpringMVC"><a href="#四、HelloSpringMVC" class="headerlink" title="四、HelloSpringMVC"></a>四、HelloSpringMVC</h2><h3 id="4-1、配置版"><a href="#4-1、配置版" class="headerlink" title="4.1、配置版"></a>4.1、配置版</h3><p><strong>步骤：</strong></p>
<ol>
<li>新建一个 项目，添加 web 支持</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件（springmvc-service.xml）</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
</ol>
<pre><code class="xml">&lt;!--配置DispatchServlet：这个是SpringMVC的核心：请求分发器，前端控制器--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--DispatchServlet要绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-service.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--
    在Spring中，/ 与 /* 的区别
    /:只匹配所有的请求，不会去匹配jsp
    /*：匹配所有请求，包括jsp页面
--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>继续配置 SpringMVC 的配置文件（springmvc-servlet.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>添加 <strong>处理映射器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>处理器适配器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>视图解析器</strong></li>
</ul>
<pre><code class="xml">&lt;!--视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="6">
<li>编写操作业务的 Controller</li>
</ol>
<ul>
<li>要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图</li>
</ul>
<pre><code class="java">public class HelloController implements Controller &#123;
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //业务代码
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC！&quot;);
        
        //视图解释
        mv.setViewName(&quot;hello&quot;);//需要拼接的视图名称，参考视图解析器的代码实际地址就是（/WEB-INF/jsp/hello.jsp）
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>注册 bean（将 HelloController 这个类交给 Spring 容器【IOC】）</li>
</ol>
<pre><code class="xml">&lt;!--BeanNameUrlHandlerMapping:匹配的id(Handler)--&gt;
&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.aze.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="8">
<li>编写跳转页面，显示 ModelandView 存放的数据，以及我们编写的页面</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><strong>大多数都会遇到的问题！</strong></p>
<p>即使你的代码正确，但是却一直报出 404 错误！</p>
<ul>
<li><p>问题原因可能就在于 IDEA 项目发布中，缺少了 springMVC 相关的 jar 包</p>
</li>
<li><p>解决办法：</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>在 WEB-INF 下创建一个 lib 目录，在这个目录下存放 相关的 jar 包</p>
<p><img src="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将所有的<strong>包</strong>导入，点击 ok</p>
</li>
</ul>
</li>
</ul>
<p>​                </p>
<p><img src="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2、注解版（-）"><a href="#4-2、注解版（-）" class="headerlink" title="4.2、注解版（*）"></a>4.2、注解版（*）</h3><p>步骤：</p>
<ol>
<li>新建一个项目，添加 web 支持</li>
<li>解决 Maven 可能存在资源过滤的问题</li>
</ol>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ol start="3">
<li><p>在 pom.xml 文件引入相关的依赖：主要有 Spring 框架核心库、Spring MVC、servlet , JSTL 等</p>
</li>
<li><p>配置 web.xml</p>
</li>
</ol>
<pre><code class="xml">&lt;!--这是使用注解开发时固定的配置--&gt;
&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--初始化Spring配置文件的位置--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动顺序，数字越小，启动越早--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--所有的请求都会被SpringMVC拦截--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>编写 springmvc-servlet.xml 配置文件</li>
</ol>
<ul>
<li>配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能</li>
<li>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问<ul>
<li>让IOC的注解生效（context:component-scan base-package=””）</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …（mvc:default-servlet-handler）</li>
<li>MVC的注解驱动（mvc:annotation-driven）</li>
<li>配置视图解析器（开发中，程序员只需要配置这一步，其他的都是死的，CV 就可以）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
    &lt;!--这也是固定配置，需要修改的只有需要注入IOC的包--&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="6">
<li>编写一个 Java 控制类 HelloController.java</li>
</ol>
<ul>
<li>@Controller 是为了让 Spring IOC 容器初始化时自动扫描到；</li>
<li>@RequestMapping 是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是 /hello/hi；</li>
<li>方法中声明 Model 类型的参数是为了把 Action 中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称 hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</li>
</ul>
<pre><code class="java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    //类上注册了@RequestMapping方法就自动下移，实际地址：项目名/hello/hi
    @RequestMapping(&quot;/hi&quot;)
    public String sayHello(Model model)&#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVCAnnotatiom!&quot;);
        //web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>编写视图层 hello.jsp</li>
</ol>
<ul>
<li>视图可以直接取出并展示从 Controller 带回的信息；</li>
<li>可以通过 EL 表示取出 Model 中存放的值，或者对象</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h3 id="4-3、结论"><a href="#4-3、结论" class="headerlink" title="4.3、结论"></a>4.3、结论</h3><p>实现步骤：</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
<li><p>编写 web.xml , 注册 DispatcherServlet</p>
</li>
<li><p>编写 springmvc 配置文件</p>
</li>
<li><p>接下来就是去创建对应的控制类 , controller</p>
</li>
<li><p>最后完善前端视图和 controller 之间的对应</p>
</li>
<li><p>测试运行调试.</p>
</li>
</ol>
<p><strong>使用springMVC必须配置的三大件：</strong></p>
<ul>
<li><p>处理器映射器</p>
</li>
<li><p>处理器适配器</p>
</li>
<li><p>视图解析器</p>
</li>
</ul>
<p>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。</p>
<h2 id="五、注解"><a href="#五、注解" class="headerlink" title="五、注解"></a>五、注解</h2><h3 id="5-1、Controller"><a href="#5-1、Controller" class="headerlink" title="5.1、Controller"></a>5.1、Controller</h3><p>Controller 控制器</p>
<p>负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
<p>负责解析用户的请求并将其转换为一个模型。</p>
<p>在 Spring MVC 中一个控制器类可以包含多个方法</p>
<p>在 Spring MVC 中，对于 Controller 的配置方式有很多种</p>
<h4 id="5-1-1、实现-Controller-接口"><a href="#5-1-1、实现-Controller-接口" class="headerlink" title="5.1.1、实现 Controller 接口"></a>5.1.1、实现 Controller 接口</h4><p>Controller是一个接口</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p>步骤：（上面 HelloSpringMVC 的配置版就是 实现 Controller 接口）</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入 SpringMVC 的依赖</p>
</li>
<li><p>创建 SpringMVC 的配置文件（springmvc-service.xml）</p>
<ul>
<li>删掉 HelloController</li>
<li>只留下 视图解析器！</li>
</ul>
</li>
<li><p>配置 web.xml，注册 DispatcherServlet</p>
</li>
<li><p>编写一个 Controller 类</p>
</li>
<li><p>编写完毕后，去 Spring 配置文件中注册请求的 bean</p>
<ul>
<li>name 对应请求路径</li>
<li>class 对应处理请求的类</li>
</ul>
</li>
<li><p>编写前端 hello.jsp</p>
<ul>
<li>注意：在 WEB-INF/jsp 目录下编写，对应我们的视图解析器</li>
</ul>
</li>
<li><p>配置 Tomcat 运行测试<br>注意：实现接口 Controller 定义控制器是较老的办法<br>缺点：</p>
<ul>
<li>一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</li>
<li>定义的方式比较麻烦；</li>
</ul>
</li>
</ol>
<h4 id="5-1-2、注解-Controller"><a href="#5-1-2、注解-Controller" class="headerlink" title="5.1.2、注解 @Controller"></a>5.1.2、注解 @Controller</h4><ul>
<li>@Controller 注解类型用于声明 Spring 类的实例是一个控制器（<ul>
<li><strong>@Controller：</strong>用于controller</li>
<li><strong>@Component：</strong>用于组件</li>
<li><strong>@Repository：</strong>用于 dao</li>
<li><strong>@Service：</strong>用于 service</li>
</ul>
</li>
<li>Spring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证 Spring 能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<p>步骤：（4.2 注解版就是用注解 @Controller）</p>
<ol>
<li>新建一个 web 项目</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
<li>编写一个 Controller 类</li>
<li>使用注解（）</li>
<li>编写前端 hello.jsp</li>
<li>配置 Tomcat 运行测试</li>
</ol>
<h3 id="5-2、RequestMapping"><a href="#5-2、RequestMapping" class="headerlink" title="5.2、RequestMapping"></a>5.2、RequestMapping</h3><ul>
<li>@RequestMapping<pre><code>+ @RequestMapping 注解用于映射 url 到控制器类或一个特定的处理程序方法。
</code></pre>
可用于类或方法上<ul>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<ul>
<li>用于方法上，方法的响应请求是该地址</li>
</ul>
</li>
</ul>
<strong>建议：</strong>类上不要使用此注解</li>
</ul>
<h2 id="六、RestFul风格"><a href="#六、RestFul风格" class="headerlink" title="六、RestFul风格"></a>六、RestFul风格</h2><h3 id="6-1、什么是-RestFul"><a href="#6-1、什么是-RestFul" class="headerlink" title="6.1、什么是 RestFul"></a>6.1、什么是 RestFul</h3><p>Restful 就是一个资源定位及资源操作的风格。</p>
<ul>
<li>不是标准也不是协议，只是一种风格</li>
<li>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
</ul>
<h3 id="6-2、RestFul-功能"><a href="#6-2、RestFul-功能" class="headerlink" title="6.2、RestFul 功能"></a>6.2、RestFul 功能</h3><p>资源：互联网所有的事物都可以被抽象为资源</p>
<ul>
<li><p>资源操作：使用 POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
</li>
<li><p>分别对应 添加、 删除、修改、查询。</p>
</li>
</ul>
<p><strong>传统方式操作资源 ：</strong>通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源 ：</strong>可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<h3 id="6-3、测试-RestFul-风格"><a href="#6-3、测试-RestFul-风格" class="headerlink" title="6.3、测试 RestFul 风格"></a>6.3、测试 RestFul 风格</h3><h4 id="6-3-1、使用-RequestMapping"><a href="#6-3-1、使用-RequestMapping" class="headerlink" title="6.3.1、使用 @RequestMapping"></a>6.3.1、使用 @RequestMapping</h4><p>步骤：</p>
<ol>
<li><p>新建一个 Controller 类，用于测试 RestFul 风格</p>
</li>
<li><p>在 Spring MVC 中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
</li>
</ol>
<pre><code class="java">@Controller
public class RestFulTest &#123;

    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;
        int result = a + b;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;hello&quot;;
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>修改下对应的参数类型，再次测试</li>
</ol>
<pre><code class="java">// 将 int b，改为 String b
@PathVariable int a, @PathVariable String b
    
// 对应的 result 也需要改为 String
String result = a+b;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="6-3-2、使用注解变体"><a href="#6-3-2、使用注解变体" class="headerlink" title="6.3.2、使用注解变体"></a>6.3.2、使用注解变体</h4><p>使用method属性指定请求类型：</p>
<ul>
<li>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE 等</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<p>问题？</p>
<p>​        这样写，代码量就会变多，这时候，注解变体他来了！<br>注解变体：（方法级别）</p>
<ul>
<li>@GetMapping：GET 类型</li>
<li>@PostMapping：POST 类型</li>
<li>@PutMapping：PUT 类型</li>
<li>@DeleteMapping：DELETE 类型</li>
<li>@PatchMapping：PATCH 类型</li>
</ul>
<pre><code class="java">// 使用注解变体
@GetMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
// 等价于 @RequestMapping(value = &quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<h3 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h3><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。（注意！！！）</p>
<p><strong>@GetMapping 是一个组合注解</strong>，平时使用的会比较多！</p>
<p>使用浏览器地址栏进行访问默认是 Get 请求，会报错 405</p>
<p>解决办法：将 POST 修改为 GET 就好了</p>
<h2 id="七、转发与重定向"><a href="#七、转发与重定向" class="headerlink" title="七、转发与重定向"></a>七、转发与重定向</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置 ModelAndView 对象 , 根据 view 的名称 , 和视图解析器跳到指定的页面 .</p>
<ul>
<li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li>
</ul>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>controller 类</li>
</ul>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>这是 JavaWeb 中学习到的用法：</p>
<ul>
<li>通过设置 ServletAPI，不需要视图解析器 .<ol>
<li>通过 HttpServletResponse 进行输出</li>
</ol>
</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/test1&quot;)
public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
&#125;
</code></pre>
<p>​        2. 通过 HttpServletResponse 实现重定向（重定向）</p>
<pre><code class="java">@RequestMapping(&quot;test2&quot;)
public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.sendRedirect(&quot;/index.jsp&quot;);
&#125;
</code></pre>
<ol start="3">
<li>通过 HttpServletResponse 实现转发（请求转发）</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/test3&quot;)
public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
    // 转发
    req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
    req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
&#125;
</code></pre>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><h4 id="7-3-1、无视图解析器"><a href="#7-3-1、无视图解析器" class="headerlink" title="7.3.1、无视图解析器"></a>7.3.1、无视图解析器</h4><pre><code class="java">@RequestMapping(&quot;/rsm/t1&quot;)
public String test1()&#123;
    // 默认就是转发
    return &quot;/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t2&quot;)
public String test2()&#123;
    // 也可以显示定义转发
    return &quot;forward:/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t3&quot;)
public String test3()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
<h4 id="7-3-2、有视图解析器"><a href="#7-3-2、有视图解析器" class="headerlink" title="7.3.2、有视图解析器"></a>7.3.2、有视图解析器</h4><p>​        重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方 , 所以注意路径问题.</p>
<pre><code class="java">@RequestMapping(&quot;/rsm2/t1&quot;)
public String test1()&#123;
    // 转发：默认就是转发
    return &quot;test&quot;;
&#125;

@RequestMapping(&quot;/rsm2/t2&quot;)
public String test2()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
    // return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
&#125;
</code></pre>
<h2 id="八、数据处理"><a href="#八、数据处理" class="headerlink" title="八、数据处理"></a>八、数据处理</h2><h3 id="8-1、处理提交数据"><a href="#8-1、处理提交数据" class="headerlink" title="8.1、处理提交数据"></a>8.1、处理提交数据</h3><ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数名不一致，就需要使用注解 @RequestParam 来解决</li>
</ol>
<pre><code class="java">// @RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<ul>
<li>实体类</li>
</ul>
<pre><code class="java">// 这里使用的是 Lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private int age;
&#125;
</code></pre>
<ul>
<li>Controller 类</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<h3 id="8-2、数据显示到前端"><a href="#8-2、数据显示到前端" class="headerlink" title="8.2、数据显示到前端"></a>8.2、数据显示到前端</h3><ol>
<li>通过 ModelAndView</li>
</ol>
<pre><code class="java">public class ControllerTest implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>通过ModelMap</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>通过 Model</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<p>区别：</p>
<ul>
<li><p>Model：只有寥寥几个方法只适合用于储存数据，简化了新手对于 Model 对象的操作和理解</p>
</li>
<li><p>ModelMap：继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView：可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<h2 id="九、中文乱码问题"><a href="#九、中文乱码问题" class="headerlink" title="九、中文乱码问题"></a>九、中文乱码问题</h2><p>解决办法：</p>
<ol>
<li>自我编写一个过滤器，再注册到 web.xml 文件中</li>
</ol>
<pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;

    // 初始化：web 服务器启动，就已经初始化了，随时等待过滤对象的出现
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    // 销毁：web 服务器关闭时，过滤器会销毁
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用 SpringMVC 自带的过滤器</li>
</ol>
<ul>
<li>导入相关依赖后，直接配置 web.xml 即可</li>
</ul>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="3">
<li>使用大佬配置的过滤器</li>
</ol>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                                       .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
<p>​        以上都不行可能是你的 Tomcat 没有配置好！去修改 tomcat 配置文件 ：设置编码</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<h2 id="十、Json"><a href="#十、Json" class="headerlink" title="十、Json"></a>十、Json</h2><ul>
<li>JSON（JavaScript Object Notation, JS 对象标记） 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。（前后端分离）</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<h3 id="10-1、JSON-与-JavaScript"><a href="#10-1、JSON-与-JavaScript" class="headerlink" title="10.1、JSON 与 JavaScript"></a>10.1、JSON 与 JavaScript</h3><p>在 JavaScript 语言中，一切都是对象。因此，任何 JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li><p>对象表示为键值对，数据由逗号分隔</p>
</li>
<li><p>花括号保存对象</p>
</li>
<li><p>方括号保存数组</p>
</li>
</ul>
<p>​        <strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值（ {“键” : “值”} ）。</p>
<p>​        JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br><strong>JSON 和 JavaScript 对象互转：</strong></p>
<ul>
<li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法</li>
</ul>
<pre><code class="java">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);
</code></pre>
<ul>
<li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法</li>
</ul>
<pre><code class="java">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
<h3 id="10-2、Controller-返回-JSON-数据"><a href="#10-2、Controller-返回-JSON-数据" class="headerlink" title="10.2、Controller 返回 JSON 数据"></a>10.2、Controller 返回 JSON 数据</h3><ul>
<li>Jackson 应该是目前比较好的 json 解析工具了</li>
<li>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</li>
<li>这里使用的是 Jackson，使用它需要导入它的 jar 包；</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>web.xml 配置 SpringMVC 需要的配置<ul>
<li>servlet 注册 SpringMVC</li>
<li>filter 注册字符过滤器</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ul>
<li>编写 springmvc-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>编写一个实体类 User，去测试<ul>
<li>需要导入 lombok 的 jar 包</li>
</ul>
</li>
</ul>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<ul>
<li>编写 UserController<ul>
<li>@ResponseBody：将 java 对象转化为 json</li>
<li>ObjectMapper：创建一个 jackson 的对象映射器，用来解析数据</li>
</ul>
</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置 Tomcat</li>
<li>配置 Artifacts</li>
</ul>
<p>问题：乱码问题</p>
<p><img src="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center" alt="在这里插入图片描述"></p>
<p>解决办法：通过 @RequestMaping 的 produces 属性来实现</p>
<pre><code class="java">// produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
<h3 id="10-3、Controller-返回-JSON-数据代码优化"><a href="#10-3、Controller-返回-JSON-数据代码优化" class="headerlink" title="10.3、Controller 返回 JSON 数据代码优化"></a>10.3、Controller 返回 JSON 数据代码优化</h3><h4 id="10-3-1、将乱码问题统一解决"><a href="#10-3-1、将乱码问题统一解决" class="headerlink" title="10.3.1、将乱码问题统一解决"></a>10.3.1、将乱码问题统一解决</h4><p>上面解决乱码的方法在项目请求多的情况下就不适用了</p>
<p>就可以使用 Spring 配置统一指定返回类型和编码，等等</p>
<ul>
<li>在 spring-mvc 的配置文件上添加一段消息<ul>
<li>StringHttpMessageConverter 转换配置</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<h4 id="10-3-2、统一解决返回为-json-字符串问题"><a href="#10-3-2、统一解决返回为-json-字符串问题" class="headerlink" title="10.3.2、统一解决返回为 json 字符串问题"></a>10.3.2、统一解决返回为 json 字符串问题</h4><p>如果类中有所有的方法都需要返回 json 字符串，那么所有的方法都需要标识注释 @ResponseBody，这将会特别麻烦</p>
<ul>
<li>所以直接在类上使用 @RestController 来标注这个类的所有方法返回的都是 json 字符串<ul>
<li>这样就不用再每个方法上写 @ResponseBody</li>
<li>前后端分离开发中，一般都会使用 @RestController ，十分便捷</li>
</ul>
</li>
</ul>
<h3 id="10-4、测试集合的输出"><a href="#10-4、测试集合的输出" class="headerlink" title="10.4、测试集合的输出"></a>10.4、测试集合的输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
public String json2() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();

    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛逼1&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼2&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼3&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼4&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼5&quot;,18,&quot;男&quot;));

    return mapper.writeValueAsString(userList);
&#125;
</code></pre>
<h3 id="10-5、测试时间对象输出"><a href="#10-5、测试时间对象输出" class="headerlink" title="10.5、测试时间对象输出"></a>10.5、测试时间对象输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();
    Date date = new Date();
    // 默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式
    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<p>默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式：</p>
<ul>
<li>取消 timestamps（时间戳）形式，自定义时间格式</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();

    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<h3 id="10-6、将重复代码抽取为工具类"><a href="#10-6、将重复代码抽取为工具类" class="headerlink" title="10.6、将重复代码抽取为工具类"></a>10.6、将重复代码抽取为工具类</h3><p>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中</p>
<pre><code class="java">public class JsonUtils &#123;
    public static String getJson(Object object)&#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat)&#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>使用工具类后的代码量</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    return JsonUtils.getJson(new Date());
&#125;
</code></pre>
<h3 id="10-7、FastJson"><a href="#10-7、FastJson" class="headerlink" title="10.7、FastJson"></a>10.7、FastJson</h3><p>fastjson.jar 是阿里开发的一款专门用于 Java 开发的包，可以方便的实现多种转换，最后的实现结果都是一样的。</p>
<ul>
<li><p>实现 json 对象与 JavaBean 对象的转换</p>
</li>
<li><p>实现 JavaBean 对象与 json 字符串的转换</p>
</li>
<li><p>实现 json 对象与 json 字符串的转换。实现 son的 转换方法很多</p>
</li>
</ul>
<p><strong>fastjson 的 pom 依赖：</strong></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.78&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject 实现了 Map 接口, 猜想 JSONObject 底层操作是由 Map 实现的。</li>
<li>JSONObject 对应 json对 象，通过各种形式的 get() 方法可以获取 json 对象中的数据，也可利用诸如 size()，isEmpty() 等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有 List 接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON 代表 JSONObject 和 JSONArray 的转化</strong></p>
<ul>
<li>JSON 类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现 json 对象，json 对象数组，javabean 对象，json 字符串之间的相互转化。</li>
</ul>
<p>代码测试：</p>
<pre><code class="java">@RequestMapping(&quot;/json6&quot;)
public String json6()&#123;
    //创建一个对象
    User user1 = new User(&quot;1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    userList.add(user4);

    System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
    String str1 = JSON.toJSONString(userList);
    System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
    String str2 = JSON.toJSONString(user1);
    System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

    System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
    User jp_user1=JSON.parseObject(str2,User.class);
    System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

    System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
    JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
    System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

    System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
    User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
    System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    
    return JSON.toJSONString(userList);
&#125;
</code></pre>
<h2 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h2><h3 id="11-1、什么是-Ajax"><a href="#11-1、什么是-Ajax" class="headerlink" title="11.1、什么是 Ajax"></a>11.1、什么是 Ajax</h3><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML。</li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
<li>传统的网页（即不用 ajax 技术的网页），想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</li>
</ul>
<h3 id="11-2、Ajax-原理"><a href="#11-2、Ajax-原理" class="headerlink" title="11.2、Ajax 原理"></a>11.2、Ajax 原理</h3><p><img src="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="11-3、伪造-Ajax"><a href="#11-3、伪造-Ajax" class="headerlink" title="11.3、伪造 Ajax"></a>11.3、伪造 Ajax</h3><ol>
<li>新建一个项目，导入 web 支持</li>
<li>编写一个 前端页面，使用 iframe 进行测试</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function x() &#123;
            var url =  document.getElementById(&#39;url&#39;).value;
            document.getElementById(&#39;iframePosition&#39;).src = url;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;p&gt;请输入地址：&lt;/p&gt;
    &lt;p&gt;
        &lt;input id=&quot;url&quot; type=&quot;text&quot; placeholder=&quot;网页地址&quot;/&gt;
        &lt;input type=&quot;button&quot; value=&quot;前往&quot; onclick=&quot;x()&quot;&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 666px&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-4、jQuery-操作-ajax"><a href="#11-4、jQuery-操作-ajax" class="headerlink" title="11.4、jQuery 操作 ajax"></a>11.4、jQuery 操作 ajax</h3><ul>
<li>使用jquery提供的，方便，有兴趣的可以自己去了解下 JS 原生 XMLHttpRequest ！<ul>
<li>Ajax 的核心是 XMLHttpRequest 对象（XHR）。XHR 为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
</ul>
</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="js">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<h3 id="11-5、原始的-HttpServletResponse-实现"><a href="#11-5、原始的-HttpServletResponse-实现" class="headerlink" title="11.5、原始的 HttpServletResponse 实现"></a>11.5、原始的 HttpServletResponse 实现</h3><ol>
<li>配置 web.xml</li>
</ol>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="2">
<li>springmvc 配置文件（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li><p>静态资源过滤和注解驱动配置（我的父工程已经配置了，所以这就不配了）</p>
</li>
<li><p>编写 Controller 类</p>
</li>
</ol>
<pre><code class="java">@RestController
public class UserController &#123;

    @RequestMapping(&quot;/a&quot;)
    public void ajax(String name, HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().write(&quot;true&quot;);
        &#125;else &#123;
            response.getWriter().write(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>导入 jQuery</p>
</li>
<li><p>编写前端页面</p>
</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ajaxTest&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function a1()&#123;
        $.post(&#123;
          url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
          data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
          success:function (data,status) &#123;
            alert(data);
            alert(status);
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; οnblur=&quot;a1()&quot;/&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="11-6、SpringMVC-实现异步加载数据"><a href="#11-6、SpringMVC-实现异步加载数据" class="headerlink" title="11.6、SpringMVC 实现异步加载数据"></a>11.6、SpringMVC 实现异步加载数据</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛&quot;,10,&quot;男&quot;));
    userList.add(new User(&quot;中牛&quot;,11,&quot;女&quot;));
    userList.add(new User(&quot;小牛&quot;,12,&quot;男&quot;));
    return userList;
&#125;
</code></pre>
<ol start="2">
<li>在 index 中增加内容</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;取得信息&quot;&gt;
  &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">$(function () &#123;
    $(&quot;#btn&quot;).click(function () &#123;
        $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
            console.log(data)
            var html=&quot;&quot;;
            for (let i = 0; i &lt; data.length ; i++) &#123;
                html+= &quot;&lt;tr&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;/tr&gt;&quot;
            &#125;
            $(&quot;#content&quot;).html(html);
        &#125;);
    &#125;)
&#125;)
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-7、注册提示效果"><a href="#11-7、注册提示效果" class="headerlink" title="11.7、注册提示效果"></a>11.7、注册提示效果</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String oldPwd,String newPwd, String newPwd2)&#123;
    String msg = &quot;&quot;;
    if (name != null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;用户名不存在&quot;;
        &#125;
    &#125;
    if (oldPwd != null)&#123;
        if (&quot;123456&quot;.equals(oldPwd))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;旧密码有误&quot;;
        &#125;
    &#125;
    return msg;
&#125;
</code></pre>
<ol start="2">
<li>编写前端</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;name&quot; οnblur=&quot;a3_1()&quot;&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
    旧密码：&lt;input type=&quot;password&quot; id=&quot;oldPwd&quot; οnblur=&quot;a3_2()&quot;&gt;
    &lt;span id=&quot;oldPwdInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function a3_1() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;name&quot;:$(&#39;#name&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#userInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
function a3_2() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;oldPwd&quot;:$(&#39;#oldPwd&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#oldPwdInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
</code></pre>
<ol start="3">
<li>解决乱码问题（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<h2 id="十二、拦截器"><a href="#十二、拦截器" class="headerlink" title="十二、拦截器"></a>十二、拦截器</h2><h3 id="12-1、什么是拦截器"><a href="#12-1、什么是拦截器" class="headerlink" title="12.1、什么是拦截器"></a>12.1、什么是拦截器</h3><p>​        SpringMVC 的处理器、拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<ul>
<li><p>过滤器</p>
<ul>
<li>servlet 规范中的一部分，任何 java web工程都可以使用</li>
<li>在 url-pattern 中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是 jsp、html、css、image、js 是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="12-2、自定义拦截器"><a href="#12-2、自定义拦截器" class="headerlink" title="12.2、自定义拦截器"></a>12.2、自定义拦截器</h3><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>配置 web.xml 和 applicationContext.xml</p>
</li>
<li><p>编写一个拦截器</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在 springmvc 配置文件中配置拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class TestController &#123;

    @RequestMapping(&quot;/t1&quot;)
    public String test()&#123;
        System.out.println(&quot;控制器方法执行！&quot;);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="12-3、验证用户是否登录（认证用户）"><a href="#12-3、验证用户是否登录（认证用户）" class="headerlink" title="12.3、验证用户是否登录（认证用户）"></a>12.3、验证用户是否登录（认证用户）</h3><p><strong>测试思路：</strong></p>
<ul>
<li>有一个登陆页面，需要写一个 controller 访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在 controller 中处理。判断用户名密码是否正确。如果正确，向 session 中写入用户信息。返回登陆成功。</li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>编写登录页面（login.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;

    &lt;h1&gt;登录页面&lt;/h1&gt;
    &lt;hr&gt;

    &lt;body&gt;
        &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt;
            用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;br&gt;
            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; required&gt; &lt;br&gt;
            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>编写 Controller 类处理请求</li>
</ol>
<pre><code class="java">package com.aze.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>编写登录成功页面（success.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;登录成功页面&lt;/h1&gt;
        &lt;hr&gt;

        $&#123;user&#125;
        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>编写首页，来测试页面跳转（index.jsp）</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 16:29
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
  &lt;/div&gt;

  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;hr&gt;
    &lt;%--登录--%&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>编写用户登录拦截器</li>
</ol>
<pre><code class="java">package com.aze.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;url: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>在 springmvc 配置文件中注册拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.aze.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="7">
<li><p>配置 Tomcat</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="13、文件上传和下载"><a href="#13、文件上传和下载" class="headerlink" title="13、文件上传和下载"></a>13、文件上传和下载</h2><h3 id="13-1、准备测试"><a href="#13-1、准备测试" class="headerlink" title="13.1、准备测试"></a>13.1、准备测试</h3><p>​        文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是 SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用 Spring 的文件上传功能，则需要在上下文中配置 MultipartResolver。</p>
<p>​        前端表单要求：为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p>对表单中的 enctype 属性做个详细的说明：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>​        一旦设置了 enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的 HTTP 响应。在2003年，Apache Software Foundation 发布了开源的 Commons FileUpload 组件，其很快成为 Servlet/JSP 程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0 规范已经提供方法来处理文件上传，但这种上传需要在 Servlet中完成。</li>
<li>而 Spring MVC 则提供了更简单的封装。</li>
<li>Spring MVC 为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver 实现的。</li>
<li>Spring MVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。</li>
<li>因此，SpringMVC 的文件上传还需要依赖 Apache Commons FileUpload 的组件。</li>
</ul>
<h3 id="13-2、文件上传"><a href="#13-2、文件上传" class="headerlink" title="13.2、文件上传"></a>13.2、文件上传</h3><ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
</ol>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--文件上传--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet-api导入高版本的--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--统一的解决乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>在 applicationContext.xml 中添加 bean 配置</li>
</ol>
<ul>
<li><strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong></li>
</ul>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 17:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;form action=&quot;/upload2&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class FileController &#123;
    
&#125;
</code></pre>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="java">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
//批量上传CommonsMultipartFile则为数组即可
@RequestMapping(&quot;/upload&quot;)
public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

    //获取文件名 : file.getOriginalFilename();
    String uploadFileName = file.getOriginalFilename();

    //如果文件名为空，直接回到首页！
    if (&quot;&quot;.equals(uploadFileName))&#123;
        return &quot;redirect:/index.jsp&quot;;
    &#125;
    System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    //如果路径不存在，创建一个
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    InputStream is = file.getInputStream(); //文件输入流
    OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

    //读取写出
    int len=0;
    byte[] buffer = new byte[1024];
    while ((len=is.read(buffer))!=-1)&#123;
        os.write(buffer,0,len);
        os.flush();
    &#125;
    os.close();
    is.close();
    return &quot;success&quot;;
&#125;
</code></pre>
<ul>
<li>方式二：采用 file.Transto 来保存上传的文件</li>
</ul>
<pre><code class="java">/*
    * 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;success&quot;;
&#125;
</code></pre>
<p>7.配置 Tomcat</p>
<ol start="8">
<li>测试</li>
</ol>
<h3 id="13-3、文件下载"><a href="#13-3、文件下载" class="headerlink" title="13.3、文件下载"></a>13.3、文件下载</h3><p>步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>Controller 类添加</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;baidu.png&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端添加</p>
<pre><code class="html">&lt;div&gt;
  &lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
&lt;/div&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SpringMVC" style=color:#00bcd4>
                SpringMVC
            </a>
        </span>
        
    </div>

    <a href="/2022/03/17/JAVA/Spring框架/SpringMVC/SpringMVC使用详解/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/17/C语言/STL六大组件简介/">
        <h2>
            STL六个组件简介
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/C语言">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                C语言
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <pre><code>    STL 从广义上分为: **容器**(container) **算法**(algorithm) **迭代器**(iterator)。
</code></pre>
<p>​        容器和算法之间通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<p>​        STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。</p>
<h1 id="STL六大组件简介"><a href="#STL六大组件简介" class="headerlink" title="STL六大组件简介"></a>STL六大组件简介</h1><p>​        STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:<strong>容器</strong>、<strong>算法</strong>、<strong>迭代器</strong>、<strong>仿函数</strong>、<strong>适配器（配接器）</strong>、<strong>空间配置器</strong>。</p>
<ul>
<li><p><strong>容器</strong>：各种数据结构，如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p>
</li>
<li><p><strong>算法</strong>：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p>
</li>
<li><p><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>
</li>
<li><p><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p>
</li>
<li><p><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
</li>
<li><p><strong>空间配置器</strong>：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p>
</li>
</ul>
<p>​        STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<p><strong>STL的优点很明显了</strong>：</p>
<ul>
<li>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。<ul>
<li>高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li>
<li>高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</li>
<li>高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</li>
</ul>
</li>
</ul>
<h1 id="三大组件介绍"><a href="#三大组件介绍" class="headerlink" title="三大组件介绍"></a>三大组件介绍</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h2><p>​        几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。<br>​        常用的数据结构：<strong>数组</strong>(array) , <strong>链表</strong>(list), tree(<strong>树</strong>)，<strong>栈</strong>(stack), <strong>队列</strong>(queue), <strong>集合</strong>(set),<strong>映射表</strong>(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li>
<li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器</li>
</ul>
<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><p>​        算法，问题的解法，以有限的步骤，解决逻辑或数学上的问题。</p>
<p>​        我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p>
<p>​        算法分为:质变算法和非质变算法。</p>
<ul>
<li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
</ul>
<h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><p>​        迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 在&lt;<Design Patterns>&gt;一书中提供了23种设计模式的完整描述， 其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>​        迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。</p>
<p>​        从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p>
<p>迭代器的种类:</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>提供对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>演示：</p>
<pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// STL 中的容器 算法 迭代器
void test01()&#123;
    vector&lt;int&gt; v;             // STL 中的标准容器之一 ：动态数组
    v.push_back(1);         // vector 容器提供的插入数据的方法
    v.push_back(5);
    v.push_back(3);
    v.push_back(7);
    
    // 迭代器
    vector&lt;int&gt;::iterator pStart = v.begin();         // vector 容器提供了 begin()方法 返回指向第一个元素的迭代器
    vector&lt;int&gt;::iterator pEnd = v.end();             // vector 容器提供了 end()方法 返回指向最后一个元素*下一个位置*的迭代器
    
    // 通过迭代器遍历
    while (pStart != pEnd)&#123;
        cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;
        pStart++;
    &#125;
    cout &lt;&lt; endl;
    
    // 算法 count 算法: 用于统计元素的个数
    int n = count(pStart, pEnd, 5);
    cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;
&#125;

// STL 容器不单单可以存储基础数据类型，也可以存储类对象
class Teacher
&#123;
    public:
        Teacher(int age) :age(age)&#123;&#125;;
        ~Teacher()&#123;&#125;;
    
    private:
        int age;
&#125;;

void test02()&#123;
    vector&lt;Teacher&gt; v;                 // 存储 Teacher 类型数据的容器
    Teacher t1(10), t2(20), t3(30);
    v.push_back(t1);
    v.push_back(t2);
    v.push_back(t3);
    
    vector&lt;Teacher&gt;::iterator pStart = v.begin();
    vector&lt;Teacher&gt;::iterator pEnd = v.end();
    
    // 通过迭代器遍历
    while (pStart != pEnd)&#123;
        cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;
        pStart++;
    &#125;
    cout &lt;&lt; endl;
&#125;

// 存储 Teacher 类型指针
void test03()&#123;
    vector&lt;Teacher*&gt; v;                 //存储 Teacher 类型指针
    Teacher* t1 = new Teacher(10);
    Teacher* t2 = new Teacher(20);
    Teacher* t3 = new Teacher(30);
    v.push_back(t1);
    v.push_back(t2);
    v.push_back(t3);
    
    // 拿到容器迭代器
    vector&lt;Teacher*&gt;::iterator pStart = v.begin();
    vector&lt;Teacher*&gt;::iterator pEnd = v.end();
    
    // 通过迭代器遍历
    while (pStart != pEnd)&#123;
        cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;
        pStart++;
    &#125;
    cout &lt;&lt; endl;
&#125;

// 容器嵌套容器 难点
void test04()
&#123;
    vector&lt; vector&lt;int&gt; &gt; v;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;

    for (int i = 0; i &lt; 5; i++)
    &#123;
        v1.push_back(i);
        v2.push_back(i * 10);
        v3.push_back(i * 100);
    &#125;
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);

    for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)
    &#123;
        for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)
        &#123;
            cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;

int main()&#123;
    //test01();
    //test02();
    //test03();
    test04();
    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="1-string容器"><a href="#1-string容器" class="headerlink" title="1. string容器"></a>1. string容器</h2><h3 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h3><p>​        C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。<br>String和c风格字符串对比：</p>
<ul>
<li>Char<em>是一个指针，String是一个类<br>string封装了char</em>，管理这个字符串，是一个char*型的容器。</li>
<li>String封装了很多实用的成员方法<br>查找find，拷贝copy，删除delete 替换replace，插入insert</li>
<li>不用考虑内存释放和越界<br>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li>
</ul>
<h3 id="string容器常用操作"><a href="#string容器常用操作" class="headerlink" title="string容器常用操作"></a>string容器常用操作</h3><p><strong>string 构造函数</strong></p>
<pre><code class="c">string();                                                        // 创建一个空的字符串 例如: string str; 

string(int n, char c);                                            // 使用n个字符c初始化

string(const string&amp; str);                                        // 使用一个string对象初始化另一个string对象
string(string &amp;str, size_type index, size_type length );        // 以index为索引开始的子串，长度为length

string(const char* s);                                            // 使用字符串s初始化
string(const char *s, size_type length );

string(input_iterator start, input_iterator end );                // 以从start到end的元素为初值.
</code></pre>
<p><strong>支持的操作符</strong></p>
<pre><code class="c">== &gt; &lt; &gt;= &lt;= != + += []
</code></pre>
<p><strong>string基本赋值操作</strong></p>
<pre><code class="c">string&amp; operator = (const char* s);                        // char*类型字符串 赋值给当前的字符串
string&amp; operator = (const string &amp;s);                    // 把字符串s赋给当前的字符串
string&amp; operator = (char c);                            // 字符赋值给当前的字符串

string&amp; assign(const char *s);                            // 把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);                    // 把字符串s的前n个字符赋给当前的字符串

string&amp; assign(const string &amp;s);                        // 把字符串s赋给当前字符串
string&amp; assign(const string &amp;s, int start, int n);        // 将s从start开始n个字符赋值给字符串

string&amp; assign(int n, char c);                            // 用n个字符c赋给当前字符串
</code></pre>
<p><strong>string存取字符操作</strong></p>
<pre><code class="c">char&amp; operator[](int n);                            // 通过[]方式取字符
char&amp; at(int n);                                    // 通过at方法获取字符
</code></pre>
<p><strong>string拼接操作</strong></p>
<pre><code class="c">string&amp; operator+=(const string&amp; str);                        // 重载+=操作符
string&amp; operator+=(const char* str);                        // 重载+=操作符
string&amp; operator+=(const char c);                            // 重载+=操作符

string&amp; append(const char *s);                                // 把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);                        // 把字符串s的前n个字符连接到当前字符串结尾

string&amp; append(const string &amp;s);                            // 同operator+=()
string&amp; append(const string &amp;s, int pos, int n);            // 把字符串s中从pos开始的n个字符连接到当前字符串结尾

string &amp;append(input_iterator start,input_iterator end);     // 在字符串的末尾添加以迭代器start和end表示的字符序列

string&amp; append(int n, char c);                                // 在当前字符串结尾添加n个字符c
</code></pre>
<p><strong>string查找和替换</strong></p>
<pre><code class="c">int find(const string&amp; str, int pos = 0) const;             // 查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;                  // 查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;              // 从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;                  // 查找字符c第一次出现位置

int rfind(const string&amp; str, int pos = npos) const;            // 查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;                // 查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;                // 从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const;                 // 查找字符c最后一次出现位置

string&amp; replace(int pos, int n, const string&amp; str);         // 替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n, const char* s);             // 替换从pos开始的n个字符为字符串s
</code></pre>
<pre><code class="c++">// 函数 find_first_of:查找在字符串中第一个与str中的某个字符匹配的字符
size_type find_first_of(const basic_string &amp;str, size_type index = 0);
size_type find_first_of(const char *str, size_type index = 0 );
size_type find_first_of(const char *str, size_type index, size_type num );
size_type find_first_of(char ch, size_type index = 0 );
 
// 函数 find_first_not_of:在字符串中查找第一个与str中的字符都不匹配的字符
size_type find_first_not_of(const basic_string &amp;str, size_type index = 0 );
size_type find_first_not_of(const char *str, size_type index = 0 );
size_type find_first_not_of(const char *str, size_type index, size_type num );
size_type find_first_not_of(char ch, size_type index = 0 );
 
// 函数 find_last_of:在字符串中查找最后一个与str中的某个字符匹配的字符
size_type find_last_of(const basic_string &amp;str, size_type index = npos );
size_type find_last_of(const char *str, size_type index = npos );
size_type find_last_of(const char *str, size_type index, size_type num );
size_type find_last_of(char ch, size_type index = npos );
 
// 函数 find_last_not_of:在字符串中查找最后一个与str中的字符都不匹配的字符
size_type find_last_not_of( const basic_string &amp;str, size_type index = npos );
size_type find_last_not_of(const char *str, size_type index = npos);
size_type find_last_not_of(const char *str, size_type index, size_type num );
size_type find_last_not_of(char ch, size_type index = npos );    
</code></pre>
<p><strong>string比较操作</strong></p>
<pre><code class="c">/*
    compare函数在 &gt; 时返回 1，&lt; 时返回 -1，== 时返回 0。
    比较区分大小写，比较时参考字典顺序，排越前面的越小。
    大写的A比小写的a小。
*/
int compare(const string &amp;s) const;                            // 与字符串s比较
int compare(const char *s) const;                            // 与字符串s比较

int compare(size_type index, size_type length,const string &amp;str);
int compare(size_type index, size_type length,const string &amp;str,size_type index2,size_type length2);

int compare(size_type index,size_type length,const char *str,size_type length2); 
int compare(int pos, int n,const char *s) 
</code></pre>
<p><strong>string子串</strong></p>
<pre><code class="c">string substr(int pos = 0, int n = npos) const;                // 返回由pos开始的n个字符组成的字符串
</code></pre>
<p><strong>string交换</strong></p>
<pre><code class="c++">void swap(string&amp; str)
</code></pre>
<p><strong>string插入和删除操作</strong></p>
<pre><code class="c">string&amp; insert(int pos, const char* s);                     // 插入字符串
string&amp; insert(int pos, const string&amp; str);                 // 插入字符串
string&amp; insert(int pos, int n, char c);                        // 在指定位置插入n个字符c

string&amp; erase(int pos, int n = npos);                        // 删除从Pos开始的n个字符
iterator erase(iterator it);                                // 删除it指向的字符，返回删除后迭代器的位置
iterator erase(iterator first, iterator last);                // 删除[first，last）之间的所有字符，返回删除后迭代器的位置
</code></pre>
<p><strong>string和c-style字符串转换</strong></p>
<pre><code class="c++">const char *c_str();                                //返回一个指向正规C字符串的指针, 内容与本字符串相同

size_type capacity();                                // 返回在重新申请更多的空间前字符串可以容纳的字符数. 这个数字至少与 size()一样大
size_type copy( char *str, size_type num, size_type index ); // 拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数

const char *data();                                    // 返回指向自己的第一个字符的指针

size_type max_size();                                // 返回字符串能保存的最大字符数
size_type length();                                    // 返回字符串的长度. 这个数字应该和size()返回的数字相同
size();                                                // 返回字符串中字符的数量

reserve( size_type num );                            // 保留一定容量以容纳字符串（设置capacity值）
void resize( size_type num );                        // 改变本字符串的大小到num, 新空间的内容不确定
void resize( size_type num, char ch );                // 也可以指定用ch填充
</code></pre>
<pre><code class="c">// string 转 char*
string str = &quot;it&quot;;
const char* cstr = str.c_str();

// char* 转 string 
char* s = &quot;it&quot;;
string str(s);
</code></pre>
<blockquote>
<p>​        在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string.</p>
<p>​        通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.</p>
</blockquote>
<p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误.</p>
<pre><code class="c">string s = &quot;abcdefg&quot;;
char&amp; a = s[2];
char&amp; b = s[3];

a = &#39;1&#39;;
b = &#39;2&#39;;

cout &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;

s = &quot;pppppppppppppppppppppppp&quot;;

// a = &#39;1&#39;;
// b = &#39;2&#39;;

cout &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;
</code></pre>
<h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2. vector容器"></a>2. vector容器</h2><h3 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h3><p>​        vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。</p>
<p>​        <strong>Array是静态空间</strong>，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p>
<p>​        Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p>
<p>​        Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”<strong>配置新空间-数据移动-释放旧空间</strong>”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。</p>
<p><img src="https://img-blog.csdnimg.cn/20190816214408796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>​        Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*、 operator-&gt;、 operator++、operator–、 operator+、 operator-、 operator+=、 operator-=，普通指针天生具备。</p>
<p>​        <strong>Vector支持随机存取</strong>，而普通指针正有着这样的能力。所以vector提供的是<strong>随机访问迭代器</strong>(Random Access Iterators).</p>
<p>​        根据上述描述，如果我们写如下的代码：</p>
<pre><code class="c">Vector&lt;int&gt;::iterator it1;
Vector&lt;Teacher&gt;::iterator it2;
</code></pre>
<p>​        it1的型别其实就是Int，it2的型别其实就是Teacher。</p>
<pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()&#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10;i ++)&#123;
        v.push_back(i);
        cout &lt;&lt; v.capacity() &lt;&lt; endl;                  // v.capacity()容器的容量
    &#125;


    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h3><p>​        Vector所采用的数据结构非常简单，<strong>线性连续空间</strong>，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器**_Myend指向整块连续内存空间的尾端**。</p>
<p>​        为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</p>
<blockquote>
<p>​        所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。</p>
</blockquote>
<h3 id="vector常用API操作"><a href="#vector常用API操作" class="headerlink" title="vector常用API操作"></a>vector常用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a>操作</h3><p><strong>vector构造函数</strong></p>
<pre><code class="c++">vector&lt;T&gt; v;                                 // 采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());                    // 将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);                            // 构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);                    // 拷贝构造函数。

// 例子 使用第二个构造函数 我们可以...
int arr[] = &#123;2,3,4,1,9&#125;;
vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); 
</code></pre>
<p><strong>vector常用赋值操作</strong></p>
<pre><code class="c++">assign(beg, end);                            // 将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);                            // 将n个elem拷贝赋值给本身。

vector&amp; operator=(const vector  &amp;vec);        // 重载等号操作符

swap(vec);                                    // 将vec与本身的元素互换。
</code></pre>
<p><strong>vector定位操作</strong></p>
<pre><code class="c++">iterator begin()                            // 返回一个当前vector容器中起始元素的迭代器。
iterator end()                                // 返回一个当前vector容器中末尾元素的迭代器。
    
const reverse_iterator rbegin()                // 返回一个逆序迭代器，指向容器的最后一个元素
const reverse_iterator rend()                // 返回一个逆序迭代器，它指向容器的第一个元素前面的位置

iterator front()                            // 返回一个当前vector容器中末尾元素的迭代器。
iterator back()                                // 返回当前vector容器中末尾元素的引用。
</code></pre>
<p><strong>vector大小操作</strong></p>
<pre><code class="c">size();                                    // 返回容器中元素的个数
empty();                                // 判断容器是否为空

resize(int num);                        // 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。若容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);                    // 重新指定容器的长度为num，若容器变长，则以elem值填充新位置。若容器变短，则末尾超出容器长&gt;度的元素被删除。

capacity();                                // 容器的容量
reserve(int len);                        // 容器预留len个元素长度，预留位置不初始化，元素不可访问。
</code></pre>
<p><strong>vector数据存取操作</strong></p>
<pre><code class="c">at(int idx);                             // 返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];                                // 返回索引idx所指的数据，越界时，运行直接报错

front();                                // 返回容器中第一个数据元素
back();                                    // 返回容器中最后一个数据元素
</code></pre>
<p><strong>vector插入和删除操作</strong></p>
<pre><code class="c">insert(const_iterator pos, int count,ele);                // 迭代器指向位置pos插入count个元素ele.
push_back(ele);                                         // 尾部插入元素ele

pop_back();                                                // 删除最后一个元素

erase(const_iterator start, const_iterator end);        // 删除迭代器从start到end之间的元素
erase(const_iterator pos);                                // 删除迭代器指向的元素

clear();                                                // 删除容器中所有元素
</code></pre>
<p>vector 小demo:  巧用swap，收缩内存空间</p>
<pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()&#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 100000;i ++)&#123;
        v.push_back(i);
    &#125;

    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;

    // 此时 通过resize改变容器大小
    v.resize(10);

    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;

    // 容量没有改变
    vector&lt;int&gt;(v).swap(v);

    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;


    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<p><strong>reserve预留空间</strong></p>
<pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()&#123;

    vector&lt;int&gt; v;

    // 预先开辟空间
    v.reserve(100000);

    int* pStart = NULL;
    int count = 0;
    for (int i = 0; i &lt; 100000;i ++)&#123;
        v.push_back(i);
        if (pStart != &amp;v[0])&#123;
            pStart = &amp;v[0];
            count++;
        &#125;
    &#125;

    cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl;

    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<h2 id="3-deque容器"><a href="#3-deque容器" class="headerlink" title="3. deque容器"></a>3. deque容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h3><p>​        Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</p>
<p>​        所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p>
<p><img src="https://img-blog.csdnimg.cn/20190817080710196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p>
<p>​        虽然deque容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p>
<h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a>deque容器实现原理</h3><p>​        Deque容器是<strong>连续的空间</strong>，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector、array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上经历了“<strong>申请更大空间—&gt;原数据复制新空间—&gt;释放原空间</strong>”三个步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>​        Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>​        既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p>
<p>​        Deque采取一块所谓的<strong>map</strong>(注意，不是STL的map容器)作为主控，这里所谓的map是<strong>一小块连续的内存空间</strong>，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。<strong>缓冲区才是deque的存储空间的主体</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190817080837663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a>deque常用API</h3><p><strong>deque构造函数</strong></p>
<pre><code class="c">deque&lt;T&gt; deqT;                            // 默认构造形式
deque(beg, end);                        // 构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);                            // 构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);                // 拷贝构造函数。
</code></pre>
<p><strong>deque赋值操作</strong></p>
<pre><code class="c">assign(beg, end);                        // 将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);                        // 将n个elem拷贝赋值给本身。

deque&amp; operator=(const deque &amp;deq);     // 重载等号操作符 

swap(deq);                                // 将deq与本身的元素互换
</code></pre>
<p><strong>deque大小操作</strong></p>
<pre><code class="c">deque.size();                            // 返回容器中元素的个数
deque.empty();                            // 判断容器是否为空

deque.resize(num);                        // 重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem);                // 重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
<p><strong>deque双端插入和删除操作</strong></p>
<pre><code class="c">push_back(elem);                        // 在容器尾部添加一个数据
push_front(elem);                        // 在容器头部插入一个数据

pop_back();                                // 删除容器最后一个数据
pop_front();                            // 删除容器第一个数据
</code></pre>
<p><strong>deque数据存取</strong></p>
<pre><code class="c">at(idx);                                // 返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];                                // 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。

front();                                // 返回第一个数据。
back();                                    // 返回最后一个数据
</code></pre>
<p><strong>deque插入操作</strong></p>
<pre><code class="c">insert(pos,elem);                        // 在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);                        // 在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);                    // 在pos位置插入[beg,end)区间的数据，无返回值。
</code></pre>
<p><strong>deque删除操作</strong></p>
<pre><code class="c">clear();                                // 移除容器的所有数据

erase(beg,end);                            // 删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);                                // 删除pos位置的数据，返回下一个数据的位置。
</code></pre>
<h2 id="4-stack容器"><a href="#4-stack容器" class="headerlink" title="4. stack容器"></a>4. stack容器</h2><h3 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h3><p>​        stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，<strong>stack不允许有遍历行为</strong>。<br>​        有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.</p>
<p><img src="https://img-blog.csdnimg.cn/20190817081120534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="stack没有迭代器"><a href="#stack没有迭代器" class="headerlink" title="stack没有迭代器"></a>stack没有迭代器</h3><p>​        Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。<strong>Stack不提供遍历功能，也不提供迭代器</strong>。</p>
<h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a>stack常用API</h3><p><strong>stack构造函数</strong></p>
<pre><code class="c">stack&lt;T&gt; stkT;                                // stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &amp;stk);                    // 拷贝构造函数
</code></pre>
<p><strong>stack赋值操作</strong></p>
<pre><code class="c">stack&amp; operator=(const stack &amp;stk);            // 重载等号操作符
</code></pre>
<p><strong>stack数据存取操作</strong></p>
<pre><code class="c">push(elem);                                    // 向栈顶添加元素
pop();                                        // 从栈顶移除第一个元素
top();                                        // 返回栈顶元素
</code></pre>
<p><strong>stack大小操作</strong></p>
<pre><code class="c">empty();                                    // 判断堆栈是否为空
size();                                        // 返回堆栈的大小
</code></pre>
<h2 id="5-queue容器"><a href="#5-queue容器" class="headerlink" title="5. queue容器"></a>5. queue容器</h2><h3 id="queue容器基本概念"><a href="#queue容器基本概念" class="headerlink" title="queue容器基本概念"></a>queue容器基本概念</h3><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<br><img src="https://img-blog.csdnimg.cn/20190817081324852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p>
<h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><p><strong>queue构造函数</strong></p>
<pre><code class="c">queue&lt;T&gt; queT;                            // queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &amp;que);                // 拷贝构造函数
</code></pre>
<p><strong>queue存取、插入和删除操作</strong></p>
<pre><code class="c">push(elem);                                // 往队尾添加元素
pop();                                    // 从队头移除第一个元素

front();                                // 返回第一个元素
back();                                    // 返回最后一个元素
</code></pre>
<p><strong>queue赋值操作</strong></p>
<pre><code class="c">queue&amp; operator=(const queue &amp;que);        // 重载等号操作符
</code></pre>
<p><strong>queue大小操作</strong></p>
<pre><code class="c">empty();                                // 判断队列是否为空
size();                                    // 返回队列的大小
</code></pre>
<h2 id="6-list容器"><a href="#6-list容器" class="headerlink" title="6. list容器"></a>6. list容器</h2><p><strong>list容器基本概念</strong><br>        链表是一种物理存储单元上<strong>非连续、非顺序</strong>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>​        链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>​        相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<p>​        List和vector是两个最常被使用的容器。</p>
<p>​        List容器是一个<strong>双向链表</strong>。<br><img src="https://img-blog.csdnimg.cn/20190817081547209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大</li>
</ul>
<h3 id="list容器的迭代器"><a href="#list容器的迭代器" class="headerlink" title="list容器的迭代器"></a>list容器的迭代器</h3><p>​        List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。</p>
<p>​        List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p>
<p>​        由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是<strong>Bidirectional Iterators</strong>.</p>
<p>​        List有一个重要的性质，<strong>插入操作和删除操作都不会造成原有list迭代器的失效</strong>。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p>
<h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a>list容器的数据结构</h3><p>list容器不仅是一个双向链表，而且还是一个<strong>循环的双向链表</strong>。</p>
<pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

int main()&#123;

    list&lt;int&gt; myList;
    for (int i = 0; i &lt; 10; i ++)&#123;
        myList.push_back(i);
    &#125;

    list&lt;int&gt;::_Nodeptr node =  myList._Myhead-&gt;_Next;

    for (int i = 0; i &lt; myList._Mysize * 2;i++)&#123;
        cout &lt;&lt; &quot;Node:&quot; &lt;&lt; node-&gt;_Myval &lt;&lt; endl;
        node = node-&gt;_Next;
        if (node == myList._Myhead)&#123;
            node = node-&gt;_Next;
        &#125;
    &#125;

    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a>list常用API</h3><p><strong>list构造函数</strong></p>
<pre><code class="c">list&lt;T&gt; lstT;                                // list采用采用模板类实现,对象的默认构造形式：
list(beg,end);                                // 构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);                                // 构造函数将n个elem拷贝给本身。
list(const list &amp;lst);                        // 拷贝构造函数。
</code></pre>
<p><strong>list数据元素插入和删除操作</strong></p>
<pre><code class="c">push_back(elem);                            // 在容器尾部加入一个元素
pop_back();                                    // 删除容器中最后一个元素

push_front(elem);                            // 在容器开头插入一个元素
pop_front();                                // 从容器开头移除第一个元素

insert(pos,elem);                            // 在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);                            // 在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);                        // 在pos位置插入[beg,end)区间的数据，无返回值。

clear();                                    // 移除容器的所有数据

erase(beg,end);                                // 删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);                                    // 删除pos位置的数据，返回下一个数据的位置。

remove(elem);                                // 删除容器中所有与elem值匹配的元素。
</code></pre>
<p><strong>list大小操作</strong></p>
<pre><code class="c">size();                                    // 返回容器中元素的个数
empty();                                // 判断容器是否为空

resize(num);                            // 重新指定容器的长度为num，若容器变长，则以默认值填充新位置;如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);                        // 重新指定容器的长度为num，若容器变长，则以elem值填充新位置;如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
<p><strong>list赋值操作</strong></p>
<pre><code class="c">assign(beg, end);                        // 将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);                        // 将n个elem拷贝赋值给本身。

list&amp; operator=(const list &amp;lst);        // 重载等号操作符

swap(lst);                                // 将lst与本身的元素互换。
</code></pre>
<p><strong>list数据的存取</strong></p>
<pre><code class="c">front();                                // 返回第一个元素。
back();                                    // 返回最后一个元素。
</code></pre>
<p><strong>list反转排序</strong></p>
<pre><code class="c">reverse();                                // 反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort();                                 // list排序
</code></pre>
<h2 id="7-set-multiset容器"><a href="#7-set-multiset容器" class="headerlink" title="7. set/multiset容器"></a>7. set/multiset容器</h2><h3 id="set容器基本概念"><a href="#set容器基本概念" class="headerlink" title="set容器基本概念"></a>set容器基本概念</h3><p>​        Set的特性是：<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p>
<p>​        我们不可以通过set的迭代器改变set元素的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种<strong>const</strong>_iterator.</p>
<p>​        set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p>
<h3 id="multiset容器基本概念"><a href="#multiset容器基本概念" class="headerlink" title="multiset容器基本概念"></a>multiset容器基本概念</h3><p>​        multiset特性及用法和set完全相同，唯一的差别在于它<strong>允许键值重复</strong>。set和multiset的底层实现是<strong>红黑树</strong>。</p>
<h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><p><strong>set构造函数</strong></p>
<pre><code class="c">set&lt;T&gt; st;                                // set默认构造函数：
mulitset&lt;T&gt; mst;                         // multiset默认构造函数:

set(const set &amp;st);                        // 拷贝构造函数
</code></pre>
<p><strong>set赋值操作</strong></p>
<pre><code class="c">set&amp; operator=(const set &amp;st);            // 重载等号操作符

swap(st);                                // 交换两个集合容器
</code></pre>
<p><strong>set大小操作</strong></p>
<pre><code class="c">size();                                    // 返回容器中元素的数目
empty();                                // 判断容器是否为空
</code></pre>
<p><strong>set插入和删除操作</strong></p>
<pre><code class="c">insert(elem);                            // 在容器中插入元素。

clear();                                // 清除所有元素

erase(pos);                                // 删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);                        // 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);                            // 删除容器中值为elem的元素。
</code></pre>
<p><strong>set查找操作</strong></p>
<pre><code class="c">find(key);                                // 查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();

count(key);                                // 查找键key的元素个数

lower_bound(keyElem);                    // 返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);                    // 返回第一个key&gt;keyElem元素的迭代器。

equal_range(keyElem);                    // 返回容器中key与keyElem相等的上下限的两个迭代器。
</code></pre>
<p><strong>set的返回值 指定set排序规则举例:</strong></p>
<pre><code class="c">//插入操作返回值
void test01()&#123;

    set&lt;int&gt; s;
    pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);
    if (ret.second)&#123;
        cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;
    &#125;
    else&#123;
        cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;
    &#125;
    
    ret = s.insert(10);
    if(ret.second)&#123;
        cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;
    &#125;
    else&#123;
        cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;
    &#125;

&#125;

struct MyCompare02&#123;
    bool operator()(int v1,int v2)&#123;
        return v1 &gt; v2;
    &#125;
&#125;;

// set从大到小
void test02()&#123;

    srand((unsigned int)time(NULL));
    // set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;
    set&lt;int, MyCompare02&gt; s;
    for (int i = 0; i &lt; 10;i++)&#123;
        s.insert(rand() % 100);
    &#125;
    
    for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

// set容器中存放对象
class Person&#123;
    public:
        Person(string name,int age)&#123;
            this-&gt;mName = name;
            this-&gt;mAge = age;
        &#125;
    
    private:
        string mName;
        int mAge;
&#125;;


struct MyCompare03&#123;
    bool operator()(const Person&amp; p1,const Person&amp; p2)&#123;
        return p1.mAge &gt; p2.mAge;
    &#125;
&#125;;

void test03()&#123;

    set&lt;Person, MyCompare03&gt; s;

    Person p1(&quot;aaa&quot;, 20);
    Person p2(&quot;bbb&quot;, 30);
    Person p3(&quot;ccc&quot;, 40);
    Person p4(&quot;ddd&quot;, 50);

    s.insert(p1);
    s.insert(p2);
    s.insert(p3);
    s.insert(p4);

    for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl;
    &#125;

&#125;
</code></pre>
<h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。<br>类模板：<code>template &lt;class T1, class T2&gt; struct pair.</code><br>创建对组:</p>
<pre><code class="c">// 第一种方法创建一个对组
pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);
cout &lt;&lt; pair1.first &lt;&lt; endl;                         // 访问pair第一个值
cout &lt;&lt; pair1.second &lt;&lt; endl;                        // 访问pair第二个值

// 第二种
pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);
cout &lt;&lt; pair2.first &lt;&lt; endl;
cout &lt;&lt; pair2.second &lt;&lt; endl;

// pair=赋值
pair&lt;string, int&gt; pair3 = pair2;
cout &lt;&lt; pair3.first &lt;&lt; endl;
cout &lt;&lt; pair3.second &lt;&lt; endl;
</code></pre>
<h2 id="8-map-multimap容器"><a href="#8-map-multimap容器" class="headerlink" title="8. map/multimap容器"></a>8. map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>​        Map的特性是，所有元素都会根据元素的键值自动排序。</p>
<p>​        Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p>
<p>​        我们不可以通过map的迭代器改变map的键值, 因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p>
<p>​        Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p>
<p>​        Multimap和map的操作类似，唯一区别multimap键值可重复。</p>
<p>​        Map和multimap都是以<strong>红黑树</strong>为底层实现机制。</p>
<h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><p><strong>map构造函数</strong></p>
<pre><code class="c">map&lt;T1, T2&gt; mapTT;                            // map默认构造函数: 
map(const map &amp;mp);                            // 拷贝构造函数
</code></pre>
<p><strong>map赋值操作</strong></p>
<pre><code class="c">map&amp; operator=(const map &amp;mp);                // 重载等号操作符
swap(mp);                                    // 交换两个集合容器
</code></pre>
<p><strong>map大小操作</strong></p>
<pre><code class="c">size();                                        // 返回容器中元素的数目
empty();                                    // 判断容器是否为空
</code></pre>
<p><strong>map插入数据元素操作</strong></p>
<pre><code class="c">map.insert(...);                             // 往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;

// 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));

// 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, &quot;校长&quot;));

// 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));

// 第四种 通过数组的方式插入值
mapStu[3] = &quot;小刘&quot;;
mapStu[5] = &quot;小王&quot;;
</code></pre>
<p><strong>map删除操作</strong></p>
<pre><code class="c">clear();                                    // 删除所有元素

erase(pos);                                    // 删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);                                // 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);                                // 删除容器中key为keyElem的对组。
</code></pre>
<p><strong>map查找操作</strong></p>
<pre><code class="c">find(key);                                    // 查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();

count(keyElem);                                // 返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。

lower_bound(keyElem);                        // 返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);                        // 返回第一个key&gt;keyElem元素的迭代器。

equal_range(keyElem);                        // 返回容器中key与keyElem相等的上下限的两个迭代器。
</code></pre>
<p><strong>multimap案例</strong></p>
<pre><code class="c">// 公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作
// 人员信息有: 姓名 年龄 电话 工资等组成
// 通过Multimap进行信息的插入 保存 显示
// 分部门显示员工信息 显示全部员工信息

#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;

// multimap 案例
// 公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作
// 人员信息有: 姓名 年龄 电话 工资等组成
// 通过 Multimap 进行信息的插入 保存 显示
// 分部门显示员工信息 显示全部员工信息


#define SALE_DEPATMENT 1                 // 销售部门
#define DEVELOP_DEPATMENT 2             // 研发部门
#define FINACIAL_DEPATMENT 3             // 财务部门
#define ALL_DEPATMENT 4                 // 所有部门

// 员工类
class person&#123;
public:
    string name;                         // 员工姓名
    int age;                             // 员工年龄
    double salary;                         // 员工工资
    string tele;                         // 员工电话
&#125;;

// 创建5个员工
void CreatePerson(vector&lt;person&gt;&amp; vlist)&#123;

    string seed = &quot;ABCDE&quot;;
    for (int i = 0; i &lt; 5; i++)&#123;
        person p;
        p.name = &quot;员工&quot;;
        p.name += seed[i];
        p.age = rand() % 30 + 20;
        p.salary = rand() % 20000 + 10000;
        p.tele = &quot;010-8888888&quot;;
        vlist.push_back(p);
    &#125;

&#125;

// 5名员工分配到不同的部门
void PersonByGroup(vector&lt;person&gt;&amp; vlist, multimap&lt;int, person&gt;&amp; plist)&#123;


    int operate = -1;                     // 用户的操作

    for (vector&lt;person&gt;::iterator it = vlist.begin(); it != vlist.end(); it++)&#123;

        cout &lt;&lt; &quot;当前员工信息:&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;tele &lt;&lt; endl;
        cout &lt;&lt; &quot;请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):&quot; &lt;&lt; endl;
        scanf(&quot;%d&quot;, &amp;operate);

        while (true)&#123;

            if (operate == SALE_DEPATMENT)&#123;  // 将该员工加入到销售部门
                plist.insert(make_pair(SALE_DEPATMENT, *it));
                break;
            &#125;
            else if (operate == DEVELOP_DEPATMENT)&#123;
                plist.insert(make_pair(DEVELOP_DEPATMENT, *it));
                break;
            &#125;
            else if (operate == FINACIAL_DEPATMENT)&#123;
                plist.insert(make_pair(FINACIAL_DEPATMENT, *it));
                break;
            &#125;
            else&#123;
                cout &lt;&lt; &quot;您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):&quot; &lt;&lt; endl;
                scanf(&quot;%d&quot;, &amp;operate);
            &#125;

        &#125;

    &#125;
    cout &lt;&lt; &quot;员工部门分配完毕!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;***********************************************************&quot; &lt;&lt; endl;

&#125;

// 打印员工信息
void printList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123;

    if (myoperate == ALL_DEPATMENT)&#123;
        for (multimap&lt;int, person&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123;
            cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;second.age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;second.salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
        &#125;
        return;
    &#125;

    multimap&lt;int, person&gt;::iterator it = plist.find(myoperate);
    int depatCount = plist.count(myoperate);
    int num = 0;
    if (it != plist.end())&#123;
        while (it != plist.end() &amp;&amp; num &lt; depatCount)&#123;
            cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;second.age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;second.salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
            it++;
            num++;
        &#125;
    &#125;
&#125;

// 根据用户操作显示不同部门的人员列表
void ShowPersonList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123;

    switch (myoperate)
    &#123;
    case SALE_DEPATMENT:
        printList(plist, SALE_DEPATMENT);
        break;
    case DEVELOP_DEPATMENT:
        printList(plist, DEVELOP_DEPATMENT);
        break;
    case FINACIAL_DEPATMENT:
        printList(plist, FINACIAL_DEPATMENT);
        break;
    case ALL_DEPATMENT:
        printList(plist, ALL_DEPATMENT);
        break;
    &#125;
&#125;

// 用户操作菜单
void PersonMenue(multimap&lt;int, person&gt;&amp; plist)&#123;

    int flag = -1;
    int isexit = 0;
    while (true)&#123;
        cout &lt;&lt; &quot;请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：&quot; &lt;&lt; endl;
        scanf(&quot;%d&quot;, &amp;flag);

        switch (flag)
        &#123;
        case SALE_DEPATMENT:
            ShowPersonList(plist, SALE_DEPATMENT);
            break;
        case DEVELOP_DEPATMENT:
            ShowPersonList(plist, DEVELOP_DEPATMENT);
            break;
        case FINACIAL_DEPATMENT:
            ShowPersonList(plist, FINACIAL_DEPATMENT);
            break;
        case ALL_DEPATMENT:
            ShowPersonList(plist, ALL_DEPATMENT);
            break;
        case 0:
            isexit = 1;
            break;
        default:
            cout &lt;&lt; &quot;您的输入有误，请重新输入!&quot; &lt;&lt; endl;
            break;
        &#125;

        if (isexit == 1)&#123;
            break;
        &#125;
    &#125;

&#125;

int main()&#123;

    vector&lt;person&gt;  vlist;                 // 创建的5个员工 未分组
    multimap&lt;int, person&gt; plist;        // 保存分组后员工信息

    // 创建5个员工
    CreatePerson(vlist);
    // 5名员工分配到不同的部门
    PersonByGroup(vlist, plist);
    // 根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表
    PersonMenue(plist);

    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table>
<thead>
<tr>
<th>.</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：不是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>​        vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>
<p>​        deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>​        <strong>vector与deque的比较：</strong></p>
<ul>
<li><p>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</p>
</li>
<li><p>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p>
</li>
<li><p>deque支持头部的快速插入与快速移除，这是deque的优点。</p>
<p><strong>使用场景：</strong></p>
</li>
</ul>
<p>​        list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>​        set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>​        map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="1-函数对象"><a href="#1-函数对象" class="headerlink" title="1. 函数对象"></a>1. 函数对象</h2><p>​        <strong>重载函数调用操作符的类</strong>，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<p>注意:</p>
<ol>
<li><strong>函数对象(仿函数)是一个类</strong>，不是一个函数。</li>
<li>函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</li>
</ol>
<p>分类:</p>
<p>​        假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；</p>
<p>​        相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
<p>函数对象的作用:<br>        STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<pre><code class="c">// 函数对象是重载了函数调用符号的类
class MyPrint
&#123;
    public:
        MyPrint()
        &#123;
            m_Num = 0;
        &#125;
        int m_Num;

    public:
        void operator() (int num)
        &#123;
            cout &lt;&lt; num &lt;&lt; endl;
            m_Num++;
        &#125;
&#125;;

// 函数对象
// 重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值
void test01()
&#123;
    MyPrint myPrint;
    myPrint(20);

&#125;

// 函数对象超出了普通函数的概念，可以保存函数的调用状态
void test02()
&#123;
    MyPrint myPrint;
    myPrint(20);
    myPrint(20);
    myPrint(20);
    cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;
&#125;

void doBusiness(MyPrint print,int num)
&#123;
    print(num);
&#125;

// 函数对象作为参数
void test03()
&#123;
    // 参数1：匿名函数对象
    doBusiness(MyPrint(),30);
&#125;
</code></pre>
<p>总结：<br>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。<br>2、函数对象超出普通函数的概念，函数对象可以有自己的状态<br>3、函数对象可内联编译，性能好。用函数指针几乎不可能<br>4、模版函数对象使函数对象具有通用性，这也是它的优势之一</p>
<h2 id="2-谓词"><a href="#2-谓词" class="headerlink" title="2. 谓词"></a>2. 谓词</h2><p>​        **谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)**。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<pre><code class="c">class GreaterThenFive
&#123;
    public:
        bool operator()(int num)
        &#123;
            return num &gt; 5;
        &#125;

&#125;;

// 一元谓词
void test01()
&#123;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10;i ++)
    &#123;
        v.push_back(i);
    &#125;
    
     vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());
     if (it == v.end())
     &#123;
         cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;
     &#125;
     else
     &#123;
         cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl;
     &#125;
&#125;

// 二元谓词
class MyCompare
&#123;
    public:
        bool operator()(int num1, int num2)
        &#123;
            return num1 &gt; num2;
        &#125;
&#125;;

void test02()
&#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(40);
    v.push_back(20);
    v.push_back(90);
    v.push_back(60);

    // 默认从小到大
    sort(v.begin(), v.end());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;
    
    // 使用函数对象改变算法策略，排序从大到小
    sort(v.begin(), v.end(),MyCompare());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="3-内建函数对象"><a href="#3-内建函数对象" class="headerlink" title="3.内建函数对象"></a>3.内建函数对象</h2><p>​        STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件</p>
<pre><code class="c">#include &lt;functional&gt;
</code></pre>
<p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p>
<pre><code class="c">template&lt;class T&gt; T plus&lt;T&gt;                            // 加法仿函数
template&lt;class T&gt; T minus&lt;T&gt;                        // 减法仿函数
template&lt;class T&gt; T multiplies&lt;T&gt;                    // 乘法仿函数
template&lt;class T&gt; T divides&lt;T&gt;                        // 除法仿函数
template&lt;class T&gt; T modulus&lt;T&gt;                        // 取模仿函数
template&lt;class T&gt; T negate&lt;T&gt;                        // 取反仿函数
</code></pre>
<p>6个关系运算类函数对象,每一种都是二元运算。</p>
<pre><code class="c">template&lt;class T&gt; bool equal_to&lt;T&gt;                    // 等于
template&lt;class T&gt; bool not_equal_to&lt;T&gt;                // 不等于
template&lt;class T&gt; bool greater&lt;T&gt;                    // 大于
template&lt;class T&gt; bool greater_equal&lt;T&gt;                // 大于等于
template&lt;class T&gt; bool less&lt;T&gt;                        // 小于
template&lt;class T&gt; bool less_equal&lt;T&gt;                // 小于等于
</code></pre>
<p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p>
<pre><code class="c">template&lt;class T&gt; bool logical_and&lt;T&gt;                // 逻辑与
template&lt;class T&gt; bool logical_or&lt;T&gt;                // 逻辑或
template&lt;class T&gt; bool logical_not&lt;T&gt;                // 逻辑非
</code></pre>
<p>内建函数对象举例:</p>
<pre><code class="c">// 取反仿函数
void test01()
&#123;
    negate&lt;int&gt; n;
    cout &lt;&lt; n(50) &lt;&lt; endl;
&#125;

// 加法仿函数
void test02()
&#123;
    plus&lt;int&gt; p;
    cout &lt;&lt; p(10, 20) &lt;&lt; endl;
&#125;

// 大于仿函数
void test03()
&#123;
    vector&lt;int&gt; v;
    srand((unsigned int)time(NULL));
    for (int i = 0; i &lt; 10; i++)&#123;
        v.push_back(rand() % 100);
    &#125;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
    sort(v.begin(), v.end(), greater&lt;int&gt;());

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="4-函数对象适配器"><a href="#4-函数对象适配器" class="headerlink" title="4. 函数对象适配器"></a>4. 函数对象适配器</h2><pre><code class="c">// 函数适配器bind1st bind2nd
// 现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？
// 我们直接给函数对象绑定参数 编译阶段就会报错
// for_each(v.begin(), v.end(), bind2nd(myprint(),100));
// 如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function
// 根据我们函数对象是一元函数对象 还是二元函数对象
class MyPrint :public binary_function&lt;int,int,void&gt;
&#123;
    public:
        void operator()(int v1,int v2) const
        &#123;
            cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2  &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl;    
        &#125;
&#125;;

//1、函数适配器
void test01()
&#123;
    vector&lt;int&gt;v;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;
    cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl;
    int x;
    cin &gt;&gt; x;

    for_each(v.begin(), v.end(), bind1st(MyPrint(), x));
    //for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));
&#125;
// 总结：  bind1st和bind2nd区别?
// bind1st ： 将参数绑定为函数对象的第一个参数
// bind2nd ： 将参数绑定为函数对象的第二个参数
// bind1st bind2nd将二元函数对象转为一元函数对象


class GreaterThenFive:public unary_function&lt;int,bool&gt;
&#123;
    public:
        bool operator ()(int v) const
        &#123;
            return v &gt; 5;
        &#125;
&#125;;

//2、取反适配器
void test02()
&#123;
    vector &lt;int&gt; v;
    for (int i = 0; i &lt; 10;i++)
    &#123;
        v.push_back(i);
    &#125;
    
//     vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器
//    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器
    //自定义输入
    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5)));
    if (it == v.end())
    &#123;
        cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;
    &#125;

    //排序  二元函数对象
    sort(v.begin(), v.end(), not2(less&lt;int&gt;()));
    for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);

&#125;
// not1 对一元函数对象取反
// not2 对二元函数对象取反

void MyPrint03(int v,int v2)
&#123;
    cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;
&#125;

//3、函数指针适配器   ptr_fun
void test03()
&#123;
    vector &lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;
    // ptr_fun( )把一个普通的函数指针适配成函数对象
    for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));
&#125;


//4、成员函数适配器
class Person
&#123;
    public:
        Person(string name, int age)
        &#123;
            m_Name = name;
            m_Age = age;
        &#125;

        // 打印函数
        void ShowPerson()&#123;
            cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl;
        &#125;
        void Plus100()
        &#123;
            m_Age += 100;
        &#125;
    public:
        string m_Name;
        int m_Age;
&#125;;

void MyPrint04(Person &amp;p)
&#123;
    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt;  p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;

&#125;;

void test04()
&#123;
    vector &lt;Person&gt;v;
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);

    // for_each(v.begin(), v.end(), MyPrint04);
    // 利用 mem_fun_ref 将Person内部成员函数适配
    for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));
//     for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));
//     for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));
&#125;

void test05()&#123;

    vector&lt;Person*&gt; v1;
    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);

    v1.push_back(&amp;p1);
    v1.push_back(&amp;p2);
    v1.push_back(&amp;p3);
    v1.push_back(&amp;p4);

    for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));
&#125;

// 如果容器存放的是对象指针，那么用 mem_fun
// 如果容器中存放的是对象实体，那么用 mem_fun_ref
</code></pre>
<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件**<algorithm><functional> <numeric>**组成。<br><algorithm>是所有STL头文件中最大的一个，其中常用的功能涉及到比较、交换、查找、遍历、复制、修改、反转、排序、合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数；<br><functional> 定义了一些模板类，用以声明函数对象。</p>
<h3 id="1-常用遍历算法"><a href="#1-常用遍历算法" class="headerlink" title="1. 常用遍历算法"></a>1. 常用遍历算法</h3><pre><code class="c">/*
    遍历算法 遍历容器元素
    @param beg 开始迭代器
    @param end 结束迭代器
    @param _callback  函数回调或者函数对象
    @return 函数对象
*/
for_each(iterator beg, iterator end, _callback);

/*
    transform算法 将指定容器区间元素搬运到另一容器中
    注意 : transform 不会给目标容器分配内存，所以需要 *提前分配好内存*
    @param beg1 源容器开始迭代器
    @param end1 源容器结束迭代器
    @param beg2 目标容器开始迭代器
    @param _cakkback 回调函数或者函数对象
    @return 返回目标容器迭代器
*/
transform(iterator beg1, iterator end1, iterator beg2, _callbakc)


for_each:
/*
    template&lt;class _InIt,class _Fn1&gt; inline
    void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
    &#123;
        for (; _First != _Last; ++_First)
            _Func(*_First);
    &#125;
*/

// 普通函数
void print01(int val)&#123;
    cout &lt;&lt; val &lt;&lt; &quot; &quot;;
&#125;

// 函数对象
struct print001&#123;
    void operator()(int val)&#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

// for_each算法基本用法
void test01()&#123;
    
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10;i++)&#123;
        v.push_back(i);
    &#125;

    // 遍历算法
    for_each(v.begin(), v.end(), print01);
    cout &lt;&lt; endl;

    for_each(v.begin(), v.end(), print001());
    cout &lt;&lt; endl;

&#125;

struct print02&#123;
    print02()&#123;
        mCount = 0;
    &#125;
    void operator()(int val)&#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
        mCount++;
    &#125;
    int mCount;
&#125;;

// for_each返回值
void test02()&#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)&#123;
        v.push_back(i);
    &#125;

    print02 p = for_each(v.begin(), v.end(), print02());
    cout &lt;&lt; endl;
    cout &lt;&lt; p.mCount &lt;&lt; endl;
&#125;

struct print03 : public binary_function&lt;int, int, void&gt;&#123;
    void operator()(int val,int bindParam) const&#123;
        cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

// for_each绑定参数输出
void test03()&#123;
    
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)&#123;
        v.push_back(i);
    &#125;

    for_each(v.begin(), v.end(), bind2nd(print03(),100));
&#125;


transform:
//transform 将一个容器中的值搬运到另一个容器中
/*
    template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline 
    _OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)
    &#123;    

        for (; _First != _Last; ++_First, ++_Dest)
            *_Dest = _Func(*_First);
        return (_Dest);
    &#125;

    template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline
    _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
    &#123;    
        for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
            *_Dest = _Func(*_First1, *_First2);
        return (_Dest);
    &#125;
*/

struct transformTest01&#123;
    int operator()(int val)&#123;
        return val + 100;
    &#125;
&#125;;
struct print01&#123;
    void operator()(int val)&#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()&#123;

    vector&lt;int&gt; vSource;
    for (int i = 0; i &lt; 10;i ++)&#123;
        vSource.push_back(i + 1);
    &#125;

    // 目标容器
    vector&lt;int&gt; vTarget;
    // 给vTarget开辟空间
    vTarget.resize(vSource.size());
    // 将vSource中的元素搬运到vTarget
    vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());
    // 打印
    for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;
    
&#125;

// 将容器1和容器2中的元素相加放入到第三个容器中
struct transformTest02&#123;
    int operator()(int v1,int v2)&#123;
        return v1 + v2;
    &#125;
&#125;;

void test02()&#123;

    vector&lt;int&gt; vSource1;
    vector&lt;int&gt; vSource2;
    for (int i = 0; i &lt; 10; i++)&#123;
        vSource1.push_back(i + 1);    
    &#125;

    // 目标容器
    vector&lt;int&gt; vTarget;
    // 给vTarget开辟空间
    vTarget.resize(vSource1.size());
    transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());
    // 打印
    for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;
&#125;
</code></pre>
<h3 id="2-常用查找算法"><a href="#2-常用查找算法" class="headerlink" title="2. 常用查找算法"></a>2. 常用查找算法</h3><pre><code class="c++">/*
    find算法 查找元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param value 查找的元素
    @return 返回查找元素的位置
*/
find(iterator beg, iterator end, value)
    
/*
    find_if算法 条件查找
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param  callback 回调函数或者谓词(返回bool类型的函数对象)
    @return bool 查找返回true 否则false
*/
bool find_if(iterator beg, iterator end, _callback);

/*
    adjacent_find算法 查找相邻重复元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param  _callback 回调函数或者谓词(返回bool类型的函数对象)
    @return 返回相邻元素的第一个位置的迭代器
*/
adjacent_find(iterator beg, iterator end, _callback);

/*
    binary_search算法 二分查找法
    注意: 在无序序列中不可用
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param value 查找的元素
    @return bool 查找返回true 否则false
*/
bool binary_search(iterator beg, iterator end, value);

/*
    count算法 统计元素出现次数
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param  value回调函数或者谓词(返回bool类型的函数对象)
    @return int返回元素个数
*/
int count(iterator beg, iterator end, value);

/*
    count算法 统计元素出现次数
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param  callback 回调函数或者谓词(返回bool类型的函数对象)
    @return int返回元素个数
*/
int count_if(iterator beg, iterator end, _callback);
</code></pre>
<h3 id="3-常用排序算法"><a href="#3-常用排序算法" class="headerlink" title="3. 常用排序算法"></a>3. 常用排序算法</h3><pre><code class="c">/*
    merge算法 容器元素合并，并存储到另一容器中
    @param beg1 容器1开始迭代器
    @param end1 容器1结束迭代器
    @param beg2 容器2开始迭代器
    @param end2 容器2结束迭代器
    @param dest  目标容器开始迭代器
*/
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
    
/*
    sort算法 容器元素排序
    注意:两个容器必须是有序的
    @param beg 容器1开始迭代器
    @param end 容器1结束迭代器
    @param _callback 回调函数或者谓词(返回bool类型的函数对象)
*/
sort(iterator beg, iterator end, _callback)
    
/*
    sort算法 对指定范围内的元素随机调整次序
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
*/
random_shuffle(iterator beg, iterator end)
    
/*
    reverse算法 反转指定范围的元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
*/
reverse(iterator beg, iterator end)
</code></pre>
<h3 id="4-常用拷贝和替换算法"><a href="#4-常用拷贝和替换算法" class="headerlink" title="4. 常用拷贝和替换算法"></a>4. 常用拷贝和替换算法</h3><pre><code class="c">/*
    copy算法 将容器内指定范围的元素拷贝到另一容器中
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param dest 目标起始迭代器
*/
copy(iterator beg, iterator end, iterator dest)
    
/*
    replace算法 将容器内指定范围的旧元素修改为新元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param oldvalue 旧元素
    @param oldvalue 新元素
*/
replace(iterator beg, iterator end, oldvalue, newvalue)
    
/*
    replace_if算法 将容器内指定范围满足条件的元素替换为新元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param callback函数回调或者谓词(返回Bool类型的函数对象)
    @param oldvalue 新元素
*/
replace_if(iterator beg, iterator end, _callback, newvalue)
    
/*
    swap算法 互换两个容器的元素
    @param c1容器1
    @param c2容器2
*/
swap(container c1, container c2)
</code></pre>
<h3 id="5-常用算数生成算法"><a href="#5-常用算数生成算法" class="headerlink" title="5. 常用算数生成算法"></a>5. 常用算数生成算法</h3><pre><code class="c">/*
    accumulate算法 计算容器元素累计总和
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param value累加值
*/
accumulate(iterator beg, iterator end, value)
    
/*
    fill算法 向容器中添加元素
    @param beg 容器开始迭代器
    @param end 容器结束迭代器
    @param value t填充元素
*/
fill(iterator beg, iterator end, value)
</code></pre>
<h3 id="6-常用集合算法"><a href="#6-常用集合算法" class="headerlink" title="6. 常用集合算法"></a>6. 常用集合算法</h3><pre><code class="c">/*
    set_intersection算法 求两个set集合的交集
    注意:两个集合必须是有序序列
    @param beg1 容器1开始迭代器
    @param end1 容器1结束迭代器
    @param beg2 容器2开始迭代器
    @param end2 容器2结束迭代器
    @param dest  目标容器开始迭代器
    @return 目标容器的最后一个元素的迭代器地址
*/
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
    
/*
    set_union算法 求两个set集合的并集
    注意:两个集合必须是有序序列
    @param beg1 容器1开始迭代器
    @param end1 容器1结束迭代器
    @param beg2 容器2开始迭代器
    @param end2 容器2结束迭代器
    @param dest  目标容器开始迭代器
    @return 目标容器的最后一个元素的迭代器地址
*/
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)

/*
    set_difference算法 求两个set集合的差集
    注意:两个集合必须是 *有序序列*
    @param beg1 容器1开始迭代器
    @param end1 容器1结束迭代器
    @param beg2 容器2开始迭代器
    @param end2 容器2结束迭代器
    @param dest  目标容器开始迭代器
    @return 目标容器的最后一个元素的迭代器地址
*/
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/03/17/C语言/STL六大组件简介/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/01/19/hello-world/">
        <h2>
            Hello Hexo
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/1/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="头部设置"><a href="#头部设置" class="headerlink" title="头部设置"></a>头部设置</h3><pre><code class="bash">title: 文章名称
date: 2021-09-01 09:36:05
tags: [标签1,标签2]
categories: 
- &quot;类别&quot;
- &quot;子类别&quot;
comments: true # 是否可评论
toc: true # 是否显示文章目录
top: true # 置顶设置
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2022/01/19/hello-world/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/2/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            

            
            <a href="/">
                <span class="page-num">1</span>
            </a>
            

            

            
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
        </span>
        

        <span class="current">
            3
        </span>

        

    </div>

    <div class="next">
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            Shuyan
        </div>
        <div class="descriptions">
            
            <div class="description">
                正しさなんてもの
            </div>
            
            <div class="description">
                人のモノサシによって変わる
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://en.korilin.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://jp.korilin.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>