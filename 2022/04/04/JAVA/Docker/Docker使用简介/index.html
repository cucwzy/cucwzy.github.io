<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>Docker使用简介 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="​         第一章 什么是docker1.1 docker的发展史​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinator的支持，后来微软谷歌亚马逊这样的大厂商也纷纷加入PAAS平台，竞争十分激烈，dotCloud举步维艰。 ​        2013年可能是公司发展的不是很好">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker使用简介">
<meta property="og:url" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="​         第一章 什么是docker1.1 docker的发展史​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinator的支持，后来微软谷歌亚马逊这样的大厂商也纷纷加入PAAS平台，竞争十分激烈，dotCloud举步维艰。 ​        2013年可能是公司发展的不是很好">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404205257479.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213106368.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213213857.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212652771.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213243444.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker使用简介.assets/image-20220404213553615.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker使用简介.assets/image-20220404212904989.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404214137451.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404214157935.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404211944042.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212013378.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212027692.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212040199.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212054623.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212157070.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212208939.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212223139.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212251383.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212311135.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212327583.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212340444.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212356259.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212411693.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212425173.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212437165.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212453512.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212503339.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212522439.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212540777.png">
<meta property="og:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212553619.png">
<meta property="article:published_time" content="2022-04-04T03:29:01.000Z">
<meta property="article:modified_time" content="2022-04-04T13:54:09.682Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404205257479.png">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1649080463895">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1649080463895">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1649080463895">
    <link rel="stylesheet" href="/css/style.css?v=1649080463895">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>43</div>
        <div><span>Tags</span>13</div>
        <div><span>Categories</span>21</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">21</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">12</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Docker”/">“Docker”</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">17</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/剑指offer/">剑指offer</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/数组/">数组</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/算法/">算法</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/">线性表</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/联邦学习/">联邦学习</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/贪心算法/">贪心算法</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/JVM/" style="font-size: 14px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 14px;">JavaWeb</a> <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/Mybaits/" style="font-size: 18px;">Mybaits</a> <a href="/tags/STL/" style="font-size: 14px;">STL</a> <a href="/tags/Spring/" style="font-size: 16px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 12px;">搜索</a> <a href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 12px;">联邦学习</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="/img/Docker使用简介.jpg" data-sizes="auto" alt="Docker使用简介" class="lazyload">
              <h1>Docker使用简介</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年04月04日</a>
</div>

      

      <p>​        </p>
<h1 id="第一章-什么是docker"><a href="#第一章-什么是docker" class="headerlink" title="第一章 什么是docker"></a>第一章 什么是docker</h1><h2 id="1-1-docker的发展史"><a href="#1-1-docker的发展史" class="headerlink" title="1.1 docker的发展史"></a>1.1 docker的发展史</h2><p>​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinator的支持，后来微软谷歌亚马逊这样的大厂商也纷纷加入PAAS平台，竞争十分激烈，dotCloud举步维艰。</p>
<p>​        2013年可能是公司发展的不是很好，工程师又不想自己的努力付之东流，于是他们决定将他们的核心技术开源。这项技术就是docker。当时docker的功能就是将linux容器中的应用代码打包，可以轻松的在服务器之间进行迁移。</p>
<p>​        无心插柳柳成荫，docker技术风靡全球，于是dotCloud公司改名为docker Inc，并全面投入到docker的开发之中。</p>
<ul>
<li><p>2014。6 Docker发布了第一个版本 Docker1。0</p>
</li>
<li><p>2014。7 获得C轮融资 $4000W</p>
</li>
<li><p>2015。4 获得D轮融资 $9500W</p>
</li>
<li><p>至今已经发布到docker </p>
</li>
</ul>
<h2 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h2><p>​        docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以放笔，书包可以放书，可以把hello word放在docker中，可以把网站放入docker中，可以把任何想得到的程序放在docker中。</p>
<p>​        我们在理解 <code>docker</code> 之前，首先我们得先区分清楚两个概念，<strong>容器</strong>和<strong>虚拟机</strong>。</p>
<p>​        我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p>
<p>​        而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p>
<p>​        容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404205257479.png" alt="image-20220404205257479" class="lazyload"></p>
<p>​        <strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 <code>Linux</code> 容器解决方案。</p>
<p>​        而 <code>Linux</code> 容器是 <code>Linux</code> 发展出了另一种虚拟化技术，简单来讲， <code>Linux</code> 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>​        <code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</p>
<p>​        总体来说， <code>Docker</code> 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h2 id="1-3-Docker的优势"><a href="#1-3-Docker的优势" class="headerlink" title="1.3 Docker的优势"></a>1.3 Docker的优势</h2><p> <strong>Docker相比于传统虚拟化方式具有更多的优势：</strong></p>
<ul>
<li><code>docker</code> 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li>
<li><code>docker</code> 需要的资源更少， <code>docker</code> 在操作系统级别进行虚拟化， <code>docker</code> 容器和内核交互，几乎没有性能损耗，性能优于通过 <code>Hypervisor</code> 层与内核层的虚拟化</li>
<li><code>docker</code> 更轻量， <code>docker</code> 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， <code>Docker</code> 运行的镜像数远多于虚拟机数量，对系统的利用率非常高</li>
<li>与虚拟机相比， <code>docker</code> 隔离性更弱， <code>docker</code> 属于进程之间的隔离，虚拟机可实现系统级别隔离</li>
<li>安全性： <code>docker</code> 的安全性也更弱。 <code>Docker</code> 的租户 <code>root</code> 和宿主机 <code>root</code> 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 <code>root</code> 权限和宿主机的 <code>root</code> 虚拟机权限是分离的，并且虚拟机利用如 <code>Intel</code> 的 <code>VT-d</code> 和 <code>VT-x</code> 的 <code>ring-1</code> 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li>
<li>可管理性： <code>docker</code> 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 <code>VMware vCenter</code> 提供完备的虚拟机管理能力</li>
<li>高可用和可恢复性： <code>docker</code> 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， <code>VMware</code> 可承诺虚拟机 <code>99。999%</code> 高可用，保证业务连续性</li>
<li>快速创建、删除：虚拟化创建是分钟级别的， <code>Docker</code> 容器创建是秒级别的， <code>Docker</code> 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li>
<li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 <code>Docker</code> 在 <code>Dockerfile</code> 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li>
</ul>
<p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">容器</th>
<th align="left">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为MB</td>
<td align="left">一般为GB</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般是几十个</td>
</tr>
</tbody></table>
<h1 id="第二章-了解docker"><a href="#第二章-了解docker" class="headerlink" title="第二章 了解docker"></a>第二章 了解docker</h1><h2 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2.1 docker思想"></a>2.1 docker思想</h2><h3 id="2-1-1-集装箱"><a href="#2-1-1-集装箱" class="headerlink" title="2.1.1 集装箱"></a>2.1.1 集装箱</h3><p>​        没有集装箱之前运输货物，东西零散容易丢失，有了集装箱之后货物不容易丢失，我们可以把货物想象成程序，目前我们要把程序部署到一台新的机器上，可能会启动不起来，比如少一些配置文件什么的或者少了什么数据，有了docker的集装箱可以保证我们的程序不管运行在哪不会缺东西。</p>
<h3 id="2-1-2-标准化"><a href="#2-1-2-标准化" class="headerlink" title="2.1.2 标准化"></a>2.1.2 标准化</h3><ol>
<li><strong>运输方式</strong></li>
</ol>
<p>​        docker运输东西有一个超级码头，任何地方需要货物都由鲸鱼先送到超级码头，然后再由鲸鱼从超级码头把货物送到目的地去。对应的技术来说，比如我们要把台式机的应用部署到笔记本上，我们可能选择用QQ发过去或者用U盘拷过去，docker就标准化了这个过程，我们只需在台式机上执行一个docker命令，把鲸鱼派过来，把程序送到超级码头去，再在笔记本上执行一个docker命令，然后由鲸鱼把程序从超级码头送到笔记本上去。</p>
<ol start="2">
<li><strong>存储方式</strong></li>
</ol>
<p>​        当我们把程序存储到笔记本上时，我们需要一个目录，且我们要记住这个目录，因为下次我们可能还要修改，有了docker之后我们就不用记住了程序在哪里了，我们使用的时候只需要一条命令就行了。</p>
<ol start="3">
<li><strong>API接口</strong></li>
</ol>
<p>​        docker提供了一系列rest api的接口，包含了对docker也就是对我们的应用的一个启动停止查看删除等等，如当我们要启动tomcat时我们要执行startup命令，当我们要停止时要执行shutdown命令，如果不是tomcat，我们可能还需要一些别的命令。有了docker我们记docker的命令就可以对其进行操作。</p>
<h3 id="2-1-3-隔离"><a href="#2-1-3-隔离" class="headerlink" title="2.1.3 隔离"></a>2.1.3 隔离</h3><p>​        我们在使用虚拟机时有自己的cpu，硬盘，内存，完全感觉不到外面主机的存在，docker也差不多，不过它更轻量，我们创建虚拟机可能要几分钟，但是docker只需要一秒。最底层的技术时linux一种内核的限制机制，叫做LXC，LXC是一种轻量级的容器虚拟化技术。最大效率的隔离了进程和资源。通过cgroup，namespace等限制，隔离进程组所使用的物理资源，比如CPU，MEMORY等等，这个机制在7，8年前已经加入到linux内核了，直到2013年docker出世的时候才火起来，大家可能奇怪为什么这么好的技术埋没这么多年都没人发现呢?英雄造时势，时势造英雄，如果没有云计算，敏捷开发，高频度的弹性伸缩需求，没有IT行业这么多年长足的发展，也就没有docker。</p>
<h2 id="2-2-docker解决的问题"><a href="#2-2-docker解决的问题" class="headerlink" title="2.2 docker解决的问题"></a>2.2 docker解决的问题</h2><h3 id="2-2-1-系统环境不一致"><a href="#2-2-1-系统环境不一致" class="headerlink" title="2.2.1 系统环境不一致"></a>2.2.1 系统环境不一致</h3><p>​        开发:我本地没问题。运维:服务器没问题。 这个问题就变成了皮球。</p>
<p>​        如果一个应用要正常的启动起来需要什么?比如java web应用。</p>
<p>​        需要一个操作系统，操作系统之上要jdk，tomcat，我们的代码，配置文件。</p>
<p>​        操作系统的改变可能会导致我们的应用开不起来，比如我们调用了某些系统命令。</p>
<p>​        jdk版本也可能导致程序的运行失败。比如class文件需要1。7编译，我们装了个1。6的jdk。</p>
<p>​        tomcat版本也能导致失败，比如旧的版本一些配置在新版本中不再支持。</p>
<p>​        代码的话就比如应用了C盘，D盘的一个文件，或者是用了系统的一些环境编码。</p>
<p>​        配置的话我们可能少了某个配置文件等等。</p>
<p>​        下面docker来了，它把操作系统，jdk，tomcat，代码，配置全部放到集装箱里。再打包放到鲸鱼上，由鲸鱼给我们送到服务器上，在我的机器上怎么运行，在别的机器上也怎么运行。不会有任何的问题。一句话就是docker解决了运行环境不一致所带来的问题。</p>
<h3 id="2-2-2-系统好卡，哪个哥们又写死循环了"><a href="#2-2-2-系统好卡，哪个哥们又写死循环了" class="headerlink" title="2.2.2 系统好卡，哪个哥们又写死循环了"></a>2.2.2 系统好卡，哪个哥们又写死循环了</h3><p>​        如果有根别人共用服务器的同学可能有这样的体会，莫名其妙发现自己的程序挂了，一查原因要不是内存不够了，要不是硬盘满了，还有就是发现某个服务变慢了，甚至敲终端都比较卡，但是linux本身就是一个多用户的操作系统本身就可以供多个用户使用，docker的隔离性可以解决这个问题，就算别人的程序还是死循环疯狂吃CPU，还是封装疯狂打日志把硬盘占满，还是内存泄漏，把内存占满，都不会导致我们的程序运行错误。因为docker在启动的时候就限定好了，它最大使用的CPU硬盘，如果超过了，就会杀掉对应进程。</p>
<h3 id="2-2-3-双11来了，服务器撑不住了"><a href="#2-2-3-双11来了，服务器撑不住了" class="headerlink" title="2.2.3 双11来了，服务器撑不住了"></a>2.2.3 双11来了，服务器撑不住了</h3><p>​        大部分系统业务量并不是每天都比较平均的，特别是一些电商系统，每天总有那么几天业务量是平时的几倍甚至几十倍，如果按双11的规模去准备服务器那么对于平时的规模来说又是极大的浪费，所以就在节日前临时扩展机器，过完节再把多余的节点下线，这就给运维带来了非常大的工作量，一到过节就在各个机器上部署各种各样的服务，我们启动程序需要java，tocmat等等，并且还可能起不来还要调试，这是非常恶心的工作，有了docker一切都变得美好了，只要点一下服务器就可以从10台变成100台甚至1000，1W台。都是分分钟的事情。</p>
<p>​        为什么会这么快呢？都是用标准的方式把我们的程序运过来，下载过来，再用标准的方式把它运行起来，就可以做到只要在每台机器上都执行一两条命令，就可以让程序正常跑起来，并且不用担心有问题。</p>
<h1 id="第三章-走进docker"><a href="#第三章-走进docker" class="headerlink" title="第三章 走进docker"></a>第三章 走进docker</h1><p>​        镜像就是上面说的集装箱，仓库就是超级码头，容器就是我们运行程序的地方。docker运行程序的过程就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213106368.png" alt="image-20220404213106368" class="lazyload"></p>
<ul>
<li><p>build：构建，就是构建镜像。</p>
</li>
<li><p>ship：运输，运输镜像，从仓库和主机运输。</p>
</li>
<li><p>run：运行的镜像就是一个容器。</p>
</li>
</ul>
<p>build，ship，run和镜像，仓库，容器是一一对应的。</p>
<h2 id="3-1-镜像"><a href="#3-1-镜像" class="headerlink" title="3.1 镜像"></a>3.1 镜像</h2><p>​        镜像的英文名交image。前面我们讲到了集装箱，鲸鱼拖着的所有集装箱就是一个镜像。</p>
<p>​        从本质上来说镜像就是一系列文件，了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>​        镜像<code>（Image）</code>就是一堆只读层<code>（read-only layer）</code>的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213213857.png" alt="image-20220404213213857" class="lazyload"></p>
<p>​        从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code> 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 <code>(union file system)</code> 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p>
<p>​        既然Docker是文件，那么是以什么样的格式在本地保存的呢?</p>
<p>​        说到<strong>存储格式</strong>，就要提到linux的一个存储技术，叫做<strong>联合文件系统</strong>，是一种分层的文件系统，可以将不同的目录挂到同一个虚拟文件系统下。</p>
<p>​        比如test1下有三个文件夹，test2下有两个文件夹，还有一个readme文件。联合文件系统就是可以在一个文件夹(test)中看到多个文件夹(test1，test2)中的内容。</p>
<p>​        通过这种方式可以实现文件的分层，test1可以把它看作第一层，test2可以把它看作第二层，每一层有每一层自己的文件，docker就是利用了这种分层的概念实现了镜像存储。</p>
<p>​        下图就是镜像的存储格式，这张图是分层的，最下面一层，上面也是一层层的好像集装箱罗列在一起。这就是镜像最直观的存储方式。下面是操作系统的引导，上面是linux操作系统，再上面是一些相关的软件，如果是我们自己的程序，就可以是tomcat，jdk，再往上是应用代码，每一层是我们自己都可以控制得，最上面一层先忽略不看，因为这是和容器有关的。注意一点，docker镜像系统的每一层都是只读的，然后把每一层加载完成之后这些文件都会被看成是同一个目录，相当于只有一个文件系统。docker的这种文件系统被称之为镜像。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212652771.png" alt="image-20220404212652771" class="lazyload"></p>
<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>​        容器 <code>(container)</code> 的定义和镜像 <code>(image)</code> 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404213243444.png" alt="image-20220404213243444" class="lazyload"></p>
<p>​        由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p>
<p>​        为了便于理解，大家可以把容器想象成虚拟机，每个虚拟机都有自己的文件系统，可以把图1整个一部分看成是文件系统，与虚拟机系统的区别是这里面的文件系统是一层一层的，并且最下面的n层都是只读的，只有上面一层是可写的。为什么要有可写的这层呢?大家的程序运行起来，势必会要写一些日志，写一些文件，或者对系统的某一些文件做一些修改，所以容器在最上面一层创建了可读可写的文件系统。</p>
<p>​        在程序的运行过程中，如果要写镜像文件时，因为镜像的每一层都是只读的，它会把文件的每一层拷到文件的最上层，然后再对它进行修改，修改之后，当我们的应用读一个文件时会从顶层进行查找，如果没有才会找下一层。</p>
<p>​        由于容器的最上一层是可以修改的，镜像是不能修改的，这样就能保证镜像可以生成多个容器独立运行，没有任何干扰。</p>
<h2 id="3-3-仓库"><a href="#3-3-仓库" class="headerlink" title="3.3 仓库"></a>3.3 仓库</h2><p>​        我们的镜像是要在其它机器上运行，如何进行传输呢?</p>
<p>​        这就用到了docker仓库，我们要先把我们的镜像传到docker仓库中，再由目的地把docker仓库拉过去，这就完成了这样的一次传输过程。</p>
<p>​        谁提供了这样的仓库呢?docker自己提供了，hub。docker。com，但是非常慢，为了解决这个问题，国内很多公司也在做自己的仓库。比较知名的是由网易蜂巢提供的 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p>
<p>​         <code>Docker</code> 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> (仓库注册服务器)就是这样的服务。有时候会把仓库 <code>(Repository)</code> 和仓库注册服务器 <code>(Registry)</code> 混为一谈，并不严格区分。<code>Docker</code> 仓库的概念跟 <code>Git</code> 类似，注册服务器可以理解为 <code>GitHub</code> 这样的托管服务。实际上，一个 <code>Docker Registry</code> 中可以包含多个仓库 <code>(Repository)</code> ，每个仓库可以包含多个标签 <code>(Tag)</code>，每个标签对应着一个镜像。所以说，镜像仓库是 <code>Docker</code> 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p>
<p>​        通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签.。</p>
<p>仓库又可以分为两种形式：</p>
<ul>
<li><code>public</code>(公有仓库)</li>
<li><code>private</code>(私有仓库)</li>
</ul>
<p>​        <code>Docker Registry</code> 公有仓库是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>​        除了使用公开服务外，用户还可以在本地搭建私有 <code>Docker Registry</code> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code>镜像，可以直接使用做为私有 <code>Registry</code> 服务。当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p>
<p>​        我们主要把 <code>Docker</code> 的一些常见概念如 <code>Image</code> ， <code>Container</code> ， <code>Repository</code> 做了详细的阐述，也从传统虚拟化方式的角度阐述了 <code>docker</code> 的优势，我们从下图可以直观地看到 <code>Docker</code> 的架构：</p>
<img data-fancybox="gallery" data-sizes="auto" data-src="Docker使用简介.assets/image-20220404213553615.png" alt="image-20220404213553615" class="lazyload">

<p>​        <code>Docker</code> 使用 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互，Docker服务端负责构建、运行和分发 <code>Docker</code> 镜像。 <code>Docker</code> 客户端和服务端可以运行在一台机器上，也可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p>
<img data-fancybox="gallery" data-sizes="auto" data-src="Docker使用简介.assets/image-20220404212904989.png" alt="image-20220404212904989" class="lazyload">



<p><code>Docker</code> 的核心组件包括：</p>
<ol>
<li><strong>Docker Client</strong></li>
<li><strong>Docker daemon</strong></li>
<li><strong>Docker Image</strong></li>
<li><strong>Docker Registry</strong></li>
<li><strong>Docker Container</strong></li>
</ol>
<p>​        这张图展示了 <code>Docker</code> 客户端、服务端和 <code>Docker</code> 仓库（即 <code>Docker Hub</code> 和 <code>Docker Cloud</code> ），默认情况下<code>Docker</code> 会在 <code>Docker</code> 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 <code>Git</code> ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p>
<h1 id="第四章-centos下docker安装"><a href="#第四章-centos下docker安装" class="headerlink" title="第四章 centos下docker安装"></a>第四章 centos下docker安装</h1><p>​        <code>Docker</code> 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 <code>Docker</code> 一开始就支持的 <code>X86-64</code> ，其他体系架构的支持则一直在不断地完善和推进中。</p>
<p>​        <code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。</p>
<p>​        我们在安装前可以参看官方文档获取最新的 <code>Docker</code> 支持情况，官方文档在这里：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">https://docs.docker.com/install/<br></code></pre></td></tr></table></figure>

<p>​        <code>Docker</code> 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 <code>Cgroup</code> 和 <code>Namespace</code> 相关选项，以及其他的网络和存储驱动等)， <code>Docker</code> 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh<br></code></pre></td></tr></table></figure>

<p>在满足前提条件后，安装就变得非常的简单了。</p>
<p><code>Docker CE</code> 的安装请参考官方文档：</p>
<ul>
<li><code>MacOS</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li>
<li><code>Windows</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></li>
<li><code>Ubuntu</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li>
<li><code>Debian</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">https://docs.docker.com/install/linux/docker-ce/debian/</a></li>
<li><code>CentOS</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></li>
<li><code>Fedora</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/fedora/">https://docs.docker.com/install/linux/docker-ce/fedora/</a></li>
<li>其他 <code>Linux</code> 发行版：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/binaries/">https://docs.docker.com/install/linux/docker-ce/binaries/</a></li>
</ul>
<ol>
<li>Docker 要求 CentOS 系统的内核版本高于 3.10，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</li>
</ol>
<p>通过 <strong>uname -r</strong> 命令查看你当前的内核版本</p>
<ol start="2">
<li>如果安装过请先卸载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker \<br>           docker-client \<br>           docker-client-latest \<br>           docker-common \<br>           docker-latest \<br>           docker-latest-logrotate \<br>           docker-logrotate \<br>           docker-engine<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>安装依赖设置yum仓库</li>
</ol>
<p>安装依赖:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">yum</span> install -y yum-utils \<br>  device-mapper-persistent-<span class="hljs-class"><span class="hljs-keyword">data</span> \</span><br>  lvm2<br></code></pre></td></tr></table></figure>

<p>设置仓库:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">yum-config-manager \<br>    --add-repo \<br>    <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/download.docker.com/linux</span><span class="hljs-regexp">/centos/docker</span>-ce.repo<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>安装docker</p>
<p>​    <code>Docker</code> 软件包已经包括在默认的 <code>CentOS-Extras</code> 软件源里。因此想要安装 <code>docker</code>，只需要运行下面的 <code>yum</code> 命令</p>
</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sudo yum install docker<br></code></pre></td></tr></table></figure>

<p>​        当然在测试或开发环境中 <code>Docker</code> 官方为了简化安装流程，提供了一套便捷的安装脚本，<code>CentOS</code> 系统上可以使用这套脚本安装：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">curl -fsSL <span class="hljs-keyword">get</span>.docker.com -o <span class="hljs-keyword">get</span>-docker.sh<br>sh <span class="hljs-keyword">get</span>-docker.sh<br></code></pre></td></tr></table></figure>

<p>​        具体可以参看 <code>docker-install</code> 的脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">https:<span class="hljs-comment">//github.com/docker/docker-install</span><br></code></pre></td></tr></table></figure>

<p>​        执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 <code>Docker CE</code> 的 <code>Edge</code> 版本安装在系统中。</p>
<p>​        安装完成后，运行下面的命令，验证是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker version<br>or<br>docker info<br></code></pre></td></tr></table></figure>

<p>​        返回docker的版本相关信息，证明 <code>docker</code> 安装成功</p>
<p><strong>或者</strong>通过以下命令安装：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">yum install docker-ce docker-ce-cli containerd.<span class="hljs-built_in">io</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>启动并加入开机启动</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">systemctl <span class="hljs-keyword">start</span> docker<br>systemctl enable docker<br></code></pre></td></tr></table></figure>

<ol start="6">
<li><p>Docker简单运用</p>
<p>​    我们通过最简单的 <code>image</code> 文件 <code>hello world</code>，感受一下 <code>Docker</code> 的魅力吧！</p>
<p>​    我们直接运行下面的命令，将名为 <code>hello-world</code> 的 <code>image</code> 文件从仓库抓取到本地。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull library/hello-world<br></code></pre></td></tr></table></figure>

<p>​        <code>docker pull images</code> 是抓取 <code>image</code> 文件， <code>library/hello-world</code> 是 <code>image</code> 文件在仓库里面的位置，其中 <code>library</code> 是 <code>image</code> 文件所在的组， <code>hello-world</code> 是 <code>image</code> 文件的名字。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404214137451.png" alt="image-20220404214137451" class="lazyload"></p>
<p>​        抓取成功以后，就可以在本机看到这个 <code>image</code> 文件了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker images<br></code></pre></td></tr></table></figure>

<p>我们可以看到如下结果：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404214157935.png" alt="image-20220404214157935" class="lazyload"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run hello-world<br></code></pre></td></tr></table></figure>

<p>显示如下即安装成功! </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@iZ2ze68ge5c1uwlkmnb9ixZ zcapp]<span class="hljs-comment"># docker run hello-world</span><br><br>Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling from library/hello-world<br>1b930d010525: Pull complete <br>Digest: sha256:0e11c388b664df8a27a901dce21eb89f11d8292f7fca1b3e3c4321bf7897bffe<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br>Hello from Docker!<br>This message shows that your installation appears to be working correctly。<br>To generate this message， Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon。<br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub。<br>    (amd64)<br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>    executable that produces the output you are currently reading。<br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>    to your terminal。<br>To try something more ambitious， you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br>Share images， automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br>For more examples and ideas,visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure>



<h1 id="第五章-docker初体验"><a href="#第五章-docker初体验" class="headerlink" title="第五章 docker初体验"></a>第五章 docker初体验</h1><h2 id="5-1-docker基本命令"><a href="#5-1-docker基本命令" class="headerlink" title="5.1 docker基本命令"></a>5.1 docker基本命令</h2><ol>
<li><p><strong><code>docker pull [options] NAME[:TAG]</code></strong></p>
<p>​    通过此命令可以docker远程仓库拉取镜像到本地。</p>
<ul>
<li><p>name是拉取镜像的名称，:TAG表示是可选的，如果不选表明时latest，如果选择表明是指定版本的。</p>
</li>
<li><p>options是拉去的一些参数。</p>
</li>
</ul>
</li>
</ol>
<p>当不加请求地址的时候回去docker的官网拉取镜像。</p>
<ol start="2">
<li><p><strong><code>docker images [options] [REPOSITORY[:TAG]]</code></strong></p>
<p>options是选项，后面是指定镜像的名称。这个用的不多，可能当本地镜像非常多的时候要指定查看某一个镜像。</p>
</li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404211944042.png" alt="image-20220404211944042" class="lazyload"></p>
<p>​        IMAGE ID 其实是一个64位的字符串，它可以唯一标识我们的镜像，这里只显示了16位，后面的被截掉了。</p>
<ol start="3">
<li><strong><code>docker run [options] IMAGE[:TAG] [COMMAND] [ARG..]</code></strong></li>
</ol>
<ul>
<li><p>IMAGE是镜像的名字</p>
</li>
<li><p>COMMAND是运行起来的时候要执行什么命令。</p>
</li>
<li><p>ARG表示这条命令运行需要的参数。</p>
</li>
</ul>
<h2 id="5-2-docker运行镜像流程"><a href="#5-2-docker运行镜像流程" class="headerlink" title="5.2 docker运行镜像流程"></a>5.2 docker运行镜像流程</h2><p>​        <strong>docker pull</strong>：首先<code>docker pull</code>向<code>docker daemon</code>发送了一条命令pull，告诉<code>docker daemon</code>要拉取某一个镜像，<code>docker daemon</code>会在本机检查镜像是否存在，如果存在且版本就是我们想要拉取的版本，它就不会做任何的操作。如果不存在下一步它会到docker的仓库中找我们要拉取的镜像名字，如果找到了就会有docker仓库传送到我们的本地，把我们要的镜像传送到我们的本地来。</p>
<p>​    <strong>docker run</strong>：首先把命令发送到我们的<code>docker daemon</code>，<code>docker daemon</code>会先检查镜像在本机是否存在，如果不存在相当于执行了一个<code>docker pull</code>的过程，下载回来之后会以一定方式把镜像运行起来变成docker容器。</p>
<h1 id="第六章-docker运行nginx"><a href="#第六章-docker运行nginx" class="headerlink" title="第六章 docker运行nginx"></a>第六章 docker运行nginx</h1><h2 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6.1 运行nginx镜像"></a>6.1 运行nginx镜像</h2><p>​        我们打开网易蜂巢镜像中心 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p>
<p>​        搜索nginx，可以看到有两个nginx，他们的名字和头上和图标都不一样，一个是鲸鱼，一个是两个球。</p>
<p>​        带有鲸鱼的镜像表示这个镜像是从官网的镜像中心复制过来的。这个镜像与docker的镜像是一摸一样的。我们使用此镜像。</p>
<p>点进去，会有下载地址，复制里面的地址，然后拉取镜像。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212013378.png" alt="image-20220404212013378" class="lazyload"></p>
<p>复制到系统中运行。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212027692.png" alt="image-20220404212027692" class="lazyload"></p>
<p>运行完后可以查看镜像状态</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212040199.png" alt="image-20220404212040199" class="lazyload"></p>
<p>在前台运行容器命令如下，输入后容器就会运行，按ctrl+c可以终止容器的运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run hub.c.163.com/library/nginx<br></code></pre></td></tr></table></figure>

<p>在后台运行容器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d hub.c.163.com/library/nginx<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212054623.png" alt="image-20220404212054623" class="lazyload"></p>
<p>查看运行的容器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker ps<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212157070.png" alt="image-20220404212157070" class="lazyload"></p>
<p>更多关于运行的命令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker run --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>

<p>因为我们在平时运行的时候需要调试容器内部的设置、查看一下日志等等。我们可以通过如下命令进入容器内部:</p>
<p>命令的大体内容:</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212208939.png" alt="image-20220404212208939" class="lazyload"></p>
<p>命令具体内容: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker <span class="hljs-built_in">exec</span> -it 02963d2002b bash<br></code></pre></td></tr></table></figure>

<p> -i保证我们的输入有效，即使在没有detach的情况下也能运行。</p>
<p>-t表示将分配给我们一个伪终端。我们将在伪终端输入我们的内容。</p>
<p>后面跟着的是容器的id，即我们上面用ps查询出来的id，这个id可以少写几位，它会自动识别。</p>
<p>可输入如下命令了解更多:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker <span class="hljs-built_in">exec</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>

<p>输入命令后发现我们前面的标识也变了，相当于进入了一个新的电脑。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212223139.png" alt="image-20220404212223139" class="lazyload"></p>
<p>可以查询一下nginx在什么位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> nginx<br></code></pre></td></tr></table></figure>

<p>​        打开ps查看一下当前运行的进程。我这里提示没有ps命令。我从网上查了一下发现是因为当前系统没有安装这个命令，然后我安装了一下。从命令可以看出，这个nginx容器附带的系统应该是ubuntu不是centos。</p>
<p>安装ps命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> update<br>apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install procps<br></code></pre></td></tr></table></figure>

<p>​        利用ps命令查看进程，可以发现nginx已经在运行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ps -ef<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212251383.png" alt="image-20220404212251383" class="lazyload"></p>
<p>​        输入 exit即可退出返回原来的系统。 </p>
<h2 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2 docker网络"></a>6.2 docker网络</h2><h3 id="6-2-1-网络介绍"><a href="#6-2-1-网络介绍" class="headerlink" title="6.2.1 网络介绍"></a>6.2.1 网络介绍</h3><p>​        上面我们只运行了nginx，并没有用浏览器进行访问，这里我们尝试用浏览器访问，但是之前我们要了解一下docker网络。</p>
<p>​        我们直到docker的隔离性，网络也是个隔离性的一部分，linux使用了命名空间来进行资源的隔离，比如pid namespace就是用来隔离进程的，mount namespace是用来隔离文件系统的，<code>network namespace</code> 是用来隔离网络的。每一个<code>network namespace</code>都提供了一个独立的网络环境，包括网卡路由iptable规则等等，都是与以其它的network space隔离的。</p>
<ol>
<li>docker容器在默认情况下，一般会分配一个独立的<code>network-namespace</code>，也就是网络类型中的Bridge模式。</li>
</ol>
<p>​        在使用Bridge时就涉及到了一个问题，既然它有独立的namesapce，这就需要一种技术使容器内的端口可以在主机上访问到，这种技术就是端口映射，docker可以指定你想把容器内的某一个端口可以在容器所在主机上的某一个端口它俩之间做一个映射，当你在访问主机上的端口时，其实就是访问容器里面的端口。</p>
<ol start="2">
<li><p>还有一种类型是Host模式，如果在启动容器的时候指定使用Host模式，那么这个容器将不会获得一个独立的network namespace，而是和主机共同使用一个，这个时候容器将不会虚拟出自己的网卡，配置出自己的ip。而是使用宿主机上的ip和端口。也就是说在docker上使用网络和在主机上使用网络是一样的。</p>
</li>
<li><p>还有一种网络类型是None。也就是没有网络，这种情况docker将不会和外界的任何东西进行通讯。</p>
</li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212311135.png" alt="image-20220404212311135" class="lazyload"></p>
<h3 id="6-2-2-实际访问端口"><a href="#6-2-2-实际访问端口" class="headerlink" title="6.2.2 实际访问端口"></a>6.2.2 实际访问端口</h3><p>​        刚才我们在运行nginx镜像的时候并没有指定端口映射，所以我们这里停掉nginx容器。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">docker <span class="hljs-keyword">stop</span> containerId<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212327583.png" alt="image-20220404212327583" class="lazyload"></p>
<ol>
<li><code>-p</code>(小写)是开放一个容器的端口到主机上</li>
</ol>
<p>在后台运行，开放主机8080端口映射到容器的80端口上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run -d -<span class="hljs-selector-tag">p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> hub.c.<span class="hljs-number">163</span>.com/library/nginx<br></code></pre></td></tr></table></figure>

<p>查看主机8080端口是否开启</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">netstat -na |<span class="hljs-keyword">grep</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<p> <img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212340444.png" alt="image-20220404212340444" class="lazyload"></p>
<p>是开启的那么访问 主机ip:8080 即可访问到nginx。</p>
<ol start="2">
<li><code>-P</code>(大写)是开放容器所有的端口到主机上一个随机的端口。</li>
</ol>
<p>停掉刚才的docker服务。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212356259.png" alt="image-20220404212356259" class="lazyload"></p>
<p>使用大P</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run -d -<span class="hljs-selector-tag">P</span> hub<span class="hljs-selector-class">.c</span>.<span class="hljs-number">163</span><span class="hljs-selector-class">.com</span>/library/nginx<br></code></pre></td></tr></table></figure>

<p>可以看到随机给我的端口是32768 </p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212411693.png" alt="image-20220404212411693" class="lazyload"></p>
<p>然后用 ip:32768去访问即可访问到nginx。 </p>
<h1 id="第七章-docker部署第一个java-web应用"><a href="#第七章-docker部署第一个java-web应用" class="headerlink" title="第七章 docker部署第一个java web应用"></a>第七章 docker部署第一个java web应用</h1><p>​        我们还需要学习Dockerfile，它告诉docker我们怎样制作我们的镜像，我们镜像的每一步操作分别是什么，写好Dockerfile后我们使用docker build命令执行Dockerfile里面的每一件事情。最终会把Dockerfile构建出来。</p>
<p>在这里因为是做一个演示，所以我们使用了一个开源的java web应用Jpress。</p>
<h2 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7.1 制作自己的镜像"></a>7.1 制作自己的镜像</h2><ol>
<li>从网易的镜像中心找一个tomcat的镜像</li>
</ol>
<p><code>docker pull hub.c.163.com/library/tomcat:latest</code></p>
<p>因为tomat镜像肯定有jdk，所以我们就不用单独再装jdk了。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212425173.png" alt="image-20220404212425173" class="lazyload"></p>
<p>2.编写dockerfile</p>
<p>我们需要建立一个dockerfile告诉docker需要做什么，这里我建立了Dockerfile，并将我们的web文件放到了和它同一个目录下。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212437165.png" alt="image-20220404212437165" class="lazyload"></p>
<p>首先我们的镜像是要运行在tomcat中的，所以填写 from tomcat，以tomcat为基础。maintainer是所有者的意思。因为war包是要放在webapps中的，所以我们使用copy命令复制到tomcat的webapps。</p>
<p>为什么webapps在local中?我们可以去下载镜像的网站查询，向下拉就好了。具体网址 : <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/repository/?repoId=2955">https://c.163yun.com/hub#/m/repository/?repoId=2955</a></p>
<p>这里说一个个人猜想，每个容器都包含一个自己的系统，所以这里的/usr/local/tomcat/webapps指的是tomcat容器中的位置，那么哪里指定是tomcat容器呢?就是在一开始的from指定的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">from</span> hub.c<span class="hljs-number">.163</span>.com<span class="hljs-operator">/</span>library<span class="hljs-operator">/</span>tomcat<br>maintainer zhangchen <span class="hljs-number">61037</span><span class="hljs-variable">@qq</span>.com<br><span class="hljs-keyword">COPY</span> jpress.war <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>tomcat<span class="hljs-operator">/</span>webapps<br></code></pre></td></tr></table></figure>

<p>3。构建容器</p>
<p>注意这里是<strong>有个点</strong>的，点标明是在根据当前目录构建</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build .<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212453512.png" alt="image-20220404212453512" class="lazyload"></p>
<p>可以使用docker images查看镜像是否build成功</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212503339.png" alt="image-20220404212503339" class="lazyload"></p>
<p>发现一个none，表明构建成功了。</p>
<p>可以重新构建给它起个名字<code> -t</code>是给镜像指定一个tag</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build -t jpress:latest .<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212522439.png" alt="image-20220404212522439" class="lazyload"></p>
<p>更多的参数查询:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker build --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>

<h2 id="7-2-运行自己的镜像"><a href="#7-2-运行自己的镜像" class="headerlink" title="7.2 运行自己的镜像"></a>7.2 运行自己的镜像</h2><p>​        运行我们制作的镜像并指定端口</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run -d -<span class="hljs-selector-tag">p</span>  <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> jpress<br></code></pre></td></tr></table></figure>

<p>​        访问我们的网站，发现网站已经可以正常访问了。</p>
<p>​        然后发现它要求我们安装自己的数据库，所以我们利用docker安装mysql。</p>
<p>​        在镜像中心搜索并拉取mysql</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull hub.c.163.com/library/mysql:latest<br></code></pre></td></tr></table></figure>

<p>​        在镜像中心查看配置，并配置root用户密码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run -d -<span class="hljs-selector-tag">p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> hub.c.<span class="hljs-number">163</span>.com/library/mysql<br></code></pre></td></tr></table></figure>

<p>​         发现我们没有创建数据库，于是停止这个容器的运行，并在与剧中创建jpress数据库。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">docker <span class="hljs-keyword">stop</span> <span class="hljs-number">4</span>be94fb2df1d3a28c1<br>ocker run -d -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -e MYSQL_DATABASE=jpress hub.c.<span class="hljs-number">163</span>.com/library/mysql<br></code></pre></td></tr></table></figure>

<p>​        这样我们的数据库就建立成功了。</p>
<p>​        进入网站后要输入网站信息，输入数据库地址时，注意不要输入localhost，因为我们jpress是运行在容器内的，我们会访问tomcat容器内的3306，我们应该用ifconfig查询我们本机的ip地址。我这里的内网ip是172.17.10.68</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212540777.png" alt="image-20220404212540777" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.assets/image-20220404212553619.png" alt="image-20220404212553619" class="lazyload"></p>
<p>以上都做完后，我们的网站就可以跑起来了。</p>
<p><a target="_blank" rel="noopener" href="http://59.110.164.62:8080/jpress/">http://59.110.164.62:8080/jpress/</a></p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/04/04/JAVA/Docker/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;04&#x2F;04&#x2F;JAVA&#x2F;Docker&#x2F;Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;04&#x2F;04&#x2F;JAVA&#x2F;Docker&#x2F;Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/">JAVA</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CDocker%E2%80%9D/">“Docker”</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Docker/" rel="tag">Docker</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFdocker"><span class="toc-number">1.</span> <span class="toc-text">第一章 什么是docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-docker%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 docker的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 什么是Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Docker%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Docker的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BA%86%E8%A7%A3docker"><span class="toc-number">2.</span> <span class="toc-text">第二章 了解docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-docker%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 docker思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E9%9B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 集装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E9%9A%94%E7%A6%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 隔离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-docker%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 docker解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 系统环境不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E7%B3%BB%E7%BB%9F%E5%A5%BD%E5%8D%A1%EF%BC%8C%E5%93%AA%E4%B8%AA%E5%93%A5%E4%BB%AC%E5%8F%88%E5%86%99%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BA%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 系统好卡，哪个哥们又写死循环了</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%8F%8C11%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%92%91%E4%B8%8D%E4%BD%8F%E4%BA%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 双11来了，服务器撑不住了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%B5%B0%E8%BF%9Bdocker"><span class="toc-number">3.</span> <span class="toc-text">第三章 走进docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BB%93%E5%BA%93"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-centos%E4%B8%8Bdocker%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">第四章 centos下docker安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-docker%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">5.</span> <span class="toc-text">第五章 docker初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 docker基本命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-docker%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 docker运行镜像流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-docker%E8%BF%90%E8%A1%8Cnginx"><span class="toc-number">6.</span> <span class="toc-text">第六章 docker运行nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%BF%90%E8%A1%8Cnginx%E9%95%9C%E5%83%8F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 运行nginx镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-docker%E7%BD%91%E7%BB%9C"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 网络介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 实际访问端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-docker%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AAjava-web%E5%BA%94%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">第七章 docker部署第一个java web应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 制作自己的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%BF%90%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 运行自己的镜像</span></a></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1649080463910"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
