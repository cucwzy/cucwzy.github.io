<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>JAVA反射机制 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="前言：反射是Java Web框架设计的灵魂。作为Java Web框架中必不可少的反射机制，比如Spring的IOC控制反转（通过第三方配置文件实现对象的控制）就会经常用到。反射是Java中一种强大技术，能够使我们很方便的创建灵活的代码，通过获取配置文件的class名，这些代码可以在运行时装配，无需在组件之间进行源代码链接，降低了代码的耦合度。但是要注意反射使用不当的话会成本很高。 一、Java反射">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA反射机制">
<meta property="og:url" content="http://example.com/2022/05/12/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="前言：反射是Java Web框架设计的灵魂。作为Java Web框架中必不可少的反射机制，比如Spring的IOC控制反转（通过第三方配置文件实现对象的控制）就会经常用到。反射是Java中一种强大技术，能够使我们很方便的创建灵活的代码，通过获取配置文件的class名，这些代码可以在运行时装配，无需在组件之间进行源代码链接，降低了代码的耦合度。但是要注意反射使用不当的话会成本很高。 一、Java反射">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-12T03:29:01.000Z">
<meta property="article:modified_time" content="2022-05-17T04:15:45.565Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1656085043061">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1656085043061">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1656085043061">
    <link rel="stylesheet" href="/css/style.css?v=1656085043061">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>98</div>
        <div><span>Tags</span>20</div>
        <div><span>Categories</span>34</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Docker/">Docker</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">43</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/LaTex/">LaTex</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">21</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Linux/">Linux</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SSM/">SSM</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/Spring框架/">Spring框架</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Docker”/">“Docker”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JAVA基础知识”/">“JAVA基础知识”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Nginx”/">“Nginx”</a>
          <span class="category-list-count">8</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Redis”/">“Redis”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/Spring框架/“Security”/">“Security”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">22</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/剑指offer/">剑指offer</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/单链表/">单链表</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/字符串/">字符串</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/数组/">数组</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/栈和队列/">栈和队列</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/算法/">算法</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/">线性表</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/网络编程/">网络编程</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/联邦学习/">联邦学习</a>
          <span class="category-list-count">11</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/贪心算法/">贪心算法</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 12.5px;">Docker</a> <a href="/tags/JAVA/" style="font-size: 12.5px;">JAVA</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 12.5px;">JavaWeb</a> <a href="/tags/LaTex/" style="font-size: 10px;">LaTex</a> <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 11.25px;">Linux</a> <a href="/tags/Mybaits/" style="font-size: 15px;">Mybaits</a> <a href="/tags/Nginx/" style="font-size: 17.5px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 12.5px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10px;">SSM</a> <a href="/tags/STL/" style="font-size: 12.5px;">STL</a> <a href="/tags/Security/" style="font-size: 11.25px;">Security</a> <a href="/tags/Spring/" style="font-size: 16.25px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 11.25px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.75px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 11.25px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 11.25px;">搜索</a> <a href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 18.75px;">联邦学习</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="/img/JAVA反射机制.jpg" data-sizes="auto" alt="JAVA反射机制" class="lazyload">
              <h1>JAVA反射机制</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年05月12日</a>
</div>

      

      <p>前言：反射是Java Web框架设计的灵魂。作为Java Web框架中必不可少的反射机制，比如Spring的IOC控制反转（通过第三方配置文件实现对象的控制）就会经常用到。反射是Java中一种强大技术，能够使我们很方便的创建灵活的代码，通过获取配置文件的class名，这些代码可以在运行时装配，无需在组件之间进行源代码链接，降低了代码的耦合度。但是要注意反射使用不当的话会成本很高。</p>
<h2 id="一、Java反射机制的概念"><a href="#一、Java反射机制的概念" class="headerlink" title="一、Java反射机制的概念"></a>一、Java反射机制的概念</h2><blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
</blockquote>
<p>1、反射机制允许Java程序在运行时取得任何一个已知名称的class的内部信息。可以动态的获取类的完整结构信息，调用对象的方法和属性。</p>
<p>反射的概念：</p>
<blockquote>
<p>比如我们想看看我们自己长什么样子，我们自己肯定看不到自己长什么样子，所以，我们借助镜子，通过镜子的反射看到我们的样子，可以看清我们自己的五官；</p>
<p>同理，Java中运行的类，也有这么一面镜子，可以反射该类的一些行为和属性，而这个反射就体现在java.lang.Class中。通过Class对象，可以得到某个类的一些行为和属性，甚至我们通过反射可以操作这个对象的行为和属性，这就是反射机制。</p>
</blockquote>
<p>我们对反射的最初接触是学习jdbc时，加载数据库驱动时会这样写：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></p>
<p>2、Java是跨平台的语言：Java编写的程序，一次编译，到处运行。因为Java的源代码会被编译成.class文件字节码，只要装有Java虚拟机JVM的地方，.class文件畅通无阻。</p>
<p>Java的反射机制，操作的就是这个.class文件，首先加载相应类的字节码，随后解剖（反射 reflect）出字节码中的构造方法、方法以及变量。所以，要想解剖一个类，必须先要获取到该类的字节码文件对象，因为解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象.。</p>
<p>3、反射主要通过Java的<strong>java.lang.Class类</strong>来完成。</p>
<blockquote>
<p>Class类存放着对应类型的运行时信息。<br> Java运行时虚拟机为所有的类型维护一个java.lang.Class对象，该对象保存着该对象的运行时信息。泛型的的class为Class<T/>  </p>
</blockquote>
<blockquote>
<p>每个类型的Class对象只有一个，也就是说地址只有一个。</p>
</blockquote>
<p>4、反射的步骤</p>
<p>1.获取目标对象的class，一般使用<code>Class.forName(String clazzName)</code>；<br>2.通过class对象分别获得该类型的构造函数、属性和方法；<br>3.通过获得的属性和方法，进行进一步操作。</p>
<h2 id="二、反射涉及的Class类和java-lang-reflect"><a href="#二、反射涉及的Class类和java-lang-reflect" class="headerlink" title="二、反射涉及的Class类和java.lang.reflect"></a>二、反射涉及的Class类和java.lang.reflect</h2><p>反射涉及的类，除了Class类之外，基本上都在java.lang.reflect包里面，常用的类有Constructor，Field，Method类等，AccessibleObject类是前面三个类的基类，主要包含设置安全性检查等方法。</p>
<p>1、反射能用来做什么？</p>
<p>我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！</p>
<p>2、反射的具体实现</p>
<p>下面是一个基本的类 Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class"> </span>&#123;<br>    <span class="hljs-comment">//私有属性</span><br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;AME&quot;</span>;<br>    <span class="hljs-comment">//公有属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">18</span>;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;    <br>    &#125;<br>    <span class="hljs-comment">//私有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;private eat()...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//公有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;public play()...&quot;</span>);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>

<p>1&gt;Java获取Class的三种方式</p>
<blockquote>
<p>a、通过给定类的全限定(包名+类名)字符串名称就可以获取该类的字节码对象，通过 Class.forName() 方法完成。</p>
<p>b、通过 Object 类中的 getClass() 方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</p>
<p>c、通过静态属性.class 来获取对应的 Class 对象。需要要明确到类才能调用类中的静态成员。</p>
</blockquote>
<p>反射中，我们常用用的是第一种方法，该方法会抛出ClassNotFoundException异常。</p>
<p>Class.forName(“类的全限定名”)为什么说是最常用的方法，相信大家都用过Spring或者MyBatis等等这类框架，在使用这类框架的时候，免不了与该框架的XML配置文件打交道，在很多配置的地方都会填写一个全类名；看过源码的同学应该就知道，因为这些框架会先解析XML配置文件得到这个全类名，然后通过这个全类名来得到Class对象，完成后面的反射调用的动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 1、通过对象调用getClass()方法来获取,通常应用在：比如你传过来一个Object类型的对象，</span><br><span class="hljs-comment">// 而我不知道你具体是什么类，用这种方法</span><br>Person person1= <span class="hljs-keyword">new</span> Person();<br>Class c1 = person1.getClass();<br>        <br><span class="hljs-comment">// 2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高</span><br><span class="hljs-comment">// 这说明任何一个类都有一个隐含的静态成员变量 class</span><br>Class c2 = Person.class;<br>        <br><span class="hljs-comment">// 3、通过 Class 对象的 forName() 静态方法来获取，用的最多。会抛出 ClassNotFoundException 异常</span><br>Class c3 = Class.forName(<span class="hljs-string">&quot;com.ys.reflex.Person&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<p><strong>2&gt;通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等</strong></p>
<p>a、通过class对象获得Constructor，Field，Method对象的API</p>
<p>注意：getMethods()该方法是获取本类以及父类或者父接口中所有的公共方法(public修饰符修饰的)</p>
<p>getDeclaredMethods()该方法是获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法。</p>
<p>同理，其他关于属性、方法和构造器的“get…”和”getDeclared…“都是一样的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1、Constructor(类构造器的获取)</span><br><span class="hljs-comment">* 带“declared”的方法可以获取包括继承，public不包括private的构造函数</span><br><span class="hljs-comment">* 不带的无法获取继承，可以获取public，protected,private和默认包访问的构造函数。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//获取所有的构造函数(公共/继承)</span><br>Constructor&lt;?&gt;[] getConstructors();<br><br><span class="hljs-comment">//指定参数获取类的特定构造函数(传入构造函数的参数类型)</span><br><span class="hljs-function">Constructor&lt;T&gt; <span class="hljs-title">getConstructors</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取指定的构造函数不包括继承</span></span><br><span class="hljs-function">Constructor&lt;T&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span></span>;<br><br><span class="hljs-comment">//获取所有的构造函数不包括继承的</span><br>Constructor&lt;?&gt; getDeclaredConstructor();<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 2、获取类属性</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//获取指定属性，传入属性名（公共和继承）</span><br><span class="hljs-function">Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span></span>;<br><br><span class="hljs-comment">//获取所有属性（公共和继承）</span><br>Field[] getFields();<br><br><span class="hljs-comment">//获取指定的属性(不包括继承)</span><br><span class="hljs-function">Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span></span>;<br><br><span class="hljs-comment">//获取所有属性（不包括继承)</span><br>Field[] getDeclaredFields();<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 3、获取类的方法</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//获取指定的方法(公共/继承),传入方法名，方法参数</span><br><span class="hljs-function">Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;<br><br><span class="hljs-comment">//该方法是获取本类以及父类或者父接口中所有的公共方法(public修饰符修饰的)</span><br><span class="hljs-function">Method <span class="hljs-title">getMethods</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//获取指定的方法（不包括继承)</span><br><span class="hljs-function">Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;<br><br><span class="hljs-comment">//该方法是获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法。</span><br>Method[] getDeclaredMethods();<br></code></pre></td></tr></table></figure>

<p>b&gt;通过获取的各个类信息进行进一步操作的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1、通过Constructor类对象获取构造函数信息</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取构造器名</span><br><span class="hljs-function">Class <span class="hljs-title">getDeclaringClass</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取一个用于描述类中定义的构造函数的class对象。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回int, 获取构造函数的修饰符等级。</span><br>Class[] getExceptionTypes();<span class="hljs-comment">//获取描述方法抛出的异常类型的Class对象数组。</span><br>Class[] getParameterTypes();<span class="hljs-comment">//获取描述参数类型的Class对象数组。</span><br>constructor.newInstance(Class&lt;?&gt;... parameterTypes);<span class="hljs-comment">//通过获取的构造函数类，通过指定</span><br><span class="hljs-comment">//参数类调用该来的指定构造函数，创建该类型的实例对象。</span><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 2、通过Field类对象获取构造函数信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取属性名</span><br><span class="hljs-function">Class <span class="hljs-title">getDeclaringClass</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取Class对象，一般为声明该属性的类的类型class</span><br><span class="hljs-function">Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取属性类型的Class对象。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回int, 获取构造函数的修饰符等级。</span><br><span class="hljs-function">Object <span class="hljs-title">get</span><span class="hljs-params">(Object obj)</span></span>;<span class="hljs-comment">//返回该类型的对象上该属性的值。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Object obj,Object Value)</span></span>;<span class="hljs-comment">//为该类型Class的对象的指定对象，的指定属性赋值。</span><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 3、通过Method类对象获取构造函数信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span>；<span class="hljs-comment">//获取方法名</span></span><br><span class="hljs-function">Class <span class="hljs-title">getDeclaringClass</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取Class对象，一般为声明该方法的类的类型class</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回int, 获取函数的修饰符等级。</span><br>Class[] getExceptionTypes();<span class="hljs-comment">//获取描述方法抛出的异常类型的Class对象数组。</span><br>Class[] getParameterTypes();<span class="hljs-comment">//获取描述参数类型的Class对象数组。</span><br><span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj,Class&lt;?&gt;... parameterTypes)</span></span>;<span class="hljs-comment">//通过反射结合类的实例对象调用函数。</span><br></code></pre></td></tr></table></figure>

<p><strong>c&gt;总结，Class类常用方法：</strong></p>
<blockquote>
<p>getSimpleName():获得类名。</p>
<p>getName()：获得类的完整名字。<br>getFields()：获得类的public类型的属性。<br>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类<br>getMethods()：获得类的public类型的方法。<br>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类<br>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。<br>getConstructors()：获得类的public类型的构造方法。<br>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。<br>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = c2.getName();<br>System.out.println(className);<span class="hljs-comment">//输出com.qf.cdxt.Person</span><br>        <br><span class="hljs-comment">//获得类的public类型的属性。</span><br>Field[] fields = c2.getFields();<br><span class="hljs-keyword">for</span>(Field field : fields)&#123;<br>   System.out.println(field.getName());<span class="hljs-comment">//age</span><br>&#125;<br>        <br><span class="hljs-comment">//获得类的所有属性。包括私有的</span><br>Field [] allFields = c2.getDeclaredFields();<br><span class="hljs-keyword">for</span>(Field field : allFields)&#123;<br>    System.out.println(field.getName());<span class="hljs-comment">//name    age</span><br>&#125;<br>        <br><span class="hljs-comment">//获得类的public类型的方法。这里包括 Object 类的一些方法</span><br>Method [] methods = c2.getMethods();<br><span class="hljs-keyword">for</span>(Method method : methods)&#123;<br>    System.out.println(method.getName());<span class="hljs-comment">//play waid equls toString hashCode等</span><br>&#125;<br>        <br><span class="hljs-comment">//获得类的所有方法。</span><br>Method [] allMethods = c2.getDeclaredMethods();<br><span class="hljs-keyword">for</span>(Method method : allMethods)&#123;<br>    System.out.println(method.getName());<span class="hljs-comment">//play eat</span><br>&#125;<br>        <br><span class="hljs-comment">//获得指定的属性</span><br>Field f1 = c2.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>System.out.println(f1);<br><span class="hljs-comment">//获得指定的私有属性</span><br>Field f2 = c2.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">//启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消</span><br>f2.setAccessible(<span class="hljs-keyword">true</span>);<br>System.out.println(f2);<br>                <br><span class="hljs-comment">//创建这个类的一个对象</span><br>Object p2 =  c2.newInstance();<br><span class="hljs-comment">//将 p2 对象的  f2 属性赋值为 Fy，f2 属性即为 私有属性 name</span><br>f2.set(p2,<span class="hljs-string">&quot;Fy&quot;</span>);<br><span class="hljs-comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。 </span><br>System.out.println(f2.get(p2)); <span class="hljs-comment">//Fy</span><br>        <br><span class="hljs-comment">//获取构造方法</span><br>Constructor [] constructors = c2.getConstructors();<br><span class="hljs-keyword">for</span>(Constructor constructor : constructors)&#123;<br>    System.out.println(constructor.toString());<span class="hljs-comment">//public com.ys.reflex.Person()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是一个反射机制的基本实现了。</p>
<h2 id="三、反射机制的应用"><a href="#三、反射机制的应用" class="headerlink" title="三、反射机制的应用"></a>三、反射机制的应用</h2><p><strong>1、通过反射运行配置文件内容</strong></p>
<p>Student类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;is show()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置文件以txt文件为例子（pro.txt）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">className <span class="hljs-operator">=</span> cn.fanshe.Student<br>methodName <span class="hljs-operator">=</span> <span class="hljs-keyword">show</span><br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Properties;<br>    <br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span><br><span class="hljs-comment">    * 我们只需要将新类发送给客户端，并修改配置文件即可</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>           <span class="hljs-comment">//通过反射获取Class对象</span><br>           Class stuClass = Class.forName(getValue(<span class="hljs-string">&quot;className&quot;</span>));<span class="hljs-comment">//&quot;cn.fanshe.Student&quot;</span><br>           <span class="hljs-comment">//2获取show()方法</span><br>           Method m = stuClass.getMethod(getValue(<span class="hljs-string">&quot;methodName&quot;</span>));<span class="hljs-comment">//show</span><br>           <span class="hljs-comment">//3.调用show()方法</span><br>           m.invoke(stuClass.getConstructor().newInstance());<br>           <br>       &#125;<br>       <br>       <span class="hljs-comment">//此方法接收一个key，在配置文件中获取相应的value</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getValue</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>           Properties pro = <span class="hljs-keyword">new</span> Properties();<span class="hljs-comment">//获取配置文件的对象</span><br>           FileReader in = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;pro.txt&quot;</span>);<span class="hljs-comment">//获取输入流</span><br>           pro.load(in);<span class="hljs-comment">//将流加载到配置文件对象中</span><br>           in.close();<br>           <span class="hljs-keyword">return</span> pro.getProperty(key);<span class="hljs-comment">//返回根据key获取的value值</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>控制台输出：<br>is show()</p>
</blockquote>
<p>需求：<br>当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动</p>
<p>要替换的student2类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;is show2()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置文件更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">className = cn.fanshe.Student2<br>methodName = show2<br></code></pre></td></tr></table></figure>

<blockquote>
<p>控制台输出：<br>is show2();</p>
</blockquote>
<p><strong>2、通过反射越过泛型检查</strong></p>
<p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的。</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过反射越过泛型检查</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        strList.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        strList.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <br>    <span class="hljs-comment">//    strList.add(100);</span><br>        <span class="hljs-comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span><br>        Class listClass = strList.getClass(); <span class="hljs-comment">//得到 strList 对象的字节码 对象</span><br>        <span class="hljs-comment">//获取add()方法</span><br>        Method m = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>        <span class="hljs-comment">//调用add()方法</span><br>        m.invoke(strList, <span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">//遍历集合</span><br>        <span class="hljs-keyword">for</span>(Object obj : strList)&#123;<br>            System.out.println(obj);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>控制台输出：<br>aaa<br>bbb<br>100</p>
</blockquote>
<p>注意：Java web框架中，里面就用到了反射机制，比如Spring中，通过第三方配置文件实现对象的控制。</p>
<p>只要在代码或配置文件中看到类的完全限定名（包名+类名）,其底层原理基本上使用的就是Java反射机制。</p>
<h2 id="四、访问私有字段和私有方法"><a href="#四、访问私有字段和私有方法" class="headerlink" title="四、访问私有字段和私有方法"></a>四、访问私有字段和私有方法</h2><p>注释：只有在单独的JAVA程序中运行该代码才有效，就像你做一些单元测试或者常规的程序。如果你尝试在JAVA APPLET内使用该方法，你需要稍稍修改SecurityManager。但是，因为你不是经常需要与它打交道，这里也就不再赘述了。</p>
<p>这里是本次内容的列表:</p>
<ol>
<li><p>访问私有字段。</p>
</li>
<li><p>访问私有方法。</p>
</li>
</ol>
<h3 id="4-1-访问私有字段"><a href="#4-1-访问私有字段" class="headerlink" title="4.1 访问私有字段:"></a>4.1 访问私有字段:</h3><p>为了访问私有字段，你需要调用Class.getDeclaredField(String name)或者Class.getDeclaredFields()方法。方法Class.getField(String name)和Class.getFields()仅仅返回共有的字段，所以它们都无法起到作用。这里有一个例子，该例子中有一个包含私有字段的类，在该类下面有通过反射访问私有字段的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateObject</span> </span>&#123;  <br><br>    <span class="hljs-keyword">private</span> String privateString = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//声明为私有字段  </span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrivateObject</span><span class="hljs-params">(String privateString)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>.privateString = privateString;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">PrivateObject privateObject = <span class="hljs-keyword">new</span> PrivateObject(<span class="hljs-string">&quot;The Private Value&quot;</span>);<span class="hljs-comment">//实例化对象  </span><br><br>Field privateStringField = PrivateObject.class.getDeclaredField(<span class="hljs-string">&quot;privateString&quot;</span>);  <br><br>privateStringField.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//允许访问私有字段  </span><br><br>String fieldValue = (String) privateStringField.get(privateObject);<span class="hljs-comment">//获得私有字段值  </span><br>System.out.println(<span class="hljs-string">&quot;fieldValue = &quot;</span> + fieldValue);  <br></code></pre></td></tr></table></figure>


<p>这个代码会打印出文本”fieldValue = The Private Value”，而该值正好是对象PrivateObject的私有字段privateString的值。</p>
<p>注意到我们使用了方法PrivateObject.class.getDeclaredfield(“privateString”)。正是这个调用这个方法返回了私有字段。这个方法仅仅根据指定的类返回字段，不会返回父类申明的字段。</p>
<p>另外仔细观察加粗的语句。通过调用 Field.setAccessible(true)，你关掉了对于这个指定字段实例的访问检查，仅仅对反射有效。现在你能访问它了，不管它是私有的，保护的或是默认的(default)，即时调用者并不在该范围中。你仍然不能通过常规方法访问该字段，因为编译器不允许。</p>
<h3 id="4-2-访问私有方法"><a href="#4-2-访问私有方法" class="headerlink" title="4.2 访问私有方法"></a>4.2 访问私有方法</h3><p>为了访问一个私有方法，你需要调用Class.getDeclaredMethod(String name,Class[] parameterTypes)或者Class.getDeclaredMethods()方法。方法Class.getMethod(String name,Class[] parameterTypes)和Class.getMethods()仅仅返回公有方法，所以它们不会起到作用。下面是一个简单的例子，该例子中有一个拥有私有方法的类，类下面是通过反射机制访问私有方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateObject</span> </span>&#123;  <br><br>    <span class="hljs-keyword">private</span> String privateString = <span class="hljs-keyword">null</span>;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrivateObject</span><span class="hljs-params">(String privateString)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>.privateString = privateString;  <br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPrivateString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//私有方法  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.privateString;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">PrivateObject privateObject = <span class="hljs-keyword">new</span> PrivateObject(<span class="hljs-string">&quot;The Private Value&quot;</span>);  <br><br>Method privateStringMethod = PrivateObject.class.getDeclaredMethod(<span class="hljs-string">&quot;getPrivateString&quot;</span>, <span class="hljs-keyword">null</span>);  <br><br>privateStringMethod.setAccessible(<span class="hljs-keyword">true</span>);  <br><br>String returnValue = (String)  privateStringMethod.invoke(privateObject, <span class="hljs-keyword">null</span>);  <br><br>System.out.println(<span class="hljs-string">&quot;returnValue = &quot;</span> + returnValue);  <br></code></pre></td></tr></table></figure>


<p>这个代码例子会打印出文本”returnValue = The private Value”，该值正好是私有方法的返回值。</p>
<h2 id="五、反射与SSM"><a href="#五、反射与SSM" class="headerlink" title="五、反射与SSM"></a>五、反射与SSM</h2><p>前言：Java SSM框架里面经常用到反射机制，相信大家都用过Spring或者MyBatis等等这类框架，在使用这类框架的时候，免不了与该框架的XML配置文件打交道，在很多配置的地方都会填写一个全类名。看过源码的同学应该就知道，因为这些框架会先解析XML配置文得件得到这个全类名，然后通过这个全类名来得到Class对象，完成后面的反射调用的动作。比如Spring中，通过第三方配置文件实现对象的控制。只要在代码或配置文件中看到类的完全限定名（包名+类名）,该Java Web框架底层原理基本上使用的就是Java反射机制。所以，为了更好学习Java后端框架，我们有必要理解这种Java反射机制。</p>
<h3 id="一、反射机制概述"><a href="#一、反射机制概述" class="headerlink" title="一、反射机制概述"></a>一、反射机制概述</h3><p>1、反射机制：无非就是先加载对应字节码中的类，然后根据加载类的信息，一点点的去解剖其中的内容。不管你是public的还是private的，亦或是本类的还是来自原继承关系或者实现接口中的方法和字段，我们Java的反射技术reflect，均可以将其从字节码中拉回到现实，不仅可以得到字段的名字，我们还可以获得字段的值和修改字段的值;不仅可以得到方法的申明我们还可以拿到方法的定义和唤起方法（执行方法）。</p>
<p>当然，我们会有这样的疑惑？</p>
<p>为什么， new一个对象那么简单，非要用反射技术中的newInstance()？<br>为什么，我可以直接对象a1. 变量访问变量，却非要用反射那么费劲的获得name字段呢？<br>为什么，我几行代码就能搞定的事情，非要用反射呢？</p>
<p>2、解密答案之前，我们先来思考一个问题？</p>
<blockquote>
<p> 假设我们定义了很多类，有Animal、Person、Car….. ，如果我想要一个Animal实例，那我就new Animal();如果另一个人想要一个Person实例，那么他需要new Person();当然,另一个说，我只要一个Car实例，于是它要new Car()……</p>
<p>这样就会导致，每个用户new的对象需求不相同，因此他们只能修改源代码，并重新编译才能生效。这种将new的对象写死在代码里的方法非常不灵活，因此，为了避免这种情况的方法，Java提供了反射机制。</p>
</blockquote>
<p>反射是Java中一种强大的工具，能够使我们很方便的创建灵活的代码，<strong>通过反射运行配置文件内容，</strong>这些代码可以在运行时装配，无需在组件之间进行源代码链接，降低了代码的耦合度。但要注意反射使用不当的话会成本很高。</p>
<h3 id="二、Spring中应用反射机制"><a href="#二、Spring中应用反射机制" class="headerlink" title="二、Spring中应用反射机制"></a>二、Spring中应用反射机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Animal();<span class="hljs-comment">//我们必须指定Animal类来创建对象</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-string">&quot;Animal&quot;</span>；<span class="hljs-comment">//我们希望通过字符串就能承接一个Animal实例，而这个字符串我们可以放在配置文件中 典型的应用就是Spring，Spring就是将类的描述放在xx.xml配置文件中！！！</span><br></code></pre></td></tr></table></figure>

<p>我们知道Spring的IOC吧，即“控制反转”（通过第三方配置文件实现对 对象的控制）。简单说是将我们设计好的对象交给容器控制，而不是直接交给程序内部进行对象的控制。</p>
<p>比如，在Spring中，我们经常看到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 让Spring管理sqlsessionfactory 使用 Mybaits 和 Spring 整个包中的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>      <span class="hljs-comment">&lt;!-- 加载mybatis的全局配置文件 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis/SqlMapConfig.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>      <br></code></pre></td></tr></table></figure>

<p><strong>针对上述的配置文件，我们Spring是怎么帮助我们实例化对象，并放到容器中去了呢？ 没错，就是通过反射！！！！</strong></p>
<p>我们看下下面的伪代码实现过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解析&lt;bean .../&gt;元素的id属性得到该字符串值为&quot;sqlSessionFactory&quot;</span><br>String idStr = <span class="hljs-string">&quot;sqlSessionFactory&quot;</span>;  <br><br><span class="hljs-comment">//解析&lt;bean .../&gt;元素的class属性得到该字符串值为&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;  </span><br>String classStr = <span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>;<br>  <br><span class="hljs-comment">//利用反射知识，通过classStr获取Class类对象  </span><br>Class cls = Class.forName(classStr);  <br>            <br><span class="hljs-comment">//实例化对象  </span><br>Object obj = cls.newInstance();  <br><br><span class="hljs-comment">//container表示Spring容器  </span><br>container.put(idStr, obj);  <br>            <br><span class="hljs-comment">//当一个类里面需要用另一类的对象时，我们继续下面的操作</span><br>            <br><span class="hljs-comment">//解析&lt;property .../&gt;元素的name属性得到该字符串值为“dataSource”  </span><br>String nameStr = <span class="hljs-string">&quot;dataSource&quot;</span>;  <br><br><span class="hljs-comment">//解析&lt;property .../&gt;元素的ref属性得到该字符串值为“dataSource”  </span><br>String refStr = <span class="hljs-string">&quot;dataSource&quot;</span>;  <br><br><span class="hljs-comment">//生成将要调用setter方法名  </span><br>String setterName = <span class="hljs-string">&quot;set&quot;</span> + nameStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + nameStr.substring(<span class="hljs-number">1</span>);  <br>            <br><span class="hljs-comment">//获取spring容器中名为refStr的Bean，该Bean将会作为传入参数  </span><br>Object paramBean = container.get(refStr);  <br><br><span class="hljs-comment">//获取setter方法的Method类，此处的cls是刚才反射代码得到的Class对象  </span><br>Method setter = cls.getMethod(setterName, paramBean.getClass());  <br><br><span class="hljs-comment">//调用invoke()方法，此处的obj是刚才反射代码得到的Object对象  </span><br>setter.invoke(obj, paramBean); <br>   <br></code></pre></td></tr></table></figure>

<p>是不是很熟悉，虽然是伪代码，但是和我们上篇讲的反射机制的使用是相同的，现在知道我们的反射机制用在哪了吧，没错就是我们经常提到的Java web框架中，里面就用到了反射机制，只要在代码或配置文件中看到类的完全限定名（包名+类名）,其底层原理基本上使用的就是Java的反射机制。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/05/12/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;05&#x2F;12&#x2F;JAVA&#x2F;JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;05&#x2F;12&#x2F;JAVA&#x2F;JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/">JAVA</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CJAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%9D/">“JAVA基础知识”</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/JAVA/" rel="tag">JAVA</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、Java反射机制的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%8D%E5%B0%84%E6%B6%89%E5%8F%8A%E7%9A%84Class%E7%B1%BB%E5%92%8Cjava-lang-reflect"><span class="toc-number">2.</span> <span class="toc-text">二、反射涉及的Class类和java.lang.reflect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">三、反射机制的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、访问私有字段和私有方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 访问私有字段:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 访问私有方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%8D%E5%B0%84%E4%B8%8ESSM"><span class="toc-number">5.</span> <span class="toc-text">五、反射与SSM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">一、反射机制概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring%E4%B8%AD%E5%BA%94%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.</span> <span class="toc-text">二、Spring中应用反射机制</span></a></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1656085043075"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
