<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Spring设计模式 | Shuyan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring框架中的设计模式一、解释器设计模式​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用解释器设计模式来做。 ​        此模式基于表达式和评估器部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring设计模式">
<meta property="og:url" content="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="Spring框架中的设计模式一、解释器设计模式​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用解释器设计模式来做。 ​        此模式基于表达式和评估器部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg">
<meta property="article:published_time" content="2022-03-17T03:29:01.000Z">
<meta property="article:modified_time" content="2022-03-17T03:46:51.048Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Shuyan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shuyan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA/Spring框架/Spring/Spring框架中的设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><h2 id="一、解释器设计模式"><a href="#一、解释器设计模式" class="headerlink" title="一、解释器设计模式"></a>一、解释器设计模式</h2><p>​        在现实世界中，我们人类需要解释手势。他们可以对文化有不同的含义。这是我们的解释，给他们一个意义。在编程中，我们还需要分析一件事情，并决定它是什么意思。我们可以用<strong>解释器设计模式</strong>来做。</p>
<p>​        此模式基于<strong>表达式和评估器</strong>部分。第一个代表一个要分析的事情。这个分析是由评价者来做出的，它们知道构成表达的人物的意义。不必要的操作是在一个上下文中进行的。</p>
<p>​        Spring主要以<strong>Spring Expression Language</strong>（Spel）为例。</p>
<p>​        这里提个醒，SpEL是一种由Spring的<strong>org.springframework.expression.ExpressionParser</strong>实现分析和执行的语言。</p>
<p>​        这些实现使用作为字符串给出的Spel表达式，并将它们转换为<strong>org.springframework.expression.Expression的</strong>实例。上</p>
<p>​        下文组件由<strong>org.springframework.expression.EvaluationContext</strong>实现表示，例如：StandardEvaluationContext。</p>
<p>举个Spel的一个例子：</p>
<pre><code class="Java">Writer writer = new Writer();
writer.setName(&quot;Writer&#39;s name&quot;);
StandardEvaluationContext modifierContext = new StandardEvaluationContext(subscriberContext);
modifierContext.setVariable(&quot;name&quot;, &quot;Overriden writer&#39;s name&quot;);
parser.parseExpression(&quot;name = #name&quot;).getValue(modifierContext);
System.out.println(&quot;writer&#39;s name is : &quot; + writer.getName());
</code></pre>
<p>​        输出应打印“Overriden writer’s name”。如你所见，一个对象的属性是通过一个表达式<code>name = #name</code>进行修改的，这个表达式只有在<code>ExpressionParser</code>才能理解，因为提供了<code>context</code>（前面的样例中的<code>modifierContext</code>实例）。</p>
<h2 id="二、建设者模式"><a href="#二、建设者模式" class="headerlink" title="二、建设者模式"></a>二、建设者模式</h2><p>​        <strong>建设者设计模式</strong>是属于创建对象模式三剑客的第一种模式。<strong>该模式用于简化复杂对象的构造</strong>。要理解这个概念，想象一个说明程序员简历的对象。在这个对象中，我们想存储个人信息（名字，地址等）以及技术信息（知识语言，已实现的项目等）。该对象的构造可能如下所示：</p>
<pre><code class="Java">// with constructor
Programmer programmer = new Programmer(&quot;first name&quot;, &quot;last name&quot;, &quot;address Street 39&quot;, &quot;ZIP code&quot;, &quot;City&quot;, &quot;Country&quot;, birthDateObject, new String[] &#123;&quot;Java&quot;, &quot;PHP&quot;, &quot;Perl&quot;, &quot;SQL&quot;&#125;, new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);

// or with setters
Programmer programmer = new Programmer();
programmer.setName(&quot;first name&quot;);
programmer.setLastName(&quot;last name&quot;);
// ... multiple lines after
programmer.setProjects(new String[] &#123;&quot;CRM system&quot;, &quot;CMS system for government&quot;&#125;);
</code></pre>
<p>​        Builder允许我们通过使用将值传递给父类的内部构建器对象来清楚地分解对象构造。所以对于我们这个程序员简历的对象的创建，构建器可以看起来像：</p>
<pre><code class="Java">public class BuilderTest &#123;

  @Test
  public void test() &#123;
    Programmer programmer = new Programmer.ProgrammerBuilder()
            .setFirstName(&quot;F&quot;)
            .setLastName(&quot;L&quot;)
            .setCity(&quot;City&quot;)
            .setZipCode(&quot;0000A&quot;)
            .setAddress(&quot;Street 39&quot;)
            .setLanguages(new String[] &#123;&quot;bash&quot;, &quot;Perl&quot;&#125;)
            .setProjects(new String[] &#123;&quot;Linux kernel&quot;&#125;).build();
    assertTrue(&quot;Programmer should be &#39;F L&#39; but was &#39;&quot;+ programmer+&quot;&#39;&quot;, programmer.toString().equals(&quot;F L&quot;));
  &#125;

&#125;

class Programmer &#123;
  private String firstName;
  private String lastName;
  private String address;
  private String zipCode;
  private String city;
  private String[] languages;
  private String[] projects;

  private Programmer(String fName, String lName, String addr, String zip, String city, String[] langs, String[] projects) &#123;
    this.firstName = fName;
    this.lastName = lName;
    this.address = addr;
    this.zipCode = zip;
    this.city = city;
    this.languages = langs;
    this.projects = projects;
  &#125;

  public static class ProgrammerBuilder &#123;
    private String firstName;
    private String lastName;
    private String address;
    private String zipCode;
    private String city;
    private String[] languages;
    private String[] projects;

    public ProgrammerBuilder setFirstName(String firstName) &#123;
      this.firstName = firstName;
      return this;
    &#125;

    public ProgrammerBuilder setLastName(String lastName) &#123;
      this.lastName = lastName;
      return this;
    &#125;

    public ProgrammerBuilder setAddress(String address) &#123;
      this.address = address;
      return this;
    &#125;

    public ProgrammerBuilder setZipCode(String zipCode) &#123;
      this.zipCode = zipCode;
      return this;
    &#125;

    public ProgrammerBuilder setCity(String city) &#123;
      this.city = city;
      return this;
    &#125;

    public ProgrammerBuilder setLanguages(String[] languages) &#123;
      this.languages = languages;
      return this;
    &#125;
    public ProgrammerBuilder setProjects(String[] projects) &#123;
      this.projects = projects;
      return this;
    &#125;

    public Programmer build() &#123;
      return new Programmer(firstName, lastName, address, zipCode, city, languages, projects);
    &#125;
  &#125;

  @Override
  public String toString() &#123;
    return this.firstName + &quot; &quot;+this.lastName;
  &#125;

&#125;
</code></pre>
<p>​        可以看出，构建器后面隐藏了对象构造的复杂性，内部静态类接受链接方法的调用。</p>
<p>​        在Spring中，我们可以在<strong>org.springframework.beans.factory.support.BeanDefinitionBuilder</strong>类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。我们可以在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/09/16/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84bean%E5%B7%A5%E5%8E%82%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">bean工厂后处理器的</a>文章中看到它，<code>BeanDefinitionBuilder</code>包含几个方法，它们为<strong>AbstractBeanDefinition</strong>抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：</p>
<pre><code class="java">public class BeanDefinitionBuilder &#123;
    /**
        * The &#123;@code BeanDefinition&#125; instance we are creating.
    */
    private AbstractBeanDefinition beanDefinition;

    // ... some not important methods for this article

    // Some of building methods
    /**
    * Set the name of the parent definition of this bean definition.
    */
    public BeanDefinitionBuilder setParentName(String parentName) &#123;
        this.beanDefinition.setParentName(parentName);
        return this;
    &#125;

    /**
    * Set the name of the factory method to use for this definition.
    */
    public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) &#123;
        this.beanDefinition.setFactoryMethodName(factoryMethod);
        return this;
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    * @deprecated since Spring 2.5, in favor of &#123;@link #addConstructorArgValue&#125;
    */
    @Deprecated
    public BeanDefinitionBuilder addConstructorArg(Object value) &#123;
        return addConstructorArgValue(value);
    &#125;

    /**
    * Add an indexed constructor arg value. The current index is tracked internally
    * and all additions are at the present point.
    */
    public BeanDefinitionBuilder addConstructorArgValue(Object value) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
        this.constructorArgIndex++, value);
        return this;
    &#125;

    /**
    * Add a reference to a named bean as a constructor arg.
    * @see #addConstructorArgValue(Object)
    */
    public BeanDefinitionBuilder addConstructorArgReference(String beanName) &#123;
        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(
            this.constructorArgIndex++, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Add the supplied property value under the given name.
    */
    public BeanDefinitionBuilder addPropertyValue(String name, Object value) &#123;
        this.beanDefinition.getPropertyValues().add(name, value);
        return this;
    &#125;

    /**
    * Add a reference to the specified bean name under the property specified.
    * @param name the name of the property to add the reference to
    * @param beanName the name of the bean being referenced
    */
    public BeanDefinitionBuilder addPropertyReference(String name, String beanName) &#123;
        this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));
        return this;
    &#125;

    /**
    * Set the init method for this definition.
    */
    public BeanDefinitionBuilder setInitMethodName(String methodName) &#123;
        this.beanDefinition.setInitMethodName(methodName);
        return this;
    &#125;

    // Methods that can be used to construct BeanDefinition
    /**
    * Return the current BeanDefinition object in its raw (unvalidated) form.
    * @see #getBeanDefinition()
    */
    public AbstractBeanDefinition getRawBeanDefinition() &#123;
        return this.beanDefinition;
    &#125;

    /**
    * Validate and return the created BeanDefinition object.
    */
    public AbstractBeanDefinition getBeanDefinition() &#123;
        this.beanDefinition.validate();
        return this.beanDefinition;
    &#125;
&#125;
</code></pre>
<h2 id="三、工厂模式"><a href="#三、工厂模式" class="headerlink" title="三、工厂模式"></a>三、工厂模式</h2><p>​        创建对象模式三剑客的第二个成员是<strong>工厂方法设计模式</strong>。它完全适于使用<strong>动态环境</strong>作为Spring框架。实际上，<strong>这种模式允许通过公共静态方法对象进行初始化，称为工厂方法</strong>。在这个概念中，我们需要定义一个接口来创建对象。但是创建是由使用相关对象的类创建的。</p>
<p>​        但是在跳到Spring世界之前，让我们用Java代码做一个例子：</p>
<pre><code class="Java">public class FactoryMethodTest &#123;

    @Test
    public void test() &#123;
        Meal fruit = Meal.valueOf(&quot;banana&quot;);
        Meal vegetable = Meal.valueOf(&quot;carrot&quot;);
        assertTrue(&quot;Banana should be a fruit but is &quot;+fruit.getType(), fruit.getType().equals(&quot;fruit&quot;));
        assertTrue(&quot;Carrot should be a vegetable but is &quot;+vegetable.getType(),                                                     vegetable.getType().equals(&quot;vegetable&quot;));
    &#125;

&#125;

class Meal &#123;

    private String type;

    public Meal(String type) &#123;
        this.type = type;
    &#125;

    public String getType() &#123;
        return this.type;
    &#125;

    // Example of factory method - different object is created depending on current context
    public static Meal valueOf(String ingredient) &#123;
        if (ingredient.equals(&quot;banana&quot;)) &#123;
            return new Meal(&quot;fruit&quot;);
        &#125;
        return new Meal(&quot;vegetable&quot;);
    &#125;
&#125;
</code></pre>
<p>​        在Spring中，我们可以通过指定的工厂方法创建bean。该方法与以前代码示例中看到的valueOf方法完全相同。它是静态的，可以采取没有或多个参数。为了更好地了解案例，让我们来看一下实例。首先搞定下配置：</p>
<pre><code class="xml">&lt;bean id=&quot;welcomerBean&quot; class=&quot;com.mysite.Welcomer&quot; factory-method=&quot;createWelcomer&quot;&gt;
    &lt;constructor-arg ref=&quot;messagesLocator&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messagesLocator&quot; class=&quot;com.mysite.MessageLocator&quot;&gt;
    &lt;property name=&quot;messages&quot; value=&quot;messages_file.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>​        现在请关注这个bean的初始化：</p>
<pre><code class="java">public class Welcomer &#123;
    private String message;

    public Welcomer(String message) &#123;
        this.message = message;
    &#125;

    public static Welcomer createWelcomer(MessageLocator messagesLocator) &#123;
        Calendar cal = Calendar.getInstance();
        String msgKey = &quot;welcome.pm&quot;;
        if (cal.get(Calendar.AM_PM) == Calendar.AM) &#123;
            msgKey = &quot;welcome.am&quot;;
        &#125;
        return new Welcomer(messagesLocator.getMessageByKey(msgKey));
    &#125;
&#125;
</code></pre>
<p>​        当Spring将构造welcomerBean时，它不会通过传统的构造函数，而是通过定义的静态工厂方法createWelcomer来实现。还要注意，这个方法接受一些参数（MessageLocator bean的实例包含所有可用的消息） 标签，通常保留给传统的构造函数。</p>
<h2 id="四、抽象工厂"><a href="#四、抽象工厂" class="headerlink" title="四、抽象工厂"></a>四、抽象工厂</h2><p>​        <strong>抽象的工厂设计模式</strong>，看起来类似于工厂方法。不同之处在于，我们可以将抽象工厂视为这个词的工业意义上的工厂，即。作为提供所需对象的东西。工厂部件有：抽象工厂，抽象产品，产品和客户。更准确地说，<strong>抽象工厂定义了构建对象的方法</strong>。抽象产品是这种结构的结果。产品是具有同样结构的具体结果。客户是要求创造产品来抽象工厂的人。</p>
<p>​        同样的，在进入Spring的细节之前，我们将首先通过示例Java代码说明这个概念：</p>
<pre><code class="java">public class FactoryTest &#123;

    // Test method which is the client
    @Test
    public void test() &#123;
        Kitchen factory = new KitchenFactory();
        KitchenMeal meal = factory.getMeal(&quot;P.1&quot;);
        KitchenMeal dessert = factory.getDessert(&quot;I.1&quot;);
        assertTrue(&quot;Meal&#39;s name should be &#39;protein meal&#39; and was &#39;&quot;+meal.getName()+&quot;&#39;&quot;, meal.getName().equals(&quot;protein meal&quot;));
        assertTrue(&quot;Dessert&#39;s name should be &#39;ice-cream&#39; and was &#39;&quot;+dessert.getName()+&quot;&#39;&quot;, dessert.getName().equals(&quot;ice-cream&quot;));
    &#125;

&#125;

// abstract factory
abstract class Kitchen &#123;
    public abstract KitchenMeal getMeal(String preferency);
    public abstract KitchenMeal getDessert(String preferency);
&#125;

// concrete factory
class KitchenFactory extends Kitchen &#123;
    @Override
    public KitchenMeal getMeal(String preferency) &#123;
        if (preferency.equals(&quot;F.1&quot;)) &#123;
            return new FastFoodMeal();
        &#125; else if (preferency.equals(&quot;P.1&quot;)) &#123;
            return new ProteinMeal();
        &#125;
        return new VegetarianMeal();
    &#125;

    @Override
    public KitchenMeal getDessert(String preferency) &#123;
        if (preferency.equals(&quot;I.1&quot;)) &#123;
            return new IceCreamMeal();
        &#125;
        return null;
    &#125;
&#125;

// abstract product
abstract class KitchenMeal &#123;
    public abstract String getName();
&#125;

// concrete products
class ProteinMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;protein meal&quot;;
    &#125;
&#125;

class VegetarianMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;vegetarian meal&quot;;
    &#125;
&#125;

class FastFoodMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;fast-food meal&quot;;
    &#125;
&#125;

class IceCreamMeal extends KitchenMeal &#123;
    @Override
    public String getName() &#123;
        return &quot;ice-cream&quot;;
    &#125;
&#125;
</code></pre>
<p>​        我们可以在这个例子中看到，<strong>抽象工厂封装了对象的创建</strong>。对象创建可以使用与经典构造函数一样使用的工厂方法模式。在Spring中，工厂的例子是<strong>org.springframework.beans.factory.BeanFactory</strong>。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，<strong>getBean</strong>方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。</p>
<p>​        在<code>BeanFactory</code>的实现中，我们可以区分：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>；</li>
<li><code>XmlWebApplicationContext</code>；</li>
<li><code>StaticWebApplicationContext</code>；</li>
<li><code>StaticPortletApplicationContext</code>；</li>
<li><code>GenericApplicationContext</code>；</li>
<li><code>StaticApplicationContext</code>。</li>
</ul>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;file:test-context.xml&quot;&#125;)
public class TestProduct &#123;

    @Autowired
    private BeanFactory factory;

    @Test
    public void test() &#123;
        System.out.println(&quot;Concrete factory is: &quot;+factory.getClass());
        assertTrue(&quot;Factory can&#39;t be null&quot;, factory != null);
        ShoppingCart cart = (ShoppingCart) factory.getBean(&quot;shoppingCart&quot;);
        assertTrue(&quot;Shopping cart object can&#39;t be null&quot;, cart != null);
        System.out.println(&quot;Found shopping cart bean:&quot;+cart.getClass());
    &#125;
&#125;
</code></pre>
<p>​        在这种情况下，抽象工厂由BeanFactory接口表示。</p>
<p>​        具体工厂是在第一个System.out中打印的，是<strong>org.springframework.beans.factory.support.DefaultListableBeanFactory</strong>的实例。它的抽象产物是一个对象。在我们的例子中，具体的产品就是被强转为ShoppingCart实例的抽象产品（Object）。</p>
<h2 id="五、代理模式"><a href="#五、代理模式" class="headerlink" title="五、代理模式"></a>五、代理模式</h2><p>​        面向对象编程（OOP）可能是编程中最流行的概念。然而，Spring引入了另一种编码规范，<strong>面向切面编程</strong>（AOP）。为了简化定义，AOP是面向系统特定点的一种编程，如：异常抛出，特定类别方法的执行等。AOP允许在执行这些特定点之前或之后执行补充动作。如何实现这种操作？它可以**通过监听器(listeners)**进行。但在这种情况下，我们应该在只要可能存在调用的地方都需要定义监听器来进行监听（比如在一个方法的开始的地方）。这就是为什么Spring不采用这个idea。相反，Spring实现了一种能够通过额外的方法调用完成任务的设计模式 - <strong>代理设计模式</strong>。</p>
<p>​        代理就像对象的镜像一样。也正因为如此，代理对象不仅可以覆盖真实对象，还可以扩展其功能。因此，对于只能在屏幕上打印一些文本的对象，我们可以添加另一个对象来过滤显示单词。可以通过代理来定义第二个对象的调用。代理是封装真实对象的对象。例如，如果您尝试调用Waiter bean，那么您将调用该Bean的代理，其行为方式完全相同。</p>
<p>​        代理设计模式的一个很好的例子是<strong>org.springframework.aop.framework.ProxyFactoryBean</strong>。该工厂根据Spring bean构建AOP代理。该类实现了定义**getObject()**方法的<code>FactoryBean</code>接口。此方法用于将需求<code>Bean</code>的实例返回给<code>bean factory</code>。在这种情况下，它不是返回的实例，而是<code>AOP代理</code>。在执行代理对象的方法之前，可以通过调用补充方法来进一步“修饰”代理对象(其实所谓的静态代理不过是在装饰模式上加了个要不要你来干动作行为而已，而不是装饰模式什么也不做就加了件衣服，其他还得由你来全权完成)。</p>
<p><code>ProxyFactory</code>的一个例子是：</p>
<pre><code class="java">public class TestProxyAop &#123;

    @Test
    public void test() &#123;
        ProxyFactory factory = new ProxyFactory(new House());
        factory.addInterface(Construction.class);
        factory.addAdvice(new BeforeConstructAdvice());
        factory.setExposeProxy(true);

        Construction construction = (Construction) factory.getProxy();
        construction.construct();
        assertTrue(&quot;Construction is illegal. &quot;
                   + &quot;Supervisor didn&#39;t give a permission to build &quot;
                   + &quot;the house&quot;, construction.isPermitted());
    &#125;

&#125;

interface Construction &#123;
    public void construct();
    public void givePermission();
    public boolean isPermitted();
&#125;

class House implements Construction&#123;

    private boolean permitted = false;

    @Override
    public boolean isPermitted() &#123;
        return this.permitted;
    &#125;

    @Override
    public void construct() &#123;
        System.out.println(&quot;I&#39;m constructing a house&quot;);
    &#125;

    @Override
    public void givePermission() &#123;
        System.out.println(&quot;Permission is given to construct a simple house&quot;);
        this.permitted = true;
    &#125;
&#125;

class BeforeConstructAdvice implements MethodBeforeAdvice &#123;

    @Override
    public void before(Method method, Object[] arguments, Object target) throws Throwable &#123;
        if (method.getName().equals(&quot;construct&quot;)) &#123;
            ((Construction) target).givePermission();
        &#125;
    &#125;

&#125;
</code></pre>
<p>​        这个测试应该通过，因为我们不直接在House实例上操作，而是代理它。代理调用第一个<code>BeforeConstructAdvice</code>的<code>before</code>方法（指向在执行目标方法之前执行，在我们的例子中为<code>construct()</code>）通过它，给出了一个“权限”来构造对象的字段（house）。代理层提供了一个额外新功能，因为它可以简单地分配给另一个对象。要做到这一点，我们只能在before方法之前修改过滤器。</p>
<h2 id="六、复合模式"><a href="#六、复合模式" class="headerlink" title="六、复合模式"></a>六、复合模式</h2><p>​        另一种结构模式是<strong>复合模式</strong>。在关于<a target="_blank" rel="noopener" href="https://muyinchen.github.io/2017/07/20/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)">Spring中设计模式</a>的第一篇文章中，我们使用构建器来构造复杂对象。另一种实现方法是使用复合模式。这种模式是<strong>基于具有共同行为的多个对象的存在</strong>，用于构建更大的对象。较大的对象仍然具有与最小对象相同的特征。那么用它来定义相同的行为。</p>
<p>​        复合对象的非Spring示例可以是一个写入HTML的文本对象，由包含span或em标签的段落组成：</p>
<pre><code class="java">public class CompositeTest &#123;

    @Test
    public void test() &#123;
        TextTagComposite composite = new PTag();
        composite.addTag(new SpanTag());
        composite.addTag(new EmTag());

        // sample client code
        composite.startWrite();
        for (TextTag leaf : composite.getTags()) &#123;
            leaf.startWrite();
            leaf.endWrite();
        &#125;
        composite.endWrite();
        assertTrue(&quot;Composite should contain 2 tags but it contains &quot;+composite.getTags().size(), composite.getTags().size() == 2);
    &#125;

&#125;

interface TextTag &#123;
    public void startWrite();
    public void endWrite();
&#125;

interface TextTagComposite extends TextTag &#123;
    public List&lt;TextTag&gt; getTags();
    public void addTag(TextTag tag);
&#125;

class PTag implements TextTagComposite &#123;
    private List&lt;TextTag&gt; tags = new ArrayList&lt;TextTag&gt;();

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;p&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/p&gt;&quot;);
    &#125;

    @Override
    public List&lt;TextTag&gt; getTags() &#123;
        return tags;
    &#125;

    @Override
    public void addTag(TextTag tag) &#123;
        tags.add(tag);
    &#125;
&#125;

class SpanTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;span&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/span&gt;&quot;);
    &#125;

&#125;

class EmTag implements TextTag &#123;

    @Override
    public void startWrite() &#123;
        System.out.println(&quot;&lt;em&gt;&quot;);
    &#125;

    @Override
    public void endWrite() &#123;
        System.out.println(&quot;&lt;/em&gt;&quot;);
    &#125;

&#125;
</code></pre>
<p>​        在这种情况下，可以看到一个复合对象。我们可以区分复合与非复合对象，因为第一个可以容纳一个或多个非复合对象（<code>PTag</code>类中的<code>private List tags</code>字段）。非复合对象称为<strong>叶子</strong>。<code>TextTag</code>接口被称为<strong>组件</strong>，因为它为两个对象类型提供了共同的行为规范(有点像<code>Linux</code>文件管理系统的有共同点的文件放在一个文件夹下进行管理，其实就是节点管理)。</p>
<p>​        在<code>Spring</code>世界中，我们检索复合对象的概念是<strong>org.springframework.beans.BeanMetadataElement</strong>接口，用于配置<code>bean</code>对象。它是所有继承对象的基本界面。</p>
<p>​        现在，在一方面，我们有一个叶子，由<strong>org.springframework.beans.factory.parsing.BeanComponentDefinition</strong>表示，另一边是复合<strong>org.springframework.beans.factory.parsing.CompositeComponentDefinition</strong>。</p>
<p>​        <code>CompositeComponentDefinition</code>类似于组件，因为它包含<strong>addNestedComponent（ComponentDefinition component）</strong>方法，它允许将叶子添加到私有final列表中<code>nestedComponents</code>。您可以看到，由于此列表，<code>BeanComponentDefinition</code>和<code>CompositeComponentDefinition</code>的组件是<strong>org.springframework.beans.factory.parsing.ComponentDefinition</strong>。</p>
<p><img src="https://static.iocoder.cn/95c0d87ef9a0ee04ef0c2a103f60a7f7.jpg" alt="img"></p>
<h2 id="七、策略模式"><a href="#七、策略模式" class="headerlink" title="七、策略模式"></a>七、策略模式</h2><p>​        <strong>策略设计模式</strong>。<strong>策略定义了通过不同方式完成相同事情的几个对象</strong>。完成任务的方式取决于采用的策略。举个例子说明，我们可以去一个国家。我们可以乘公共汽车，飞机，船甚至汽车去那里。所有这些方法将把我们运送到目的地国家。但是，我们将通过检查我们的银行帐户来选择最适应的方式。如果我们有很多钱，我们将采取最快的方式（可能是私人飞行）。如果我们没有足够的话，我们会采取最慢的（公车，汽车）。该银行账户作为确定适应策略的因素。</p>
<p>​        Spring在<strong>org.springframework.web.servlet.mvc.multiaction.MethodNameResolver</strong>类(过时，但不影响拿来研究)中使用策略设计模式。它是<code>MultiActionController</code>(同样过时)的参数化实现。在开始解释策略之前，我们需要了解MultiActionController的实用性。这个类允许同一个类处理几种类型的请求。</p>
<p>​        作为Spring中的每个控制器，MultiActionController执行方法来响应提供的请求。策略用于检测应使用哪种方法。解析过程在MethodNameResolver实现中实现，例如在同一个包中的<strong>ParameterMethodNameResolver中</strong>。方法可以通过多个条件解决：属性映射，HTTP请求参数或URL路径。</p>
<pre><code class="java">@Override
public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException &#123;
    String methodName = null;

    // Check parameter names where the very existence of each parameter
    // means that a method of the same name should be invoked, if any.
    if (this.methodParamNames != null) &#123;
        for (String candidate : this.methodParamNames) &#123;
            if (WebUtils.hasSubmitParameter(request, candidate)) &#123;
                methodName = candidate;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                                 &quot;&#39; based on existence of explicit request parameter of same name&quot;);
                &#125;
                break;
            &#125;
        &#125;
    &#125;

    // Check parameter whose value identifies the method to invoke, if any.
    if (methodName == null &amp;&amp; this.paramName != null) &#123;
        methodName = request.getParameter(this.paramName);
        if (methodName != null) &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Determined handler method &#39;&quot; + methodName +
                             &quot;&#39; based on value of request parameter &#39;&quot; + this.paramName + &quot;&#39;&quot;);
            &#125;
        &#125;
    &#125;

    if (methodName != null &amp;&amp; this.logicalMappings != null) &#123;
        // Resolve logical name into real method name, if appropriate.
        String originalName = methodName;
        methodName = this.logicalMappings.getProperty(methodName, methodName);
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Resolved method name &#39;&quot; + originalName + &quot;&#39; to handler method &#39;&quot; + methodName + &quot;&#39;&quot;);
        &#125;
    &#125;

    if (methodName != null &amp;&amp; !StringUtils.hasText(methodName)) &#123;
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Method name &#39;&quot; + methodName + &quot;&#39; is empty: treating it as no method name found&quot;);
        &#125;
        methodName = null;
    &#125;

    if (methodName == null) &#123;
        if (this.defaultMethodName != null) &#123;
            // No specific method resolved: use default method.
            methodName = this.defaultMethodName;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Falling back to default handler method &#39;&quot; + this.defaultMethodName + &quot;&#39;&quot;);
            &#125;
        &#125;
        else &#123;
            // If resolution failed completely, throw an exception.
            throw new NoSuchRequestHandlingMethodException(request);
        &#125;
    &#125;

    return methodName;
&#125;
</code></pre>
<p>​        正如我们在前面的代码中可以看到的，方法的名称通过提供的参数映射，URL中的预定义属性或参数存在来解决（默认情况下，该参数的名称是action）。</p>
<h2 id="八、模板模式"><a href="#八、模板模式" class="headerlink" title="八、模板模式"></a>八、模板模式</h2><p>​        <strong>模板方法</strong>。此模式定义了类行为的骨架，并将子步骤的某些步骤的延迟执行(具体就是下面例子中一个方法放在另一个方法中，只有调用另一方方法的时候这个方法才会执行,而且还可能会在其他行为方法之后按顺序执行)。其中写了一种方法(下面例子中的construct())，注意定义为final，起着同步器的角色。它以给定的顺序执行由子类定义的方法。在现实世界中，我们可以将模板方法与房屋建设进行比较。独立于建造房屋的公司，我们需要从建立基础开始，只有在我们完成之后才能做其他的工作。这个执行逻辑将被保存在一个我们不能改变的方法中。例如基础建设或刷墙会被作为一个模板方法中的方法，具体到建筑房屋的公司。我们可以在给定的例子中看到它：</p>
<pre><code class="java">public class TemplateMethod &#123;

  public static void main(String[] args) &#123;
    HouseAbstract house = new SeaHouse();
    house.construct();
  &#125;

&#125;

abstract class HouseAbstract &#123;
  protected abstract void constructFoundations();
  protected abstract void constructWall();

  // template method
  public final void construct() &#123;
    constructFoundations();
    constructWall();
  &#125;
&#125;

class EcologicalHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Making foundations with wood&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Making wall with wood&quot;);
  &#125;

&#125;

class SeaHouse extends HouseAbstract &#123;

  @Override
  protected void constructFoundations() &#123;
    System.out.println(&quot;Constructing very strong foundations&quot;);
  &#125;

  @Override
  protected void constructWall() &#123;
    System.out.println(&quot;Constructing very strong wall&quot;);
  &#125;

&#125;
</code></pre>
<p>​        该代码应该输出：</p>
<pre><code class="java">Constructing very strong foundations
Constructing very strong wall
</code></pre>
<p>​        Spring在<strong>org.springframework.context.support.AbstractApplicationContext</strong>类中使用模板方法。他们不是一个模板方法（在我们的例子中是construct ），而是多个。例如，<strong>getsFreshBeanFactory</strong>返回内部<code>bean工厂</code>的新版本，调用两个抽象方法：<code>refreshBeanFactory</code>（刷新工厂bean）和<code>getBeanFactory</code>（以获取更新的工厂bean）。这个方法和其他一些方法一样，用在<strong>public void refresh()<strong>中，抛出</strong>构造应用程序上下文的BeansException，IllegalStateException</strong>方法(这里会在后面Spring中与应用程序上下文分析中再次提到)。</p>
<p>​        我们可以从同一个包中的GenericApplicationContext找到一些通过模板方法所实现的抽象方法的实现的例子(说的有点拗口，多读几遍就好):</p>
<pre><code class="java">/**
  * Do nothing: We hold a single internal BeanFactory and rely on callers
  * to register beans through our public methods (or the BeanFactory&#39;s).
  * @see #registerBeanDefinition
  */
@Override
protected final void refreshBeanFactory() throws IllegalStateException &#123;
  if (this.refreshed) &#123;
    throw new IllegalStateException(
      &quot;GenericApplicationContext does not support multiple refresh attempts: just call &#39;refresh&#39; once&quot;);
  &#125;
  this.beanFactory.setSerializationId(getId());
  this.refreshed = true;
&#125;

@Override
protected void cancelRefresh(BeansException ex) &#123;
  this.beanFactory.setSerializationId(null);
  super.cancelRefresh(ex);
&#125;

/**
  * Not much to do: We hold a single internal BeanFactory that will never
  * get released.
  */
@Override
protected final void closeBeanFactory() &#123;
  this.beanFactory.setSerializationId(null);
&#125;

/**
  * Return the single internal BeanFactory held by this context
  * (as ConfigurableListableBeanFactory).
  */
@Override
public final ConfigurableListableBeanFactory getBeanFactory() &#123;
  return this.beanFactory;
&#125;

/**
  * Return the underlying bean factory of this context,
  * available for registering bean definitions.
  * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; You need to call &#123;@link #refresh()&#125; to initialize the
  * bean factory and its contained beans with application context semantics
  * (autodetecting BeanFactoryPostProcessors, etc).
  * @return the internal bean factory (as DefaultListableBeanFactory)
  */
public final DefaultListableBeanFactory getDefaultListableBeanFactory() &#123;
  return this.beanFactory;
&#125;
</code></pre>
<p>​        经过上面这些可以让我们发现Spring如何通过使用行为和结构设计模式来更好地组织上下文（<strong>模板方法</strong>），并通过相应<strong>策略</strong>来解决执行方法。它使用两种结构设计模式，通过<strong>代理模式</strong>来简化AOP部分并通过<strong>复合模式</strong>来构造复杂对象。</p>
<h2 id="九、原型模式"><a href="#九、原型模式" class="headerlink" title="九、原型模式"></a>九、原型模式</h2><p>​        可以通过官方文档查找有关Spring作用域中的bean作用域的文章中介绍了类似的概念(<strong>prototype</strong>)。原型设计模式与有用相同名称的(<strong>prototype</strong>)作用域有点相似。此设计模式允许通过复制已存在的对象来创建一个对象的实例。副本应该是<strong>真正的副本</strong>。这意味着新对象的所有属性应与复制对象的属性相同。如果不清楚，比一个简单的<code>JUnit</code>案例更好的说明：</p>
<pre><code class="java">public class PrototypeTest &#123;

  @Test
  public void test() &#123;
    Robot firstRobot = new Robot(&quot;Droid#1&quot;);
    Robot secondRobot = (Robot) firstRobot.clone();
    assertTrue(&quot;Cloned robot&#39;s instance can&#39;t be the same as the&quot;
      +&quot; source robot instance&quot;,
      firstRobot != secondRobot);
    assertTrue(&quot;Cloned robot&#39;s name should be &#39;&quot;+firstRobot.getName()+&quot;&#39;&quot;
      +&quot; but was &#39;&quot;+secondRobot.getName()+&quot;&#39;&quot;,
      secondRobot.getName().equals(firstRobot.getName()));
  &#125;

&#125;


class Robot implements Cloneable &#123;
  private String name;

  public Robot(String name) &#123;
    this.name = name;
  &#125;

  public String getName() &#123;
    return this.name;
  &#125;

  protected Object clone() throws CloneNotSupportedException &#123;
    return super.clone();
  &#125;
&#125;
</code></pre>
<p>​        在<code>Spring</code>中，在<strong>org.springframework.beans.factory.support.AbstractBeanFactory</strong>中使用一种特定的原型设计模式，它将初始化<code>bean原型作用域</code>。新对象基于配置文件中的bean定义。我们可以看到，在给定的例子中：</p>
<pre><code class="java">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; scope=&quot;prototype&quot;&gt;
  &lt;property name=&quot;id&quot; value=&quot;9&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&#123;&quot;applicationContext-test.xml&quot;&#125;)
public class SpringPrototypeTest &#123;

  @Autowired
  private BeanFactory beanFactory;

  @Test
  public void test() &#123;
    ShoppingCart cart1 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart1 should be 9 but was &quot;+cart1.getId(),
      cart1.getId() == 9);
    cart1.setId(100);
    ShoppingCart cart2 = (ShoppingCart) beanFactory.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;Id of cart2 should be 9 but was &quot;+cart2.getId(),
      cart2.getId() == 9);
    assertTrue(&quot;Id of second cart (&quot;+cart2.getId()+&quot;) shouldn&#39;t be the same as the first one: &quot;+cart1.getId(),
      cart1.getId() != cart2.getId());
    cart2.setId(cart1.getId());
    assertTrue(&quot;Now (after cart2.setId(cart1.getId())), the id of second cart (&quot;+cart2.getId()+&quot;) should be the same as the first one: &quot;
      +cart1.getId(), cart1.getId() == cart2.getId());
    assertTrue(&quot;Both instance shouldn&#39;t be the same&quot;, cart1 != cart2);
  &#125;

&#125;
</code></pre>
<p>​        从前面的例子可以看出，<code>ShoppingCart</code>实例是直接从bean定义创建的。最初，<code>cart1</code>和<code>cart2</code>对象的<code>id</code>值为<code>9</code>.它在测试结束时被修改，以证明两个引用都属于两个不同的对象。</p>
<h2 id="十、对象池"><a href="#十、对象池" class="headerlink" title="十、对象池"></a>十、对象池</h2><p>​        <code>Spring</code>中使用的另一个模型是<strong>对象池设计模式</strong>。其主要目的在于在一个池中保存特定数量的对象，并根据需要重新使用。通过它，我们可以改善我们想要使用<code>巨型对象</code>的响应时间。<code>巨型</code>意味着这些对象的构造需要很多时间（例如：持有数据库连接的对象），最好重用已经存在的和未获取的对象，而不是创建新对象。</p>
<p>​        Spring还使用线程池来管理其调度部分。一些示例位于<strong>org.springframework.scheduling.concurrent中</strong>。我们检索数据库（<code>Spring JDBC</code>）项目中的对象池的想法。数据库连接池不是由<code>Spring</code>直接实现的，而是适用于<code>Spring</code>工作方式的项目，如<code>C3P0</code>或<code>Jakarta Commons DBCP</code>连接池。</p>
<h2 id="十一、观察者"><a href="#十一、观察者" class="headerlink" title="十一、观察者"></a>十一、观察者</h2><p>​        当一个或几个课程正在等待具体事件时可以使用它。观察者模式由一个科目和观察员名单组成。一个很好的例子就是<code>GUI界面</code>，其中点击按钮（按钮是主题）会引起听众（观察者）启动的一些操作(再说的直白点就是电影院一场电影这个<code>subject</code>,需要<code>观众</code>(也就是观察者咯),电影产生的一些画面产生的事件，比如恐怖 电影给男人女人带来的不同的感官的感受，传播到观察者也就是观众的眼里所带来的不一样的反应，这个中间一般会添加一个<code>事件传播者</code>，在后面解释<code>Spring</code>的例子的时候会说到)，例如：打开一个新页面这个动作。可以参考下面的例子：</p>
<pre><code class="java">public class ObserverTest &#123;

  @Test
  public void test() &#123;
    Observer pageOpener = new PageOpener();
    Observer register = new Register();
    Button btn = new Button();
    btn.addListener(pageOpener);
    btn.addListener(register);
    btn.clickOn();
    assertTrue(&quot;Button should be clicked but it wasn&#39;t&quot;,
      btn.wasClicked());
    assertTrue(&quot;Page opener should be informed about click but it wasn&#39;t&quot;,
      pageOpener.wasInformed());
    assertTrue(&quot;Register should be informed about click but it wasn&#39;t&quot;,
      register.wasInformed());
  &#125;

&#125;

class Button &#123;

  private boolean clicked;
  private List&lt;observer&gt; listeners;

  public List&lt;observer&gt; getListeners() &#123;
    if (this.listeners == null) &#123;
      this.listeners = new ArrayList&lt;observer&gt;();
    &#125;
    return this.listeners;
  &#125;

  public void addListener(Observer observer) &#123;
    getListeners().add(observer);
  &#125;

  public boolean wasClicked() &#123;
    return this.clicked;
  &#125;

  public void clickOn() &#123;
    this.clicked = true;
    informAll();
  &#125;

  private void informAll() &#123;
    for (Observer observer : getListeners()) &#123;
      observer.informAboutEvent();
    &#125;
  &#125;

&#125;

abstract class Observer &#123;
  protected boolean informed;

  public void informAboutEvent() &#123;
    this.informed = true;
  &#125;

  public boolean wasInformed() &#123;
    return this.informed;
  &#125;
&#125;

class PageOpener extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Preparing download of new page&quot;);
    super.informAboutEvent();
  &#125;

&#125;

class Register extends Observer &#123;

  @Override
  public void informAboutEvent() &#123;
    System.out.println(&quot;Adding the action to register&quot;);
    super.informAboutEvent();
  &#125;
&#125;
</code></pre>
<p>​        可以看到，关于我们的<code>Button</code>实例点击的事件被发送到所有的观察者对象。从这些对象开始下载页面内容，第二个将在事件的信息保存在注册表中。在<code>Spring</code>中，观察者设计模式用于将与应用程序上下文相关的事件传输到<strong>org.springframework.context.ApplicationListener的实现</strong>。要了解它们的实现方法，我们来看一下<code>AbstractApplicationContext</code>类(老版本的代码，新版本的请自行对照)：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader
  implements ConfigurableApplicationContext, DisposableBean &#123;
  /** Statically specified listeners */
  private Set&lt;applicationlistener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;applicationlistener&lt;?&gt;&gt;();

  // some other fields and methods
  @Override
  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;
    if (this.applicationEventMulticaster != null) &#123;
      this.applicationEventMulticaster.addApplicationListener(listener);
    &#125;
    else &#123;//新版本这里直接咔嚓掉，上面的applicationEventMulticaster一旦为空，就会报错的
      this.applicationListeners.add(listener);
    &#125;
  &#125;

  /**
    * Return the list of statically specified ApplicationListeners.
    */
  public Collection&lt;applicationlistener&lt;?&gt;&gt; getApplicationListeners() &#123;
    return this.applicationListeners;
  &#125;

  /**
    * Add beans that implement ApplicationListener as listeners.
    * Doesn&#39;t affect other listeners, which can be added without being beans.
    */
  protected void registerListeners() &#123;
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;
      getApplicationEventMulticaster().addApplicationListener(listener);
    &#125;
    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String lisName : listenerBeanNames) &#123;
      getApplicationEventMulticaster().addApplicationListenerBean(lisName);
    &#125;
  &#125;
&#125;java
</code></pre>
<p>​        在提供的代码中，监听器在内部添加到应用程序上下文类中，并且在<code>registerListeners()</code>方法之后，它们被注册到由接口<strong>org.springframework.context.event.ApplicationEventMulticaster</strong>表示的适当的事件多路广播器(因为有很多listeners)。<code>EventMulticaster</code>负责管理不同的<code>listener</code>和向他们发布事件。</p>
<pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;
    private Executor taskExecutor;
    private ErrorHandler errorHandler;

    public SimpleApplicationEventMulticaster() &#123;
    &#125;

    public SimpleApplicationEventMulticaster(BeanFactory beanFactory) &#123;
        this.setBeanFactory(beanFactory);
    &#125;

    public void setTaskExecutor(Executor taskExecutor) &#123;
        this.taskExecutor = taskExecutor;
    &#125;

    protected Executor getTaskExecutor() &#123;
        return this.taskExecutor;
    &#125;

    public void setErrorHandler(ErrorHandler errorHandler) &#123;
        this.errorHandler = errorHandler;
    &#125;

    protected ErrorHandler getErrorHandler() &#123;
        return this.errorHandler;
    &#125;

    public void multicastEvent(ApplicationEvent event) &#123;
        this.multicastEvent(event, this.resolveDefaultEventType(event));
    &#125;
    //发布事件:通过池执行任务的方式来做并发处理，这样就把之前的对象池模式给利用上了
    public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123;
        ResolvableType type = eventType != null?eventType:this.resolveDefaultEventType(event);
        Iterator var4 = this.getApplicationListeners(event, type).iterator();

        while(var4.hasNext()) &#123;
            final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();
            Executor executor = this.getTaskExecutor();
            if(executor != null) &#123;
                executor.execute(new Runnable() &#123;
                    public void run() &#123;
                        SimpleApplicationEventMulticaster.this.invokeListener(listener, event);
                    &#125;
                &#125;);
            &#125; else &#123;
                this.invokeListener(listener, event);
            &#125;
        &#125;

    &#125;
...
&#125;
</code></pre>
<p>​        这次我们讲3种设计模式:用于在同一个调用作用域内创建<code>bean的原型</code>，避免重新创建巨型对象的对象池，以及将应用程序的上下文事件分派给适当的监听器的观察者。</p>
<h2 id="十二、适配器"><a href="#十二、适配器" class="headerlink" title="十二、适配器"></a>十二、适配器</h2><p>​        当我们需要在给定场景下(也就是给定接口)想要不改变自身行为而又想做到一些事情的情况下(就是我给电也就是接口了，你来做事也就是各种电器)，使用<strong>适配器设计模式</strong>(这里再说一点，就相当于我们再一个规章制度的环境下，如何去适应并达到我们期待的效果，放在架构设计这里，可以拿一个php系统和一个Java系统来说，假如两者要互相调用对方的功能，我们可以设计一套对外的api来适配)。这意味着在调用此对象之前，我们将更改使用对象而不改变机制。拿一个现实中的例子进行说明，想象一下你想要用电钻来钻一个洞。要钻一个小洞，你会使用小钻头，钻一个大的需要用大钻头。可以看下面的代码：</p>
<pre><code class="java">public class AdapterTest &#123;

  public static void main(String[] args) &#123;
    HoleMaker maker = new HoleMakerImpl();
    maker.makeHole(1);
    maker.makeHole(2);
    maker.makeHole(30);
    maker.makeHole(40);
  &#125;
&#125;

interface HoleMaker &#123;
  public void makeHole(int diameter);
&#125;

interface DrillBit &#123;
  public void makeSmallHole();
  public void makeBigHole();
&#125;

// Two adaptee objects
class BigDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    // do nothing
  &#125;

  @Override
  public void makeBigHole() &#123;
    System.out.println(&quot;Big hole is made byt WallBigHoleMaker&quot;);
  &#125;
&#125;

class SmallDrillBit implements DrillBit &#123;

  @Override
  public void makeSmallHole() &#123;
    System.out.println(&quot;Small hole is made byt WallSmallHoleMaker&quot;);
  &#125;

  @Override
  public void makeBigHole() &#123;
    // do nothing
  &#125;
&#125;

// Adapter class
class Drill implements HoleMaker &#123;

  private DrillBit drillBit;

  public Drill(int diameter) &#123;
    drillBit = getMakerByDiameter(diameter);
  &#125;

  @Override
  public void makeHole(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            drillBit.makeSmallHole();
    &#125; else &#123;
            drillBit.makeBigHole();
    &#125;
  &#125;

  private DrillBit getMakerByDiameter(int diameter) &#123;
    if (isSmallDiameter(diameter)) &#123;
            return new SmallDrillBit();
    &#125;
    return new BigDrillBit();
  &#125;

  private boolean isSmallDiameter(int diameter) &#123;
    return diameter &lt; 10;
  &#125;
&#125;

// Client class
class HoleMakerImpl implements HoleMaker &#123;

  @Override
  public void makeHole(int diameter) &#123;
    HoleMaker maker = new Drill(diameter);
    maker.makeHole(diameter);
  &#125;
&#125;
</code></pre>
<p>以上代码的结果如下:</p>
<pre><code class="java">Small hole is made byt SmallDrillBit
Small hole is made byt SmallDrillBit
Big hole is made byt BigDrillBit
Big hole is made byt BigDrillBit
</code></pre>
<p>​        可以看到，hole 是由所匹配的DrillBit对象制成的。如果孔的直径小于10，则使用SmallDrillBit。如果它更大，我们使用BigDrillBit。</p>
<p>​        思路就是，要打洞，那就要有打洞的工具，这里提供一个电钻接口和钻头。电钻就是用来打洞的，所以，它就一个接口方法即可，接下来定义钻头的接口，无非就是钻头的尺寸标准，然后搞出两个钻头实现类出来，接下来就是把钻头和电钻主机组装起来咯，也就是<code>Drill</code>类，里面有电钻接口+钻头(根据要钻的孔大小来确定用哪个钻头)，其实也就是把几个单一的东西组合起来拥有丰富的功能，最后我们进行封装下:<code>HoleMakerImpl</code>，这样只需要根据尺寸就可以打相应的孔了，对外暴露的接口极为简单，无须管内部逻辑是多么复杂</p>
<p>​        Spring使用适配器设计模式来处理不同servlet容器中的<strong>加载时编织</strong>(<strong>load-time-weaving</strong>)。在面向切面编程（AOP）中使用<strong>load-time-weaving</strong>，一种方式是在类加载期间将AspectJ的方面注入字节码。另一种方式是对类进行编译时注入或对已编译的类进行静态注入。</p>
<p>​        我们可以从关于Spring和JBoss的处理接口这里找到一个很好的例子，它包含在<strong>org.springframework.instrument.classloading.jboss</strong>包中。我们检索<code>JBossLoadTimeWeaver类</code>负责<code>JBoss容器</code>的编织管理。然而，类加载器对于<code>JBoss 6</code>（使用<code>JBossMCAdapter</code>实例）和<code>JBoss 7/8</code>（使用<code>JBossModulesAdapter</code>实例）是不同的。根据<code>JBoss</code>版本，我们在<code>JBossLoadTimeWeaver</code>构造函数中初始化相应的适配器（与我们示例中的<code>Drill</code>的构造函数完全相同）：</p>
<pre><code class="java">public JBossLoadTimeWeaver(ClassLoader classLoader) &#123;
  private final JBossClassLoaderAdapter adapter;

  Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
  if (classLoader.getClass().getName().startsWith(&quot;org.jboss.modules&quot;)) &#123;
    // JBoss AS 7 or WildFly 8
    this.adapter = new JBossModulesAdapter(classLoader);
  &#125;
  else &#123;
    // JBoss AS 6
    this.adapter = new JBossMCAdapter(classLoader);
  &#125;
&#125;
</code></pre>
<p>​        而且，此适配器所创建的实例用于根据运行的servlet容器版本进行编织操作：</p>
<pre><code class="java">@Override
public void addTransformer(ClassFileTransformer transformer) &#123;
  this.adapter.addTransformer(transformer);
&#125;

@Override
public ClassLoader getInstrumentableClassLoader() &#123;
  return this.adapter.getInstrumentableClassLoader();
&#125;
</code></pre>
<blockquote>
<p>总结：适配器模式，其实就是我们用第一人称的视角去看世界，我想拓展我自己的技能的时候，就实行拿来主义，就好比这里的我是电钻的视角，那么我想拥有钻大孔或者小孔的功能，那就把钻头拿到手组合起来就好。</p>
<p>和装饰模式的区别：装饰模式属于第三人称的视角，也就是上帝视角！我只需要把几个功能性的组件给拿到手，进行组合一下，实现一个更加<code>niubility</code>的功能这里提前说下，这样看下面的内容能好理解些。下面解释装饰模式</p>
</blockquote>
<h2 id="十三、装饰"><a href="#十三、装饰" class="headerlink" title="十三、装饰"></a>十三、装饰</h2><p>​        这里描述的第二种设计模式看起来类似于适配器。它是<strong>装饰模式</strong>。这种设计模式的主要作用是为给定的对象添加补充角色。举个现实的例子，就拿咖啡来讲。通常越黑越苦，你可以添加（<code>装饰</code>）糖和牛奶，使咖啡不那么苦。咖啡在这里被装饰的对象，糖与牛奶是用来装饰的。可以参考下面的例子：</p>
<pre><code class="java">public class DecoratorSample &#123;

  @Test
  public void test() &#123;
    Coffee sugarMilkCoffee=new MilkDecorator(new SugarDecorator(new BlackCoffee()));
    assertEquals(sugarMilkCoffee.getPrice(), 6d, 0d);
  &#125;
&#125;

// decorated
abstract class Coffee&#123;
  protected int candied=0;
  protected double price=2d;
  public abstract int makeMoreCandied();
  public double getPrice()&#123;
    return this.price;
  &#125;
  public void setPrice(double price)&#123;
    this.price+=price;
  &#125;
&#125;
class BlackCoffee extends Coffee&#123;
  @Override
  public int makeMoreCandied()&#123;
    return 0;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.price;
  &#125;
&#125;

// abstract decorator
abstract class CoffeeDecorator extends Coffee&#123;
  protected Coffee coffee;
  public CoffeeDecorator(Coffee coffee)&#123;
    this.coffee=coffee;
  &#125;
  @Override
  public double getPrice()&#123;
    return this.coffee.getPrice();
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return this.coffee.makeMoreCandied();
  &#125;
&#125;

// concrete decorators
class MilkDecorator extends CoffeeDecorator&#123;
  public MilkDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+1d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
class SugarDecorator extends CoffeeDecorator&#123;
  public SugarDecorator(Coffee coffee)&#123;
    super(coffee);
  &#125;
  @Override
  public double getPrice()&#123;
    return super.getPrice()+3d;
  &#125;
  @Override
  public int makeMoreCandied()&#123;
    return super.makeMoreCandied()+1;
  &#125;
&#125;
</code></pre>
<p>​        上面这个简单的装饰器的小例子是基于对父方法的调用，从而改变最后的属性（我们这里是指价格和加糖多少）。在Spring中，我们在处理与Spring管理缓存同步事务的相关类中可以 发现装饰器设计模式的例子。这个类是<strong>org.springframework.cache.transaction.TransactionAwareCacheDecorator</strong>。</p>
<p>​        这个类的哪些特性证明它是<strong>org.springframework.cache.Cache</strong>对象的装饰器？首先，与我们的咖啡示例一样，<code>TransactionAwareCacheDecorator</code>的构造函数接收参数装饰对象（Cache）：</p>
<pre><code class="java">private final Cache targetCache;
/**
 * Create a new TransactionAwareCache for the given target Cache.
 * @param targetCache the target Cache to decorate
 */
public TransactionAwareCacheDecorator(Cache targetCache) &#123;
  Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
  this.targetCache = targetCache;
&#125;
</code></pre>
<p>​        其次，通过这个对象，我们可以得到一个新的行为:为给定的目标缓存创建一个新的TransactionAwareCache。这个我们可以在<code>TransactionAwareCacheDecorator</code>的注释中可以阅读到，其主要目的是提供缓存和Spring事务之间的同步级别。这是通过<strong>org.springframework.transaction.support.TransactionSynchronizationManager</strong>中的两种缓存方法实现的：<code>put</code> 和 <code>evict</code>(其实最终不还是通过<code>targetCache</code>来实现的么)：</p>
<pre><code class="java">@Override
public void put(final Object key, final Object value) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
    TransactionSynchronizationManager.registerSynchronization(
      new TransactionSynchronizationAdapter() &#123;
        @Override
        public void afterCommit() &#123;
          targetCache.put(key, value);
        &#125;
    &#125;);
  &#125;
  else &#123;
    this.targetCache.put(key, value);
  &#125;
&#125;

@Override
public void evict(final Object key) &#123;
  if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
          TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronizationAdapter() &#123;
              @Override
              public void afterCommit() &#123;
                targetCache.evict(key);
              &#125;
          &#125;);
  &#125;
  else &#123;
    this.targetCache.evict(key);
  &#125;
&#125;
</code></pre>
<p>​        这种模式看起来类似于适配器，对吧？但是，它们还是有区别的。我们可以看到，适配器将对象适配到运行时环境，即。如果我们在JBoss 6中运行，我们使用与JBoss 7不同的类加载器。Decorator每次使用相同的主对象（Cache）工作，并且仅向其添加新行为（与本例中的Spring事务同步），另外，可以通过我在解读这个设计模式之前的说法来区分二者。</p>
<p>​        我们再以springboot的初始化来举个例子的，这块后面会进行仔细的源码分析的，这里就仅仅用设计模式来说下的:</p>
<pre><code class="java">/**
 * Event published as early as conceivably possible as soon as a &#123;@link SpringApplication&#125;
 * has been started - before the &#123;@link Environment&#125; or &#123;@link ApplicationContext&#125; is
 * available, but after the &#123;@link ApplicationListener&#125;s have been registered. The source
 * of the event is the &#123;@link SpringApplication&#125; itself, but beware of using its internal
 * state too much at this early stage since it might be modified later in the lifecycle.
 *
 * @author Dave Syer
 */
@SuppressWarnings(&quot;serial&quot;)
public class ApplicationStartedEvent extends SpringApplicationEvent &#123;

    /**
     * Create a new &#123;@link ApplicationStartedEvent&#125; instance.
     * @param application the current application
     * @param args the arguments the application is running with
     */
    public ApplicationStartedEvent(SpringApplication application, String[] args) &#123;
        super(application, args);
    &#125;

&#125;
</code></pre>
<p>​        从注释可以看出 <code>ApplicationListener</code>要先行到位的，然后就是started的时候<code>Event published</code>走起，接着就是<code>Environment</code>配置好，<code>ApplicationContext</code>进行初始化完毕，那我们去看<code>ApplicationListener</code>的源码:</p>
<pre><code class="java">/**
 * Listener for the &#123;@link SpringApplication&#125; &#123;@code run&#125; method.
 * &#123;@link SpringApplicationRunListener&#125;s are loaded via the &#123;@link SpringFactoriesLoader&#125;
 * and should declare a public constructor that accepts a &#123;@link SpringApplication&#125;
 * instance and a &#123;@code String[]&#125; of arguments. A new
 * &#123;@link SpringApplicationRunListener&#125; instance will be created for each run.
 *
 * @author Phillip Webb
 * @author Dave Syer
 */
public interface SpringApplicationRunListener &#123;

    /**
     * Called immediately when the run method has first started. Can be used for very
     * early initialization.
     */
    void started();

    /**
     * Called once the environment has been prepared, but before the
     * &#123;@link ApplicationContext&#125; has been created.
     * @param environment the environment
     */
    void environmentPrepared(ConfigurableEnvironment environment);

    /**
     * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but
     * before sources have been loaded.
     * @param context the application context
     */
    void contextPrepared(ConfigurableApplicationContext context);

    /**
     * Called once the application context has been loaded but before it has been
     * refreshed.
     * @param context the application context
     */
    void contextLoaded(ConfigurableApplicationContext context);

    /**
     * Called immediately before the run method finishes.
     * @param context the application context or null if a failure occurred before the
     * context was created
     * @param exception any run exception or null if run completed successfully.
     */
    void finished(ConfigurableApplicationContext context, Throwable exception);

&#125;
</code></pre>
<p>​        看类注释我们可以知道，需要实现此接口内所定义的这几个方法，ok，来看个实现类:</p>
<pre><code class="java">/**
 * &#123;@link SpringApplicationRunListener&#125; to publish &#123;@link SpringApplicationEvent&#125;s.
 * &lt;p&gt;
 * Uses an internal &#123;@link ApplicationEventMulticaster&#125; for the events that are fired
 * before the context is actually refreshed.
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 */
public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;

    private final SpringApplication application;

    private final String[] args;

    private final ApplicationEventMulticaster initialMulticaster;

    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;
        this.application = application;
        this.args = args;
        this.initialMulticaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;
            this.initialMulticaster.addApplicationListener(listener);
        &#125;
    &#125;

    @Override
    public int getOrder() &#123;
        return 0;
    &#125;

    @Override
    public void started() &#123;
        this.initialMulticaster
                .multicastEvent(new ApplicationStartedEvent(this.application, this.args));
    &#125;

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) &#123;
        this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(
                this.application, this.args, environment));
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;

    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        for (ApplicationListener&lt;?&gt; listener : this.application.getListeners()) &#123;
            if (listener instanceof ApplicationContextAware) &#123;
                ((ApplicationContextAware) listener).setApplicationContext(context);
            &#125;
            context.addApplicationListener(listener);
        &#125;
        this.initialMulticaster.multicastEvent(
                new ApplicationPreparedEvent(this.application, this.args, context));
    &#125;

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;
        // Listeners have been registered to the application context so we should
        // use it at this point
        context.publishEvent(getFinishedEvent(context, exception));
    &#125;

    private SpringApplicationEvent getFinishedEvent(
            ConfigurableApplicationContext context, Throwable exception) &#123;
        if (exception != null) &#123;
            return new ApplicationFailedEvent(this.application, this.args, context,
                    exception);
        &#125;
        return new ApplicationReadyEvent(this.application, this.args, context);
    &#125;

&#125;
</code></pre>
<p>​        从上可以看出，<code>EventPublishingRunListener</code>里对接口功能的实现，主要是通过<code>SpringApplication</code> <code>ApplicationEventMulticaster</code> 来实现的，自己不干活，挂个虚名，从上帝模式的角度来看，这不就是应用了装饰模式来实现的么</p>
<h2 id="十四、单例模式"><a href="#十四、单例模式" class="headerlink" title="十四、单例模式"></a>十四、单例模式</h2><p>​        <strong>单例</strong>，我们最常用的设计模式。正如我们在很多Spring Framework中关于单例和原型bean的文章(网上太多了)中已经看到过的，单例是几个bean作用域中的中的一个。此作用域在每个应用程序上下文中仅创建一个给定bean的实例。与signleton设计模式有所区别的是，Spring将实例的数量限制的作用域在整个应用程序的上下文。而Singleton设计模式在Java应用程序中是将这些实例的数量限制在给定类加载器管理的整个空间中。这意味着我们可以为两个Spring的上下文(同一份配置文件起两个容器，也就是不同端口的容器实例)使用相同的类加载器，并检索两个单例作用域的bean。</p>
<p>​        在看Spring单例应用之前，让我们来看一个Java的单例例子：</p>
<pre><code class="java">public class SingletonTest &#123;

  @Test
  public void test() &#123;
    President president1 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    President president2 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();
    assertTrue(&quot;Both references of President should point to the same object&quot;, president1 == president2);
    System.out.println(&quot;president1 = &quot;+president1+&quot; and president2 = &quot;+president2);
    // sample output
    // president1 = com.migo.test.President@17414c8 and president2 = com.migo.test.President@17414c8

  &#125;

&#125;

enum SingletonsHolder &#123;

  PRESIDENT(new President());

  private Object holdedObject;

  private SingletonsHolder(Object o) &#123;
          this.holdedObject = o;
  &#125;

  public Object getHoldedObject() &#123;
          return this.holdedObject;
  &#125;

&#125;

class President &#123;
&#125;
</code></pre>
<p>​        这个测试例子证明，只有一个由SingletonsHolder所持有的President实例。在Spring中，我们可以在bean工厂中找到单例应用的影子（例如在<strong>org.springframework.beans.factory.config.AbstractFactoryBean中</strong>）：</p>
<pre><code class="java">/**
 * Expose the singleton instance or create a new prototype instance.
 * @see #createInstance()
 * @see #getEarlySingletonInterfaces()
 */
@Override
public final T getObject() throws Exception &#123;
  if (isSingleton()) &#123;
    return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());
  &#125;
  else &#123;
    return createInstance();
  &#125;
&#125;
</code></pre>
<p>​        我们看到，当需求对象被视为单例时，它只被初始化一次，并且在每次使用同一个bean类的实例后返回。我们可以在给定的例子中看到，类似于我们以前看到的President情况。将测试bean定义为：</p>
<pre><code class="xml">&lt;bean id=&quot;shoppingCart&quot; class=&quot;com.migo.data.ShoppingCart&quot; /&gt;
</code></pre>
<p>测试用例如下所示：</p>
<pre><code class="java">public class SingletonSpringTest &#123;

  @Test
  public void test() &#123;
    // retreive two different contexts
    ApplicationContext firstContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);
    ApplicationContext secondContext = new FileSystemXmlApplicationContext(&quot;applicationContext-test.xml&quot;);

    // prove that both contexts are loaded by the same class loader
    assertTrue(&quot;Class loaders for both contexts should be the same&quot;,
      firstContext.getClassLoader() == secondContext.getClassLoader());
    // compare the objects from different contexts
    ShoppingCart firstShoppingCart = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    ShoppingCart secondShoppingCart = (ShoppingCart) secondContext.getBean(&quot;shoppingCart&quot;);
    assertFalse(&quot;ShoppingCart instances got from different application context shouldn&#39;t be the same&quot;,
      firstShoppingCart == secondShoppingCart);

    // compare the objects from the same context
    ShoppingCart firstShoppingCartBis = (ShoppingCart) firstContext.getBean(&quot;shoppingCart&quot;);
    assertTrue(&quot;ShoppingCart instances got from the same application context should be the same&quot;,
      firstShoppingCart == firstShoppingCartBis);
  &#125;
&#125;
</code></pre>
<p>​        这个测试案例显示了Spring单例模式与纯粹的单例设计模式的主要区别。尽管使用相同的类加载器来加载两个应用程序上下文，但是ShoppingCart的实例是不一样的。但是，当我们比较两次创建并属于相同上下文的实例时，我们认为它们是相等的。</p>
<p>​        也正因为有了单例，Spring可以控制在每个应用程序上下文中只有一个这样指定的bean的实例可用。因为适配器，Spring可以决定使用由谁来处理<code>JBoss servlet</code>容器中的加载时编织,也可以实现<code>ConfigurableListableBeanFactory</code>的相应实例。第三种设计模式，装饰器，用于向Cache对象添加同步功能，还有Springboot的容器初始化。</p>
<p>​        其实对于适配器和装饰者确实有太多的相似的地方，一个是运行时选择，一个是加料组合产生新的化学效应，还有从看待事物的角度不同得到不同的行为，适配适配，更注重面向接口的实现，而内部又根据不同情况调用面向一套接口的多套实现的实例的相应方法来实现所要实现的具体功能，装饰者更注重添油加醋，通过组合一些其他对象实例来让自己的功能实现的更加华丽一些(达到1+1&gt;2的这种效果)。</p>
<h2 id="十五、命令模式"><a href="#十五、命令模式" class="headerlink" title="十五、命令模式"></a>十五、命令模式</h2><p>​        这篇文章描述的第一个行为设计模式是<strong>命令</strong>。它允许将请求封装在一个对象内并附加一个回调动作(每次遇到所所谓的回调大家就只需要理解为一个函数方法就好，省的去浪费那么多脑子)。请求被封装在命令对象之下，而请求的结果被发送到接收者。命令本身不是由调用者执行。为了直白了解其中的主要思想，想象一下管理服务器的情况(远程通过<code>ssh</code>操作<code>Linux</code>服务器)。管理员（<code>invoker</code>）在命令行（<code>commands</code>）中启动一些操作，将结果发送到服务器（接收器）。在这里,所有这一切都是由客户端的终端(也就是我们用的<code>xshell</code>)来完成的。搞个<code>Demo</code>来说明一下(对于命令，它的动作就是执行，对于管理员来讲，我们的动作其实就是一个回车，执不执行当然是管理员说的算了，执行交给命令对象了，服务器最后就是一个展示结果)：</p>
<pre><code class="java">public class CommandTest &#123;

  // This test method is a client
  @Test
  public void test() &#123;
    Administrator admin = new Administrator();
    Server server = new Server();

    // start Apache
    admin.setCommand(new StartApache(server));
    admin.typeEnter();

    // start Tomcat
    admin.setCommand(new StartTomcat(server));
    admin.typeEnter();

    // check executed commands
    int executed = server.getExecutedCommands().size();
    assertTrue(&quot;Two commands should be executed but only &quot;+
      executed+ &quot; were&quot;, executed == 2);
  &#125;

&#125;

// commands
abstract class ServerCommand &#123;

  protected Server server;

  public ServerCommand(Server server) &#123;
    this.server = server;
  &#125;

  public abstract void execute();
&#125;

class StartTomcat extends ServerCommand &#123;

  public StartTomcat(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service tomcat7 start&quot;);
  &#125;
&#125;

class StartApache extends ServerCommand &#123;

  public StartApache(Server server) &#123;
    super(server);
  &#125;

  @Override
  public void execute() &#123;
    server.launchCommand(&quot;sudo service apache2 start&quot;);
  &#125;
&#125;

// invoker
class Administrator &#123;

  private ServerCommand command;

  public void setCommand(ServerCommand command) &#123;
    this.command = command;
  &#125;

  public void typeEnter() &#123;
    this.command.execute();
  &#125;

&#125;

// receiver
class Server &#123;

  // as in common terminals, we store executed commands in history
  private List&lt;String&gt; executedCommands = new ArrayList&lt;String&gt;();

  public void launchCommand(String command) &#123;
    System.out.println(&quot;Executing: &quot;+command+&quot; on server&quot;);
    this.executedCommands.add(command);
  &#125;

  public List&lt;String&gt; getExecutedCommands() &#123;
    return this.executedCommands;
  &#125;

&#125;
</code></pre>
<p>测试应通过并打印两个命令：</p>
<pre><code class="java">Executing: sudo service apache2 start on server
Executing: sudo service tomcat7 start on server
</code></pre>
<p>​        命令模式不仅允许封装请求（ServerCommand）并将其传输到接收器（Server），而且还可以更好地处理给定的请求。在这里，这种更好的处理是通过存储命令的执行历史。在Spring中，我们在beanFactory后置处理器的特性中来找到指令设计模式的原理。要通过快速对它们进行定义，应用程序上下文会启动后置处理器，并可以用来对创建的bean进行一些操作（这里不打算细说了，具体的我后面会专门写一篇这方面的文章，来分析其中的源码细节）。</p>
<p>​        当我们将先前Demo里呈现的命令逻辑转换并对比到<code>Spring bean工厂后处理器</code>时，我们可以区分以下<code>actors</code>：<strong>后置处理器bean</strong>(是指实现<code>BeanFactoryPostProcessor</code>接口)是命令，<strong>org.springframework.context.support.PostProcessorRegistrationDelegate</strong>是调用者(它执行<code>postProcessBeanFactory</code>方法注册所有的后置处理器bean，此处看下面第二段代码)和接收器<strong>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</strong>可以在元素（bean）构造初始化之前修改它们（例如：在初始化bean之前可以更改属性）。</p>
<p>​        另外，回顾下上面的那个Demo，和我们的Demo中的命令历史管理一样。<code>PostProcessorRegistrationDelegate</code>包含一个内部类<code>BeanPostProcessorChecker</code>，它可以记录当一个bean不符合处理条件的情况。</p>
<p>​        可以观察<code>PostProcessorRegistrationDelegate</code>中的两段代码:</p>
<pre><code class="java">/**
     * BeanPostProcessor that logs an info message when a bean is created during
     * BeanPostProcessor instantiation, i.e. when a bean is not eligible for
     * getting processed by all BeanPostProcessors.
     */
    private static class BeanPostProcessorChecker implements BeanPostProcessor &#123;

        private static final Log logger = LogFactory.getLog(BeanPostProcessorChecker.class);

        private final ConfigurableListableBeanFactory beanFactory;

        private final int beanPostProcessorTargetCount;

        public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) &#123;
            this.beanFactory = beanFactory;
            this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
        &#125;

        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;
            return bean;
        &#125;

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) &#123;
            if (bean != null &amp;&amp; !(bean instanceof BeanPostProcessor) &amp;&amp; !isInfrastructureBean(beanName) &amp;&amp;
                    this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount) &#123;
                if (logger.isInfoEnabled()) &#123;
                    logger.info(&quot;Bean &#39;&quot; + beanName + &quot;&#39; of type [&quot; + bean.getClass() +
                            &quot;] is not eligible for getting processed by all BeanPostProcessors &quot; +
                            &quot;(for example: not eligible for auto-proxying)&quot;);
                &#125;
            &#125;
            return bean;
        &#125;

        private boolean isInfrastructureBean(String beanName) &#123;
            if (beanName != null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName)) &#123;
                BeanDefinition bd = this.beanFactory.getBeanDefinition(beanName);
                return RootBeanDefinition.ROLE_INFRASTRUCTURE == bd.getRole();
            &#125;
            return false;
        &#125;
    &#125;
</code></pre>
<p>​        定义后的调用,用的就是<code>ConfigurableListableBeanFactory</code>的实例(看<code>BeanPostProcessorChecker</code>注释):</p>
<pre><code class="java">public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  //BeanPostProcessorChecker
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                    internalPostProcessors.add(pp);
                &#125;
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        sortPostProcessors(beanFactory, orderedPostProcessors);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(beanFactory, internalPostProcessors);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    &#125;
</code></pre>
<blockquote>
<p>总结一个过程就是，我要BeanFactory里面得到对象(也就是为了得到一个命令的执行结果)，那么，想要在得到对象的时候就已经实现了一些对其修改的想法，那么就通过后置处理器，也是就实现了后置处理器接口的beans(命令里可以通过传入不同的参数来得到不同结果，或者对命令的脚本进行修改)，然后还需要一个执行者(我们在做自动化运维的时候，不止操作一个脚本，这里的<code>PostProcessorRegistrationDelegate</code>就是集中来管理这些的)，最后得到的结果就由<code>BeanFactory</code>来展示咯。</p>
</blockquote>
<h2 id="十六、访问者模式"><a href="#十六、访问者模式" class="headerlink" title="十六、访问者模式"></a>十六、访问者模式</h2><p>​        接下来要介绍的一个行为设计模式是<strong>Visitor</strong>:抽象一点就是通过另一种类型的对象来使一个对象访问。在这个简短定义中，使用这个设计模式中的对象将被视为访问者或对象可被访问。第一个访问者要有可访问支持。这个模式的一个现实的例子可以是一个汽车质检员，他们检查一些汽车零件，比如轮子，制动器和发动机，以判断汽车质量是否合格。我们来做个JUnit测试用例：</p>
<pre><code class="java">public class VisitorTest &#123;

  @Test
  public void test() &#123;
    CarComponent car = new Car();
    Mechanic mechanic = new QualifiedMechanic();
    car.accept(mechanic);
    assertTrue(&quot;After qualified mechanics visit, the car should be broken&quot;,
      car.isBroken());
    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();
    car.accept(nonqualifiedMechanic);
    assertFalse(&quot;Car shouldn&#39;t be broken becase non qualified mechanic &quot; +
      &quot; can&#39;t see breakdowns&quot;, car.isBroken());
  &#125;

&#125;

// visitor
interface Mechanic &#123;
  public void visit(CarComponent element);
  public String getName();
&#125;

class QualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;qualified&quot;;
  &#125;
&#125;

class NonQualifiedMechanic implements Mechanic &#123;

  @Override
  public void visit(CarComponent element) &#123;
    element.setBroken(true);
  &#125;

  @Override
  public String getName() &#123;
    return &quot;unqualified&quot;;
  &#125;
&#125;

// visitable
abstract class CarComponent &#123;
  protected boolean broken;

  public abstract void accept(Mechanic mechanic);

  public void setBroken(boolean broken) &#123;
    this.broken = broken;
  &#125;

  public boolean isBroken() &#123;
    return this.broken;
  &#125;
&#125;

class Car extends CarComponent &#123;

  private boolean broken = false;
  private CarComponent[] components;

  public Car() &#123;
    components = new CarComponent[] &#123;
      new Wheels(), new Engine(), new Brake()
    &#125;;
  &#125;

  @Override
  public void accept(Mechanic mechanic) &#123;
    this.broken = false;
    if (mechanic.getName().equals(&quot;qualified&quot;)) &#123;
      int i = 0;
      while (i &lt; components.length &amp;&amp; this.broken == false) &#123;
        CarComponent component = components[i];
        mechanic.visit(component);
        this.broken = component.isBroken();
        i++;
      &#125;
    &#125;
    // if mechanic isn&#39;t qualified, we suppose that
    // he isn&#39;t able to see breakdowns and so
    // he considers the car as no broken
    // (even if the car is broken)
  &#125;

  @Override
  public boolean isBroken() &#123;
          return this.broken;
  &#125;
&#125;

class Wheels extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Engine extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;

class Brake extends CarComponent &#123;

  @Override
  public void accept(Mechanic mechanic) &#123;
    mechanic.visit(this);
  &#125;
&#125;
</code></pre>
<p>​        在这个例子中，我们可以看到他们有两个机制(访问者,其实就是免检和不免检)：合格和不合格。暴露于他们的可见对象是汽车。通过其接受方式，决定哪个角色应该适用于被访问者(通过代码<code>mechanic.getName().equals(&quot;qualified&quot;)</code>来判断)。当访问者合格时，Car让他分析所有组件。如果访问者不合格，Car认为其干预是无用的，并且在方法<code>isBroken()</code>中直接返回<code>false</code>(其实就是为了达到一个免检的效果)。<code>Spring在beans配置中实现了访问者设计模式</code>。为了观察，我们可以看看<strong>org.springframework.beans.factory.config.BeanDefinitionVisitor</strong>对象，该对象用于<code>解析bean元数据</code>并将其解析为<code>String</code>（例如：具有作用域或工厂方法名称的XML属性）或<code>Object</code>（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的<code>BeanDefinition</code>实例中进行判断设置。具体的源码请看<code>BeanDefinitionVisitor</code>的代码片段：</p>
<pre><code class="java">/**
 * Traverse the given BeanDefinition object and the MutablePropertyValues
 * and ConstructorArgumentValues contained in them.
 * @param beanDefinition the BeanDefinition object to traverse
 * @see #resolveStringValue(String)
 */
public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;
  visitParentName(beanDefinition);
  visitBeanClassName(beanDefinition);
  visitFactoryBeanName(beanDefinition);
  visitFactoryMethodName(beanDefinition);
  visitScope(beanDefinition);
  visitPropertyValues(beanDefinition.getPropertyValues());
  ConstructorArgumentValues cas = beanDefinition.
    getConstructorArgumentValues();
  visitIndexedArgumentValues(cas.
    getIndexedArgumentValues());
  visitGenericArgumentValues(cas.
    getGenericArgumentValues());
&#125;

protected void visitParentName(BeanDefinition beanDefinition) &#123;
  String parentName = beanDefinition.getParentName();
  if (parentName != null) &#123;
    String resolvedName = resolveStringValue(parentName);
    if (!parentName.equals(resolvedName)) &#123;
      beanDefinition.setParentName(resolvedName);
    &#125;
  &#125;
&#125;
</code></pre>
<p>​        在这种情况下，他们只是访问方式，没有对访问者做任何补充的控制(在Demo里对car的质检员做了控制)。这里访问包括分析给定<code>BeanDefinition</code>的参数，并将其替换为已解析对象。</p>
<p>在这篇关于Spring中设计模式的文章中，我们发现了2种行为模式：<code>用于处理bean工厂的后置处理的命令模式</code>和<code>用于将定义的bean参数转换为面向对象（String或Object的实例）参数的访问者模式</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cl0us61fq003akovsan24anib" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Mybatis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SpringBoot整合Mybaits
        
      </div>
    </a>
  
  
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SpringBoot使用详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringMVC/">SpringMVC</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybaits/" rel="tag">Mybaits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">G1使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">JVM使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/JavaWeb/">JavaWeb</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/helloservlet/">配置文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Shuyan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>