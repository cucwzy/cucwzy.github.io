<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>Mybaits知识点 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="一、概念、使用方法向的问题1.1、Mybaits介绍​        （1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 ​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybaits知识点">
<meta property="og:url" content="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="一、概念、使用方法向的问题1.1、Mybaits介绍​        （1）Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 ​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200920171405540.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020092018550771.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200920190114946.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917203424287.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200920183713811.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200920183657317.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915221915851.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020092018294130.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200920183022252.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200830162428980.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915222654319.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915221915851.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915223612191.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915224121930.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200915225840294.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916211402947.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916214700706.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916213826490.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916214239389.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916214959863.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916215029787.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916215442588.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916215556263.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200916215523383.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917203050838.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917203424287.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917205236272.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917205454850.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917210415293.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917210606702.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917210831277.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917211035123.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917211124589.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200919104808424.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917211725203.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200917211854628.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200919110111271.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020091911381497.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020091911204922.png">
<meta property="article:published_time" content="2022-03-17T03:29:01.000Z">
<meta property="article:modified_time" content="2022-03-17T03:54:14.947Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="Mybaits">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200920171405540.png">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1648456240151">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1648456240151">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1648456240151">
    <link rel="stylesheet" href="/css/style.css?v=1648456240151">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>32</div>
        <div><span>Tags</span>11</div>
        <div><span>Categories</span>14</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">20</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">17</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 12.5px;">搜索</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="http://mms0.baidu.com/it/u=2467909075,3604847220&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=801&h=500" data-sizes="auto" alt="Mybaits知识点" class="lazyload">
              <h1>Mybaits知识点</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年03月17日</a>
</div>

      

      <h2 id="一、概念、使用方法向的问题"><a href="#一、概念、使用方法向的问题" class="headerlink" title="一、概念、使用方法向的问题"></a>一、概念、使用方法向的问题</h2><h3 id="1-1、Mybaits介绍"><a href="#1-1、Mybaits介绍" class="headerlink" title="1.1、Mybaits介绍"></a>1.1、Mybaits介绍</h3><p>​        （1）Mybatis是一个<strong>半ORM框架</strong>，它<strong>内部封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>​        （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>​        （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后<u>由mybatis框架执行sql并将结果映射为java对象并返回</u>。</p>
<h3 id="1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同"><a href="#1-2、-为什么说Mybatis是半ORM框架-与Hibernate有哪些不同" class="headerlink" title="1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?"></a>1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</h3><p>​        <strong>ORM是对象和关系之间的映射，包括对象-&gt;关系和关系-&gt;对象两方面。</strong>Hibernate是个完整的ORM框架，而MyBatis只完成了<strong>关系-&gt;对象</strong>，准确地说MyBatis是SQL映射框架而不是ORM框架，因为其仅有字段映射，对象数据以及对象实际关系仍然需要通过手写SQL来实现和管理。</p>
<p>​        （1）Hibernate为完整的ORM框架，Mybatis为半ORM框架。</p>
<p>​        （2）Mybatis程序员直接编写原生sql，可严格控制sql执行性能，灵活度高，适用于对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等；Hibernate只能通过编写hql实现数据库查询。</p>
<p>​        （3）Hibernate对象/关系映射能力强，数据库无关性好，适用于对关系模型要求高的软件； Mybatis的数据库无关性较差，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件。</p>
<h3 id="1-3、-Mybaits的优点"><a href="#1-3、-Mybaits的优点" class="headerlink" title="1.3、 Mybaits的优点?"></a><strong>1.3、 Mybaits的优点?</strong></h3><p>​        （1）基于SQL语句编程，不会对应用程序或者数据库的现有设计造成任何影响，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，重用性高。</p>
<p>​        （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>​        （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>​        （4）能够与Spring很好的集成；</p>
<p>​        （5）<strong>提供映射标签</strong>，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="1-4-、MyBatis框架的缺点"><a href="#1-4-、MyBatis框架的缺点" class="headerlink" title="1.4 、MyBatis框架的缺点?"></a>1.4 、MyBatis框架的缺点?</h3><p>​        （1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>​        （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h3 id="1-5、-和-的区别"><a href="#1-5、-和-的区别" class="headerlink" title="1.5、 #{}和${}的区别?"></a>1.5、 #{}和${}的区别?</h3><p>​        （1）**${}<strong>是properties文件中的</strong>变量占位符**，它可以用于标签属性值和sql内部，属于静态文本替换。</p>
<p>​        （2）**#{}<strong>是sql的</strong>参数占位符<strong>，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。</strong>使用#{}可以有效的防止 SQL 注入**，提高系统安全性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">$&#123;param&#125;传递的参数会被当成<span class="hljs-keyword">sql</span>语句中的一部分，<br>举例：<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $&#123;param&#125;<br>则解析成的<span class="hljs-keyword">sql</span>为：<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br><br><br>#&#123;parm&#125;传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，<br>举例：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;param&#125;，<br>则解析成的<span class="hljs-keyword">sql</span>为：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;id&quot;<br></code></pre></td></tr></table></figure>

<h3 id="1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题"><a href="#1-6-、怎么解决实体类中的属性名和表中的字段名不一样的问题" class="headerlink" title="1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?"></a>1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</h3><p>​        （1）通过在查询的sql语句中定义字段名的<strong>别名</strong>，使字段名的别名和实体类的属性名一致</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">resultetype</span>=<span class="hljs-string">&quot;com.en.entity.user&quot;</span>&gt;</span><br>    select user_id as id, user_no as no from test where user_id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>​        （2）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”me.gacl.domain.order”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderresultmap”</span>&gt;</span><br>    &lt;!–用id标签来映射主键字段–&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>&gt;</span><br>        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_no&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="1-7、-如何在mapper中传递多个参数"><a href="#1-7、-如何在mapper中传递多个参数" class="headerlink" title="1.7、 如何在mapper中传递多个参数?"></a>1.7、 如何在mapper中传递多个参数?</h3><p>​        （1）使用 <a target="_blank" rel="noopener" href="https://github.com/param">@param</a> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">user <span class="hljs-title">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@param(&quot;username&quot;)</span> string username,<span class="hljs-meta">@param(&quot;password&quot;)</span> string password)</span></span>;<br></code></pre></td></tr></table></figure>

<p>​        （2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-string">&quot;start&quot;</span>, start);<br>map.put(<span class="hljs-string">&quot;end&quot;</span>, end);<br>sqlSession.selectList(<span class="hljs-string">&quot;student.selectUser&quot;</span>, map);<br></code></pre></td></tr></table></figure>

<h3 id="1-8、-MyBatis的接口绑定有哪些实现方式？"><a href="#1-8、-MyBatis的接口绑定有哪些实现方式？" class="headerlink" title="1.8、 MyBatis的接口绑定有哪些实现方式？"></a>1.8、 MyBatis的接口绑定有哪些实现方式？</h3><p>​        <strong>接口绑定</strong>有两种实现方式：</p>
<p>​        （1）一种是<strong>通过注解绑定</strong>，就是在接口的方法上面加上<a target="_blank" rel="noopener" href="https://github.com/Select">@Select</a>、<a target="_blank" rel="noopener" href="https://github.com/Update">@Update</a>等注解里面包含Sql语句来绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select ID,CODE,NAME from T_SYS_DICT_TYPE &quot;)</span><br><span class="hljs-meta">@Results(</span><br><span class="hljs-meta">    	 id = &quot;distTypeMap&quot;,</span><br><span class="hljs-meta">         value =&#123;</span><br><span class="hljs-meta">    		@Result(id =true,property=&quot;id&quot;,column=&quot;ID&quot;)，</span><br><span class="hljs-meta">            @Result(property=&quot;code&quot;,column=&quot;CODE&quot;)，</span><br><span class="hljs-meta">            @Result(property=&quot;name&quot;,column=&quot;NAME&quot;)，</span><br><span class="hljs-meta">            @Result(</span><br><span class="hljs-meta">                property = &quot;dictDtos&quot; ,</span><br><span class="hljs-meta">                column = &quot;ID&quot;,</span><br><span class="hljs-meta">                many = @Many(</span><br><span class="hljs-meta">                    select = &quot;com.santbbd.ams.sysconfig.mapper.SysInitMapper.findByDistTypeId&quot;,</span><br><span class="hljs-meta">                    fetchType = FetchType.EAGER</span><br><span class="hljs-meta">                )</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    	&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function">List&lt;SysDictTypeDto&gt; <span class="hljs-title">getAllDist</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>​        （2）另外一种就是<strong>通过xml里面写SQL来绑定</strong>，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;mapper namespace=<span class="hljs-string">&quot;com.xxx.xxx.modular.batch.mapper.IllegalCollectionMapper&quot;</span>&gt;<br>&lt;select id=<span class="hljs-string">&quot;queryFileDisposeInfo&quot;</span> parameterType=<span class="hljs-string">&quot;FileDisposeVo&quot;</span> resultMap=<span class="hljs-string">&quot;illegalcollection-map&quot;</span>&gt;<br>   SELECT <br>        BATCH_NUMBER,<br>        FINISH_DATE,<br>        FILE_NAME,<br>        FILE_SIZE,<br>        DATA_SIZE,<br>        FILE_TYPE,<br>        ORG_CODE<br>   FROM <br>        T_FILE_DISPOSE<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<h3 id="1-9、-使用MyBatis-Mapper接口开发时有哪些要求？"><a href="#1-9、-使用MyBatis-Mapper接口开发时有哪些要求？" class="headerlink" title="1.9、 使用MyBatis Mapper接口开发时有哪些要求？"></a>1.9、 <strong>使用MyBatis Mapper接口开发时有哪些要求？</strong></h3><p>​        （1）Mapper接口<strong>方法名</strong>和mapper.xml中定义的每个<strong>sql的id</strong>相同；<br>​        （2）Mapper接口方法的<strong>输入参数类型</strong>和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>​        （3）Mapper接口方法的<strong>输出参数类型</strong>和mapper.xml中定义的每个sql的resultType的类型相同；<br>​        （4）Mapper.xml文件中的namespace即是mapper接口的<strong>类路径</strong>;</p>
<h2 id="二、源码向的问题"><a href="#二、源码向的问题" class="headerlink" title="二、源码向的问题"></a>二、源码向的问题</h2><h3 id="2-1、-解释下MyBatis面向Mapper编程工作原理？"><a href="#2-1、-解释下MyBatis面向Mapper编程工作原理？" class="headerlink" title="2.1、 解释下MyBatis面向Mapper编程工作原理？"></a>2.1、 解释下<strong>MyBatis面向Mapper编程工作原理？</strong></h3><p>​        Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的<strong>动态代理</strong>，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h3 id="2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？"><a href="#2-2、-为什么MyBatis-Mapper接口中的方法不支持重载？" class="headerlink" title="2.2、 为什么MyBatis Mapper接口中的方法不支持重载？"></a>2.2、 为什么<strong>MyBatis Mapper接口中的方法不支持重载？</strong></h3><p>​        在MyBatis源码中有这么几行代码，我们可以看到在解析XML文件创建mappe接口对应方法的时候，采用了<strong>接口全限名+方法名</strong>的方式作为StrictMap(MappedStatement数据存放的Map集合)的key值，而源码对于StrictMap的put方法进行了判断，如果存入的数据key已重复则抛出异常，所以Mapper接口中的方法不支持重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">id = applyCurrentNamespace(id, <span class="hljs-keyword">false</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">applyCurrentNamespace</span><span class="hljs-params">(String base, <span class="hljs-keyword">boolean</span> isReference)</span> </span>&#123;<br>   ...<br>   <span class="hljs-comment">// 返回值为mapper的全限名(xml中namespace的值)+方法名(xml中Statement id的值)</span><br>   <span class="hljs-keyword">return</span> currentNamespace + <span class="hljs-string">&quot;.&quot;</span> + base;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200920171405540.png" alt="img" class="lazyload"></p>
<h3 id="2-3、-Mybatis动态sql执行原理"><a href="#2-3、-Mybatis动态sql执行原理" class="headerlink" title="2.3、 Mybatis动态sql执行原理?"></a>2.3、 Mybatis动态sql执行原理?</h3><p>​        （1）<strong>初始化阶段：</strong>通过XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder解析XML文件中的信息存储到Configuration类中；<br>​        （2）<strong>代理阶段：</strong>先从Configuration配置类的MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息，再利用代理对象工厂MapperProxyFactory创建实际代理类，最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。<br>​        （3）<strong>数据读写阶段：</strong>通过四种Executor调用四种Handler进行查询和封装数据；</p>
<h3 id="2-4、-Mybatis的一级、二级缓存实现原理"><a href="#2-4、-Mybatis的一级、二级缓存实现原理" class="headerlink" title="2.4、 Mybatis的一级、二级缓存实现原理?"></a>2.4、 Mybatis的一级、二级缓存实现原理?</h3><p>​        （1）<strong>一级缓存：</strong> 基于 PerpetualCache 的 HashMap 本地缓存，<strong>其存储作用域为 Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认打开一级缓存，一级缓存存放在BaseExecutor的localCache变量中：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/2020092018550771.png" alt="img" class="lazyload"></p>
<p>​        （2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于<strong>其存储作用域为 Mapper(Namespace)级别</strong>。</p>
<p>​        Mybatis默认不打开二级缓存，可以在config文件中xml<code> &lt;settings&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code>开启全局的二级缓存，但并不会为所有的Mapper设置二级缓存，每个mapper.xml文件中使用标签来开启当前mapper的二级缓存，二级缓存存放在MappedStatement类cache变量中：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200920190114946.png" alt="img" class="lazyload"></p>
<p>​        （3）对于<strong>缓存数据更新机制</strong>，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被清除并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
<h3 id="2-5-、Mybatis是如何进行分页的？"><a href="#2-5-、Mybatis是如何进行分页的？" class="headerlink" title="2.5 、Mybatis是如何进行分页的？"></a>2.5 、Mybatis是如何进行分页的？</h3><p>​        （1）<strong>SQL分页</strong>(物理分页)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryStudentsBySql&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentmapper&quot;</span>&gt;</span> <br>    select * from student limit #&#123;start&#125; , #&#123;end&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>​        （2）使用<strong>RowBounds</strong>实现分页(逻辑分页)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Service:<br>    <span class="hljs-function">publicList <span class="hljs-title">queryRolesByPage</span><span class="hljs-params">(String roleName,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        returnroleDao.queryRolesByPage(roleName,<span class="hljs-keyword">new</span> RowBounds(start, limit));<br>    &#125;<br><br><br>Dao:<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryUsersByPage</span><span class="hljs-params">(String userName, RowBounds rowBounds)</span></span>;<br></code></pre></td></tr></table></figure>

<p>​        （3）使用<strong>分页插件PageHelper</strong>：</p>
<p>​        添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分页--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>​        在mybatis-config.xml中配置PageInterceptor拦截器:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--2.配置分页插件，此插件必须配置在typeAliases后面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--分页合理化参数，默认文false；pageNum&lt;=0，查询第一页；pageNum&gt;总页数，查询最后一页--&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reasonable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Json <span class="hljs-title">queryByPage</span><span class="hljs-params">(User userParam,Integer pageNum,Integer pageSize)</span> </span>&#123;<br>    PageHelper.startPage(pageNum, pageSize);<br>    List&lt;User&gt; userList = userMapper.queryByPage(userParam);<br>    Json json = <span class="hljs-keyword">new</span> Json();<br>    <span class="hljs-keyword">return</span> json;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6、-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img" class="lazyload"></p>
<p>​        <strong>Executor</strong>是mybatis中的<strong>执行器接口</strong>:</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193704124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193729573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" class="lazyload"></p>
<p>​        <strong>BaseExecutor（基础执行器）：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了<strong>缓存管理和事务管理</strong>的能力，使用了<strong>模板模式</strong>，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现。BaseExecutor的一级缓存是会话级别的，增、删、改都会清空一级缓存；而CachingExecutor的二级缓存是应用级的。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193759456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" class="lazyload"></p>
<p>​        <strong>CachingExecutor（缓存执行器）：</strong>直接实现Executor接口，使用装饰器模式<strong>提供二级缓存能力</strong>。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193914827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200705191437604.png" class="lazyload"></p>
<p>​        <strong>BatchExecutor（批处理执行器）：</strong>BaseExecutor具体子类实现，在doUpdate方法中，<strong>提供批量执行多条SQL语句的能力</strong>；</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193851637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" class="lazyload"></p>
<p>​        <strong>SimpleExecutor（简单执行器）：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor（可重用执行器）：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200705193821188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NXMTg1NzM3MDcxMDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" class="lazyload"></p>
<h3 id="2-7、-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7、-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7、 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7、 Mybatis中如何指定使用哪一种Executor执行器？</h3><p>​        在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200920183713811.png" alt="img" class="lazyload"></p>
<blockquote>
<p>&lt;class=”reference-link”&gt;</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200920183657317.png" alt="img" class="lazyload"></p>
<h3 id="2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#2-8、-Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/2020092018294130.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200920183022252.png" alt="img" class="lazyload"></p>
<p>​        Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="2-9、-Mybatis中用到了哪些设计模式？"><a href="#2-9、-Mybatis中用到了哪些设计模式？" class="headerlink" title="2.9、 Mybatis中用到了哪些设计模式？"></a>2.9、 Mybatis中用到了哪些设计模式？</h3><p>​        日志模块：代理模式、适配器模式</p>
<p>​        数据源模块：代理模式、工厂模式</p>
<p>​        缓存模块：装饰器模式</p>
<p>​        初始化阶段：建造者模式</p>
<p>​        代理阶段：策略模式</p>
<p>​        数据读写阶段：模板模式</p>
<p>​        插件化开发：责任链模式</p>
<h2 id="三、Mybaits源码结构"><a href="#三、Mybaits源码结构" class="headerlink" title="三、Mybaits源码结构"></a>三、Mybaits源码结构</h2><h3 id="3-1-、源码包功能模块图"><a href="#3-1-、源码包功能模块图" class="headerlink" title="3.1 、源码包功能模块图"></a>3.1 、源码包功能模块图</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200830162428980.png" alt="img" class="lazyload"></p>
<h3 id="3-2-、各包详细功能解析"><a href="#3-2-、各包详细功能解析" class="headerlink" title="3.2 、各包详细功能解析"></a>3.2 、各包详细功能解析</h3><p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                包含所有mapper 接口中用到的注解</p>
<p>​        <strong>org.apache.ibatis.binding：</strong></p>
<p>​                生成mapper 接口的动态代理并进行管理</p>
<p>​        <strong>org.apache.ibatis.builder：</strong></p>
<p>​                1、包含Configuration对象所有构建器，主要包括XML、注解2种方式配置解析</p>
<p>​                2、BaseBuilder 构建器基类</p>
<p>​                3、XMLConfigBuilder 解析configuration.xml配置文件</p>
<p>​                4、XMLMapperBuilder 解析Mapper.xml配置文件</p>
<p>​                5、XMLStatementBuilder 解析selectupdatedelete 标签MapperAnnotationBuilder 注解式Mapper</p>
<p>​        <strong>org.apache.ibatis.cache：</strong></p>
<p>​                1、缓存功能实现、包含各种缓存装饰器</p>
<p>​                2、TransactionalCache 二级缓存功能实现</p>
<p>​        <strong>org.apache.ibatis.cursor：</strong></p>
<p>​                实现游标的方式查询数据、游标非常适合处理百万级别的数据查询</p>
<p>​        <strong>org.apache.ibatis.datasource：</strong></p>
<p>​                数据源 包括jndi数据源、连接池功能</p>
<p>​        <strong>org.apache.ibatis.executor：</strong></p>
<p>​                1、包含SQL语句执行器，核心功能包</p>
<p>​                2、功能包括：主键生成功能、执行参数解析功能、执行结果集解析功能、SQL执行器、缓存执行器</p>
<p>​        <strong>org.apache.ibatis.exceptions：</strong></p>
<p>​                框架异常，常见异常：TooManyResultsException</p>
<p>​        <strong>org.apache.ibatis.io：</strong></p>
<p>​                资源文件读取</p>
<p>​        <strong>org.apache.ibatis.jdbc：</strong></p>
<p>​                1、JDBC一些操作</p>
<p>​                2、SqlRunner SQL执行</p>
<p>​                3、ScriptRunner 脚本执行，可以执行建库语句</p>
<p>​        <strong>org.apache.ibatis.logging：</strong></p>
<p>​                1、日志功能，实现多种日志框架的对接</p>
<p>​                2、org.apache.ibatis.logging.jdbc 代理所有功能JDBC 操作，实现了在debug模式下能够输出SQL</p>
<p>​        <strong>org.apache.ibatis.mapping：</strong></p>
<p>​                配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</p>
<p>​        <strong>org.apache.ibatis.parsing：</strong></p>
<p>​                1、解析工具包</p>
<p>​                2、GenericTokenParser：解析#{} ${} 这种占位符</p>
<p>​                3、XPathParser：XPath形式解析XML</p>
<p>​                4、PropertyParser: properties解析器</p>
<p>​        <strong>org.apache.ibatis.scripting：</strong></p>
<p>​                动态SQL语言实现，配置文件中<code>&lt;if&gt; &lt;where&gt; &lt;set&gt; &lt;foreach&gt; &lt;choose&gt; </code>功能就是在这个包实现，借助OGNL表达式,你也可以扩展自己的语言实现功能</p>
<p>​        <strong>org.apache.ibatis.session：</strong></p>
<p>​                1、主要实现SqlSession功能，非常核心包</p>
<p>​                2、官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口你可以 执行SQL命令（insertdeleteupdateselect），获取Mapper，管理实务</p>
<p>​        <strong>org.apache.ibatis.transaction：</strong></p>
<p>​                事务功能实现，包装了数据库连接，处理数据库连接生命周期包括：连接创建，预编译，提交回滚和关闭</p>
<p>​        <strong>org.apache.ibatis.type：</strong></p>
<p>​                类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</p>
<h2 id="四、MyBatis初始化阶段"><a href="#四、MyBatis初始化阶段" class="headerlink" title="四、MyBatis初始化阶段"></a>四、MyBatis初始化阶段</h2><p>​        前面几篇分析了MyBatis的日志、数据源和缓存模块的源码，本篇将分析MyBatis核心流程三大阶段的第一阶段：初始化阶段。Mybatis启动初始化的核心就是<strong>将所有xml配置文件信息加载到Configuration对象中，Configuration为单例，生命周期为应用级</strong>。</p>
<p>MyBatis初始化流程大致有三步：</p>
<ol>
<li>加载配置文件</li>
<li>解析配置文件、将配置文件中的信息装载到Configuration中。</li>
<li>根据Configuration创建SqlSessionFactory并返回。</li>
</ol>
<h3 id="4-1、加载配置文件"><a href="#4-1、加载配置文件" class="headerlink" title="4.1、加载配置文件"></a>4.1、<strong>加载配置文件</strong></h3><p>​        下面我们来看一段经典查询操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String resouce = <span class="hljs-string">&quot;config/mybatis/mybatis-config.xml&quot;</span>;<br>InputStream is = Resources.getResourceAsStream(resouce);<br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(is);<br>SqlSession session = sqlSessionFactory.openSession();<br>user = session.selectOne(<span class="hljs-string">&quot;com.luoxn28.dao.UserDao.getById&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>​        以上代码经过了MyBatis初始化、创建sqlSession、执行sql语句3个过程。首先由mybatis-config.xml配置文件创建SqlSessionFactory，然后由session工厂创建SqlSession对象，执行SQL语句。<strong>当然初始化的第一阶段：扫描配置文件所在包路径并加载</strong>。</p>
<h3 id="4-2、解析配置文件、将配置文件中的信息装载到Configuration中"><a href="#4-2、解析配置文件、将配置文件中的信息装载到Configuration中" class="headerlink" title="4.2、解析配置文件、将配置文件中的信息装载到Configuration中"></a>4.2、解析配置文件、将配置文件中的信息装载到Configuration中</h3><p>​        让我们来看一下梦开始的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(is);<br></code></pre></td></tr></table></figure>

<p>​        跟进**build()**方法，我们可以看到new了一个XMLConfigBuilder对象并调用了parse()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建XMLConfigBuilder对象解析XML配置</span><br>      XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);<br>      <span class="hljs-comment">// 将XML配置解析成Configuration对象，通过Configuration对象创建SqlSessionFactory</span><br>      <span class="hljs-keyword">return</span> build(parser.parse());<br>    &#125; <br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        跟进<strong>parse()<strong>方法，我们可以看到parser.evalNode(“/configuration”)，</strong>evalNode</strong>为xml结点解析器，可以解析指定参数结点的信息，而”**/configuration**”则是mybatis.xml的根节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    parseConfiguration(parser.evalNode(<span class="hljs-string">&quot;/configuration&quot;</span>));<br>    <span class="hljs-keyword">return</span> configuration;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        看到这，我们就不得不提初始化的三大金刚了，分别是XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder。</p>
<p>​        <strong>XMLConfigBuilder：</strong>主要负责解析mybatis-config.xml</p>
<p>​        <strong>XMLMapperBuilder：</strong>主要负责解析映射配置文件</p>
<p>​        <strong>XMLStatementBuilder：</strong>主要负责解析映射配置文件中的sql节点</p>
<p><strong>三大金刚图解：</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915222654319.png" alt="img" class="lazyload"></p>
<p>MyBatis中的xml文件是由三大金刚读取到Configuration类中，那么我们来看下Configuration类的数据结构：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915221915851.png" alt="img" class="lazyload"></p>
<p>​        Configuration类的源码实在太多，可以先了解下该类中有哪些成员变量对应存储着些什么数据。下面主要列举几个比较重要的成员变量：</p>
<p>​        <strong>MapperRegistry：</strong>mapper接口动态代理工厂类的注册中心。通过mapperProxy实现InvocationHandler接口，其中的MapperProxyFactory用于生成动态代理的实例对象；<br>​        <strong>ResultMap：</strong>用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；<br>​        <strong>MappedStatement：</strong>用于存储mapper.xml文件中select、insert、update和delete节点，同时还包含了这些节点的重要属性；<br>​        <strong>SqlSource：</strong>mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行；</p>
<p>​        接上面XMLConfigBuilder开始解析”/configuration”节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">parseConfiguration(parser.evalNode(<span class="hljs-string">&quot;/configuration&quot;</span>));<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));<br>      Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));<br>      loadCustomVfs(settings);<br>      loadCustomLogImpl(settings);<br>      typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));<br>      pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));<br>      objectFactoryElement(root.evalNode(<span class="hljs-string">&quot;objectFactory&quot;</span>));<br>      objectWrapperFactoryElement(root.evalNode(<span class="hljs-string">&quot;objectWrapperFactory&quot;</span>));<br>      reflectorFactoryElement(root.evalNode(<span class="hljs-string">&quot;reflectorFactory&quot;</span>));<br>      settingsElement(settings);<br>      <span class="hljs-comment">// read it after objectFactory and objectWrapperFactory issue #631</span><br>      environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));<br>      databaseIdProviderElement(root.evalNode(<span class="hljs-string">&quot;databaseIdProvider&quot;</span>));<br>      typeHandlerElement(root.evalNode(<span class="hljs-string">&quot;typeHandlers&quot;</span>));<br>      mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>​        点进去一看，就是对照着MyBatis官网主配置文件中的元素一个一个的进行解析</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915223612191.png" alt="img" class="lazyload"></p>
<p>​        在解析”mappers”节点的时候，就引入了XMLMapperBuilder开始对映射配置文件进行解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">XMLMapperBuilder mapperParser = <span class="hljs-keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());<br>mapperParser.parse();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurationElement</span><span class="hljs-params">(XNode context)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      String namespace = context.getStringAttribute(<span class="hljs-string">&quot;namespace&quot;</span>);<br>      ...<br>      builderAssistant.setCurrentNamespace(namespace);<br>      cacheRefElement(context.evalNode(<span class="hljs-string">&quot;cache-ref&quot;</span>));<br>      cacheElement(context.evalNode(<span class="hljs-string">&quot;cache&quot;</span>));<br>      parameterMapElement(context.evalNodes(<span class="hljs-string">&quot;/mapper/parameterMap&quot;</span>));<br>      resultMapElements(context.evalNodes(<span class="hljs-string">&quot;/mapper/resultMap&quot;</span>));<br>      sqlElement(context.evalNodes(<span class="hljs-string">&quot;/mapper/sql&quot;</span>));<br>      buildStatementFromContext(context.evalNodes(<span class="hljs-string">&quot;select|insert|update|delete&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="hljs-string">&quot;&#x27;. Cause: &quot;</span> + e, e);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>一一对应官网提供的节点信息进行解析</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915224121930.png" alt="img" class="lazyload"></p>
<p>​        下面大家猜也猜到了，在解析具体select、insert、update、delete的时候，引入了XMLStatementBuilder对节点数据进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildStatementFromContext</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (XNode context : list) &#123;<br>      <span class="hljs-keyword">final</span> XMLStatementBuilder statementParser = <span class="hljs-keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);<br>      <span class="hljs-keyword">try</span> &#123;<br>        statementParser.parseStatementNode();<br>      &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException e) &#123;<br>        configuration.addIncompleteStatement(statementParser);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>​        继三大金刚分别解析自己负责的xml文件之后，Configuration对象的数据被填充完毕，<strong>初始化的第二阶段：解析配置文件，将数据装载进Configuration对象完成。</strong></p>
<h3 id="4-3、根据Configuration创建SqlSessionFactory并返回"><a href="#4-3、根据Configuration创建SqlSessionFactory并返回" class="headerlink" title="4.3、根据Configuration创建SqlSessionFactory并返回"></a>4.3、根据Configuration创建SqlSessionFactory并返回</h3><p>​        第三阶段就是根据SqlSessionFactoryBuilder的内部方法直接返回一个DefaultSqlSessionFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionFactoryBuilder</span> </span>&#123;<br>   ...<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(Configuration config)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSessionFactory(config);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        此工厂内封装了Configuration对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSqlSessionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SqlSessionFactory</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultSqlSessionFactory</span><span class="hljs-params">(Configuration configuration)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.configuration = configuration;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        初始化阶段图解：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200915225840294.png" alt="img" class="lazyload"></p>
<p>​        至此，MyBatis初始化阶段完成。</p>
<h2 id="五、MyBatis代理阶段（binding模块分析）"><a href="#五、MyBatis代理阶段（binding模块分析）" class="headerlink" title="五、MyBatis代理阶段（binding模块分析）"></a>五、MyBatis代理阶段（binding模块分析）</h2><h3 id="5-1、MyBatis是如何做到面向Mapper接口编程？"><a href="#5-1、MyBatis是如何做到面向Mapper接口编程？" class="headerlink" title="5.1、MyBatis是如何做到面向Mapper接口编程？"></a>5.1、MyBatis是如何做到面向Mapper接口编程？</h3><p>​        只有接口，没有实现类，那么我们很容易会想到是通过解析xml配置文件+动态代理来实现的。我们先来说下MyBatis动态代理实际做了一些什么事情，我们正常编写的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSession sqlSession = sqlSessionFactory.openSession();<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>User uer = userMapper.selectByPrimarKey(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>​        MyBatis动态代理后执行的为下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSession sqlSession = sqlSessionFactory.openSession();<br>User uer = sqlSession.selectOne(<span class="hljs-string">&quot;com.en.iot.mapper.&quot;</span>+<span class="hljs-string">&quot;UserMapper.selectByPrimarKey&quot;</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>​        我们可以看到MyBatis动态代理主要做的是翻译的工作，主要翻译的内容有三点：</p>
<p>​        <strong>1、找到Session中对应的方法执行</strong></p>
<p>​        <strong>2、找到命名空间和方法名</strong></p>
<p>​        <strong>3、传递参数</strong></p>
<p>​        这三项工作主要是由MapperMethod这个类来实现的，解读这个类之前，我们有必要对binding模块进行一个整体的分析：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916211402947.png" alt="img" class="lazyload"></p>
<p>​        <strong>MapperRegistry：</strong>为MyBatis配置类Configuration类中一个重要的属性，它是mapper接口和对应的代理对象工厂的注册中心；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperRegistry</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration config;<br>   <span class="hljs-comment">//mapper接口和对应的代理对象工厂之间的关系</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        <strong>MapperProxyFactory：</strong>用于生成mapper接口动态代理的实例对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxyFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  ...<br>  <span class="hljs-comment">//key为mapper接口中的某个方法的method对象，value为对应的MapperMethod</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, MapperMethodInvoker&gt; methodCache = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        <strong>MapperProxy：</strong>实现InvocationHandler接口，它是增强mapper接口的实现；</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916214700706.png" alt="img" class="lazyload"></p>
<p>​        接着跟进**cachedInvoker(method).invoke(proxy, method, args, sqlSession)**方法</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916213826490.png" alt="img" class="lazyload"></p>
<p>​        我们可以看到在cachedInvoker中判断了一下是选用DefaultMethodInvoker还是PlainMethodInvoker</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916214239389.png" alt="img" class="lazyload"></p>
<p>​        那么我们大胆猜测一下，调用execute的这个MapperMethod类中一定保持着Mapper接口中对应方法以及对应的sql语句的信息。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916214959863.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916215029787.png" alt="img" class="lazyload"></p>
<p>​        通过观察这三个对象的构造方法我们可以看到，这三个对象全部是从Configuration类中获取信息，由此证实了我们的猜想，MapperMethod类中通过这三个对象建立mapper接口和配置文件sql语句的联系。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916215442588.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916215556263.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200916215523383.png" alt="img" class="lazyload"></p>
<h3 id="5-2、代理阶段流程梳理"><a href="#5-2、代理阶段流程梳理" class="headerlink" title="5.2、代理阶段流程梳理"></a>5.2、代理阶段流程梳理</h3><p>​        1、先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory）</p>
<p>​        2、利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy）</p>
<p>​        3、在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。</p>
<h2 id="六、MyBatis数据读写阶段"><a href="#六、MyBatis数据读写阶段" class="headerlink" title="六、MyBatis数据读写阶段"></a>六、MyBatis数据读写阶段</h2><h3 id="6-1、MyBatis是怎样的封装jdbc操作的"><a href="#6-1、MyBatis是怎样的封装jdbc操作的" class="headerlink" title="6.1、MyBatis是怎样的封装jdbc操作的"></a>6.1、MyBatis是怎样的封装jdbc操作的</h3><p>​        我们先来回忆一下jdbc代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.加载驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);     <br><span class="hljs-comment">//2.获取连接conn</span><br>Connection con=DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-comment">//3.创建查询接口</span><br>Statement sta= con.createStatement();<br><span class="hljs-comment">//4.执行SQL，返回结果集</span><br>ResultSet rs= sta.executeQuery(<span class="hljs-string">&quot;SELECT * FROM `user`&quot;</span>);<br><span class="hljs-comment">//5.对结果集数据进行操作</span><br>User user = <span class="hljs-keyword">new</span> User();<br>user.setUserName(String.valueOf(rs.getObject(<span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure>

<p>​        其中第一步加载驱动在MyBatis的初始化阶段就已经完成了，数据读写阶段就是处理sqlSession.executeQuery的阶段，对应JDBC第二步获取连接开始，到返回结果集封装对象结束。那MyBatis究竟是怎样封装JDBC操作的呢？我们先从sqlSession的默认实现DefaultSqlSession开始入手：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917203050838.png" alt="img" class="lazyload"></p>
<p>​        可以看到该类包含一个核心组件Executor（执行器），查询相关操作最终都借助该组件实现，那么我们来看一下Executor的关系类图：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917203424287.png" alt="img" class="lazyload"></p>
<p>​        <strong>BaseExecutor：</strong>基础抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，使用了模板模式，doUpdate,doQuery,doQueryCursor 等方法的具体实现交给不同的子类进行实现</p>
<p>​        <strong>CachingExecutor：</strong>直接实现Executor接口，使用装饰器模式提供二级缓存能力。先从二级缓存查，缓存没有命中再从数据库查，最后将结果添加到缓存中。如果在xml文件中配置了cache节点，则会创建CachingExecutor。</p>
<p>​        <strong>BatchExecutor：</strong>BaseExecutor具体子类实现，在doUpdate方法中，提供批量执行多条SQL语句的能力；</p>
<p>​        <strong>SimpleExecutor：</strong>BaseExecutor具体子类实现且为默认配置，在doQuery方法中使用PrepareStatement对象访问数据库， 每次访问都要创建新的 PrepareStatement对象；</p>
<p>​        <strong>ReuseExecutor：</strong>BaseExecutor具体子类实现，与SimpleExecutor不同的是，在doQuery方法中，使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象，而不是每次都创建新的PrepareStatement。</p>
<p>​        一下子丢出来这么多执行器有点蒙，没关系我们跟进一个查询流程走下来就清楚了。首先从DefaultSqlSession开始，我们调用的sqlSession.selectList方法：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917205236272.png" alt="img" class="lazyload"></p>
<p>​        可以看到只有BaseExecutor和CachingExecutor两个类重写了**query()**方法，而CachingExecutor类前面也说过，在Configuration类初始化的时候如果在XML中配置了<code>&lt;cache&gt;</code>节点的话，则会用装饰器模式对基础执行器进行增强，使其拥有二级缓存能力，并且我们也可以看到在初始化Executor时是通过设定的类型来决定初始化哪一个执行器子类。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917205454850.png" alt="img" class="lazyload"></p>
<p>​        好的我们继续跟进BaseExecutor的**query()**方法:</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917210415293.png" alt="img" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917210606702.png" alt="img" class="lazyload"></p>
<p>​        可以看到首先通过MappedStatement拿到对应的SQL信息BoundSql，再封装一级缓存值CacheKey，具体的查询为先从一级缓存拿，如果一级缓存为空，就从数据库加载数据，具体从数据库查询的方法源码：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917210831277.png" alt="img" class="lazyload"></p>
<p>​        我们跟进默认实现SimpleExecutor的**doQuery()**方法：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917211035123.png" alt="img" class="lazyload"></p>
<p>​        这段代码有两点值得我们注意，一个是**prepareStatement(handler, ms.getStatementLog())**这个方法，我们跟进去会发现：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917211124589.png" alt="img" class="lazyload"></p>
<p>​        <strong>终于找到了我们熟悉的JDBC代码，获取Connection，创建Statement查询接口</strong>；再一个是我们看到了四个新面孔，四种不同的处理器，一起来看下StatementHandler体系结构类图：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200919104808424.png" alt="img" class="lazyload"></p>
<p>​        <strong>BaseStatementHandler：</strong> 所有子类的抽象父类，定义了初始化statement的操作顺序，由具体子类实例化不同的statement</p>
<p>​        <strong>CallableStatementHandler：</strong>调用存储过程</p>
<p>​        <strong>PreparedStatementHandler：</strong>使用预编译PrepareStatement对象访问数据库</p>
<p>​        <strong>RoutingStatementHandler：</strong>Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类</p>
<p>​        <strong>SimpleStatementHandler：</strong>直接使用statement对象访问数据库，无须参数化</p>
<p>​        RoutingStatementHandler类源码，很清晰的静态代理</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917211725203.png" alt="img" class="lazyload"></p>
<p>​        接上文调用SimpleStatementHandler的query方法:</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200917211854628.png" alt="img" class="lazyload"></p>
<p>​        <strong>jdbc的execute()方法也找到了</strong>，最后借助DefaultResultSetHandler对数据库返回的结果集进行封装，返回用户指定的实体类型。handleResultSets()方法部分源码：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20200919110111271.png" alt="img" class="lazyload"></p>
<p>​        处理结果集的过程略复杂，这里只简单的梳理下MyBaits对于结果集封装的步骤：</p>
<ol>
<li>创建multipleResults集合，保存最终返回的结果。</li>
<li>取出第一个结果集</li>
<li>获取对应的resultMap</li>
<li>根据resultMap转化结果集，转换成目标对象后添加到multipleResults集合；</li>
<li>resultset.close()关闭结果集，将multipleResults集合返回</li>
</ol>
<h3 id="6-2、sqlSession查询流程图和Executor内部调用流程图"><a href="#6-2、sqlSession查询流程图和Executor内部调用流程图" class="headerlink" title="6.2、sqlSession查询流程图和Executor内部调用流程图"></a>6.2、sqlSession查询流程图和Executor内部调用流程图</h3><h4 id="6-2-1、sqlSession查询流程图："><a href="#6-2-1、sqlSession查询流程图：" class="headerlink" title="6.2.1、sqlSession查询流程图："></a>6.2.1、sqlSession查询流程图：</h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/2020091911381497.png" alt="img" class="lazyload"></p>
<h4 id="6-2-2、Executor内部调用流程图："><a href="#6-2-2、Executor内部调用流程图：" class="headerlink" title="6.2.2、Executor内部调用流程图："></a>6.2.2、Executor内部调用流程图：</h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/2020091911204922.png" alt="img" class="lazyload"></p>
<p>此MyBatis核心流程最后一个阶段：数据读写阶段完成。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/Mybaits/Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;Spring%E6%A1%86%E6%9E%B6&#x2F;Mybaits&#x2F;Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;Spring%E6%A1%86%E6%9E%B6&#x2F;Mybaits&#x2F;Mybaits%E7%9F%A5%E8%AF%86%E7%82%B9&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/">JAVA</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Mybaits/" rel="tag">Mybaits</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">一、概念、使用方法向的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81Mybaits%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、Mybaits介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Mybatis%E6%98%AF%E5%8D%8AORM%E6%A1%86%E6%9E%B6-%E4%B8%8EHibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">1.2.</span> <span class="toc-text">1.2、 为什么说Mybatis是半ORM框架?与Hibernate有哪些不同?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81-Mybaits%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">1.3、 Mybaits的优点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E3%80%81MyBatis%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 、MyBatis框架的缺点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5、 #{}和${}的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 、怎么解决实体类中的属性名和表中的字段名不一样的问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7%E3%80%81-%E5%A6%82%E4%BD%95%E5%9C%A8mapper%E4%B8%AD%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">1.7、 如何在mapper中传递多个参数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8%E3%80%81-MyBatis%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">1.8、 MyBatis的接口绑定有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9%E3%80%81-%E4%BD%BF%E7%94%A8MyBatis-Mapper%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">1.9、 使用MyBatis Mapper接口开发时有哪些要求？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">二、源码向的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81-%E8%A7%A3%E9%87%8A%E4%B8%8BMyBatis%E9%9D%A2%E5%90%91Mapper%E7%BC%96%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、 解释下MyBatis面向Mapper编程工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88MyBatis-Mapper%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E6%94%AF%E6%8C%81%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、 为什么MyBatis Mapper接口中的方法不支持重载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81-Mybatis%E5%8A%A8%E6%80%81sql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、 Mybatis动态sql执行原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、 Mybatis的一级、二级缓存实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E3%80%81Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 、Mybatis是如何进行分页的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E3%80%81-Mybatis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9BExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">2.6、 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E3%80%81-Mybatis%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8DExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7、 Mybatis中如何指定使用哪一种Executor执行器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E3%80%81-Mybatis%E7%9A%84Xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8CMybatis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">2.8、 Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9%E3%80%81-Mybatis%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">2.9、 Mybatis中用到了哪些设计模式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Mybaits%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">三、Mybaits源码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E3%80%81%E6%BA%90%E7%A0%81%E5%8C%85%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 、源码包功能模块图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E3%80%81%E5%90%84%E5%8C%85%E8%AF%A6%E7%BB%86%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 、各包详细功能解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">4.</span> <span class="toc-text">四、MyBatis初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、加载配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E5%B0%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A3%85%E8%BD%BD%E5%88%B0Configuration%E4%B8%AD"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、解析配置文件、将配置文件中的信息装载到Configuration中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E6%A0%B9%E6%8D%AEConfiguration%E5%88%9B%E5%BB%BASqlSessionFactory%E5%B9%B6%E8%BF%94%E5%9B%9E"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、根据Configuration创建SqlSessionFactory并返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81MyBatis%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88binding%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">五、MyBatis代理阶段（binding模块分析）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81MyBatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%9D%A2%E5%90%91Mapper%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、MyBatis是如何做到面向Mapper接口编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">5.2、代理阶段流程梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81MyBatis%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E9%98%B6%E6%AE%B5"><span class="toc-number">6.</span> <span class="toc-text">六、MyBatis数据读写阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81MyBatis%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%B0%81%E8%A3%85jdbc%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、MyBatis是怎样的封装jdbc操作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81sqlSession%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8CExecutor%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、sqlSession查询流程图和Executor内部调用流程图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1%E3%80%81sqlSession%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1、sqlSession查询流程图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2%E3%80%81Executor%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2、Executor内部调用流程图：</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1648456240154"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
