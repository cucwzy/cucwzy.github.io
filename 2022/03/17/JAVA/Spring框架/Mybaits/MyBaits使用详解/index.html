
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || Mybaits使用详解</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Mybaits使用详解 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                JAVA
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Mybaits" style=color:#1bccbc>
                    Mybaits
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="MyBaits使用详解"><a href="#MyBaits使用详解" class="headerlink" title="MyBaits使用详解"></a>MyBaits使用详解</h1><blockquote>
<p> 环境说明：</p>
</blockquote>
<ul>
<li>jdk 8 +</li>
<li>MySQL 5.7.19</li>
<li>maven-3.6.1</li>
<li>IDEA</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1、Mybaits简介"><a href="#1-1、Mybaits简介" class="headerlink" title="1.1、Mybaits简介"></a>1.1、Mybaits简介</h3><ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</li>
<li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到<strong>Github</strong> .</li>
<li>Mybatis官方文档 : <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li>
<li>GitHub : <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li>
</ul>
<h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p>
<ul>
<li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
<li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li>
</ul>
<p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p>
<ul>
<li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li>
<li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p><strong>什么是持久层？</strong></p>
<ul>
<li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li>
<li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li>
<li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li>
<li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li>
</ul>
<h3 id="1-4、Mybaits功能"><a href="#1-4、Mybaits功能" class="headerlink" title="1.4、Mybaits功能"></a>1.4、Mybaits功能</h3><ul>
<li><p>Mybatis就是帮助程序员将数据存入数据库中 , 和从数据库中取数据 .</p>
</li>
<li><p>传统的jdbc操作 , 有很多重复代码块 。比如：数据取出时的封装 , 数据库的建立连接等等，通过框架可以减少重复代码，提高开发效率 。</p>
</li>
<li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p>
</li>
<li><p>MyBatis的优点</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
</ul>
<ul>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<h3 id="1-5、Mybaits程序"><a href="#1-5、Mybaits程序" class="headerlink" title="1.5、Mybaits程序"></a>1.5、Mybaits程序</h3><h4 id="1-5-1、数据库搭建"><a href="#1-5-1、数据库搭建" class="headerlink" title="1.5.1、数据库搭建"></a>1.5.1、数据库搭建</h4><pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
`id` int(20) NOT NULL,
`name` varchar(30) DEFAULT NULL,
`pwd` varchar(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) 
values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);
</code></pre>
<h4 id="1-5-2、导入依赖"><a href="#1-5-2、导入依赖" class="headerlink" title="1.5.2、导入依赖"></a>1.5.2、导入依赖</h4><pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1-5-3、核心配置文件"><a href="#1-5-3、核心配置文件" class="headerlink" title="1.5.3、核心配置文件"></a>1.5.3、核心配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
   &lt;!-- 配置环境 --&gt;
   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
               &lt;property name=&quot;url&quot; 
                         value=&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;amp;
                                useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
    
   &lt;!-- 加载映射地址 --&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="1-5-4、Mybaits工具类"><a href="#1-5-4、Mybaits工具类" class="headerlink" title="1.5.4、Mybaits工具类"></a>1.5.4、Mybaits工具类</h4><pre><code class="java">import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils &#123;

    /**
     * 禁止外界通过new方法创建
         private MybatisUtil()&#123;&#125;
     */
    
   private static SqlSessionFactory sqlSessionFactory;

   static &#123;
       try &#123;
           String resource = &quot;mybatis-config.xml&quot;;
           // 加载核心配置文件
           InputStream inputStream = Resources.getResourceAsStream(resource);
           // 创建sqlsession工厂 --&gt;相当于connection
           sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
      &#125; catch (IOException e) &#123;
           e.printStackTrace();
      &#125;
  &#125;

   //获取SqlSession连接 --&gt;相当于执行sql语句对象
   public static SqlSession getSession()&#123;
       
       /*       
           //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象为空
            if(sqlSession == null)&#123;
                //在SqlSessionFactory非空的情况下，获取SqlSession对象
                sqlSession = sqlSessionFactory.openSession();
                //将SqlSession对象与当前线程绑定在一起
                threadLocal.set(sqlSession);
            &#125;       
       */
       
       return sqlSessionFactory.openSession();
  &#125;
    
   /**
     * 
          关闭SqlSession与当前线程分开
           public static void closeSqlSession()&#123;
            //从当前线程中获取SqlSession对象
            SqlSession sqlSession = threadLocal.get();
            //如果SqlSession对象非空
            if(sqlSession != null)&#123;
                //关闭SqlSession对象
                sqlSession.close();
                //分开当前线程与SqlSession对象的关系，目的是让GC尽早回收
                threadLocal.remove();
            &#125;
        &#125;
     
     */
  

&#125;
</code></pre>
<p><strong>MybatisUtil工具类的作用</strong>:</p>
<ul>
<li>在静态初始化块中加载mybatis配置文件和StudentMapper.xml文件一次</li>
<li>使用ThreadLocal对象让当前线程与SqlSession对象绑定在一起</li>
<li>获取当前线程中的SqlSession对象，如果没有的话，从SqlSessionFactory对象中获取SqlSession对象</li>
<li>获取当前线程中的SqlSession对象，再将其关闭，释放其占用的资源</li>
</ul>
<h4 id="1-5-5、实体类"><a href="#1-5-5、实体类" class="headerlink" title="1.5.5、实体类"></a>1.5.5、实体类</h4><pre><code class="java">@Data
public class User &#123;
   
   private int id;  //id
   private String name;   //姓名
   private String pwd;   //密码
   
&#125;
</code></pre>
<h4 id="1-5-6、Mapper接口类"><a href="#1-5-6、Mapper接口类" class="headerlink" title="1.5.6、Mapper接口类"></a>1.5.6、Mapper接口类</h4><pre><code class="java">import com.kuang.pojo.User;
import java.util.List;

public interface UserMapper &#123;
   List&lt;User&gt; selectUser();
&#125;
</code></pre>
<h4 id="1-5-7、Mapper-xml配置文件"><a href="#1-5-7、Mapper-xml配置文件" class="headerlink" title="1.5.7、Mapper.xml配置文件"></a>1.5.7、Mapper.xml配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;
 &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
  select * from user
 &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="1-5-8、测试类"><a href="#1-5-8、测试类" class="headerlink" title="1.5.8、测试类"></a>1.5.8、测试类</h4><pre><code class="java">public class MyTest &#123;
   @Test
   public void selectUser() &#123;
       SqlSession session = MybatisUtils.getSession();
       //方法一:
       List&lt;User&gt; users1 = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);
       
       for (User user: users1)&#123;
           System.out.println(user);
      &#125;    
       
       
       //方法二:
       UserMapper mapper = session.getMapper(UserMapper.class);
       List&lt;User&gt; users2 = mapper.selectUser();
   
       for (User user: users2)&#123;
           System.out.println(user);
      &#125;
       session.close();
  &#125;
&#125;
</code></pre>
<h3 id="1-6、问题说明"><a href="#1-6、问题说明" class="headerlink" title="1.6、问题说明"></a>1.6、问题说明</h3><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p>
<pre><code class="xml">&lt;resources&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/java&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
   &lt;resource&gt;
       &lt;directory&gt;src/main/resources&lt;/directory&gt;
       &lt;includes&gt;
           &lt;include&gt;**/*.properties&lt;/include&gt;
           &lt;include&gt;**/*.xml&lt;/include&gt;
       &lt;/includes&gt;
       &lt;filtering&gt;false&lt;/filtering&gt;
   &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="二、CUDR操作及配置解析"><a href="#二、CUDR操作及配置解析" class="headerlink" title="二、CUDR操作及配置解析"></a>二、CUDR操作及配置解析</h2><h3 id="2-1、namespace"><a href="#2-1、namespace" class="headerlink" title="2.1、namespace"></a>2.1、namespace</h3><ol>
<li>将上面案例中的UserMapper接口改名为 UserDao；</li>
<li>将UserMapper.xml中的namespace改为为UserDao的路径 ；</li>
<li>再次测试</li>
</ol>
<p><strong>结论：</strong></p>
<p>​        <strong>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名，必须一致！</strong></p>
<h3 id="2-2、CUDR操作"><a href="#2-2、CUDR操作" class="headerlink" title="2.2、CUDR操作"></a>2.2、CUDR操作</h3><h4 id="2-2-1、select操作"><a href="#2-2-1、select操作" class="headerlink" title="2.2.1、select操作"></a>2.2.1、select操作</h4><ul>
<li><p>select标签是mybatis中最常用的标签之一</p>
</li>
<li><p>select语句有很多属性可以详细配置每一条SQL语句</p>
</li>
<li><ul>
<li>SQL语句返回值类型。【完整的类名或者别名】</li>
<li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li>
<li>命名空间中唯一的标识符</li>
<li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li>
<li>id</li>
<li>parameterType</li>
<li>resultType</li>
</ul>
</li>
</ul>
<p><strong>需求一：根据id查询用户</strong></p>
<p>1、在UserMapper中添加对应方法</p>
<pre><code class="java">public interface UserMapper &#123;
   //查询全部用户
   List&lt;User&gt; selectUser();
   //根据id查询用户
   User selectUserById(int id);
&#125;
</code></pre>
<p>2、在UserMapper.xml中添加Select语句</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>select参数：</p>
<p>1). id：</p>
<p>2). <strong>parametweType：</strong>传递的参数</p>
<p>3). <strong>resultType：</strong>是SQL映射文件中定义返回值类型，返回值有基本类型，对象类型，List类型，Map类型等。</p>
<ul>
<li>基本类型：resultType=基本类型</li>
<li>List类型：resultType=<strong>List中元素的类型</strong></li>
<li>Map类型  <ul>
<li>单条记录：resultType=map</li>
<li>多条记录：resultType =Map中value的类型</li>
</ul>
</li>
</ul>
<p><strong>注：</strong>为什么是使用map而不是Map呢？</p>
<p>刚刚配置中的**resultType=”map”**，为什么是map，不是Map呢？</p>
<p>如果想写Map，需要写成全限定类名，即：<strong>resultType = “java.util.Map”</strong> map是java.util.Map的一个简写，还有其他的简写可以参考下方表格：</p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M1.png"></p>
<p><img src="D:\编程学习资料\java\学习笔记\Mybaits\kuangStudy\M2.png"></p>
<p>3、测试类中测试</p>
<pre><code class="java">@Test
public void tsetSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   System.out.println(user);
   
   session.close();
&#125;
</code></pre>
<p><strong>需求二：根据密码和名字查询用户</strong></p>
<p><strong>思路一：直接在方法中传递参数</strong></p>
<p>1、在接口方法的参数前加 @Param属性</p>
<p>2、Sql语句编写的时候，直接取**@Param中设置的值**即可，不需要单独设置参数类型</p>
<pre><code class="java">//通过密码和名字查询用户
User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);
</code></pre>
<p>3、Mapper.xml配置文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p><strong>思路二：使用Map</strong></p>
<p>1、在接口方法中，参数直接传递Map；</p>
<pre><code class="java">User selectUserByNP2(Map&lt;String,Object&gt; map);
</code></pre>
<p>2、编写sql语句的时候，需要传递参数类型，参数类型为map</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;
&lt;/select&gt;
</code></pre>
<p>3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put(&quot;username&quot;,&quot;小明&quot;);
map.put(&quot;pwd&quot;,&quot;123456&quot;);
User user = mapper.selectUserByNP2(map);
</code></pre>
<p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可.</p>
<h4 id="2-2-2、insert操作"><a href="#2-2-2、insert操作" class="headerlink" title="2.2.2、insert操作"></a>2.2.2、insert操作</h4><p><strong>需求：给数据库增加一个用户</strong></p>
<p>1、在UserMapper接口中添加对应的方法</p>
<pre><code class="java">//添加一个用户
int addUser(User user);
</code></pre>
<p>2、在UserMapper.xml中添加insert语句</p>
<pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
&lt;/insert&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);
   int i = mapper.addUser(user);
   System.out.println(i);
   
   // 提交事务，将事务提交到数据库
   session.commit(); 
   session.close();
&#125;
</code></pre>
<p>​    <strong>注：</strong>增、删、改操作需要提交事务！</p>
<h4 id="2-2-3、update操作"><a href="#2-2-3、update操作" class="headerlink" title="2.2.3、update操作"></a>2.2.3、update操作</h4><p><strong>需求：修改用户的信息</strong></p>
<p>1、同理，编写接口方法</p>
<pre><code class="java">//修改一个用户
int updateUser(User user);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   User user = mapper.selectUserById(1);
   user.setPwd(&quot;asdfgh&quot;);
   int i = mapper.updateUser(user);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-4、delete操作"><a href="#2-2-4、delete操作" class="headerlink" title="2.2.4、delete操作"></a>2.2.4、delete操作</h4><p><strong>需求：根据id删除一个用户</strong></p>
<p>1、编写接口方法</p>
<pre><code class="java">//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>2、编写对应的配置文件SQL</p>
<pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from user where id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   
   int i = mapper.deleteUser(5);
   System.out.println(i);
   
   // 提交事务
   session.commit(); 
   session.close();
&#125;
</code></pre>
<h4 id="2-2-5、模糊查询like语句"><a href="#2-2-5、模糊查询like语句" class="headerlink" title="2.2.5、模糊查询like语句"></a>2.2.5、模糊查询like语句</h4><p>方法一：在Java代码中添加sql通配符。</p>
<pre><code class="java">string wildcardname = “%smi%”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like #&#123;value&#125;
&lt;/select&gt;
</code></pre>
<p>方法二：在sql语句中拼接通配符，会引起sql注入</p>
<pre><code class="java">string wildcardname = “smi”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);
</code></pre>
<pre><code class="xml">&lt;select id=”selectlike”&gt;
    select * 
    from foo 
    where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
&lt;/select&gt;
</code></pre>
<h4 id="2-4-6、小结"><a href="#2-4-6、小结" class="headerlink" title="2.4.6、小结"></a>2.4.6、小结</h4><ul>
<li>所有的增删改操作都需要提交事务！</li>
<li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li>
<li>有时候根据业务的需求，可以考虑使用map传递参数！</li>
<li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li>
</ul>
<h3 id="2-3、配置解析"><a href="#2-3、配置解析" class="headerlink" title="2.3、配置解析"></a>2.3、配置解析</h3><h4 id="2-3-1、核心配置文件"><a href="#2-3-1、核心配置文件" class="headerlink" title="2.3.1、核心配置文件"></a>2.3.1、核心配置文件</h4><ul>
<li>mybatis-config.xml 系统核心配置文件</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
<li>能配置的内容如下：</li>
</ul>
<pre><code class="xml">configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;
</code></pre>
<p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p>
<h4 id="2-3-2、environments元素"><a href="#2-3-2、environments元素" class="headerlink" title="2.3.2、environments元素"></a>2.3.2、environments元素</h4><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;

        &lt;!-- 事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<ul>
<li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p>
</li>
<li><p>子元素节点：<strong>environment</strong></p>
<ul>
<li>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</li>
</ul>
<ul>
<li><p>数据源是必须配置的。</p>
</li>
<li><p>有三种内建的数据源类型</p>
</li>
</ul>
</li>
</ul>
<pre><code class="xml">type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）
</code></pre>
<ul>
<li><p><strong>unpooled：</strong>这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
</li>
<li><p><strong>JNDI：</strong>这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
<li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p>
</li>
<li><p>详情：点击查看官方文档</p>
</li>
<li><p>这两种事务管理器类型都不需要设置任何属性。</p>
</li>
<li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p>
</li>
<li><p>子元素节点：transactionManager - [ 事务管理器 ]</p>
</li>
</ul>
<pre><code class="xml">&lt;!-- 语法 --&gt;
&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;
</code></pre>
<ul>
<li>子元素节点：<strong>数据源（dataSource）</strong></li>
</ul>
<h4 id="2-3-3、mappers元素"><a href="#2-3-3、mappers元素" class="headerlink" title="2.3.3、mappers元素"></a>2.3.3、mappers元素</h4><p><strong>mappers</strong></p>
<ul>
<li><strong>映射器 :</strong> 定义映射SQL语句文件</li>
<li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用<strong>相对于类路径的资源引用</strong>， 或<strong>完全限定资源定位符</strong>（包括 <code>file:///</code> 的 URL），或类名和包名等。</li>
<li>映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li>
</ul>
<p><strong>引入资源方式</strong></p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
    使用映射器接口实现类的完全限定类名
    需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;

&lt;!--
将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下
--&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Mapper文件</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
   
&lt;/mapper&gt;
</code></pre>
<ul>
<li><p>namespace中文意思：命名空间，作用如下：</p>
<ul>
<li>namespace的命名必须跟某个接口同名</li>
</ul>
<ul>
<li>接口中的方法与映射文件中sql语句id应该一一对应<ul>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p>
<h4 id="2-3-4、Properties优化"><a href="#2-3-4、Properties优化" class="headerlink" title="2.3.4、Properties优化"></a>2.3.4、Properties优化</h4><p>​        数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<p>​        第一步 ; 在资源目录下新建一个<strong>db.properties</strong></p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
username=root
password=123456
</code></pre>
<p>​        第二步 : 将文件导入properties 配置文件</p>
<pre><code class="xml">&lt;configuration&gt;
   &lt;!--导入properties文件--&gt;
   &lt;properties resource=&quot;db.properties&quot;/&gt;

   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
               &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;
   &lt;mappers&gt;
       &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>更多操作，可以查看官方文档！【演示带领学习】</p>
<ul>
<li>配置文件优先级问题</li>
<li>新特性：使用占位符</li>
</ul>
<h4 id="2-4-5、typeAliases优化"><a href="#2-4-5、typeAliases优化" class="headerlink" title="2.4.5、typeAliases优化"></a>2.4.5、typeAliases优化</h4><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<pre><code class="xml">&lt;!--配置别名,注意顺序--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p>
<pre><code class="xml">&lt;typeAliases&gt;
   &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p>
<p>若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class User &#123;
  ...
&#125;
</code></pre>
<p>去官网查看一下Mybatis默认的一些类型别名！</p>
<h4 id="2-4-6、其他浏览设置"><a href="#2-4-6、其他浏览设置" class="headerlink" title="2.4.6、其他浏览设置"></a>2.4.6、其他浏览设置</h4><ul>
<li><p>设置（settings）相关 =&gt; 查看帮助文档</p>
<ul>
<li>懒加载</li>
</ul>
<ul>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li><p>一个配置完整的 settings 元素的示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;!--该配置影响的所有映射器中配置的缓存的全局开关--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态--&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--是否允许单一语句返回多结果集（需要兼容驱动）。--&gt;
    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。--&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    
    &lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。--&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。--&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
   
    &lt;!----&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    
    &lt;!--配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。--&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
   
    &lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。--&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
   
    &lt;!--Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.--&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    
    &lt;!--允许在嵌套语句中使用分页（RowBounds）。--&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
   
    &lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。--&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    
    &lt;!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。--&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    
    &lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。--&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    
    &lt;!--指定哪个对象的方法触发一次延迟加载。--&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;

    &lt;!--指定动态 SQL 生成的默认语言。--&gt;
    &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver&quot;/&gt;

    &lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。--&gt;
    &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;

    &lt;!--定 MyBatis 增加到日志名称的前缀。--&gt;
    &lt;setting name=&quot;logPrefix&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 MyBatis 所用日志的具体实现，未指定时将自动查找。--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;Not set&quot;/&gt;

    &lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。--&gt;
    &lt;setting name=&quot;proxyFactory&quot; value=&quot;JAVASSIST&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
</ul>
<p><strong>类型处理器</strong></p>
<ul>
<li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li>
<li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li>
</ul>
<p><strong>对象工厂</strong></p>
<ul>
<li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li>
<li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li>
<li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li>
</ul>
<h4 id="2-4-7、生命周期和作用域"><a href="#2-4-7、生命周期和作用域" class="headerlink" title="2.4.7、生命周期和作用域"></a>2.4.7、生命周期和作用域</h4><p>​        理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>作用域理解</strong></p>
<ul>
<li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li>
<li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li>
<li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li>
<li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li>
<li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li>
<li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="三、ResultMap以及分页"><a href="#三、ResultMap以及分页" class="headerlink" title="三、ResultMap以及分页"></a>三、ResultMap以及分页</h2><h3 id="3-1、查询为null"><a href="#3-1、查询为null" class="headerlink" title="3.1、查询为null"></a>3.1、查询为null</h3><h4 id="3-1-1、属性名和字段名不一致问题"><a href="#3-1-1、属性名和字段名不一致问题" class="headerlink" title="3.1.1、属性名和字段名不一致问题"></a>3.1.1、属性名和字段名不一致问题</h4><p>环境：新建一个项目，将之前的项目拷贝过来</p>
<p>1、查看之前的数据库的字段名</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KdXPq6whFkfHe43CtgZMJrr62lCnbfxl25aQ4ZDwlU4JiaMZHs3nqAoNxFsJYZRC4Cm11uSH0USNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、Java中的实体类设计</p>
<pre><code class="java">@Data
public class User &#123;

   private int id;  //id
   private String name;   //姓名
   private String password;   //密码和数据库不一样！
   
&#125;
</code></pre>
<p>3、接口</p>
<pre><code class="java">//根据id查询用户
User selectUserById(int id);
</code></pre>
<p>4、mapper映射文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   System.out.println(user);
   session.close();
&#125;
</code></pre>
<p><strong>结果:</strong></p>
<ul>
<li>User{id=1, name=’狂神’, password=’null’}</li>
<li>查询出来发现 password 为空 . 说明出现了问题！</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li><p>select * from user where id = #{id} 可以看做</p>
<p>select  id,name,pwd  from user where id = #{id}</p>
</li>
<li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p>
</li>
</ul>
<h4 id="3-1-2、解决方案"><a href="#3-1-2、解决方案" class="headerlink" title="3.1.2、解决方案"></a>3.1.2、解决方案</h4><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;
    select id , name , pwd as password 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>方案二：使用结果集映射——-&gt;ResultMap</strong> 【推荐】</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
    select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;

&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!-- id为主键 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="3-2、ResultMap"><a href="#3-2、ResultMap" class="headerlink" title="3.2、ResultMap"></a>3.2、ResultMap</h3><p><strong>自动映射</strong></p>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li>
<li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li>
<li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li>
</ul>
<p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;
    select id , name , pwd
    from user
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p>
<p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p>
<p><strong>手动映射</strong></p>
<p>1、返回值类型为resultMap</p>
<pre><code class="xml">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;
  select id , name , pwd 
    from user 
    where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>2、编写resultMap，实现手动映射！</p>
<pre><code class="xml">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
   &lt;!-- id为主键 --&gt;
   &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;
   &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
   &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<p>​        数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p>
<h3 id="3-3、分页"><a href="#3-3、分页" class="headerlink" title="3.3、分页"></a>3.3、分页</h3><h4 id="3-3-1、日志工厂"><a href="#3-3-1、日志工厂" class="headerlink" title="3.3.1、日志工厂"></a>3.3.1、日志工厂</h4><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p>
<p>​        如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p>
<p>​        对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p>
<p>​        Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>​        具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p>
<p><strong>标准日志实现</strong></p>
<p>​        指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p>
<pre><code class="xml">&lt;settings&gt;
       &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>​        测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p>
<h4 id="3-3-2、Log4j简介："><a href="#3-3-2、Log4j简介：" class="headerlink" title="3.3.2、Log4j简介："></a>3.3.2、Log4j<strong>简介：</strong></h4><ul>
<li>Log4j是Apache的一个开源项目</li>
<li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p><strong>使用步骤：</strong></p>
<p>1、导入log4j的包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置文件编写</p>
<pre><code class="properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
<p>3、setting设置日志实现</p>
<pre><code class="xml">&lt;settings&gt;
   &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>4、在程序中使用Log4j进行输出！</p>
<pre><code class="java">//注意导包：org.apache.log4j.Logger
static Logger logger = Logger.getLogger(MyTest.class);

@Test
public void selectUser() &#123;
   logger.info(&quot;info：进入selectUser方法&quot;);
   logger.debug(&quot;debug：进入selectUser方法&quot;);
   logger.error(&quot;error: 进入selectUser方法&quot;);
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   List&lt;User&gt; users = mapper.selectUser();
   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<p>5、测试，看控制台输出！</p>
<ul>
<li>使用Log4j 输出日志</li>
<li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</li>
</ul>
<h4 id="3-3-3、limit实现分页"><a href="#3-3-3、limit实现分页" class="headerlink" title="3.3.3、limit实现分页"></a>3.3.3、limit实现分页</h4><p><strong>思考：为什么需要分页？</strong></p>
<p>​        在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p>
<p><strong>使用Limit实现分页</strong></p>
<pre><code class="sql">#语法
SELECT * FROM table LIMIT stratIndex，pageSize

SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  

#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   
SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  

#如果只给定一个参数，它表示返回最大的记录行数目：   
SELECT * FROM table LIMIT 5; //检索前 5 个记录行  

#换句话说，LIMIT n 等价于 LIMIT 0,n。 
</code></pre>
<p><strong>步骤：</strong></p>
<p>1、修改Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;
    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>
<p>2、Mapper接口，参数为map</p>
<pre><code class="java">//选择全部用户实现分页
List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);
</code></pre>
<p>3、在测试类中传入参数测试</p>
<ul>
<li>推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li>
</ul>
<pre><code class="java">//分页查询 , 两个参数startIndex , pageSize
@Test
public void testSelectUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   int currentPage = 1;  //第几页
   int pageSize = 2;  //每页显示几个
   Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();
   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);
   map.put(&quot;pageSize&quot;,pageSize);

   List&lt;User&gt; users = mapper.selectUser(map);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<blockquote>
<p>RowBounds分页</p>
</blockquote>
<p>​        我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p>
<p><strong>步骤：</strong></p>
<p>1、mapper接口</p>
<pre><code class="java">//选择全部用户RowBounds实现分页
List&lt;User&gt; getUserByRowBounds();
</code></pre>
<p>2、mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<p>在这里，我们需要使用RowBounds类</p>
<pre><code class="java">@Test
public void testUserByRowBounds() &#123;
   SqlSession session = MybatisUtils.getSession();

   int currentPage = 2;  //第几页
   int pageSize = 2;  //每页显示几个
   RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);

   //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]
   List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds);

   for (User user: users)&#123;
       System.out.println(user);
  &#125;
   session.close();
&#125;
</code></pre>
<h4 id="3-3-4、PageHelper"><a href="#3-3-4、PageHelper" class="headerlink" title="3.3.4、PageHelper"></a>3.3.4、PageHelper</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<h2 id="四、注解开发"><a href="#四、注解开发" class="headerlink" title="四、注解开发"></a>四、注解开发</h2><h3 id="4-1、面向接口编程"><a href="#4-1、面向接口编程" class="headerlink" title="4.1、面向接口编程"></a>4.1、面向接口编程</h3><ul>
<li><strong>根本原因 :  解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<h4 id="4-1-1、关于接口的理解"><a href="#4-1-1、关于接口的理解" class="headerlink" title="4.1.1、关于接口的理解"></a>4.1.1、关于接口的理解</h4><ul>
<li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p>
</li>
<li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p>
</li>
<li><p>接口应有两类：</p>
<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； </li>
</ul>
<ul>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li>
</ul>
</li>
<li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p>
</li>
</ul>
<h4 id="4-1-2、三个面向区别"><a href="#4-1-2、三个面向区别" class="headerlink" title="4.1.2、三个面向区别"></a>4.1.2、三个面向区别</h4><ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</li>
</ul>
<h3 id="4-2、利用注解开发"><a href="#4-2、利用注解开发" class="headerlink" title="4.2、利用注解开发"></a>4.2、利用注解开发</h3><ul>
<li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p>
</li>
<li><p>sql 类型主要分成 :</p>
<ul>
<li>@select () </li>
</ul>
<ul>
<li>@update ()</li>
<li>@Insert ()</li>
<li>@delete ()</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>利用注解开发就不需要mapper.xml映射文件了 .</p>
<p>1、我们在我们的接口中添加注解</p>
<pre><code class="java">//查询全部用户
@Select(&quot;select id,name,pwd password from user&quot;)
public List&lt;User&gt; getAllUser();
</code></pre>
<p>2、在mybatis的核心配置文件中注入</p>
<pre><code class="xml">&lt;!--使用class绑定接口--&gt;
&lt;mappers&gt;
   &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>3、我们去进行测试</p>
<pre><code class="java">@Test
public void testGetAllUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   //本质上利用了jvm的动态代理机制
   UserMapper mapper = session.getMapper(UserMapper.class);

   List&lt;User&gt; users = mapper.getAllUser();
   for (User user : users)&#123;
       System.out.println(user);
  &#125;

   session.close();
&#125;
</code></pre>
<p>4、利用Debug查看本质</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNnMiahVkdvictXZkDDWHQCwob9rMlKtxnhiaQee5Kxa6K0BCbHH2ibRERibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>5、本质上利用了jvm的动态代理机制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNeukjWMleICg2Jsm8hTI63hvVLiarGmD7zT1CmgXlUXSUbmdhialeIjpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>6、Mybatis详细的执行流程</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="4-3、注解增删改"><a href="#4-3、注解增删改" class="headerlink" title="4.3、注解增删改"></a>4.3、注解增删改</h3><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。</p>
<pre><code class="java">//获取SqlSession连接
public static SqlSession getSession()&#123;
    return getSession(true); //事务自动提交
&#125;

public static SqlSession getSession(boolean flag)&#123;
    return sqlSessionFactory.openSession(flag);
&#125;
</code></pre>
<p>【注意】确保实体类和数据库字段对应</p>
<p><strong>查询：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id查询用户
@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
User selectUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testSelectUserById() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.selectUserById(1);
   System.out.println(user);

   session.close();
&#125;
</code></pre>
<p><strong>新增：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//添加一个用户
@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)
int addUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testAddUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;);
   mapper.addUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>修改：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//修改一个用户
@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)
int updateUser(User user);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testUpdateUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);
   mapper.updateUser(user);

   session.close();
&#125;
</code></pre>
<p><strong>删除：</strong></p>
<p>1、编写接口方法注解</p>
<pre><code class="java">//根据id删除用
@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
int deleteUser(@Param(&quot;id&quot;)int id);
</code></pre>
<p>2、测试</p>
<pre><code class="java">@Test
public void testDeleteUser() &#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   mapper.deleteUser(6);
   
   session.close();
&#125;
</code></pre>
<p>【注意点：增删改一定记得对事务的处理】</p>
<h3 id="4-4、关于-Param"><a href="#4-4、关于-Param" class="headerlink" title="4.4、关于@Param"></a>4.4、关于@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p>
<ul>
<li>在方法只接受一个参数的情况下，可以不使用@Param。</li>
<li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li>
<li>如果参数是 JavaBean ， 则不能使用@Param。</li>
<li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li>
</ul>
<h3 id="4-5、-与-的区别"><a href="#4-5、-与-的区别" class="headerlink" title="4.5、#与$的区别"></a>4.5、#与$的区别</h3><ul>
<li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (#&#123;name&#125;);
INSERT INTO user (name) VALUES (?);
</code></pre>
</li>
<li><p>${} 的作用是直接进行字符串替换</p>
<pre><code class="sql">INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);
INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);
</code></pre>
</li>
</ul>
<h2 id="五、一对多处理与多对一处理"><a href="#五、一对多处理与多对一处理" class="headerlink" title="五、一对多处理与多对一处理"></a>五、一对多处理与多对一处理</h2><h3 id="5-1、多对一处理"><a href="#5-1、多对一处理" class="headerlink" title="5.1、多对一处理"></a>5.1、多对一处理</h3><h4 id="5-1-1、数据库设计"><a href="#5-1-1、数据库设计" class="headerlink" title="5.1.1、数据库设计"></a>5.1.1、数据库设计</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LPbib5To6slfFhMArq5QvCjofjccx37cuQgKsWEHibax0bDiaicU6ojNfEzWrj3TibFsX3MJju4sAp5Pg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<pre><code class="sql">CREATE TABLE `teacher` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);

CREATE TABLE `student` (
`id` INT(10) NOT NULL,
`name` VARCHAR(30) DEFAULT NULL,
`tid` INT(10) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `fktid` (`tid`),
CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;);
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
</code></pre>
<h4 id="5-1-2、搭建测试环境"><a href="#5-1-2、搭建测试环境" class="headerlink" title="5.1.2、搭建测试环境"></a>5.1.2、搭建测试环境</h4><p>1、IDEA安装Lombok插件</p>
<p>2、引入Maven依赖</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.16.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、在代码中增加注解</p>
<pre><code class="java">@Data //GET,SET,ToString，有参，无参构造
public class Teacher &#123;
   private int id;
   private String name;
&#125;
@Data
public class Student &#123;
   private int id;
   private String name;
   //多个学生可以是同一个老师，即多对一
   private Teacher teacher;
&#125;
</code></pre>
<p>4、编写实体类对应的Mapper接口 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="java">public interface StudentMapper &#123;
&#125;
public interface TeacherMapper &#123;
&#125;
</code></pre>
<p>5、编写Mapper接口对应的 mapper.xml配置文件 【两个】</p>
<ul>
<li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

&lt;/mapper&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="5-1-3、按查询嵌套处理"><a href="#5-1-3、按查询嵌套处理" class="headerlink" title="5.1.3、按查询嵌套处理"></a>5.1.3、按查询嵌套处理</h4><p>1、给StudentMapper接口增加方法</p>
<pre><code class="java">//获取所有学生及对应老师的信息
public List&lt;Student&gt; getStudents();
</code></pre>
<p>2、编写对应的Mapper文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;

   &lt;!--
   需求：获取所有学生及对应老师的信息
   思路：
       1. 获取所有学生的信息
       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息
       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？
           1. 做一个结果集映射：StudentTeacher
           2. StudentTeacher结果集的类型为 Student
           3. 学生中老师的属性为teacher，对应数据库中为tid。
              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多
           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询
   --&gt;
   &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
   &lt;/select&gt;
   &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
       &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
       &lt;association property=&quot;teacher&quot;  column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
   &lt;/resultMap&gt;
   &lt;!--
   这里传递过来的id，只有一个属性的时候，下面可以写任何值
   association中column多参数配置：
       column=&quot;&#123;key=value,key=value&#125;&quot;
       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
      select * from teacher where id = #&#123;id&#125;
   &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p>
<p>4、注意点说明：</p>
<pre><code class="xml">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
   &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;
   &lt;association property=&quot;teacher&quot;  column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
这里传递过来的id，只有一个属性的时候，下面可以写任何值
association中column多参数配置：
   column=&quot;&#123;key=value,key=value&#125;&quot;
   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
--&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;
&lt;/select&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="java">@Test
public void testGetStudents()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<h4 id="5-1-4、按结果嵌套处理"><a href="#5-1-4、按结果嵌套处理" class="headerlink" title="5.1.4、按结果嵌套处理"></a>5.1.4、按结果嵌套处理</h4><p>我们还可以按照结果进行嵌套处理；</p>
<p>1、接口方法编写</p>
<pre><code class="java">public List&lt;Student&gt; getStudents2();
</code></pre>
<p>2、编写对应的mapper文件</p>
<pre><code class="xml">&lt;!--
按查询结果嵌套处理
思路：
   1. 直接查询出结果，进行结果集的映射
--&gt;
&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;
  select s.id sid, s.name sname , t.name tname
  from student s,teacher t
  where s.tid = t.id
&lt;/select&gt;

&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
   &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
   &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
   &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;
   &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
       &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
   &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<p>3、去mybatis-config文件中注入【此处应该处理过了】</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetStudents2()&#123;
   SqlSession session = MybatisUtils.getSession();
   StudentMapper mapper = session.getMapper(StudentMapper.class);

   List&lt;Student&gt; students = mapper.getStudents2();

   for (Student student : students)&#123;
       System.out.println(
               &quot;学生名:&quot;+ student.getName()
                       +&quot;\t老师:&quot;+student.getTeacher().getName());
  &#125;
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>按照查询进行嵌套处理就像SQL中的子查询</p>
<p>按照结果进行嵌套处理就像SQL中的联表查询</p>
<h3 id="5-2、一对多处理"><a href="#5-2、一对多处理" class="headerlink" title="5.2、一对多处理"></a>5.2、一对多处理</h3><h4 id="5-2-1、实体类编写"><a href="#5-2-1、实体类编写" class="headerlink" title="5.2.1、实体类编写"></a>5.2.1、实体类编写</h4><pre><code class="java">@Data
public class Student &#123;
   private int id;
   private String name;
   private int tid;
&#125;

@Data
public class Teacher &#123;
   private int id;
   private String name;
   //一个老师多个学生
   private List&lt;Student&gt; students;
&#125;
</code></pre>
<h4 id="5-2-2、按结果嵌套"><a href="#5-2-2、按结果嵌套" class="headerlink" title="5.2.2、按结果嵌套"></a>5.2.2、按结果嵌套</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">//获取指定老师，及老师下的所有学生
public Teacher getTeacher(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;

   &lt;!--
   思路:
       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名
       2. 对查询出来的操作做结果集映射
           1. 集合的话，使用collection！
               JavaType和ofType都是用来指定对象类型的
               JavaType是用来指定pojo中属性的类型
               ofType指定的是映射到list集合属性中pojo的类型。
   --&gt;
   &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
      select s.id sid, s.name sname , t.name tname, t.id tid
      from student s,teacher t
      where s.tid = t.id and t.id=#&#123;id&#125;
   &lt;/select&gt;

   &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
       &lt;result  property=&quot;name&quot; column=&quot;tname&quot;/&gt;
       &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
           &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;
           &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;
           &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;
       &lt;/collection&gt;
   &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<pre><code class="xml">&lt;mappers&gt;
   &lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<h4 id="5-2-3、按查询嵌套处理"><a href="#5-2-3、按查询嵌套处理" class="headerlink" title="5.2.3、按查询嵌套处理"></a>5.2.3、按查询嵌套处理</h4><p>1、TeacherMapper接口编写方法</p>
<pre><code class="java">public Teacher getTeacher2(int id);
</code></pre>
<p>2、编写接口对应的Mapper配置文件</p>
<pre><code class="xml">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;
    select * from teacher where id = #&#123;id&#125;
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>3、将Mapper文件注册到MyBatis-config文件中</p>
<p>4、测试</p>
<pre><code class="java">@Test
public void testGetTeacher2()&#123;
   SqlSession session = MybatisUtils.getSession();
   TeacherMapper mapper = session.getMapper(TeacherMapper.class);
   Teacher teacher = mapper.getTeacher2(1);
   System.out.println(teacher.getName());
   System.out.println(teacher.getStudents());
&#125;
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、关联-association</p>
<p>2、集合-collection</p>
<p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p>
<p>4、JavaType和ofType都是用来指定对象类型的</p>
<ul>
<li>JavaType是用来指定pojo中属性的类型</li>
<li>ofType指定的是映射到list集合属性中pojo的类型。</li>
</ul>
<p><strong>注意说明：</strong></p>
<p>1、保证SQL的可读性，尽量通俗易懂</p>
<p>2、根据实际要求，尽量编写性能更高的SQL语句</p>
<p>3、注意属性名和字段不一致的问题</p>
<p>4、注意一对多和多对一 中：字段和属性对应的问题</p>
<p>5、尽量使用Log4j，通过日志来查看自己的错误</p>
<h2 id="六、动态SQL"><a href="#六、动态SQL" class="headerlink" title="六、动态SQL"></a>六、动态SQL</h2><h3 id="6-1、动态SQL简介"><a href="#6-1、动态SQL简介" class="headerlink" title="6.1、动态SQL简介"></a>6.1、动态SQL简介</h3><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p>
<pre><code>官网描述：
MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。
虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。
动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

  -------------------------------
  - if
  - choose (when, otherwise)
  - trim (where, set)
  - foreach
  -------------------------------
</code></pre>
<p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p>
<p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p>
<h3 id="6-2、搭建环境"><a href="#6-2、搭建环境" class="headerlink" title="6.2、搭建环境"></a>6.2、搭建环境</h3><h4 id="6-2-1、数据库"><a href="#6-2-1、数据库" class="headerlink" title="6.2.1、数据库"></a>6.2.1、数据库</h4><pre><code class="sql">CREATE TABLE `blog` (
`id` varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,
`author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
`create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
`views` int(30) NOT NULL COMMENT &#39;浏览量&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<h4 id="6-2-2、创建Mybaits基础工程"><a href="#6-2-2、创建Mybaits基础工程" class="headerlink" title="6.2.2、创建Mybaits基础工程"></a>6.2.2、创建Mybaits基础工程</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JISvrLfLvE3e9Wv1kpFL9qzPPOq4EuoibKKLvGve4vEicLpXeEHfz1flqX3ribyzpbjDlOGzziapTsIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2、IDutil工具类</p>
<pre><code class="java">public class IDUtil &#123;

   public static String genId()&#123;
       return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);
  &#125;

&#125;
</code></pre>
<p>3、实体类编写  【注意set方法作用】</p>
<pre><code class="java">import java.util.Date;

public class Blog &#123;

   private String id;
   private String title;
   private String author;
   private Date createTime;
   private int views;
   //set，get....
&#125;
</code></pre>
<p>4、编写Mapper接口及xml文件</p>
<pre><code class="java">public interface BlogMapper &#123;
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<p>5、mybatis核心配置文件，下划线驼峰自动转换</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
&lt;!--注册Mapper.xml--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>6、插入初始数据</p>
<p>编写接口</p>
<pre><code class="java">//新增一个博客
int addBlog(Blog blog);
</code></pre>
<p>sql配置文件</p>
<pre><code class="xml">&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;
  insert into blog (id, title, author, create_time, views)
  values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);
&lt;/insert&gt;
</code></pre>
<p>初始化博客方法</p>
<pre><code class="java">@Test
public void addInitBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   Blog blog = new Blog();
   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Mybatis如此简单&quot;);
   blog.setAuthor(&quot;狂神说&quot;);
   blog.setCreateTime(new Date());
   blog.setViews(9999);

   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Java如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;Spring如此简单&quot;);
   mapper.addBlog(blog);

   blog.setId(IDUtil.genId());
   blog.setTitle(&quot;微服务如此简单&quot;);
   mapper.addBlog(blog);

   session.close();
&#125;
</code></pre>
<p>初始化数据完毕！</p>
<h3 id="6-3、if语句"><a href="#6-3、if语句" class="headerlink" title="6.3、if语句"></a>6.3、if语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p>
<p>1、编写接口类</p>
<pre><code class="java">//需求1
List&lt;Blog&gt; queryBlogIf(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询
select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;
--&gt;
&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog where
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogIf()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！</p>
<h3 id="6-4、Where语句"><a href="#6-4、Where语句" class="headerlink" title="6.4、Where语句"></a>6.4、Where语句</h3><p>修改上面的SQL语句；</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;if test=&quot;title != null&quot;&gt;
          title = #&#123;title&#125;
       &lt;/if&gt;
       &lt;if test=&quot;author != null&quot;&gt;
          and author = #&#123;author&#125;
       &lt;/if&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p>
<h3 id="6-5、Set语句"><a href="#6-5、Set语句" class="headerlink" title="6.5、Set语句"></a>6.5、Set语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p>
<p>1、编写接口方法</p>
<pre><code class="java">int updateBlog(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;!--注意set是用的逗号隔开--&gt;
&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;
  update blog
     &lt;set&gt;
         &lt;if test=&quot;title != null&quot;&gt;
            title = #&#123;title&#125;,
         &lt;/if&gt;
         &lt;if test=&quot;author != null&quot;&gt;
            author = #&#123;author&#125;
         &lt;/if&gt;
     &lt;/set&gt;
  where id = #&#123;id&#125;;
&lt;/update&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testUpdateBlog()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
   map.put(&quot;title&quot;,&quot;动态SQL&quot;);
   map.put(&quot;author&quot;,&quot;秦疆&quot;);
   map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);

   mapper.updateBlog(map);


   session.close();
&#125;
</code></pre>
<h3 id="6-6、choose语句"><a href="#6-6、choose语句" class="headerlink" title="6.6、choose语句"></a>6.6、choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>1、编写接口方法</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogChoose(Map map);
</code></pre>
<p>2、sql配置文件</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;choose&gt;
           &lt;when test=&quot;title != null&quot;&gt;
                title = #&#123;title&#125;
           &lt;/when&gt;
           &lt;when test=&quot;author != null&quot;&gt;
              and author = #&#123;author&#125;
           &lt;/when&gt;
           &lt;otherwise&gt;
              and views = #&#123;views&#125;
           &lt;/otherwise&gt;
       &lt;/choose&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试类</p>
<pre><code class="java">@Test
public void testQueryBlogChoose()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
   map.put(&quot;author&quot;,&quot;狂神说&quot;);
   map.put(&quot;views&quot;,9999);
   List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<h3 id="6-7、SQL片段"><a href="#6-7、SQL片段" class="headerlink" title="6.7、SQL片段"></a>6.7、SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p>
<p><strong>提取SQL片段：</strong></p>
<pre><code class="xml">&lt;sql id=&quot;if-title-author&quot;&gt;
   &lt;if test=&quot;title != null&quot;&gt;
      title = #&#123;title&#125;
   &lt;/if&gt;
   &lt;if test=&quot;author != null&quot;&gt;
      and author = #&#123;author&#125;
   &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<p><strong>引用SQL片段：</strong></p>
<pre><code class="xml">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;
       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>注意：</p>
<p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p>
<p>②、在 sql 片段中不要包括 where</p>
<h3 id="6-8、Foreach"><a href="#6-8、Foreach" class="headerlink" title="6.8、Foreach"></a>6.8、Foreach</h3><p>将数据库中前三个数据的id修改为1,2,3；</p>
<p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p>
<p>1、编写接口</p>
<pre><code class="java">List&lt;Blog&gt; queryBlogForeach(Map map);
</code></pre>
<p>2、编写SQL语句</p>
<pre><code class="xml">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
  select * from blog
   &lt;where&gt;
       &lt;!--
       collection:指定输入对象中的集合属性
       item:每次遍历生成的对象
       open:开始遍历时的拼接字符串
       close:结束时拼接的字符串
       separator:遍历对象之间需要拼接的字符串
       select * from blog where 1=1 and (id=1 or id=2 or id=3)
     --&gt;
       &lt;foreach collection=&quot;ids&quot;  item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
          id=#&#123;id&#125;
       &lt;/foreach&gt;
   &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="java">@Test
public void testQueryBlogForeach()&#123;
   SqlSession session = MybatisUtils.getSession();
   BlogMapper mapper = session.getMapper(BlogMapper.class);

   HashMap map = new HashMap();
   List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
   ids.add(1);
   ids.add(2);
   ids.add(3);
   map.put(&quot;ids&quot;,ids);

   List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);

   System.out.println(blogs);

   session.close();
&#125;
</code></pre>
<p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。</p>
<h2 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h2><h3 id="7-1、缓存简介"><a href="#7-1、缓存简介" class="headerlink" title="7.1、缓存简介"></a>7.1、缓存简介</h3><h4 id="7-1-1、缓存"><a href="#7-1-1、缓存" class="headerlink" title="7.1.1、缓存"></a>7.1.1、缓存</h4><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
<h4 id="7-1-2、Mybaits缓存"><a href="#7-1-2、Mybaits缓存" class="headerlink" title="7.1.2、Mybaits缓存"></a>7.1.2、Mybaits缓存</h4><ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p>
</li>
<li><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="7-2、一级缓存"><a href="#7-2、一级缓存" class="headerlink" title="7.2、一级缓存"></a>7.2、一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<h4 id="7-2-1、测试"><a href="#7-2-1、测试" class="headerlink" title="7.2.1、测试"></a>7.2.1、测试</h4><p>1、在mybatis中加入日志，方便测试结果</p>
<p>2、编写接口方法</p>
<pre><code class="java">//根据id查询用户
User queryUserById(@Param(&quot;id&quot;) int id);
</code></pre>
<p>3、接口对应的Mapper文件</p>
<pre><code class="xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
  select * from user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>4、测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>5、结果分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="7-2-2、一级缓存失效情况"><a href="#7-2-2、一级缓存失效情况" class="headerlink" title="7.2.2、一级缓存失效情况"></a>7.2.2、一级缓存失效情况</h4><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
   session2.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！</p>
<p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(2);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：发现发送了两条SQL语句！很正常的理解</p>
<p>结论：<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<pre><code class="java">//修改用户
int updateUser(Map map);
</code></pre>
<p>编写SQL</p>
<pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;
  update user set name = #&#123;name&#125; where id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   HashMap map = new HashMap();
   map.put(&quot;name&quot;,&quot;kuangshen&quot;);
   map.put(&quot;id&quot;,4);
   mapper.updateUser(map);

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>观察结果：查询在中间执行了增删改操作后，重新执行了</p>
<p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存</p>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   session.clearCache();//手动清除缓存

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
&#125;
</code></pre>
<p>一级缓存就是一个map</p>
<h3 id="7-3、二级缓存"><a href="#7-3、二级缓存" class="headerlink" title="7.3、二级缓存"></a>7.3、二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、开启全局缓存 【mybatis-config.xml】</p>
<pre><code class="xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<pre><code class="xml">&lt;cache/&gt;

官方示例=====&gt;查看官方文档
&lt;cache
 eviction=&quot;FIFO&quot;
 flushInterval=&quot;60000&quot;
 size=&quot;512&quot;
 readOnly=&quot;true&quot;/&gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
</code></pre>
<p>3、代码测试</p>
<ul>
<li>所有的实体类先实现序列化接口</li>
<li>测试代码</li>
</ul>
<pre><code class="java">@Test
public void testQueryUserById()&#123;
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();

   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   session.close();

   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session2.close();
&#125;
</code></pre>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<h3 id="7-4、缓存原理图"><a href="#7-4、缓存原理图" class="headerlink" title="7.4、缓存原理图"></a>7.4、缓存原理图</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="7-5、EhCache"><a href="#7-5、EhCache" class="headerlink" title="7.5、EhCache"></a>7.5、EhCache</h3><p>第三方缓存实现–EhCache: 查看百度百科</p>
<p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p>
<p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
   &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在mapper.xml中使用对应的缓存即可</p>
<pre><code class="xml">&lt;mapper namespace = “org.acme.FooMapper” &gt;
   &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;
&lt;/mapper&gt;
</code></pre>
<p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&gt;
   &lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      user.home – 用户主目录
      user.dir – 用户当前工作目录
      java.io.tmpdir – 默认临时文件路径
    --&gt;
   &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
   
   &lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

   &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
   &lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
   &lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&gt;

&lt;/ehcache&gt;
</code></pre>
<p>合理的使用缓存，可以让我们程序的性能大大提升！</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>