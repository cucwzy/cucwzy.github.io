
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuyan || JavaWeb</title>
    <meta name="author" content="Shuyan">
    <meta name="description" content="ShuyanCoding...... ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Shuyan</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Shuyan</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>JavaWeb </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/17
        </span>

        
        <span class="category">
            <a href="/categories/JAVA">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                JAVA
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/JavaWeb" style=color:#00bcd4>
                    JavaWeb
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="一、Tomcat"><a href="#一、Tomcat" class="headerlink" title="一、Tomcat"></a>一、Tomcat</h2><blockquote>
<p>tomcat官网：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
</blockquote>
<h3 id="1-1、tomcat启动"><a href="#1-1、tomcat启动" class="headerlink" title="1.1、tomcat启动"></a>1.1、tomcat启动</h3><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225113582.png" alt="image-20210317225113582"></p>
<p>启动、关闭tomcat</p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225203904.png" alt="image-20210317225203904"></p>
<p>可能遇到的问题：</p>
<p>​            1、Java环境变量没有配置</p>
<p>​            2、乱码问题：配置文件中设置</p>
<h3 id="1-2、tomcat配置"><a href="#1-2、tomcat配置" class="headerlink" title="1.2、tomcat配置"></a>1.2、tomcat配置</h3><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210317225435335.png" alt="image-20210317225435335"></p>
<p>可以配置启动的<strong>端口号</strong></p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<pre><code class="xml">&lt;Connectorport=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre>
<p>可以配置<strong>主机名称</strong></p>
<ul>
<li>默认主机名为: localhost —&gt;127.0.0.1<ul>
<li>默认网站:存放的位置为: webapps</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;Hostname=&quot;www.baidu.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<p><strong>网站是如何访问的？</strong></p>
<ul>
<li>输入一个域名: 回车</li>
<li></li>
</ul>
<p>这种需要在本机配置域名映射</p>
<p>C:\Windows\System32\drivers\etc下的hosts文件</p>
<p>127.0.0.1 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
<h3 id="1-3、搭建一个web网站"><a href="#1-3、搭建一个web网站" class="headerlink" title="1.3、搭建一个web网站"></a>1.3、搭建一个web网站</h3><p>将自己的war包项目放到tomcat中webapps目录下，然后启动tomcat即可</p>
<p>网站应该有的结构</p>
<pre><code class="xml">--webapps ：Tomcat服务器的web目录
-ROOT-myblog ：网站的目录名
- WEB-INF-classes : java程序
-lib：web应用所依赖的jar包
-web.xml ：网站配置文件
- index.html 默认的首页
-static-css-style.css-js-img-.....
</code></pre>
<h3 id="1-4、启动多个不同端口的Tomcat"><a href="#1-4、启动多个不同端口的Tomcat" class="headerlink" title="1.4、启动多个不同端口的Tomcat"></a>1.4、启动多个不同端口的Tomcat</h3><p>​        一个服务器可能需要启动多个项目，为了方便，不同项目访问只需要通过不同的端口号区分。</p>
<p>​        修改端口只需修改三处即可，以<strong>tomcat8</strong>为例</p>
<p>1、<strong>shutdown端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113724868.png" alt="image-20210318113724868"></p>
<p>2、<strong>HTTP端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113738086.png" alt="image-20210318113738086"></p>
<p>3、<strong>AJP端口</strong></p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318113750347.png" alt="image-20210318113750347"></p>
<p>tomcat9版本不需要第三步了</p>
<p>注意：有时更新项目后不能得到及时刷新，这是可以清除缓存，进入tomcat目录下删除work文件夹里面的文件。</p>
<h2 id="二、HTTP"><a href="#二、HTTP" class="headerlink" title="二、HTTP"></a>二、HTTP</h2><h3 id="2-1、HTTP简介"><a href="#2-1、HTTP简介" class="headerlink" title="2.1、HTTP简介"></a>2.1、HTTP简介</h3><p>​        HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<h3 id="2-2、两个时代"><a href="#2-2、两个时代" class="headerlink" title="2.2、两个时代"></a>2.2、两个时代</h3><ul>
<li>http1.0<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接（<strong>短连接</strong>）。</li>
</ul>
</li>
<li>http2.0<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源（<strong>长连接</strong>）</li>
</ul>
</li>
</ul>
<h3 id="2-3、HTTP请求"><a href="#2-3、HTTP请求" class="headerlink" title="2.3、HTTP请求"></a>2.3、HTTP请求</h3><blockquote>
<p><strong>客户端—-&gt;发请求(request)—-&gt;服务端</strong></p>
</blockquote>
<p>​        访问百度：</p>
<pre><code class="xml">Request URL: https://www.baidu.com/  请求地址
Request Method: GET    //请求方式get/post
Status Code:200 OK    //状态码
Remote(远程) Address:14.215.177.38:443//远程ip地址
</code></pre>
<blockquote>
<p><strong>请求行</strong></p>
</blockquote>
<ul>
<li>请求行中的请求方式:GET</li>
<li>请求方式：GeT , POST , HEAD , Delete , PUT , Tract<ul>
<li>get 能够携带的参数比较少, 大小有限制 , 会在浏览器URL地址栏显示数据内容 ,不安全,但是高效</li>
<li>post 能够携带的参数无限制, 大小无限制 , 不会在浏览器URL地址栏显示数据内容 ,安全,但是不太高效</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>请求（消息）头</strong></p>
</blockquote>
<pre><code class="xml">Accept:text/html  //支持的数据类型
Accept-Encoding:gzip, deflate, br  //支持的编码格式
Accept-Language:zh-CN,zh;q=0.9//语言
Cache-Control:max-age=0//缓存控制
Connection:keep-alive  //是否长连接
</code></pre>
<h3 id="2-4、HTTP响应"><a href="#2-4、HTTP响应" class="headerlink" title="2.4、HTTP响应"></a>2.4、HTTP响应</h3><blockquote>
<p><strong>服务端—-&gt;响应—-&gt;客户端</strong></p>
</blockquote>
<pre><code class="properties">Cache-Control:private        缓存控制
Connection:Keep-Alive        连接
Content-Encoding:gzip        编码
Content-Type:text/html       类型
</code></pre>
<h4 id="2-4-1、响应体"><a href="#2-4-1、响应体" class="headerlink" title="2.4.1、响应体"></a>2.4.1、响应体</h4><pre><code class="xmsl">Accept：                告诉浏览器，它所支持的数据类型
Accept-Encoding：    支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：    告诉浏览器，它的语言环境Cache-Control：缓存控制
Connection：            告诉浏览器，请求完成是断开还是保持连接
HOST：                主机....
Refresh：            告诉客户端，多久刷新一次；Location：让网页重新定位；
Location:             让网页重新定位
</code></pre>
<h4 id="2-4-2、响应状态码"><a href="#2-4-2、响应状态码" class="headerlink" title="2.4.2、响应状态码"></a>2.4.2、响应状态码</h4><p><img src="https://img-blog.csdnimg.cn/20191102141905774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI0NTU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191102141918916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI0NTU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-5、Maven"><a href="#2-5、Maven" class="headerlink" title="2.5、Maven"></a>2.5、Maven</h3><h3 id="2-5-1-Maven项目架构管理工具"><a href="#2-5-1-Maven项目架构管理工具" class="headerlink" title="2.5.1 Maven项目架构管理工具"></a>2.5.1 Maven项目架构管理工具</h3><p>​        作用：导jar包</p>
<p>​        Maven 的核心思想：<strong>约定大于配置</strong></p>
<p>​                有约束不要去违反</p>
<p>​        Maven会规定好如何来写java代码，必须按照这个规定来。</p>
<h3 id="2-5-2下载安装Maven"><a href="#2-5-2下载安装Maven" class="headerlink" title="2.5.2下载安装Maven"></a>2.5.2下载安装Maven</h3><p>​        下载后解压就能用,和TOMCAT 一样</p>
<h3 id="2-5-3-配置环境变量"><a href="#2-5-3-配置环境变量" class="headerlink" title="2.5.3 配置环境变量"></a>2.5.3 配置环境变量</h3><p>​        在系统环境变量中</p>
<p>​        配置如下:</p>
<p>​                    M2_HOME maven下的bin目录</p>
<p>​                    MAVEN_HOME maven目录</p>
<p>​                    系统中path中配置 %MAVEN_HOME%\bin</p>
<h3 id="2-5-4-阿里云镜像"><a href="#2-5-4-阿里云镜像" class="headerlink" title="2.5.4 阿里云镜像"></a>2.5.4 阿里云镜像</h3><ul>
<li>镜像: mirrors<ul>
<li>作用: 加速下载</li>
<li>国内建议使用阿里镜像</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;
    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;
    &lt;name&gt;Nexus aliyun&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
&lt;/mirror&gt;
</code></pre>
<h3 id="2-5-5-本地仓库"><a href="#2-5-5-本地仓库" class="headerlink" title="2.5.5 本地仓库"></a>2.5.5 本地仓库</h3><p>​        在本地的仓库，远程仓库;</p>
<p>​        建立一个本地仓库：<strong>localRepository</strong></p>
<h3 id="2-5-6-在IDEA中使用MAVEN"><a href="#2-5-6-在IDEA中使用MAVEN" class="headerlink" title="2.5.6 在IDEA中使用MAVEN"></a>2.5.6 在IDEA中使用MAVEN</h3><ol>
<li><p>启动IDEA</p>
</li>
<li><p>创建一个Maven项目</p>
</li>
<li><p>sav</p>
</li>
<li><p>等待自动导包,出现build success表示成功!!!</p>
</li>
<li><p>IDEA 中Maven的设置</p>
<p><strong>注意：</strong>IDEA项目创建成功后看一眼Maven的配置</p>
</li>
<li><p>到这里Maven在IDEA中的使用就配置完成了</p>
</li>
</ol>
<h3 id="2-5-7创建一个普通的Maven项目"><a href="#2-5-7创建一个普通的Maven项目" class="headerlink" title="2.5.7创建一个普通的Maven项目"></a>2.5.7创建一个普通的Maven项目</h3><p>将文件标记为指定文件1类型</p>
<pre><code class="html">&lt;img src=&quot;C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210508222659273.png&quot; alt=&quot;image-20210508222659273&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;img src=&quot;C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210508223015644.png&quot; alt=&quot;image-20210508223015644&quot; style=&quot;zoom:67%;&quot; /&gt;
</code></pre>
<h3 id="2-5-8-IDEA配置TOMECAT"><a href="#2-5-8-IDEA配置TOMECAT" class="headerlink" title="2.5.8 IDEA配置TOMECAT"></a>2.5.8 IDEA配置TOMECAT</h3><h3 id="2-5-9-pom文件"><a href="#2-5-9-pom文件" class="headerlink" title="2.5.9 pom文件"></a>2.5.9 pom文件</h3><p>pom.xml是Maven的核心配置文件</p>
<pre><code class="xml">&lt;!--  在build中配置resources , 来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;
                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;
            &lt;/excludes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h2 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h2><h3 id="3-1、Servlet简介"><a href="#3-1、Servlet简介" class="headerlink" title="3.1、Servlet简介"></a>3.1、Servlet简介</h3><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="3-2、HelloServlet"><a href="#3-2、HelloServlet" class="headerlink" title="3.2、HelloServlet"></a>3.2、HelloServlet</h3><ol>
<li><p>构建一个普通的Maven项目, 删掉 src,以后我们的学习,就在项目中建立Moudle</p>
</li>
<li><p>关于Maven父子工程的理解</p>
</li>
</ol>
<p>  <strong>父项目中会有:</strong></p>
<pre><code class="xml">&lt;modules&gt;
    &lt;module&gt;servlet-01&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
<p>​        <strong>子项目中会有:</strong></p>
<pre><code class="xml">&lt;parent&gt;
    &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
    &lt;groupId&gt;com.zhu&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<p>​        父项目中的java子项目可以直接使用</p>
<pre><code class="xml">son extend father
</code></pre>
<p>​        <strong>Maven 环境优化</strong></p>
<pre><code class="xml"> 1. 修改web.xml为最新
 2. 将maven的结构搭建完整
</code></pre>
<h4 id="3-2-1、编写一个servlet-程序"><a href="#3-2-1、编写一个servlet-程序" class="headerlink" title="3.2.1、编写一个servlet 程序"></a>3.2.1、编写一个servlet 程序</h4><ol>
<li>实现Servlet 接口 直接继承 HttpServlet</li>
<li>编写Serviet 的映射<ol>
<li>为什么写映射: 我们写的是JAVA程序,但是要通过浏览器访问,浏览器需要连接web浏览器, 所以我们需要在web服务中注册我们写的Servlet 还需要给他一个浏览器能够访问的路径</li>
</ol>
</li>
</ol>
<ul>
<li>导入依赖</li>
</ul>
<pre><code class="xml">&lt;!--添加Servlet和JSP依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>编写servlet类继承HttpServlet</li>
</ul>
<pre><code class="java">public class HellowServlet extends HttpServlet &#123;
    //由于gat或者post只是请求实现的不同方法,可以互相调用,业务逻辑一样
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter();///响应流
        writer.println(&quot;HellowServlet&quot;);
    &#125;
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 直接调用doGet，逻辑相似
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-2-2、配置映射"><a href="#3-2-2、配置映射" class="headerlink" title="3.2.2、配置映射"></a>3.2.2、配置映射</h4><p>一、xml方式</p>
<pre><code class="xml">&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;hellow&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.javaweb.servlet.HellowServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!--  servlet请求路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hellow&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hellow&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>二、注解方式</p>
<pre><code class="java">@WebServlet(&quot;/hi&quot;)
public class HelloServletextendsHttpServlet&#123;
    ...
&#125;
</code></pre>
<ul>
<li><p>配置tomcat</p>
<p>注意配置项目发布的路径</p>
</li>
<li><p>启动项目，访问路径</p>
</li>
</ul>
<h3 id="3-3、Servlet原理"><a href="#3-3、Servlet原理" class="headerlink" title="3.3、Servlet原理"></a>3.3、Servlet原理</h3><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</p>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210318220210550.png" alt="image-20210318220210550"></p>
<h3 id="3-4、Mapping问题"><a href="#3-4、Mapping问题" class="headerlink" title="3.4、Mapping问题"></a>3.4、Mapping问题</h3><p>1、一个Servlet可以指定一个映射路径</p>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>2、一个Servlet可以指定多个映射路径</p>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>3、一个Servlet可以指定<strong>通用</strong>映射路径</p>
<ul>
<li>/hello/* ——&gt; /hellow后边不管写啥都返回当前带哦用的servlet-name 的方法</li>
<li>/* 默认通配符</li>
</ul>
<pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>4、默认请求路径</p>
<pre><code class="xml">&lt;!--默认请求路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>5、指定一些后缀或者前缀等等….</p>
<pre><code class="xml">&lt;!--
    可以自定义后缀实现请求映射    
    注意点：*前面不能加项目映射的路径hello/sajdlkajda.qinjiang，只要以 .qinjiang  就能访问
 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.qinjiang&lt;/url-pattern&gt;
&lt;/servlet-mapping
</code></pre>
<p>6、优先级问题<br>        指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求（404）；</p>
<pre><code class="xml">&lt;!--404--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h3 id="3-5、ServletContext"><a href="#3-5、ServletContext" class="headerlink" title="3.5、ServletContext"></a>3.5、ServletContext</h3><p>​        web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用</p>
<h4 id="3-5-1、共享数据"><a href="#3-5-1、共享数据" class="headerlink" title="3.5.1、共享数据"></a>3.5.1、共享数据</h4><pre><code class="java">public class Serlvet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //this.getServletConfig()  //servlrt 配置
        //this.getInitParameter()   //初始化参数
        //this.getServletContext();   //servlet上下文
        ServletContext contxt = this.getServletContext();
        String username = &quot;JOBB&quot;; //数据
        contxt.setAttribute(&quot;username&quot;,username);//将一个数据保存在了ServletContext中,  名字为: username 值: username
        System.out.println(&quot;欢迎&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ReadSerlvet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //数据
        ServletContext context = this.getServletContext();
        String username = (String)context.getAttribute(&quot;username&quot;);
        //响应
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.getWriter().println(&quot;姓名: &quot;+username);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;setnum&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.zhu.servlet.Serlvet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;setnum&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
    &lt;servlet-name&gt;get&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.zhu.servlet.ReadSerlvet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;get&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/get&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>必须先访问hello接口，然后访问get接口，才能获取name的值。</p>
<h4 id="3-5-2、获取初始化参数"><a href="#3-5-2、获取初始化参数" class="headerlink" title="3.5.2、获取初始化参数"></a>3.5.2、获取初始化参数</h4><p>web.xml中配置</p>
<pre><code class="xml">&lt;!--Web的初始化配置--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>java中</p>
<pre><code class="java">public class ServletContext extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        javax.servlet.ServletContext context = this.getServletContext();
        String url = context.getInitParameter(&quot;url&quot;);
        resp.getWriter().println(url);
    &#125;
    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-5-3、请求转发"><a href="#3-5-3、请求转发" class="headerlink" title="3.5.3、请求转发"></a>3.5.3、请求转发</h4><pre><code class="java">public class ServletrequestDispatcher extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;进入了ServletrequestDispatcher&quot;);
        ServletContext context = this.getServletContext();
        
        //RequestDispatcher url = context.getRequestDispatcher(&quot;url&quot;);//转发路径 格式: /url  /路径
        //url.forward(req,resp);//调用forward 转发
        context.getRequestDispatcher(&quot;/url&quot;).forward(req,resp);//合写
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-5-4、读取资源文件"><a href="#3-5-4、读取资源文件" class="headerlink" title="3.5.4、读取资源文件"></a>3.5.4、读取资源文件</h4><p>编写b.properties文件</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现: 都被打包到了同一路径下: classes,俗称为类路径</p>
<p>思路: 需要一个<strong>文件流</strong>；</p>
<pre><code class="properties">username = Mack
id = 00001
passworld = 123456789
</code></pre>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320004726070.png" alt="image-20210320004726070"></p>
<pre><code class="java">public class ServletReadPropise extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        InputStream is = context.getResourceAsStream(&quot;/WEB-INF/classes/db.propise&quot;);
        Properties prop = new Properties();
        prop.load(is);
        String username = prop.getProperty(&quot;username&quot;);
        String id = prop.getProperty(&quot;id&quot;);
        String passworld = prop.getProperty(&quot;passworld&quot;);
        resp.getWriter().println(username+&quot;, &quot;+passworld+&quot;, &quot;+id);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp); 
    &#125;
&#125;
</code></pre>
<h3 id="3-6、HttpServletResponse"><a href="#3-6、HttpServletResponse" class="headerlink" title="3.6、HttpServletResponse"></a>3.6、HttpServletResponse</h3><p>​        web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；</p>
<ul>
<li>如果要获取客户端请求过来的参数：<ul>
<li>HttpServlet<strong>Request</strong></li>
</ul>
</li>
<li>如果要给客户端响应一些信息：<ul>
<li>HttpServlet<strong>Response</strong></li>
</ul>
</li>
</ul>
<h4 id="3-6-1、简单分类"><a href="#3-6-1、简单分类" class="headerlink" title="3.6.1、简单分类"></a>3.6.1、简单分类</h4><p>​        负责向浏览器发送数据的方法</p>
<pre><code class="java">ServletOutputStream getOutputStream() throws IOException;//y
PrintWriter getWriter() throws IOException;//一般中文用
</code></pre>
<p><strong>负责向浏览器发送响应头的方法：</strong></p>
<pre><code class="java">void setCharacterEncoding(String var1);
void setContentLength(int var1);
void setContentLengthLong(long var1);
void setContentType(String var1);
void setDateHeader(String var1,long var2);
void addDateHeader(String var1,long var2);
void setHeader(String var1,String var2);
void addHeader(String var1,String var2);
void setIntHeader(String var1,int var2);
void addIntHeader(String var1,int var2);
</code></pre>
<p><strong>响应的状态码：</strong></p>
<pre><code class="java">/*200：请求响应成功 200
3xx：请求重定向
- 重定向：你重新到我给你新位置去；
4xx：找不到资源 404
- 资源不存在；
5xx：服务器代码错误 500 502:网关错误
*/
int SC_CONTINUE =100;
int SC_SWITCHING_PROTOCOLS =101;
int SC_OK =200;
int SC_CREATED =201;
int SC_ACCEPTED =202;
int SC_NON_AUTHORITATIVE_INFORMATION =203;
int SC_NO_CONTENT =204;
int SC_RESET_CONTENT =205;
int SC_PARTIAL_CONTENT =206;
int SC_MULTIPLE_CHOICES =300;
int SC_MOVED_PERMANENTLY =301;
int SC_MOVED_TEMPORARILY =302;
int SC_FOUND =302;
int SC_SEE_OTHER =303;
int SC_NOT_MODIFIED =304;
int SC_USE_PROXY =305;
int SC_TEMPORARY_REDIRECT =307;
int SC_BAD_REQUEST =400;
int SC_UNAUTHORIZED =401;
int SC_PAYMENT_REQUIRED =402;
int SC_FORBIDDEN =403;
int SC_NOT_FOUND =404;
int SC_METHOD_NOT_ALLOWED =405;
int SC_NOT_ACCEPTABLE =406;
int SC_PROXY_AUTHENTICATION_REQUIRED =407;
int SC_REQUEST_TIMEOUT =408;
int SC_CONFLICT =409;
int SC_GONE =410;
int SC_LENGTH_REQUIRED =411;
int SC_PRECONDITION_FAILED =412;
int SC_REQUEST_ENTITY_TOO_LARGE =413;
int SC_REQUEST_URI_TOO_LONG =414;
int SC_UNSUPPORTED_MEDIA_TYPE =415;
int SC_REQUESTED_RANGE_NOT_SATISFIABLE =416;
int SC_EXPECTATION_FAILED =417;
int SC_INTERNAL_SERVER_ERROR =500;
int SC_NOT_IMPLEMENTED =501;
int SC_BAD_GATEWAY =502;
int SC_SERVICE_UNAVAILABLE =503;
int SC_GATEWAY_TIMEOUT =504;
int SC_HTTP_VERSION_NOT_SUPPORTED =505;
</code></pre>
<h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><h4 id="3-6-2、下载文件"><a href="#3-6-2、下载文件" class="headerlink" title="3.6.2、下载文件"></a>3.6.2、下载文件</h4><ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class Servlet_04_FileDown extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 1. 要获取下载文件的路径
        String realPath = &quot;D:\\IDEA_project\\JavaWeb\\response\\target\\classes\\60599be88322e6675c2d7c68.jpg&quot;;
        System.out.println(&quot;下载的文件的路径: &quot;+realPath);
        // 2. 下载的文件名是啥？
        String filename = realPath.substring(realPath.indexOf(&quot;\\&quot;) + 1);
        // 3. 设置想办法让浏览器能够支持下载我们需要的东西
        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename= &quot;+ filename);
        // 4. 获取下载文件的输入流
        FileInputStream in = new FileInputStream(realPath);
        // 5. 创建缓冲区
        int length = 0;
         byte[]buffer = new byte[1024];
        // 6. 获取OutputStream对象
        ServletOutputStream out= resp.getOutputStream();
        // 7. 将FileOutputStream流写入到buffer缓冲区
        // 8. 使用OutputStream将缓冲区中的数据输出到客户端！
        while ((length=in.read(buffer))&gt;0)&#123;
            out.write(buffer,0,length);
        &#125;
        // 9.关闭流
        in.close();
        out.close();
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        super.doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h4 id="3-6-3、验证码功能"><a href="#3-6-3、验证码功能" class="headerlink" title="3.6.3、验证码功能"></a>3.6.3、验证码功能</h4><ul>
<li>前端实现</li>
<li>后端实现，需要用到Java的图片类，生产一个图片</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/img&quot;)
public class ImageServletextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        //如何让浏览器3秒自动刷新一次;        
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image =newBufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g =(Graphics2D) image.getGraphics();
        
        //笔
        //设置图片的背景颜色        
        g.setColor(Color.white);        
        g.fillRect(0,0,80,20);
        
        //给图片写数据        
        g.setColor(Color.BLUE);        
        g.setFont(newFont(null,Font.BOLD,20));        
        g.drawString(makeNum(),0,20);
        
        //告诉浏览器，这个请求用图片的方式打开        
        resp.setContentType(&quot;image/jpeg&quot;);
        
        //网站存在缓存，不让浏览器缓存        
        resp.setDateHeader(&quot;expires&quot;,-1);        
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
       
        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());
    &#125;
    
    //生成随机数
    private String makeNum()&#123;
        Random random =newRandom();
        String num = random.nextInt(9999999)+&quot;&quot;;
        StringBuffer sb =newStringBuffer();
        for(int i =0; i &lt; 7 - num.length(); i++)&#123;            
            sb.append(&quot;0&quot;);
        &#125;        
        num = sb.toString()+ num;return num;
    &#125;
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;        
        doGet(req, resp);
    &#125; 
&#125;
</code></pre>
<h4 id="3-6-4、实现重定向"><a href="#3-6-4、实现重定向" class="headerlink" title="3.6.4、实现重定向"></a>3.6.4、实现重定向</h4><p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320172123691.png" alt="image-20210320172123691"></p>
<p>​        B一个web资源收到客户端A请求后，B会通知A去访问另外一个web资源C，这个过程叫<strong>重定向</strong>。</p>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="java">void sendRedirect(String varl)throw IOException;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    /*
         */
    resp.setHeader(&quot;Location&quot;,&quot;/r/image&quot;);
    resp.setStatus(302);
    resp.sendRedirect(&quot;/r/image&quot;);//重定向
&#125;
</code></pre>
<p><strong>重定向和转发的区别？</strong></p>
<p>相同点:</p>
<ul>
<li>页面都会跳转</li>
</ul>
<p>不同点:</p>
<ul>
<li>请求转发 url不会产生变化， 重定向会发生变化</li>
<li>请求转发 可以携带参数， 重定向不能携带参数</li>
<li>请求转发 只能发送一个请求， 重定向至少发送两次请求</li>
</ul>
<h4 id="3-6-5、简单实现登录重定向"><a href="#3-6-5、简单实现登录重定向" class="headerlink" title="3.6.5、简单实现登录重定向"></a>3.6.5、简单实现登录重定向</h4><pre><code class="java">public class Servlet_06_RequestTest extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;进入请求&quot;);
        //处理请求
        //从那个请求中获取参数
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        System.out.println(username+&quot; : &quot;+password);
        //重定向时一定要注意路径问题  否则44
        resp.sendRedirect(&quot;/r/success.jsp&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<h3 id="3-7、HttpServletRequest"><a href="#3-7、HttpServletRequest" class="headerlink" title="3.7、HttpServletRequest"></a>3.7、HttpServletRequest</h3><p>​        HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</p>
<h4 id="3-7-1-获取前端传递的参数-并-请求转发"><a href="#3-7-1-获取前端传递的参数-并-请求转发" class="headerlink" title="3.7.1. 获取前端传递的参数 并 请求转发"></a>3.7.1. 获取前端传递的参数 并 请求转发</h4><pre><code class="java"> @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
        System.out.println(&quot;--------------------------------------&quot;);
        System.out.println(username);
        System.out.println(password);
        System.out.println(Arrays.toString(hobbies));
        System.out.println(&quot;--------------------------------------&quot;);
        //通过请求转发
        //这里的/代表当前Web应用
        req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
</code></pre>
<pre><code class="java">@WebServlet(&quot;/req&quot;)
public class ReqServletextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        System.out.println(&quot;url路径：&quot;+req.getRequestURL());
        System.out.println(&quot;uri路径：&quot;+req.getRequestURI());
        System.out.println(&quot;context路径：&quot;+req.getContextPath());
        req.getRequestDispatcher(&quot;/file&quot;).forward(req,resp);
    &#125; 
&#125;
</code></pre>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210320180403649.png" alt="image-20210320180403649"></p>
<h2 id="四、Cookie、Session"><a href="#四、Cookie、Session" class="headerlink" title="四、Cookie、Session"></a>四、Cookie、Session</h2><h3 id="4-1、会话"><a href="#4-1、会话" class="headerlink" title="4.1、会话"></a>4.1、会话</h3><p>​        <strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p>​        <strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<h3 id="4-2、保存会话的两种技术"><a href="#4-2、保存会话的两种技术" class="headerlink" title="4.2、保存会话的两种技术"></a>4.2、保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术（响应、请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<h3 id="4-3、Cookie"><a href="#4-3、Cookie" class="headerlink" title="4.3、Cookie"></a>4.3、Cookie</h3><p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li><p>不设置有效期，关闭浏览器，自动失效；（默认）</p>
</li>
<li><p>设置有效期时间为 0 ；</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>cookie默认有效期是在浏览器关闭后失效，如果设置了有效期就在过期后失效</li>
</ul>
<pre><code class="java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    //服务器告诉你你来的时间,把时间封装成一个信件,下次来的时候带着
    //解决中文乱码
    resp.setCharacterEncoding(&quot;utf-8&quot;);
    req.setCharacterEncoding(&quot;utf-8&quot;);
    //响应
    PrintWriter out = resp.getWriter();
    //Cookie ,服务端从客户端获取
    Cookie[] cookies = req.getCookies();//返回数组,说明可能存在多个
    //判断Cookie是否存在
    if (cookies!=null)&#123;
        //如果存在怎么办
        out.write(&quot;When was your last visit: &quot;);
        for (int i = 0; i &lt;cookies.length ; i++) &#123;
            Cookie cookie =  cookies[i];
            //或缺Cookie的名字
            if(cookie.getName().equals(&quot;LastLoginTime&quot;))&#123;
                //获取cookie中的值
                long LastLoginTime = Long.parseLong(cookie.getValue());
                Date date = new Date(LastLoginTime);
                out.write(date.toLocaleString());
            &#125;
        &#125;
    &#125;else &#123;
        System.out.println(&quot;This is your first visit&quot;);
    &#125;
    //服务器给客户端响应一个Cookie
    Cookie cookie = new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);
    //给cookie设置有效期为一天
    cookie.setMaxAge(24*60*60);
    resp.addCookie(cookie);
</code></pre>
<pre><code class="java">Cookie[] cookie = req.getCookies();//获得cookie
cookie.getName();//获得cookie中的key
cookie.getValve();//获得cookie中的value
new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);//新建cookie
cookie.setMaxAge(24*60*60);        //给cookie设置有效期为一天
resp.addCookie(cookie);//添加一个cookie
</code></pre>
<p>编码与解码，防止乱码</p>
<pre><code class="java">@WebServlet(&quot;/c3&quot;)
public class CookieDemo2extendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
       PrintWriter out = resp.getWriter();
       for(Cookie cookie : req.getCookies())&#123;
           if(cookie.getName().equals(&quot;name&quot;))&#123;
               out.write(URLDecoder.decode(cookie.getValue(),&quot;utf-8&quot;));
           &#125; 
       &#125;
     Cookie cookie = new Cookie(&quot;name&quot;,URLEncoder.encode(&quot;筱语&quot;,&quot;utf-8&quot;));        
      resp.addCookie(cookie);
    &#125; 
&#125;
</code></pre>
<h3 id="4-3、Session（重点）"><a href="#4-3、Session（重点）" class="headerlink" title="4.3、Session（重点）"></a>4.3、Session（重点）</h3><p>什么是session</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个session对象</li>
<li>一个session独占一个浏览器，主要浏览器没有关闭，这个session就存在</li>
<li>用户登录后，整个网站它都可以访问——&gt;保存用户的信息，保存购物车的信息。</li>
</ul>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210323084508377.png" alt="image-20210323084508377"></p>
<ul>
<li>给session中存用户信息</li>
</ul>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class Servlet_09_Session extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 解决乱码问题
        req.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
        
        // 获得Session
        HttpSession session = req.getSession();
        
        // 给Session存东西
        // session.setAttribute(&quot;name&quot;,&quot;小狗&quot;);
        session.setAttribute(&quot;name&quot;,new Person(18,&quot;小红&quot;,123456789));
        // 获取Session的id
        String id = session.getId();
        System.out.println(id);
        // 判断Session是不是新创建的
        boolean aNew = session.isNew();
        if (aNew)&#123;
            resp.getWriter().println(&quot;session创建成功! session id 为: &quot;+id);
        &#125;else &#123;
            resp.getWriter().println(&quot;session已经创建了id 为: &quot;+id);
        &#125;
        // session在创建的时候做了啥
        // Cookie cookie = new Cookie(&quot;SESSIONID&quot;, id);
        // resp.addCookie(cookie);
    &#125;
    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<ul>
<li>获取session中存储的用户信息</li>
</ul>
<pre><code class="java">package com.zhu;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class Servlet_09_SessionGet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 解决编码问题
        resp.setCharacterEncoding(&quot;utf8&quot;);
        req.setCharacterEncoding(&quot;utf8&quot;);
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
        
        // 得到session
        HttpSession session = req.getSession();
        Person person = (Person) session.getAttribute(&quot;name&quot;);
        System.out.println(person.toString());
    &#125;
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
&#125;
</code></pre>
<p>每次新打开一个浏览器访问地址，都会新建一个session会话，也会向客户端存储一个值为sessionId的cookie。</p>
<h5 id="手动注销session"><a href="#手动注销session" class="headerlink" title="手动注销session"></a>手动注销session</h5><pre><code class="java">public class Servlet_10_SessionRemove extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        HttpSession session = req.getSession();
        session.removeAttribute(&quot;name&quot;);
        session.invalidate();//注销
    &#125;
</code></pre>
<h5 id="设置session的失效时间，在web-xml中"><a href="#设置session的失效时间，在web-xml中" class="headerlink" title="设置session的失效时间，在web.xml中"></a>设置session的失效时间，在web.xml中</h5><pre><code class="xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<h4 id="7天免登录案例实现"><a href="#7天免登录案例实现" class="headerlink" title="7天免登录案例实现"></a>7天免登录案例实现</h4><p>思路：session在一次会话后就会结束，所以可以通过servletContext来存储当前的session，以sessionId为key，session对象为值，然后将sessionId存在客户端的cookie中，每次获取用户信息先去cookie中查找是否有这个id，然后通过该id获取servletContext中的session对象实现。</p>
<ul>
<li>登录接口，将session存到ServletContext中</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/ss1&quot;)
public class SessionAnextendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        HttpSession session = req.getSession();
        session.setAttribute(&quot;name&quot;,&quot;小腿&quot;);                                                                          String sessionId = session.getId();
       Cookie cookie =newCookie(&quot;session&quot;,sessionId);        
       cookie.setMaxAge(Integer.MAX_VALUE);        
       resp.addCookie(cookie);
       //存session对象
       this.getServletContext().setAttribute(sessionId,session);       
       resp.getWriter().write(&quot;登录成功！&quot;);
     &#125; 
&#125;
</code></pre>
<ul>
<li>获取用户信息接口</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/ss2&quot;)
public class SessionAn2extendsHttpServlet&#123;
    @Override
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)throwsServletException,IOException&#123;
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        String sId =&quot;&quot;;
        for(Cookie cookie : req.getCookies())&#123;
            if(cookie.getName().equals(&quot;session&quot;))&#123;                
                sId = cookie.getValue();
            &#125; 
        &#125;
        HttpSession session = (HttpSession) this.getServletContext().getAttribute(sId);
        String  name =(String)session.getAttribute(&quot;name&quot;);        
        resp.getWriter().write(&quot;欢迎你，&quot;+name);
    &#125; 
&#125;
</code></pre>
<p>​        先访问ss1接口，设置用户信息到session中，然后访问ss2接口就可以拿到用户信息了。将cookie过期时间设置为7天即可。当关闭浏览器后，下次直接访问ss2接口就能拿到用户信息，相当于不用再通过ss1接口登录了。</p>
<p><strong>注意：</strong>每次访问网站都会生成一个JsessionId在cookie中，而且会是不同的值。</p>
<h3 id="4-4、session与cookie异同"><a href="#4-4、session与cookie异同" class="headerlink" title="4.4、session与cookie异同"></a>4.4、session与cookie异同</h3><table>
<thead>
<tr>
<th align="left">COOKIE</th>
<th align="left">SESSION</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存在客户端中，不安全</td>
<td align="left">存在服务端中，比较安全</td>
</tr>
<tr>
<td align="left">只支持存字符串数据</td>
<td align="left">支持任意数据类型</td>
</tr>
<tr>
<td align="left">单个cookie存的数据大小不能超过4k</td>
<td align="left">可存储数据远高于Cookie</td>
</tr>
</tbody></table>
<h3 id="4-5使用场景"><a href="#4-5使用场景" class="headerlink" title="4.5使用场景:"></a>4.5使用场景:</h3><ul>
<li>保存一个登录用户的信息</li>
<li>购物车信息</li>
<li>在整个网站中经常会使用的数据,我们将他保存在Session中</li>
</ul>
<h2 id="五、JSP"><a href="#五、JSP" class="headerlink" title="五、JSP"></a>五、JSP</h2><h3 id="5-1什么是JSP"><a href="#5-1什么是JSP" class="headerlink" title="5.1什么是JSP"></a>5.1什么是JSP</h3><p>Java Server Pages: java 服务端界面 也和Servlet一样,用于动态Web技术!</p>
<p>最大的特点:</p>
<ol>
<li>写JSP就像像写HTML                   </li>
<li>区别:                                 <ul>
<li>HTML只提供静态界面                                 </li>
<li>JSP可以嵌入JAVA代码,为用户提供动态数据</li>
</ul>
</li>
</ol>
<h3 id="5-2-JSP原理"><a href="#5-2-JSP原理" class="headerlink" title="5.2 JSP原理-"></a>5.2 JSP原理-</h3><p><strong>JSP 本质上</strong>是也是一个Servlet</p>
<ol>
<li><p>判断请求</p>
</li>
<li><p>内置一些对象</p>
<ol>
<li>输出页面前增加的代码</li>
</ol>
</li>
</ol>
<h3 id="5-3JSP基本语法"><a href="#5-3JSP基本语法" class="headerlink" title="5.3JSP基本语法"></a>5.3JSP基本语法</h3><p>任何语言都有自己的语法,jsp作为java技术的一种应用,也有一些自己的扩充语法(了解,知道即可!!)java所有语法都支持!!</p>
<h4 id="JSP表达式"><a href="#JSP表达式" class="headerlink" title="JSP表达式"></a>JSP表达式</h4><pre><code class="xml">&lt;%--    jsp表达式
作用:用来将程序的输出,输出到客户端
&lt;%= bian&#39;laing %&gt;
--%&gt;
&lt;%= new java.util.Date()%&gt;
</code></pre>
<h4 id="JSP脚本片段"><a href="#JSP脚本片段" class="headerlink" title="JSP脚本片段"></a>JSP脚本片段</h4><pre><code class="xml">&lt;%--  JSP脚本片段--%&gt;
&lt;%
    int sum = 0;
    for (int i = 0; i &lt;100 ; i++) &#123;
        sum++;
    &#125;
    System.out.println(&quot;&lt;h1&gt;SUM=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
%&gt;
</code></pre>
<h4 id="JSP代码的在实现"><a href="#JSP代码的在实现" class="headerlink" title="JSP代码的在实现"></a>JSP代码的在实现</h4><pre><code class="xml">&lt;%
    for (int i = 0; i &lt; 5; i++) &#123;
%&gt;
&lt;h1&gt;HELLO,WOrLD&lt;/h1&gt;
&lt;%
    &#125;
%&gt;
输出5个Hello World
</code></pre>
<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a>JSP声明</h4><pre><code class="xml">&lt;%!
    static &#123;
        System.out.println(&quot;Loading Servlet...&quot;);
&#125;;
    private int globalVar = 0;
    public void kuang()&#123;
        System.out.println(&quot;进入了方法&quot;);
    &#125;
%&gt;
</code></pre>
<p>jsp声明会被编译到jsp生成的java的类中其他的会被生成到_jspServlet方法中!</p>
<p>在jsp,嵌入java代码即可!</p>
<pre><code class="xml">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;
&lt;%--注释--%&gt;
</code></pre>
<p>jsp的注释不会在客户端显示,但是HTML的就会!!</p>
<p>说明jsp会相较于html更安全</p>
<p><strong>EL表达式</strong></p>
<blockquote>
<p>在JSP页面的任何静态部分均可通过：${expression}来获取到指定表达式的值</p>
</blockquote>
<h4 id="jsp指令"><a href="#jsp指令" class="headerlink" title="jsp指令"></a>jsp指令</h4><pre><code class="xml">&lt;%@ page ...%&gt;
</code></pre>
<h3 id="5-4-九大内置对象"><a href="#5-4-九大内置对象" class="headerlink" title="5.4 九大内置对象"></a>5.4 九大内置对象</h3><ul>
<li><p>PageContext 存东西</p>
</li>
<li><p>Request 存东西</p>
</li>
<li><p>Response</p>
</li>
<li><p>Session 存东西</p>
</li>
<li><p>Application (Servlet Context) 存东西</p>
</li>
<li><p>config (servlet config)</p>
</li>
<li><p>out</p>
</li>
<li><p>page</p>
</li>
<li><p>exception</p>
<p>request: 客户端向服务器发送请求,产生的数据,用户看完就没用了, 比如: 新闻,用户看完没用的!</p>
<p>session: 客户端向服务器发送请求,产生的数据,用户用完之后还有用 , 比如: 购物车;</p>
<p>application: 客户端向服务器发送请求,产生的数据,一个用户用完了,其他用户还可以使用, 比如:聊天数据</p>
</li>
</ul>
<h3 id="5-5Jsp-标签-JSbTL表达式-EL表达式"><a href="#5-5Jsp-标签-JSbTL表达式-EL表达式" class="headerlink" title="5.5Jsp 标签 ,JSbTL表达式,EL表达式"></a>5.5Jsp 标签 ,JSbTL表达式,EL表达式</h3><p>EL表达式: ${}</p>
<ul>
<li>获取数据</li>
<li>执行运算</li>
<li>获取WEB开发的常用对象</li>
</ul>
<p>JSP 标签</p>
<pre><code class="xml">&lt;%--jsp:include--%&gt;
&lt;%--
http://localhost:8080?jsptag.jsp?name=kuangshen&amp;age=12
--%&gt;
&lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>JSTL表达式</strong></p>
<p><strong>JSTL标签库的使用</strong>就是为了弥补HTML的不足: 他自定义了许多标签,可以供我们使用,标签功能和Java代码一样!</p>
<p>格式化标签</p>
<p>SQL标签</p>
<p>XML标签</p>
<p>核心标签(<strong>掌握部分</strong>)</p>
<p>JSTL使用步骤:</p>
<pre><code class="xml">1. 引入对应taglib
2. 使用其中的方法
3. 在tomcat中也要引入JSTL的包,否则会报错:JSTL解析错误
</code></pre>
<pre><code class="html">&lt;body&gt;
&lt;h4&gt;if测试&lt;/h4&gt;
&lt;hr&gt;
&lt;form action=&quot;JSTL_CoreIf.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
        EL表达式获取表单中的数据
        $&#123;param.参数名&#125; &#125;
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;
&lt;%--判断如果是管理员则提交成功--%&gt;
&lt;c:if test=&quot;$&#123;param.username ==&#39;admin&#39;&#125;&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎你~~!&quot;/&gt;
&lt;/c:if&gt;
&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%--定义一个变量 值为85--%&gt;
    &lt;c:set var=&quot;score&quot; value=&quot;85&quot;/&gt;
&lt;c:choose&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt;
        你的分数挺高!~
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt;
        你的分数还行
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt;
        你的分数一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&lt;=60&#125;&quot;&gt;
        你的分数想死
    &lt;/c:when&gt;
&lt;/c:choose&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="六、JavaBean"><a href="#六、JavaBean" class="headerlink" title="六、JavaBean"></a>六、JavaBean</h2><p>实体类</p>
<p>JavaBean有特定的写法:</p>
<ul>
<li>必须有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法</li>
</ul>
<p>**_<strong>一般来和数据库字段做映射</strong>_**ORM</p>
<p>ORM对象关系映射</p>
<ul>
<li><p>表——&gt;类</p>
</li>
<li><p>字段—-&gt;属性</p>
</li>
<li><p>行记录——&gt;对象</p>
<p>People表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小猪</td>
<td>3</td>
<td>广州</td>
</tr>
<tr>
<td>2</td>
<td>小猪</td>
<td>15</td>
<td>上海</td>
</tr>
<tr>
<td>3</td>
<td>小猪</td>
<td>88</td>
<td>北京</td>
</tr>
</tbody></table>
<pre><code class="java">class People&#123;
    private int id;
    private String name;
    private int age; 
    private String address;
&#125;

class A&#123;
    new people(1,&quot;小猪&quot;,3,&quot;广州&quot;);
     new people(2,&quot;小猪&quot;,15,&quot;上海&quot;);
     new people(3,&quot;小猪&quot;,88,&quot;北京&quot;);
&#125;
</code></pre>
<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC复习,如何使用JDBC , JDBC crud , JDBC事物</li>
</ul>
<h2 id="七、三层架构MVC"><a href="#七、三层架构MVC" class="headerlink" title="七、三层架构MVC"></a>七、三层架构MVC</h2><p><strong>MVC是啥?</strong> model view controller 模型(实体类与数据库对应的字段) 视图(jsp页面) 控制器(Servlet) | 当前理解</p>
<p>Model</p>
<ul>
<li>业务处理: 业务逻辑 (service)</li>
<li>数据库持久层: CRUD (Dao)</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供连接发起servlet请求(a from img)</li>
</ul>
<p>Controller</p>
<ul>
<li>接受用户请求: request :请求参数,Session信息</li>
<li>交给业务层处理对应代码</li>
<li>控制视图的跳转</li>
</ul>
<pre><code class="xml">登录
----&gt;接受用户的登录请求
-----&gt;处理用户请求(获取用户登陆的参数 usename passworld)
----&gt;交给业务层处理登录业务(判断用户名 密码是否吻合 )
----&gt;Dao层查询用户名密码是否正确
---&gt;查数据库
</code></pre>
<h2 id="八、Filter过滤器"><a href="#八、Filter过滤器" class="headerlink" title="八、Filter过滤器"></a>八、Filter过滤器</h2><p><strong>Filter</strong>：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证…</li>
</ul>
<p><img src="https://gitee.com/xiaoyu-98/blogImage/raw/master/img/image-20210325121124401.png" alt="image-20210325121124401"></p>
<p>开发步骤:</p>
<ol>
<li>导包</li>
<li>编写过滤器</li>
<li>导包不要错(javax.servlet)</li>
<li>实现Filer接口,重写对应方法即可</li>
</ol>
<pre><code class="java">public class Filer implements Filter &#123;
    //初始化
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;初始化成功~~~~!&quot;);
    &#125;
    //初始化: web服务器启动时就初始化,随时等待过滤器对象的出现
    //Chain 链
    //1. 过滤器中的所有代码,在过滤特定请求时
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html; charset=UTF-8&quot;);
        System.out.println(&quot;执行前...&quot;);
        chain.doFilter(servletRequest, servletResponse);//让请求继续走,如果不写拦截停止
        System.out.println(&quot;执行后....&quot;);
    &#125;
    //销毁 web服务器关闭的时候才会被销毁
    public void destroy() &#123;
        System.out.println(&quot;已被销毁~~~~!&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li>在web.xml中配置Filter映射</li>
</ol>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;filer&lt;/filter-name&gt;
    &lt;filter-class&gt;com.zhu.Filer.Filer&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;!-- /*会过滤所有的请求--&gt;
    &lt;!--servlet/*会过滤所有servlet下的所有请求--&gt;
    &lt;filter-name&gt;filer&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<h2 id="九、监听器"><a href="#九、监听器" class="headerlink" title="九、监听器"></a>九、监听器</h2><p>监测网站在线人数（基于session）</p>
<p>1、编写一个监听器，实现HttpSessionListener</p>
<pre><code class="java">public class OnlineListenimplementsHttpSessionListener&#123;
    /**     
    * 监听session新创建时执行的方法     
    * @param se     
    */
    @Override
    public void sessionCreated(HttpSessionEvent se)&#123;
        ServletContext sc = se.getSession().getServletContext();
        System.out.println(&quot;sessionId:&quot;+ se.getSession().getId());
        Integer onlineCount =(Integer) sc.getAttribute(&quot;onlineCount&quot;);
        if(onlineCount ==null)&#123;            
            onlineCount =1;
        &#125;else&#123;           
            onlineCount++;
        &#125;        
        sc.setAttribute(&quot;onlineCount&quot;,onlineCount);&#125;
    
    /**     
    * 监听session销毁时执行方法     
    * @param se     
    */
    @Override
    public void sessionDestroyed(HttpSessionEvent se)&#123;
        ServletContext sc = se.getSession().getServletContext();
        Integer onlineCount =(Integer) sc.getAttribute(&quot;onlineCount&quot;);
        if(onlineCount ==null)&#123;            
            onlineCount =0;
        &#125;else&#123;            
            onlineCount--;
        &#125;
        System.out.println(&quot;销毁session了--监听到&quot;);        
        sc.setAttribute(&quot;onlineCount&quot;,onlineCount);
    &#125; 
&#125;
</code></pre>
<p>2、web.xml中注册监听器</p>
<pre><code class="xml">&lt;!--监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.bug.listener.OnlineListen&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>session销毁方法</p>
<ul>
<li>手动销毁 getSession().invalidate();</li>
<li>自动销毁 在web.xml中设置超时时间</li>
</ul>
<h2 id="十、-过滤器-监听器常见应用"><a href="#十、-过滤器-监听器常见应用" class="headerlink" title="十、 过滤器,监听器常见应用"></a>十、 过滤器,监听器常见应用</h2><p>监听器在javaGUI中常常被使用:</p>
<p>用户登录才能进入主页,注销后不能进去主页</p>
<h2 id="十一、SMBS-项目从头到尾"><a href="#十一、SMBS-项目从头到尾" class="headerlink" title="十一、SMBS 项目从头到尾"></a>十一、SMBS 项目从头到尾</h2><h3 id="11-1、-项目怎么搭建"><a href="#11-1、-项目怎么搭建" class="headerlink" title="11.1、 项目怎么搭建"></a>11.1、 项目怎么搭建</h3><h4 id="11-1-1、是否使用Maven"><a href="#11-1-1、是否使用Maven" class="headerlink" title="11.1.1、是否使用Maven"></a>11.1.1、是否使用Maven</h4><p>依赖 or jar包</p>
<h4 id="11-1-2、项目搭建的准备工作"><a href="#11-1-2、项目搭建的准备工作" class="headerlink" title="11.1.2、项目搭建的准备工作"></a>11.1.2、项目搭建的准备工作</h4><ol>
<li><p>搭建一个Maven Web 项目</p>
</li>
<li><p>配置Tomcat</p>
</li>
<li><p>测试项目是否能跑起来</p>
</li>
<li><p>导入项目的jar 包</p>
<p> JSP Servlet Mysql</p>
</li>
<li><p>创建项目包结构</p>
</li>
<li><p>编写实体类</p>
<p>ORM映射, 表-&gt;类映射</p>
</li>
<li><p>编写基础公共类</p>
</li>
</ol>
<h4 id="11-1-3、数据库配置文件"><a href="#11-1-3、数据库配置文件" class="headerlink" title="11.1.3、数据库配置文件"></a>11.1.3、数据库配置文件</h4><pre><code class="properties">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306?useUnicode=true &amp; characterEncoding=utf-8 
useername = root
password = 510562
</code></pre>
<p><strong>编写数据库的公共类</strong></p>
<pre><code class="java">package com.zhu.dao;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.*;
import java.util.Properties;
/**
 * 操作数据库的公共类
 */
public class BaseDao &#123;
    private static String driver;
    private static String url;
    private static String username;
    private static String password;
    
    //静态代码块,类加载的时候就会加载
    static &#123;
        Properties properties = new Properties();
        //通过类加载器读取资源
        InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);
        try &#123;
            properties.load(is);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        //获取 db.properties 中对应的数据
        driver = properties.getProperty(&quot;driver&quot;);
        url = properties.getProperty(&quot;url&quot;);
        username = properties.getProperty(&quot;username&quot;);
        password = properties.getProperty(&quot;password&quot;);
    &#125;
    
    //获取数据库的链接
    public static Connection getConnection() &#123;
        Connection connection = null;
        try &#123;
            Class.forName(driver);
            connection = DriverManager.getConnection(url, username, password);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return connection;
    &#125;
    
    //编写查询公共类
    public static ResultSet excute(Connection connection, String sql, Object[] params, ResultSet resultSet, PreparedStatement preparedStatement) throws SQLException &#123;
        //预编译的SQL在后边直接执行就行
        preparedStatement = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; params.length; i++) &#123;
            //setobject ,占位符从1开始,  数组从0开始
            preparedStatement.setObject(i + 1, params[i]);
        &#125;
        resultSet = preparedStatement.executeQuery();
        return resultSet;
    &#125;
    
    //编写增删改公共方法
    public static int excute(Connection connection, String sql, Object[] params, PreparedStatement preparedStatement) throws SQLException &#123;
        preparedStatement = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; params.length; i++) &#123;
            //setobject ,占位符从1开始,  数组从0开始
            preparedStatement.setObject(i + 1, params[i]);
        &#125;
        int updateRow = preparedStatement.executeUpdate();
        return updateRow;
    &#125;
    
    //关闭链接,释放资源
    public static boolean closeResource(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123;
        boolean flag = true;
        if (resultSet != null) &#123;
            try &#123;
                resultSet.close();
                //GC回收
                resultSet = null;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        if (connection != null) &#123;
            try &#123;
                connection.close();
                //GC回收
                connection = null;
                ;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        &#125;
        if (resultSet != null) &#123;
            try &#123;
                resultSet.close();
                //GC回收
                resultSet = null;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
                flag = false;
            &#125;
        &#125;
        return flag;
    &#125;
&#125;
</code></pre>
<h3 id="11-2、编写字符编码过滤器"><a href="#11-2、编写字符编码过滤器" class="headerlink" title="11.2、编写字符编码过滤器"></a>11.2、编写字符编码过滤器</h3><h4 id="11-2-1、导入静态资源"><a href="#11-2-1、导入静态资源" class="headerlink" title="11.2.1、导入静态资源"></a>11.2.1、导入静态资源</h4><h4 id="11-2-2、登录功能实现"><a href="#11-2-2、登录功能实现" class="headerlink" title="11.2.2、登录功能实现"></a>11.2.2、登录功能实现</h4><ol>
<li>编写前端</li>
<li>设置首页</li>
<li>编写dao层,得到用户登陆的接口</li>
<li>编写dao接口的实现类</li>
<li>业务层接口</li>
<li>业务层实现类</li>
<li>编写Servlet</li>
<li>注册Servlet</li>
</ol>
<pre><code class="xml">&lt;session-config&gt;&lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt;
</code></pre>
<pre><code class="xml">  以下是mavaen推荐的项目目录.
  ├── pom.xml
  └── src
      ├── main
      │   ├── java
      │   │   └── group
      │   │       ├── controller
      │   │       │   ├── HomeController.java
      │   │       │   └── PersonController.java
      │   │       ├── dao
      │   │       │   └── PersonDao.java
      │   │       └── model
      │   │           └── Person.java
      │   ├── resources
      │   │   ├── db.properties
      │   │   ├── log4j.xml
      │   │   └── META-INF
      │   │       └── persistence.xml
      │   └── webapp
      │       ├── index.html
      │       ├── META-INF
      │       │   ├── context.xml
      │       │   └── MANIFEST.MF
      │       ├── resources
      │       │   └── css
      │       │       └── screen.css
      │       └── WEB-INF
      │           ├── spring
      │           │   ├── app
      │           │   │   ├── controllers.xml
      │           │   │   └── servlet-context.xml
      │           │   ├── db.xml
      │           │   └── root-context.xml
      │           ├── views
      │           │   ├── edit.jsp
      │           │   ├── home.jsp
      │           │   └── list.jsp
      │           └── web.xml
      └── test
          ├── java
          │   └── group
          │       ├── controller
          │       │   ├── DataInitializer.java
          │       │   ├── HomeControllerTest.java
          │       │   └── PersonControllerTest.java
          │       └── dao
          │           └── PersonDaoTest.java
          └── resources
              ├── db.properties
              ├── log4j.xml
              ├── test-context.xml
              └── test-db.xml
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Shuyan
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Shuyan
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>