<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>SpringMVC使用详解 | Shuyan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SpringMVC使用详解一、SpringMVC简介1.1、什么是 SpringMVC​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架 1.2、为什么学习 SpringMVC​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC使用详解">
<meta property="og:url" content="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="SpringMVC使用详解一、SpringMVC简介1.1、什么是 SpringMVC​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架 1.2、为什么学习 SpringMVC​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="article:published_time" content="2022-03-17T03:29:01.000Z">
<meta property="article:modified_time" content="2022-03-17T03:50:53.859Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
  
    <link rel="alternate" href="/atom.xml" title="Shuyan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shuyan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA/Spring框架/SpringMVC/SpringMVC使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-03-17T03:29:01.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a>►<a class="article-category-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SpringMVC使用详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringMVC使用详解"><a href="#SpringMVC使用详解" class="headerlink" title="SpringMVC使用详解"></a>SpringMVC使用详解</h1><h2 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h2><h3 id="1-1、什么是-SpringMVC"><a href="#1-1、什么是-SpringMVC" class="headerlink" title="1.1、什么是 SpringMVC"></a>1.1、什么是 SpringMVC</h3><p>​        Spring MVC 是 Spring Framework 的一部分，是基于 Java 实现 MVC 的轻量级 Web 框架</p>
<h3 id="1-2、为什么学习-SpringMVC"><a href="#1-2、为什么学习-SpringMVC" class="headerlink" title="1.2、为什么学习 SpringMVC"></a>1.2、为什么学习 SpringMVC</h3><p>​        因为 SpringMVC “简单好学”，便捷，能与 Spring 无缝集成（SpringIOC、AOP），使用约定大于配置，能够进行简单的 junit 测试，支持 Restful 风格，异常处理，本地化，国际化，数据验证，类型转换，拦截器，等等</p>
<h3 id="1-3、SpringMVC-的特点"><a href="#1-3、SpringMVC-的特点" class="headerlink" title="1.3、SpringMVC 的特点"></a>1.3、SpringMVC 的特点</h3><ul>
<li>简单好学</li>
<li>高效（基于请求相应的 MVC 框架）</li>
<li>与 Spring 无缝集成，兼容性好</li>
<li>约定大于配置</li>
<li>功能强大（Restful、数据验证、格式化、本地化、类型转换、等等）</li>
<li>简洁灵活</li>
</ul>
<h2 id="二、中心控制器"><a href="#二、中心控制器" class="headerlink" title="二、中心控制器"></a>二、中心控制器</h2><p>​        Spring 的 web 框架围绕 DispatcherServlet 设计。<strong>DispatcherServlet 的作用是将请求分发到不同的处理器</strong>。从 Spring 2.5 开始，使用 Java 5 或者以上版本的用户可以采用基于注解的 controller 声明方式。</p>
<p>​        Spring MVC 框架像许多其他 MVC 框架一样, 以请求为驱动 , 围绕一个中心 Servlet 分派请求及提供其他功能，DispatcherServlet 是一个实际的 Servlet (它继承自 HttpServlet 基类)。</p>
<p><img src="https://img-blog.csdnimg.cn/441a74b64c644a4b93927bab0306f534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        SpringMVC的原理如下图所示：</p>
<ul>
<li>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</li>
</ul>
<h2 id="三、SpringMVC原理"><a href="#三、SpringMVC原理" class="headerlink" title="三、SpringMVC原理"></a>三、SpringMVC原理</h2><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://img-blog.csdnimg.cn/7b38f8444d9d4d78a90640c64839f5b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringMVC执行原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/82601aa48ca44254b397e8e459b34b8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>​        实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet 表示前置控制器，是整个 SpringMVC 的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。</p>
<p>​        我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p>​        如上 url 拆分成三部分：</p>
<ul>
<li><p> <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 服务器域名</p>
</li>
<li><p> SpringMVC 部署在服务器上的 web 站点</p>
</li>
<li><p>hello 表示控制器</p>
</li>
</ul>
<p> 通过分析，如上 url 表示为：请求位于服务器 localhost:8080上的Spring MVC站点的 hello 控制器。</p>
</li>
<li><p>HandlerMapping 为处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</p>
</li>
<li><p>HandlerExecution 表示具体的Handler，其主要作用是根据 url 查找控制器，如上 url 被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution 将解析后的信息传递给 DispatcherServlet，如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行 Handler。</p>
</li>
<li><p>Handler 让具体的 Controller 执行。</p>
</li>
<li><p>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</p>
</li>
<li><p>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="四、HelloSpringMVC"><a href="#四、HelloSpringMVC" class="headerlink" title="四、HelloSpringMVC"></a>四、HelloSpringMVC</h2><h3 id="4-1、配置版"><a href="#4-1、配置版" class="headerlink" title="4.1、配置版"></a>4.1、配置版</h3><p><strong>步骤：</strong></p>
<ol>
<li>新建一个 项目，添加 web 支持</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件（springmvc-service.xml）</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
</ol>
<pre><code class="xml">&lt;!--配置DispatchServlet：这个是SpringMVC的核心：请求分发器，前端控制器--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--DispatchServlet要绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-service.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--
    在Spring中，/ 与 /* 的区别
    /:只匹配所有的请求，不会去匹配jsp
    /*：匹配所有请求，包括jsp页面
--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>继续配置 SpringMVC 的配置文件（springmvc-servlet.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>添加 <strong>处理映射器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>处理器适配器</strong></li>
</ul>
<pre><code class="xml">&lt;!--处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加 <strong>视图解析器</strong></li>
</ul>
<pre><code class="xml">&lt;!--视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="6">
<li>编写操作业务的 Controller</li>
</ol>
<ul>
<li>要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图</li>
</ul>
<pre><code class="java">public class HelloController implements Controller &#123;
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //业务代码
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC！&quot;);
        
        //视图解释
        mv.setViewName(&quot;hello&quot;);//需要拼接的视图名称，参考视图解析器的代码实际地址就是（/WEB-INF/jsp/hello.jsp）
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>注册 bean（将 HelloController 这个类交给 Spring 容器【IOC】）</li>
</ol>
<pre><code class="xml">&lt;!--BeanNameUrlHandlerMapping:匹配的id(Handler)--&gt;
&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.aze.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="8">
<li>编写跳转页面，显示 ModelandView 存放的数据，以及我们编写的页面</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><strong>大多数都会遇到的问题！</strong></p>
<p>即使你的代码正确，但是却一直报出 404 错误！</p>
<ul>
<li><p>问题原因可能就在于 IDEA 项目发布中，缺少了 springMVC 相关的 jar 包</p>
</li>
<li><p>解决办法：</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/281cc79568cc4bbfbc95ebf8f7ce8581.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>在 WEB-INF 下创建一个 lib 目录，在这个目录下存放 相关的 jar 包</p>
<p><img src="https://img-blog.csdnimg.cn/6f4ae1e0ae5547ba85752fa779e91d75.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将所有的<strong>包</strong>导入，点击 ok</p>
</li>
</ul>
</li>
</ul>
<p>​                </p>
<p><img src="https://img-blog.csdnimg.cn/a5eb9eba82fc43f5b8f352204787aea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2、注解版（-）"><a href="#4-2、注解版（-）" class="headerlink" title="4.2、注解版（*）"></a>4.2、注解版（*）</h3><p>步骤：</p>
<ol>
<li>新建一个项目，添加 web 支持</li>
<li>解决 Maven 可能存在资源过滤的问题</li>
</ol>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ol start="3">
<li><p>在 pom.xml 文件引入相关的依赖：主要有 Spring 框架核心库、Spring MVC、servlet , JSTL 等</p>
</li>
<li><p>配置 web.xml</p>
</li>
</ol>
<pre><code class="xml">&lt;!--这是使用注解开发时固定的配置--&gt;
&lt;!--注册servlet--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--初始化Spring配置文件的位置--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动顺序，数字越小，启动越早--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!--所有的请求都会被SpringMVC拦截--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>编写 springmvc-servlet.xml 配置文件</li>
</ol>
<ul>
<li>配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能</li>
<li>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问<ul>
<li>让IOC的注解生效（context:component-scan base-package=””）</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …（mvc:default-servlet-handler）</li>
<li>MVC的注解驱动（mvc:annotation-driven）</li>
<li>配置视图解析器（开发中，程序员只需要配置这一步，其他的都是死的，CV 就可以）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
    &lt;!--这也是固定配置，需要修改的只有需要注入IOC的包--&gt;
    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="6">
<li>编写一个 Java 控制类 HelloController.java</li>
</ol>
<ul>
<li>@Controller 是为了让 Spring IOC 容器初始化时自动扫描到；</li>
<li>@RequestMapping 是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是 /hello/hi；</li>
<li>方法中声明 Model 类型的参数是为了把 Action 中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称 hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</li>
</ul>
<pre><code class="java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    //类上注册了@RequestMapping方法就自动下移，实际地址：项目名/hello/hi
    @RequestMapping(&quot;/hi&quot;)
    public String sayHello(Model model)&#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVCAnnotatiom!&quot;);
        //web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ol start="7">
<li>编写视图层 hello.jsp</li>
</ol>
<ul>
<li>视图可以直接取出并展示从 Controller 带回的信息；</li>
<li>可以通过 EL 表示取出 Model 中存放的值，或者对象</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            $&#123;msg&#125;
        &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h3 id="4-3、结论"><a href="#4-3、结论" class="headerlink" title="4.3、结论"></a>4.3、结论</h3><p>实现步骤：</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
<li><p>编写 web.xml , 注册 DispatcherServlet</p>
</li>
<li><p>编写 springmvc 配置文件</p>
</li>
<li><p>接下来就是去创建对应的控制类 , controller</p>
</li>
<li><p>最后完善前端视图和 controller 之间的对应</p>
</li>
<li><p>测试运行调试.</p>
</li>
</ol>
<p><strong>使用springMVC必须配置的三大件：</strong></p>
<ul>
<li><p>处理器映射器</p>
</li>
<li><p>处理器适配器</p>
</li>
<li><p>视图解析器</p>
</li>
</ul>
<p>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。</p>
<h2 id="五、注解"><a href="#五、注解" class="headerlink" title="五、注解"></a>五、注解</h2><h3 id="5-1、Controller"><a href="#5-1、Controller" class="headerlink" title="5.1、Controller"></a>5.1、Controller</h3><p>Controller 控制器</p>
<p>负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
<p>负责解析用户的请求并将其转换为一个模型。</p>
<p>在 Spring MVC 中一个控制器类可以包含多个方法</p>
<p>在 Spring MVC 中，对于 Controller 的配置方式有很多种</p>
<h4 id="5-1-1、实现-Controller-接口"><a href="#5-1-1、实现-Controller-接口" class="headerlink" title="5.1.1、实现 Controller 接口"></a>5.1.1、实现 Controller 接口</h4><p>Controller是一个接口</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p>步骤：（上面 HelloSpringMVC 的配置版就是 实现 Controller 接口）</p>
<ol>
<li><p>新建一个 web 项目</p>
</li>
<li><p>导入 SpringMVC 的依赖</p>
</li>
<li><p>创建 SpringMVC 的配置文件（springmvc-service.xml）</p>
<ul>
<li>删掉 HelloController</li>
<li>只留下 视图解析器！</li>
</ul>
</li>
<li><p>配置 web.xml，注册 DispatcherServlet</p>
</li>
<li><p>编写一个 Controller 类</p>
</li>
<li><p>编写完毕后，去 Spring 配置文件中注册请求的 bean</p>
<ul>
<li>name 对应请求路径</li>
<li>class 对应处理请求的类</li>
</ul>
</li>
<li><p>编写前端 hello.jsp</p>
<ul>
<li>注意：在 WEB-INF/jsp 目录下编写，对应我们的视图解析器</li>
</ul>
</li>
<li><p>配置 Tomcat 运行测试<br>注意：实现接口 Controller 定义控制器是较老的办法<br>缺点：</p>
<ul>
<li>一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</li>
<li>定义的方式比较麻烦；</li>
</ul>
</li>
</ol>
<h4 id="5-1-2、注解-Controller"><a href="#5-1-2、注解-Controller" class="headerlink" title="5.1.2、注解 @Controller"></a>5.1.2、注解 @Controller</h4><ul>
<li>@Controller 注解类型用于声明 Spring 类的实例是一个控制器（<ul>
<li><strong>@Controller：</strong>用于controller</li>
<li><strong>@Component：</strong>用于组件</li>
<li><strong>@Repository：</strong>用于 dao</li>
<li><strong>@Service：</strong>用于 service</li>
</ul>
</li>
<li>Spring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证 Spring 能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<p>步骤：（4.2 注解版就是用注解 @Controller）</p>
<ol>
<li>新建一个 web 项目</li>
<li>导入 SpringMVC 的依赖</li>
<li>创建 SpringMVC 的配置文件</li>
<li>配置 web.xml，注册 DispatcherServlet</li>
<li>编写一个 Controller 类</li>
<li>使用注解（）</li>
<li>编写前端 hello.jsp</li>
<li>配置 Tomcat 运行测试</li>
</ol>
<h3 id="5-2、RequestMapping"><a href="#5-2、RequestMapping" class="headerlink" title="5.2、RequestMapping"></a>5.2、RequestMapping</h3><ul>
<li>@RequestMapping<pre><code>+ @RequestMapping 注解用于映射 url 到控制器类或一个特定的处理程序方法。
</code></pre>
可用于类或方法上<ul>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<ul>
<li>用于方法上，方法的响应请求是该地址</li>
</ul>
</li>
</ul>
<strong>建议：</strong>类上不要使用此注解</li>
</ul>
<h2 id="六、RestFul风格"><a href="#六、RestFul风格" class="headerlink" title="六、RestFul风格"></a>六、RestFul风格</h2><h3 id="6-1、什么是-RestFul"><a href="#6-1、什么是-RestFul" class="headerlink" title="6.1、什么是 RestFul"></a>6.1、什么是 RestFul</h3><p>Restful 就是一个资源定位及资源操作的风格。</p>
<ul>
<li>不是标准也不是协议，只是一种风格</li>
<li>基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
</ul>
<h3 id="6-2、RestFul-功能"><a href="#6-2、RestFul-功能" class="headerlink" title="6.2、RestFul 功能"></a>6.2、RestFul 功能</h3><p>资源：互联网所有的事物都可以被抽象为资源</p>
<ul>
<li><p>资源操作：使用 POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
</li>
<li><p>分别对应 添加、 删除、修改、查询。</p>
</li>
</ul>
<p><strong>传统方式操作资源 ：</strong>通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源 ：</strong>可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p> <a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<h3 id="6-3、测试-RestFul-风格"><a href="#6-3、测试-RestFul-风格" class="headerlink" title="6.3、测试 RestFul 风格"></a>6.3、测试 RestFul 风格</h3><h4 id="6-3-1、使用-RequestMapping"><a href="#6-3-1、使用-RequestMapping" class="headerlink" title="6.3.1、使用 @RequestMapping"></a>6.3.1、使用 @RequestMapping</h4><p>步骤：</p>
<ol>
<li><p>新建一个 Controller 类，用于测试 RestFul 风格</p>
</li>
<li><p>在 Spring MVC 中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
</li>
</ol>
<pre><code class="java">@Controller
public class RestFulTest &#123;

    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;
        int result = a + b;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;hello&quot;;
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/82da90c58c4a4cff945b48160031cd47.png#pic_center" alt="在这里插入图片描述"></p>
<ol start="4">
<li>修改下对应的参数类型，再次测试</li>
</ol>
<pre><code class="java">// 将 int b，改为 String b
@PathVariable int a, @PathVariable String b
    
// 对应的 result 也需要改为 String
String result = a+b;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2023e0c16a774d3cafa1b68444f2961a.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="6-3-2、使用注解变体"><a href="#6-3-2、使用注解变体" class="headerlink" title="6.3.2、使用注解变体"></a>6.3.2、使用注解变体</h4><p>使用method属性指定请求类型：</p>
<ul>
<li>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE 等</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<p>问题？</p>
<p>​        这样写，代码量就会变多，这时候，注解变体他来了！<br>注解变体：（方法级别）</p>
<ul>
<li>@GetMapping：GET 类型</li>
<li>@PostMapping：POST 类型</li>
<li>@PutMapping：PUT 类型</li>
<li>@DeleteMapping：DELETE 类型</li>
<li>@PatchMapping：PATCH 类型</li>
</ul>
<pre><code class="java">// 使用注解变体
@GetMapping(&quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;)
// 等价于 @RequestMapping(value = &quot;/commit/&#123;a&#125;/&#123;b&#125;&quot;,method = &#123;RequestMethod.GET&#125;)
</code></pre>
<h3 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h3><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。（注意！！！）</p>
<p><strong>@GetMapping 是一个组合注解</strong>，平时使用的会比较多！</p>
<p>使用浏览器地址栏进行访问默认是 Get 请求，会报错 405</p>
<p>解决办法：将 POST 修改为 GET 就好了</p>
<h2 id="七、转发与重定向"><a href="#七、转发与重定向" class="headerlink" title="七、转发与重定向"></a>七、转发与重定向</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置 ModelAndView 对象 , 根据 view 的名称 , 和视图解析器跳到指定的页面 .</p>
<ul>
<li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li>
</ul>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>controller 类</li>
</ul>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>这是 JavaWeb 中学习到的用法：</p>
<ul>
<li>通过设置 ServletAPI，不需要视图解析器 .<ol>
<li>通过 HttpServletResponse 进行输出</li>
</ol>
</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/test1&quot;)
public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
&#125;
</code></pre>
<p>​        2. 通过 HttpServletResponse 实现重定向（重定向）</p>
<pre><code class="java">@RequestMapping(&quot;test2&quot;)
public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
    rsp.sendRedirect(&quot;/index.jsp&quot;);
&#125;
</code></pre>
<ol start="3">
<li>通过 HttpServletResponse 实现转发（请求转发）</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/test3&quot;)
public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
    // 转发
    req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
    req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
&#125;
</code></pre>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><h4 id="7-3-1、无视图解析器"><a href="#7-3-1、无视图解析器" class="headerlink" title="7.3.1、无视图解析器"></a>7.3.1、无视图解析器</h4><pre><code class="java">@RequestMapping(&quot;/rsm/t1&quot;)
public String test1()&#123;
    // 默认就是转发
    return &quot;/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t2&quot;)
public String test2()&#123;
    // 也可以显示定义转发
    return &quot;forward:/index.jsp&quot;;
&#125;

@RequestMapping(&quot;/rsm/t3&quot;)
public String test3()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
<h4 id="7-3-2、有视图解析器"><a href="#7-3-2、有视图解析器" class="headerlink" title="7.3.2、有视图解析器"></a>7.3.2、有视图解析器</h4><p>​        重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方 , 所以注意路径问题.</p>
<pre><code class="java">@RequestMapping(&quot;/rsm2/t1&quot;)
public String test1()&#123;
    // 转发：默认就是转发
    return &quot;test&quot;;
&#125;

@RequestMapping(&quot;/rsm2/t2&quot;)
public String test2()&#123;
    // 重定向：需要显示定义
    return &quot;redirect:/index.jsp&quot;;
    // return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
&#125;
</code></pre>
<h2 id="八、数据处理"><a href="#八、数据处理" class="headerlink" title="八、数据处理"></a>八、数据处理</h2><h3 id="8-1、处理提交数据"><a href="#8-1、处理提交数据" class="headerlink" title="8.1、处理提交数据"></a>8.1、处理提交数据</h3><ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数名不一致，就需要使用注解 @RequestParam 来解决</li>
</ol>
<pre><code class="java">// @RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<ul>
<li>实体类</li>
</ul>
<pre><code class="java">// 这里使用的是 Lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    private int id;
    private String name;
    private int age;
&#125;
</code></pre>
<ul>
<li>Controller 类</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<h3 id="8-2、数据显示到前端"><a href="#8-2、数据显示到前端" class="headerlink" title="8.2、数据显示到前端"></a>8.2、数据显示到前端</h3><ol>
<li>通过 ModelAndView</li>
</ol>
<pre><code class="java">public class ControllerTest implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        // 返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>通过ModelMap</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<ol start="3">
<li>通过 Model</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<p>区别：</p>
<ul>
<li><p>Model：只有寥寥几个方法只适合用于储存数据，简化了新手对于 Model 对象的操作和理解</p>
</li>
<li><p>ModelMap：继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView：可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<h2 id="九、中文乱码问题"><a href="#九、中文乱码问题" class="headerlink" title="九、中文乱码问题"></a>九、中文乱码问题</h2><p>解决办法：</p>
<ol>
<li>自我编写一个过滤器，再注册到 web.xml 文件中</li>
</ol>
<pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;

    // 初始化：web 服务器启动，就已经初始化了，随时等待过滤对象的出现
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    // 销毁：web 服务器关闭时，过滤器会销毁
    public void destroy() &#123;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用 SpringMVC 自带的过滤器</li>
</ol>
<ul>
<li>导入相关依赖后，直接配置 web.xml 即可</li>
</ul>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="3">
<li>使用大佬配置的过滤器</li>
</ol>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                                       .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
<p>​        以上都不行可能是你的 Tomcat 没有配置好！去修改 tomcat 配置文件 ：设置编码</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<h2 id="十、Json"><a href="#十、Json" class="headerlink" title="十、Json"></a>十、Json</h2><ul>
<li>JSON（JavaScript Object Notation, JS 对象标记） 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。（前后端分离）</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<h3 id="10-1、JSON-与-JavaScript"><a href="#10-1、JSON-与-JavaScript" class="headerlink" title="10.1、JSON 与 JavaScript"></a>10.1、JSON 与 JavaScript</h3><p>在 JavaScript 语言中，一切都是对象。因此，任何 JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li><p>对象表示为键值对，数据由逗号分隔</p>
</li>
<li><p>花括号保存对象</p>
</li>
<li><p>方括号保存数组</p>
</li>
</ul>
<p>​        <strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值（ {“键” : “值”} ）。</p>
<p>​        JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br><strong>JSON 和 JavaScript 对象互转：</strong></p>
<ul>
<li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法</li>
</ul>
<pre><code class="java">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);
</code></pre>
<ul>
<li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法</li>
</ul>
<pre><code class="java">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
<h3 id="10-2、Controller-返回-JSON-数据"><a href="#10-2、Controller-返回-JSON-数据" class="headerlink" title="10.2、Controller 返回 JSON 数据"></a>10.2、Controller 返回 JSON 数据</h3><ul>
<li>Jackson 应该是目前比较好的 json 解析工具了</li>
<li>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</li>
<li>这里使用的是 Jackson，使用它需要导入它的 jar 包；</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>web.xml 配置 SpringMVC 需要的配置<ul>
<li>servlet 注册 SpringMVC</li>
<li>filter 注册字符过滤器</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ul>
<li>编写 springmvc-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>编写一个实体类 User，去测试<ul>
<li>需要导入 lombok 的 jar 包</li>
</ul>
</li>
</ul>
<pre><code class="java">//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<ul>
<li>编写 UserController<ul>
<li>@ResponseBody：将 java 对象转化为 json</li>
<li>ObjectMapper：创建一个 jackson 的对象映射器，用来解析数据</li>
</ul>
</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置 Tomcat</li>
<li>配置 Artifacts</li>
</ul>
<p>问题：乱码问题</p>
<p><img src="https://img-blog.csdnimg.cn/ed4ce7fedb724bfeb2e95bc9786d3765.png#pic_center" alt="在这里插入图片描述"></p>
<p>解决办法：通过 @RequestMaping 的 produces 属性来实现</p>
<pre><code class="java">// produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
<h3 id="10-3、Controller-返回-JSON-数据代码优化"><a href="#10-3、Controller-返回-JSON-数据代码优化" class="headerlink" title="10.3、Controller 返回 JSON 数据代码优化"></a>10.3、Controller 返回 JSON 数据代码优化</h3><h4 id="10-3-1、将乱码问题统一解决"><a href="#10-3-1、将乱码问题统一解决" class="headerlink" title="10.3.1、将乱码问题统一解决"></a>10.3.1、将乱码问题统一解决</h4><p>上面解决乱码的方法在项目请求多的情况下就不适用了</p>
<p>就可以使用 Spring 配置统一指定返回类型和编码，等等</p>
<ul>
<li>在 spring-mvc 的配置文件上添加一段消息<ul>
<li>StringHttpMessageConverter 转换配置</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<h4 id="10-3-2、统一解决返回为-json-字符串问题"><a href="#10-3-2、统一解决返回为-json-字符串问题" class="headerlink" title="10.3.2、统一解决返回为 json 字符串问题"></a>10.3.2、统一解决返回为 json 字符串问题</h4><p>如果类中有所有的方法都需要返回 json 字符串，那么所有的方法都需要标识注释 @ResponseBody，这将会特别麻烦</p>
<ul>
<li>所以直接在类上使用 @RestController 来标注这个类的所有方法返回的都是 json 字符串<ul>
<li>这样就不用再每个方法上写 @ResponseBody</li>
<li>前后端分离开发中，一般都会使用 @RestController ，十分便捷</li>
</ul>
</li>
</ul>
<h3 id="10-4、测试集合的输出"><a href="#10-4、测试集合的输出" class="headerlink" title="10.4、测试集合的输出"></a>10.4、测试集合的输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
public String json2() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();

    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛逼1&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼2&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼3&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼4&quot;,18,&quot;男&quot;));
    userList.add(new User(&quot;大牛逼5&quot;,18,&quot;男&quot;));

    return mapper.writeValueAsString(userList);
&#125;
</code></pre>
<h3 id="10-5、测试时间对象输出"><a href="#10-5、测试时间对象输出" class="headerlink" title="10.5、测试时间对象输出"></a>10.5、测试时间对象输出</h3><p>在 UserController 中增加一个方法来进行测试</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;
    ObjectMapper mapper = new ObjectMapper();
    Date date = new Date();
    // 默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式
    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<p>默认的是日期格式，但是 Jackson 默认是会把时间转成 timestamps（时间戳）形式：</p>
<ul>
<li>取消 timestamps（时间戳）形式，自定义时间格式</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();

    return mapper.writeValueAsString(date);
&#125;
</code></pre>
<h3 id="10-6、将重复代码抽取为工具类"><a href="#10-6、将重复代码抽取为工具类" class="headerlink" title="10.6、将重复代码抽取为工具类"></a>10.6、将重复代码抽取为工具类</h3><p>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中</p>
<pre><code class="java">public class JsonUtils &#123;
    public static String getJson(Object object)&#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat)&#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>使用工具类后的代码量</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    return JsonUtils.getJson(new Date());
&#125;
</code></pre>
<h3 id="10-7、FastJson"><a href="#10-7、FastJson" class="headerlink" title="10.7、FastJson"></a>10.7、FastJson</h3><p>fastjson.jar 是阿里开发的一款专门用于 Java 开发的包，可以方便的实现多种转换，最后的实现结果都是一样的。</p>
<ul>
<li><p>实现 json 对象与 JavaBean 对象的转换</p>
</li>
<li><p>实现 JavaBean 对象与 json 字符串的转换</p>
</li>
<li><p>实现 json 对象与 json 字符串的转换。实现 son的 转换方法很多</p>
</li>
</ul>
<p><strong>fastjson 的 pom 依赖：</strong></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.78&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>JSONObject 代表 json 对象</strong></p>
<ul>
<li>JSONObject 实现了 Map 接口, 猜想 JSONObject 底层操作是由 Map 实现的。</li>
<li>JSONObject 对应 json对 象，通过各种形式的 get() 方法可以获取 json 对象中的数据，也可利用诸如 size()，isEmpty() 等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray 代表 json 对象数组</strong></p>
<ul>
<li>内部是有 List 接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON 代表 JSONObject 和 JSONArray 的转化</strong></p>
<ul>
<li>JSON 类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现 json 对象，json 对象数组，javabean 对象，json 字符串之间的相互转化。</li>
</ul>
<p>代码测试：</p>
<pre><code class="java">@RequestMapping(&quot;/json6&quot;)
public String json6()&#123;
    //创建一个对象
    User user1 = new User(&quot;1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    userList.add(user4);

    System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
    String str1 = JSON.toJSONString(userList);
    System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
    String str2 = JSON.toJSONString(user1);
    System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

    System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
    User jp_user1=JSON.parseObject(str2,User.class);
    System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

    System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
    JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
    System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

    System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
    User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
    System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    
    return JSON.toJSONString(userList);
&#125;
</code></pre>
<h2 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h2><h3 id="11-1、什么是-Ajax"><a href="#11-1、什么是-Ajax" class="headerlink" title="11.1、什么是 Ajax"></a>11.1、什么是 Ajax</h3><ul>
<li>AJAX（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML。</li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样!</li>
<li>传统的网页（即不用 ajax 技术的网页），想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</li>
</ul>
<h3 id="11-2、Ajax-原理"><a href="#11-2、Ajax-原理" class="headerlink" title="11.2、Ajax 原理"></a>11.2、Ajax 原理</h3><p><img src="https://img-blog.csdnimg.cn/12c950793aae4ade829c509dc47ac4fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byA546p5ZacNjY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="11-3、伪造-Ajax"><a href="#11-3、伪造-Ajax" class="headerlink" title="11.3、伪造 Ajax"></a>11.3、伪造 Ajax</h3><ol>
<li>新建一个项目，导入 web 支持</li>
<li>编写一个 前端页面，使用 iframe 进行测试</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function x() &#123;
            var url =  document.getElementById(&#39;url&#39;).value;
            document.getElementById(&#39;iframePosition&#39;).src = url;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;p&gt;请输入地址：&lt;/p&gt;
    &lt;p&gt;
        &lt;input id=&quot;url&quot; type=&quot;text&quot; placeholder=&quot;网页地址&quot;/&gt;
        &lt;input type=&quot;button&quot; value=&quot;前往&quot; onclick=&quot;x()&quot;&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 666px&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-4、jQuery-操作-ajax"><a href="#11-4、jQuery-操作-ajax" class="headerlink" title="11.4、jQuery 操作 ajax"></a>11.4、jQuery 操作 ajax</h3><ul>
<li>使用jquery提供的，方便，有兴趣的可以自己去了解下 JS 原生 XMLHttpRequest ！<ul>
<li>Ajax 的核心是 XMLHttpRequest 对象（XHR）。XHR 为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
</ul>
</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="js">jQuery.ajax(...)
      部分参数：
            url：请求地址
            type：请求方式，GET、POST（1.9.0之后用method）
        headers：请求头
            data：要发送的数据
    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
          async：是否异步
        timeout：设置请求超时时间（毫秒）
      beforeSend：发送请求前执行的函数(全局)
        complete：完成之后执行的回调函数(全局)
        success：成功之后执行的回调函数(全局)
          error：失败之后执行的回调函数(全局)
        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
        dataType：将服务器端返回的数据转换成指定类型
          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<h3 id="11-5、原始的-HttpServletResponse-实现"><a href="#11-5、原始的-HttpServletResponse-实现" class="headerlink" title="11.5、原始的 HttpServletResponse 实现"></a>11.5、原始的 HttpServletResponse 实现</h3><ol>
<li>配置 web.xml</li>
</ol>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol start="2">
<li>springmvc 配置文件（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li><p>静态资源过滤和注解驱动配置（我的父工程已经配置了，所以这就不配了）</p>
</li>
<li><p>编写 Controller 类</p>
</li>
</ol>
<pre><code class="java">@RestController
public class UserController &#123;

    @RequestMapping(&quot;/a&quot;)
    public void ajax(String name, HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().write(&quot;true&quot;);
        &#125;else &#123;
            response.getWriter().write(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>导入 jQuery</p>
</li>
<li><p>编写前端页面</p>
</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ajaxTest&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function a1()&#123;
        $.post(&#123;
          url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
          data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
          success:function (data,status) &#123;
            alert(data);
            alert(status);
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; οnblur=&quot;a1()&quot;/&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="11-6、SpringMVC-实现异步加载数据"><a href="#11-6、SpringMVC-实现异步加载数据" class="headerlink" title="11.6、SpringMVC 实现异步加载数据"></a>11.6、SpringMVC 实现异步加载数据</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    userList.add(new User(&quot;大牛&quot;,10,&quot;男&quot;));
    userList.add(new User(&quot;中牛&quot;,11,&quot;女&quot;));
    userList.add(new User(&quot;小牛&quot;,12,&quot;男&quot;));
    return userList;
&#125;
</code></pre>
<ol start="2">
<li>在 index 中增加内容</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;取得信息&quot;&gt;
  &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">$(function () &#123;
    $(&quot;#btn&quot;).click(function () &#123;
        $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
            console.log(data)
            var html=&quot;&quot;;
            for (let i = 0; i &lt; data.length ; i++) &#123;
                html+= &quot;&lt;tr&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                    &quot;&lt;/tr&gt;&quot;
            &#125;
            $(&quot;#content&quot;).html(html);
        &#125;);
    &#125;)
&#125;)
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<h3 id="11-7、注册提示效果"><a href="#11-7、注册提示效果" class="headerlink" title="11.7、注册提示效果"></a>11.7、注册提示效果</h3><ol>
<li>编写 Controller 类</li>
</ol>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String oldPwd,String newPwd, String newPwd2)&#123;
    String msg = &quot;&quot;;
    if (name != null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;用户名不存在&quot;;
        &#125;
    &#125;
    if (oldPwd != null)&#123;
        if (&quot;123456&quot;.equals(oldPwd))&#123;
            msg = &quot;ok&quot;;
        &#125;else &#123;
            msg = &quot;旧密码有误&quot;;
        &#125;
    &#125;
    return msg;
&#125;
</code></pre>
<ol start="2">
<li>编写前端</li>
</ol>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;name&quot; οnblur=&quot;a3_1()&quot;&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
    旧密码：&lt;input type=&quot;password&quot; id=&quot;oldPwd&quot; οnblur=&quot;a3_2()&quot;&gt;
    &lt;span id=&quot;oldPwdInfo&quot;&gt;&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function a3_1() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;name&quot;:$(&#39;#name&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#userInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#userInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
function a3_2() &#123;
  $.post(&#123;
    url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
    data: &#123;&quot;oldPwd&quot;:$(&#39;#oldPwd&#39;).val()&#125;,
    success:function (data) &#123;
      if (data.toString() === &#39;ok&#39;)&#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;green&quot;);
      &#125;else &#123;
        $(&#39;#oldPwdInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);
      &#125;
      $(&#39;#oldPwdInfo&#39;).html(data)
    &#125;
  &#125;)
&#125;
</code></pre>
<ol start="3">
<li>解决乱码问题（applicationContext.xml）</li>
</ol>
<pre><code class="xml">&lt;!--统一的解决乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<h2 id="十二、拦截器"><a href="#十二、拦截器" class="headerlink" title="十二、拦截器"></a>十二、拦截器</h2><h3 id="12-1、什么是拦截器"><a href="#12-1、什么是拦截器" class="headerlink" title="12.1、什么是拦截器"></a>12.1、什么是拦截器</h3><p>​        SpringMVC 的处理器、拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<ul>
<li><p>过滤器</p>
<ul>
<li>servlet 规范中的一部分，任何 java web工程都可以使用</li>
<li>在 url-pattern 中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li><p>拦截器</p>
<ul>
<li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是 jsp、html、css、image、js 是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="12-2、自定义拦截器"><a href="#12-2、自定义拦截器" class="headerlink" title="12.2、自定义拦截器"></a>12.2、自定义拦截器</h3><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>配置 web.xml 和 applicationContext.xml</p>
</li>
<li><p>编写一个拦截器</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在 springmvc 配置文件中配置拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class TestController &#123;

    @RequestMapping(&quot;/t1&quot;)
    public String test()&#123;
        System.out.println(&quot;控制器方法执行！&quot;);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
</code></pre>
<ol start="7">
<li>测试</li>
</ol>
<h3 id="12-3、验证用户是否登录（认证用户）"><a href="#12-3、验证用户是否登录（认证用户）" class="headerlink" title="12.3、验证用户是否登录（认证用户）"></a>12.3、验证用户是否登录（认证用户）</h3><p><strong>测试思路：</strong></p>
<ul>
<li>有一个登陆页面，需要写一个 controller 访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在 controller 中处理。判断用户名密码是否正确。如果正确，向 session 中写入用户信息。返回登陆成功。</li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>编写登录页面（login.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;

    &lt;h1&gt;登录页面&lt;/h1&gt;
    &lt;hr&gt;

    &lt;body&gt;
        &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt;
            用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;br&gt;
            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; required&gt; &lt;br&gt;
            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>编写 Controller 类处理请求</li>
</ol>
<pre><code class="java">package com.aze.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>编写登录成功页面（success.jsp）</li>
</ol>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;登录成功页面&lt;/h1&gt;
        &lt;hr&gt;

        $&#123;user&#125;
        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>编写首页，来测试页面跳转（index.jsp）</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 16:29
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;测试&lt;/a&gt;
  &lt;/div&gt;

  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;hr&gt;
    &lt;%--登录--%&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>编写用户登录拦截器</li>
</ol>
<pre><code class="java">package com.aze.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;url: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

&#125;
</code></pre>
<ol start="6">
<li>在 springmvc 配置文件中注册拦截器</li>
</ol>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.aze.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.aze.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ol start="7">
<li><p>配置 Tomcat</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="13、文件上传和下载"><a href="#13、文件上传和下载" class="headerlink" title="13、文件上传和下载"></a>13、文件上传和下载</h2><h3 id="13-1、准备测试"><a href="#13-1、准备测试" class="headerlink" title="13.1、准备测试"></a>13.1、准备测试</h3><p>​        文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是 SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用 Spring 的文件上传功能，则需要在上下文中配置 MultipartResolver。</p>
<p>​        前端表单要求：为了能上传文件，必须将表单的 method 设置为 POST，并将 enctype 设置为 multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p>对表单中的 enctype 属性做个详细的说明：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>​        一旦设置了 enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的 HTTP 响应。在2003年，Apache Software Foundation 发布了开源的 Commons FileUpload 组件，其很快成为 Servlet/JSP 程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0 规范已经提供方法来处理文件上传，但这种上传需要在 Servlet中完成。</li>
<li>而 Spring MVC 则提供了更简单的封装。</li>
<li>Spring MVC 为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver 实现的。</li>
<li>Spring MVC 使用 Apache Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver。</li>
<li>因此，SpringMVC 的文件上传还需要依赖 Apache Commons FileUpload 的组件。</li>
</ul>
<h3 id="13-2、文件上传"><a href="#13-2、文件上传" class="headerlink" title="13.2、文件上传"></a>13.2、文件上传</h3><ol>
<li><p>新建一个项目，添加 web 支持</p>
</li>
<li><p>导入相关 jar 包</p>
</li>
</ol>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--文件上传--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet-api导入高版本的--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.aze.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--统一的解决乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>在 applicationContext.xml 中添加 bean 配置</li>
</ol>
<ul>
<li><strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong></li>
</ul>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>编写前端页面</li>
</ol>
<pre><code class="html">&lt;%--
  Created by IntelliJ IDEA.
  User: Hasaki
  Date: 2021/10/3
  Time: 17:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;div&gt;
    &lt;form action=&quot;/upload2&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>编写 Controller</li>
</ol>
<pre><code class="java">@RestController
public class FileController &#123;
    
&#125;
</code></pre>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="java">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
//批量上传CommonsMultipartFile则为数组即可
@RequestMapping(&quot;/upload&quot;)
public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

    //获取文件名 : file.getOriginalFilename();
    String uploadFileName = file.getOriginalFilename();

    //如果文件名为空，直接回到首页！
    if (&quot;&quot;.equals(uploadFileName))&#123;
        return &quot;redirect:/index.jsp&quot;;
    &#125;
    System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    //如果路径不存在，创建一个
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    InputStream is = file.getInputStream(); //文件输入流
    OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

    //读取写出
    int len=0;
    byte[] buffer = new byte[1024];
    while ((len=is.read(buffer))!=-1)&#123;
        os.write(buffer,0,len);
        os.flush();
    &#125;
    os.close();
    is.close();
    return &quot;success&quot;;
&#125;
</code></pre>
<ul>
<li>方式二：采用 file.Transto 来保存上传的文件</li>
</ul>
<pre><code class="java">/*
    * 采用file.Transto 来保存上传的文件
*/
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;success&quot;;
&#125;
</code></pre>
<p>7.配置 Tomcat</p>
<ol start="8">
<li>测试</li>
</ol>
<h3 id="13-3、文件下载"><a href="#13-3、文件下载" class="headerlink" title="13.3、文件下载"></a>13.3、文件下载</h3><p>步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>Controller 类添加</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;baidu.png&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端添加</p>
<pre><code class="html">&lt;div&gt;
  &lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
&lt;/div&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringMVC/SpringMVC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" data-id="cl0us61fs003gkovs9k0a357b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SpringBoot使用详解
        
      </div>
    </a>
  
  
    <a href="/2022/03/17/C%E8%AF%AD%E8%A8%80/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">STL六个组件简介</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/">“Spring框架”</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Mybaits/">Mybaits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/%E2%80%9CSpring%E6%A1%86%E6%9E%B6%E2%80%9D/SpringMVC/">SpringMVC</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybaits/" rel="tag">Mybaits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">G1使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">JVM使用详解</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/JavaWeb/">JavaWeb</a>
          </li>
        
          <li>
            <a href="/2022/03/17/JAVA/Spring%E6%A1%86%E6%9E%B6/JavaWeb/helloservlet/">配置文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Shuyan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>