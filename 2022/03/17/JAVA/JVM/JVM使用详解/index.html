<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>JVM使用详解 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="一、Java 内存区域与内存溢出异常1.1、运行时数据区域 1.1.1、程序计数器 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成  ​        如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM使用详解">
<meta property="og:url" content="http://example.com/2022/03/17/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="一、Java 内存区域与内存溢出异常1.1、运行时数据区域 1.1.1、程序计数器 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成  ​        如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107194951119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107194241173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107194535119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107194653461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107195054275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-03-17T03:29:01.000Z">
<meta property="article:modified_time" content="2022-03-17T03:39:56.150Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1648456519227">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1648456519227">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1648456519227">
    <link rel="stylesheet" href="/css/style.css?v=1648456519227">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>32</div>
        <div><span>Tags</span>11</div>
        <div><span>Categories</span>14</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">20</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">17</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 12.5px;">搜索</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="http://mms0.baidu.com/it/u=2467909075,3604847220&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=801&h=500" data-sizes="auto" alt="JVM使用详解" class="lazyload">
              <h1>JVM使用详解</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年03月17日</a>
</div>

      

      <p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" class="lazyload"></p>
<h2 id="一、Java-内存区域与内存溢出异常"><a href="#一、Java-内存区域与内存溢出异常" class="headerlink" title="一、Java 内存区域与内存溢出异常"></a>一、Java 内存区域与内存溢出异常</h2><h3 id="1-1、运行时数据区域"><a href="#1-1、运行时数据区域" class="headerlink" title="1.1、运行时数据区域"></a>1.1、运行时数据区域</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="1-1-1、程序计数器"><a href="#1-1-1、程序计数器" class="headerlink" title="1.1.1、程序计数器"></a>1.1.1、程序计数器</h4><blockquote>
<p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p>
</blockquote>
<p>​        如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h4 id="1-1-2、Java-虚拟机栈"><a href="#1-1-2、Java-虚拟机栈" class="headerlink" title="1.1.2、Java 虚拟机栈"></a>1.1.2、Java 虚拟机栈</h4><blockquote>
<p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p>
</blockquote>
<ul>
<li><strong>局部变量表：</strong>存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</li>
<li><strong>StackOverflowError：</strong>线程请求的栈深度大于虚拟机所允许的深度。</li>
<li><strong>OutOfMemoryError：</strong>如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</li>
</ul>
<h4 id="1-1-3、本地方法栈"><a href="#1-1-3、本地方法栈" class="headerlink" title="1.1.3、本地方法栈"></a>1.1.3、本地方法栈</h4><blockquote>
<p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p>
</blockquote>
<h4 id="1-1-4、Java-堆"><a href="#1-1-4、Java-堆" class="headerlink" title="1.1.4、Java 堆"></a>1.1.4、Java 堆</h4><blockquote>
<p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p>
</blockquote>
<ul>
<li><strong>OutOfMemoryError：</strong>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</li>
</ul>
<h4 id="1-1-5、方法区"><a href="#1-1-5、方法区" class="headerlink" title="1.1.5、方法区"></a>1.1.5、方法区</h4><blockquote>
<p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<p>现在用一张图来介绍每个区域存储的内容。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="1-1-6、运行时常量池"><a href="#1-1-6、运行时常量池" class="headerlink" title="1.1.6、运行时常量池"></a>1.1.6、运行时常量池</h4><blockquote>
<p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p>
</blockquote>
<h4 id="1-1-7、直接内存"><a href="#1-1-7、直接内存" class="headerlink" title="1.1.7、直接内存"></a>1.1.7、直接内存</h4><blockquote>
<p>非虚拟机运行时数据区的部分</p>
</blockquote>
<p>​        在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。</p>
<ul>
<li><strong>OutOfMemoryError：</strong>会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</li>
</ul>
<h3 id="1-2、HotSpot-虚拟机对象探秘"><a href="#1-2、HotSpot-虚拟机对象探秘" class="headerlink" title="1.2、HotSpot 虚拟机对象探秘"></a>1.2、HotSpot 虚拟机对象探秘</h3><blockquote>
<p>主要介绍数据是如何创建、如何布局以及如何访问的。</p>
</blockquote>
<h4 id="1-2-1、对象的创建"><a href="#1-2-1、对象的创建" class="headerlink" title="1.2.1、对象的创建"></a>1.2.1、对象的创建</h4><blockquote>
<p>创建过程比较复杂，建议看书了解，这里提供个人的总结。</p>
</blockquote>
<p>​        遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p>
<p>​        类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p>
<p>​        前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p>
<p>​        内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p>
<p>​        执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p>
<h4 id="1-2-2、对象的内存布局"><a href="#1-2-2、对象的内存布局" class="headerlink" title="1.2.2、对象的内存布局"></a>1.2.2、对象的内存布局</h4><blockquote>
<p>在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p>
</blockquote>
<p>​        <strong>对象头(Header)：</strong>包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p>​        <strong>实例数据(Instance Data)：</strong>程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p>​        <strong>对齐填充(Padding)：</strong>不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<h4 id="1-2-3、对象的访问定位"><a href="#1-2-3、对象的访问定位" class="headerlink" title="1.2.3、对象的访问定位"></a>1.2.3、对象的访问定位</h4><blockquote>
<p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p>
</blockquote>
<ul>
<li><strong>通过句柄访问</strong></li>
</ul>
<blockquote>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<ul>
<li><strong>使用直接指针访问</strong></li>
</ul>
<blockquote>
<p>reference 中直接存储对象地址</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>​        比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h3 id="1-3、实战"><a href="#1-3、实战" class="headerlink" title="1.3、实战"></a>1.3、实战</h3><p>// 待填</p>
<h2 id="二、垃圾回收器与内存分配策略"><a href="#二、垃圾回收器与内存分配策略" class="headerlink" title="二、垃圾回收器与内存分配策略"></a>二、垃圾回收器与内存分配策略</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p>​        程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p>
<h3 id="2-2、对象已死吗？"><a href="#2-2、对象已死吗？" class="headerlink" title="2.2、对象已死吗？"></a>2.2、对象已死吗？</h3><p>​        在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p>
<h4 id="2-2-1、引用计数法"><a href="#2-2-1、引用计数法" class="headerlink" title="2.2.1、引用计数法"></a>2.2.1、引用计数法</h4><p>​        给对象添加一个引用计数器。但是难以解决循环引用问题。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>​        从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p>
<h4 id="2-2-2、可达性分析法"><a href="#2-2-2、可达性分析法" class="headerlink" title="2.2.2、可达性分析法"></a>2.2.2、可达性分析法</h4><p>​        通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>可作为 GC Roots 的对象：</p>
<p>虚拟机栈(栈帧中的本地变量表)中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</p>
<h4 id="2-2-3、再谈引用"><a href="#2-2-3、再谈引用" class="headerlink" title="2.2.3、再谈引用"></a>2.2.3、再谈引用</h4><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p>
<p>下面四种引用强度一次逐渐减弱</p>
<ul>
<li><p>强引用</p>
<ul>
<li>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</li>
</ul>
</li>
<li><p>软引用</p>
<ul>
<li>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li>
</ul>
</li>
<li><p>弱引用</p>
<ul>
<li>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li>
</ul>
</li>
<li><p>虚引用</p>
<ul>
<li>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
</li>
</ul>
<h4 id="2-2-4、生存还是死亡"><a href="#2-2-4、生存还是死亡" class="headerlink" title="2.2.4、生存还是死亡"></a>2.2.4、生存还是死亡</h4><p>​        即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>​        如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p>
<p>​        finalize() 方法只会被系统自动调用一次。</p>
<h4 id="2-2-5、回收方法区"><a href="#2-2-5、回收方法区" class="headerlink" title="2.2.5、回收方法区"></a>2.2.5、回收方法区</h4><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p>
<ul>
<li>判断废弃常量：一般是判断没有该常量的引用。</li>
<li>判断无用的类：要以下三个条件都满足</li>
</ul>
<p>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例<br>加载该类的 ClassLoader 已经被回收<br>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</p>
<h3 id="2-3、垃圾回收算法"><a href="#2-3、垃圾回收算法" class="headerlink" title="2.3、垃圾回收算法"></a>2.3、垃圾回收算法</h3><p>仅提供思路</p>
<h4 id="2-3-1、标记-——-清除算法"><a href="#2-3-1、标记-——-清除算法" class="headerlink" title="2.3.1、标记 —— 清除算法"></a>2.3.1、标记 —— 清除算法</h4><p>直接标记清除就可。</p>
<p>两个不足：</p>
<p>效率不高<br>空间会产生大量碎片</p>
<h4 id="2-3-2、复制算法"><a href="#2-3-2、复制算法" class="headerlink" title="2.3.2、复制算法"></a>2.3.2、复制算法</h4><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p>
<p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p>
<h4 id="2-3-3、标记-整理算法"><a href="#2-3-3、标记-整理算法" class="headerlink" title="2.3.3、标记-整理算法"></a>2.3.3、标记-整理算法</h4><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p>
<h4 id="2-3-4、分代回收"><a href="#2-3-4、分代回收" class="headerlink" title="2.3.4、分代回收"></a>2.3.4、分代回收</h4><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p>
<p>新生代</p>
<p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p>
<p>老年代</p>
<p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。</p>
<h3 id="2-4、HotSpot-的算法实现"><a href="#2-4、HotSpot-的算法实现" class="headerlink" title="2.4、HotSpot 的算法实现"></a>2.4、HotSpot 的算法实现</h3><p>// 待填</p>
<h3 id="2-5、垃圾回收器"><a href="#2-5、垃圾回收器" class="headerlink" title="2.5、垃圾回收器"></a>2.5、垃圾回收器</h3><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p>
<h4 id="2-5-1、Serial-收集器"><a href="#2-5-1、Serial-收集器" class="headerlink" title="2.5.1、Serial 收集器"></a>2.5.1、Serial 收集器</h4><blockquote>
<p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="2-5-2、ParNew-收集器"><a href="#2-5-2、ParNew-收集器" class="headerlink" title="2.5.2、ParNew 收集器"></a>2.5.2、ParNew 收集器</h4><blockquote>
<p>可以认为是 Serial 收集器的多线程版本。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>并行：Parallel</p>
<p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p>
<p>并发：Concurrent</p>
<p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p>
<h4 id="2-5-3、Parallel-Scavenge-收集器"><a href="#2-5-3、Parallel-Scavenge-收集器" class="headerlink" title="2.5.3、Parallel Scavenge 收集器"></a>2.5.3、Parallel Scavenge 收集器</h4><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p>
<p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p>
<p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p>
<h4 id="2-5-4、Serial-Old-收集器"><a href="#2-5-4、Serial-Old-收集器" class="headerlink" title="2.5.4、Serial Old 收集器"></a>2.5.4、Serial Old 收集器</h4><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="2-5-5、Parallel-Old-收集器"><a href="#2-5-5、Parallel-Old-收集器" class="headerlink" title="2.5.5、Parallel Old 收集器"></a>2.5.5、Parallel Old 收集器</h4><blockquote>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 <code>标记 —— 整理</code></p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="2-5-6、CMS-收集器"><a href="#2-5-6、CMS-收集器" class="headerlink" title="2.5.6、CMS 收集器"></a>2.5.6、CMS 收集器</h4><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p>
<p>运作步骤:</p>
<p>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象<br>并发标记(CMS concurrent mark)：进行 GC Roots Tracing<br>重新标记(CMS remark)：修正并发标记期间的变动部分<br>并发清除(CMS concurrent sweep)</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p>
<h4 id="2-5-7、G1-收集器"><a href="#2-5-7、G1-收集器" class="headerlink" title="2.5.7、G1 收集器"></a>2.5.7、G1 收集器</h4><p>面向服务端的垃圾回收器。</p>
<p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p>
<p>运作步骤:</p>
<p>初始标记(Initial Marking)<br>并发标记(Concurrent Marking)<br>最终标记(Final Marking)<br>筛选回收(Live Data Counting and Evacuation)</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h3 id="2-6、内存分配与回收策略"><a href="#2-6、内存分配与回收策略" class="headerlink" title="2.6、内存分配与回收策略"></a>2.6、内存分配与回收策略</h3><h4 id="2-6-1、对象优先在-Eden-分配"><a href="#2-6-1、对象优先在-Eden-分配" class="headerlink" title="2.6.1、对象优先在 Eden 分配"></a>2.6.1、对象优先在 Eden 分配</h4><blockquote>
<p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p>
</blockquote>
<p>一般来说 Java 堆的内存模型如下图所示：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>新生代 GC (Minor GC)</p>
<p>发生在新生代的垃圾回收动作，频繁，速度快。</p>
<p>老年代 GC (Major GC / Full GC)</p>
<p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p>
<h4 id="2-6-2、大对象直接进入老年代"><a href="#2-6-2、大对象直接进入老年代" class="headerlink" title="2.6.2、大对象直接进入老年代"></a>2.6.2、大对象直接进入老年代</h4><h4 id="2-6-3、长期存活的对象将进入老年代"><a href="#2-6-3、长期存活的对象将进入老年代" class="headerlink" title="2.6.3、长期存活的对象将进入老年代"></a>2.6.3、长期存活的对象将进入老年代</h4><h4 id="2-6-4、动态对象年龄判定"><a href="#2-6-4、动态对象年龄判定" class="headerlink" title="2.6.4、动态对象年龄判定"></a>2.6.4、动态对象年龄判定</h4><h4 id="2-6-5、空间分配担保"><a href="#2-6-5、空间分配担保" class="headerlink" title="2.6.5、空间分配担保"></a>2.6.5、空间分配担保</h4><h2 id="三、Java-内存模型与线程"><a href="#三、Java-内存模型与线程" class="headerlink" title="三、Java 内存模型与线程"></a>三、Java 内存模型与线程</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h3 id="3-1、Java-内存模型"><a href="#3-1、Java-内存模型" class="headerlink" title="3.1、Java 内存模型"></a>3.1、Java 内存模型</h3><blockquote>
<p>屏蔽掉各种硬件和操作系统的内存访问差异。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h4 id="3-1-1、主内存和工作内存之间的交互"><a href="#3-1-1、主内存和工作内存之间的交互" class="headerlink" title="3.1.1、主内存和工作内存之间的交互"></a>3.1.1、主内存和工作内存之间的交互</h4><p>操作    作用对象    解释<br>lock    主内存    把一个变量标识为一条线程独占的状态<br>unlock    主内存    把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定<br>read    主内存    把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用<br>load    工作内存    把 read 操作从主内存中得到的变量值放入工作内存中<br>use    工作内存    把工作内存中一个变量的值传递给执行引擎，<br>每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作<br>assign    工作内存    把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，<br>每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作<br>store    工作内存    把工作内存中的一个变量的值传送到主内存中，以便 write 操作<br>write    工作内存    把 store 操作从工作内存中得到的变量的值放入主内存的变量中</p>
<h4 id="3-1-2、对于-volatile-型变量的特殊规则"><a href="#3-1-2、对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2、对于 volatile 型变量的特殊规则"></a>3.1.2、对于 volatile 型变量的特殊规则</h4><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p>
<p>一个变量被定义为 volatile 的特性：</p>
<p>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。<br>如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p>
<p>禁止指令重排序优化。<br>通过插入内存屏障保证一致性。</p>
<h4 id="3-1-3、对于-long-和-double-型变量的特殊规则"><a href="#3-1-3、对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3、对于 long 和 double 型变量的特殊规则"></a>3.1.3、对于 long 和 double 型变量的特殊规则</h4><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p>
<h4 id="3-1-4、原子性、可见性与有序性"><a href="#3-1-4、原子性、可见性与有序性" class="headerlink" title="3.1.4、原子性、可见性与有序性"></a>3.1.4、原子性、可见性与有序性</h4><p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p>
<p>原子性(Atomicity)<br>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p>
<p>可见性(Visibility)<br>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p>
<p>有序性(Ordering)<br>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h4 id="3-1-5、先行发生原则"><a href="#3-1-5、先行发生原则" class="headerlink" title="3.1.5、先行发生原则"></a>3.1.5、先行发生原则</h4><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>
<p>天然的先行发生关系</p>
<p>规则    解释<br>程序次序规则    在一个线程内，代码按照书写的控制流顺序执行<br>管程锁定规则    一个 unlock 操作先行发生于后面对同一个锁的 lock 操作<br>volatile 变量规则    volatile 变量的写操作先行发生于后面对这个变量的读操作<br>线程启动规则    Thread 对象的 start() 方法先行发生于此线程的每一个动作<br>线程终止规则    线程中所有的操作都先行发生于对此线程的终止检测<br>(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)<br>线程中断规则    对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生<br>(通过 Thread.interrupted() 方法检测)<br>对象终结规则    一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始<br>传递性    如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</p>
<h3 id="3-2、Java-与线程"><a href="#3-2、Java-与线程" class="headerlink" title="3.2、Java 与线程"></a>3.2、Java 与线程</h3><h4 id="3-2-1、线程的实现"><a href="#3-2-1、线程的实现" class="headerlink" title="3.2.1、线程的实现"></a>3.2.1、线程的实现</h4><p>使用内核线程实现</p>
<p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>使用用户线程实现</p>
<blockquote>
<p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>使用用户线程夹加轻量级进程混合实现</p>
<blockquote>
<p>直接看图</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>Java 线程实现</p>
<p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p>
<h4 id="3-2-2、Java-线程调度"><a href="#3-2-2、Java-线程调度" class="headerlink" title="3.2.2、Java 线程调度"></a>3.2.2、Java 线程调度</h4><p>协同式线程调度</p>
<p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p>
<p>抢占式线程调度</p>
<p>每个线程由系统来分配执行时间。</p>
<h4 id="3-2-3、状态转换"><a href="#3-2-3、状态转换" class="headerlink" title="3.2.3、状态转换"></a>3.2.3、状态转换</h4><p>五种状态：</p>
<p>新建(new)<br>创建后尚未启动的线程。</p>
<p>运行(Runable)<br>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p>
<p>无限期等待(Waiting)<br>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p>
<p>以下方法会然线程进入无限期等待状态：<br>1.没有设置 Timeout 参数的 Object.wait() 方法。<br>2.没有设置 Timeout 参数的 Thread.join() 方法。<br>3.LookSupport.park() 方法。</p>
<p>限期等待(Timed Waiting)<br>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p>
<p>以下方法会让线程进入限期等待状态：<br>1.Thread.sleep() 方法。<br>2.设置了 Timeout 参数的 Object.wait() 方法。<br>3.设置了 Timeout 参数的 Thread.join() 方法。<br>4.LockSupport.parkNanos() 方法。<br>5.LockSupport.parkUntil() 方法。</p>
<p>阻塞(Blocked)<br>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
<p>结束(Terminated)<br>已终止线程的线程状态。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<h2 id="四、线程安全与锁优化"><a href="#四、线程安全与锁优化" class="headerlink" title="四、线程安全与锁优化"></a>四、线程安全与锁优化</h2><p>// 待填</p>
<h2 id="五、类文件结构"><a href="#五、类文件结构" class="headerlink" title="五、类文件结构"></a>五、类文件结构</h2><p>// 待填</p>
<p>有点懒了。。。先贴几个网址吧。</p>
<ol>
<li>Official：The class File Format<br>2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构</li>
</ol>
<h2 id="六、虚拟机类加载机制"><a href="#六、虚拟机类加载机制" class="headerlink" title="六、虚拟机类加载机制"></a>六、虚拟机类加载机制</h2><p>  虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
<p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
<h3 id="6-1、类加载时机"><a href="#6-1、类加载时机" class="headerlink" title="6.1、类加载时机"></a>6.1、类加载时机</h3><p>类的生命周期( 7 个阶段)</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p>
<p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p>
<p>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。<br>使用 java.lang.reflect 包的方法对类进行反射调用的时候。<br>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。<br>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。<br>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。<br>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperClass init!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">1127</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass init!&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstClass</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ConstClass init!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HELLOWORLD = <span class="hljs-string">&quot;hello world!&quot;</span><br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotInitialization</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(SubClass.value);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  output : SuperClass init!</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 通过子类引用父类的静态对象不会导致子类的初始化</span><br><span class="hljs-comment">         * 只有直接定义这个字段的类才会被初始化</span><br><span class="hljs-comment">         */</span><br> <br>        SuperClass[] sca = <span class="hljs-keyword">new</span> SuperClass[<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  output : </span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 通过数组定义来引用类不会触发此类的初始化</span><br><span class="hljs-comment">         * 虚拟机在运行时动态创建了一个数组类</span><br><span class="hljs-comment">         */</span><br> <br>        System.out.println(ConstClass.HELLOWORLD);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  output : </span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span><br><span class="hljs-comment">         * 因此不会触发定义常量的类的初始化。</span><br><span class="hljs-comment">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-2、类的加载过程"><a href="#6-2、类的加载过程" class="headerlink" title="6.2、类的加载过程"></a>6.2、类的加载过程</h3><h4 id="6-2-1、加载"><a href="#6-2-1、加载" class="headerlink" title="6.2.1、加载"></a>6.2.1、加载</h4><p>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。<br>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p>
<p>如果数组的组件类型是引用类型，那就递归采用类加载加载。<br>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。<br>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。<br>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p>
<h4 id="6-2-2、验证"><a href="#6-2-2、验证" class="headerlink" title="6.2.2、验证"></a>6.2.2、验证</h4><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p>
<p>文件格式验证</p>
<p>是否以魔数 0xCAFEBABE 开头<br>主、次版本号是否在当前虚拟机处理范围之内<br>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）<br>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量<br>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据<br>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息<br>……<br>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p>
<p>元数据验证</p>
<p>这个类是否有父类（除 java.lang.Object 之外）<br>这个类的父类是否继承了不允许被继承的类（final 修饰的类）<br>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法<br>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）<br>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<p>字节码验证</p>
<p>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）<br>保证跳转指令不会跳转到方法体以外的字节码指令上<br>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）<br>……<br>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<p>符号引用验证</p>
<p>符号引用中通过字符创描述的全限定名是否能找到对应的类<br>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段<br>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问<br>……<br>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p>
<h4 id="6-2-3、准备"><a href="#6-2-3、准备" class="headerlink" title="6.2.3、准备"></a>6.2.3、准备</h4><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p>
<p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p>
<p>基本数据类型的零值</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">零值</th>
<th align="left">数据类型</th>
<th align="left">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">(short) 0</td>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
<td align="left">reference</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">(byte) 0</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p>
<h4 id="6-2-4、解析"><a href="#6-2-4、解析" class="headerlink" title="6.2.4、解析"></a>6.2.4、解析</h4><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。<br>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p>
<h4 id="6-2-5、初始化"><a href="#6-2-5、初始化" class="headerlink" title="6.2.5、初始化"></a>6.2.5、初始化</h4><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p>
<h3 id="6-3、类加载器"><a href="#6-3、类加载器" class="headerlink" title="6.3、类加载器"></a>6.3、类加载器</h3><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p>
<h4 id="6-3-1、双亲委派模型"><a href="#6-3-1、双亲委派模型" class="headerlink" title="6.3.1、双亲委派模型"></a>6.3.1、双亲委派模型</h4><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p>
<p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p>
<p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p>
<p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" class="lazyload"></p>
<p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p>
<h4 id="6-3-2、破坏双亲委派模型"><a href="#6-3-2、破坏双亲委派模型" class="headerlink" title="6.3.2、破坏双亲委派模型"></a>6.3.2、破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>
<h2 id="七、JVM问题"><a href="#七、JVM问题" class="headerlink" title="七、JVM问题"></a>七、JVM问题</h2><h3 id="7-1、什么是JVM？"><a href="#7-1、什么是JVM？" class="headerlink" title="7.1、什么是JVM？"></a>7.1、什么是JVM？</h3><ul>
<li>JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机。</li>
<li>jvm是运行在操作系统之上的，与硬件没有任何关系。</li>
</ul>
<h3 id="7-2、JVM跨平台及原理"><a href="#7-2、JVM跨平台及原理" class="headerlink" title="7.2、JVM跨平台及原理"></a>7.2、JVM跨平台及原理</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20201107194951119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img" class="lazyload"></p>
<ul>
<li>跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行。</li>
<li>原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) </li>
</ul>
<h3 id="7-3、JVM的分类"><a href="#7-3、JVM的分类" class="headerlink" title="7.3、JVM的分类"></a>7.3、JVM的分类</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20201107194241173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img" class="lazyload"></p>
<ul>
<li>类加载子系统。</li>
<li>运行时数据区 [ 我们核心关注这里 的栈、堆、方法区 ]。</li>
<li>执行引擎(一般都是JIT编译器和解释器共存)<ul>
<li>JIT编译器(主要影响性能)：编译执行； 一般热点数据会进行二次编译，将字节码指令变成机器指令。将机器指令放在方法区缓存。</li>
<li>解释器(负责响应时间，他的响应时间很快)：逐行解释字节码。</li>
</ul>
</li>
</ul>
<h3 id="7-4、JVM的位置"><a href="#7-4、JVM的位置" class="headerlink" title="7.4、JVM的位置"></a>7.4、JVM的位置</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20201107194535119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img" class="lazyload"></p>
<p>JVM位于操作系统上层，但是位于应用程序下层。</p>
<h3 id="7-5、JVM的体系结构"><a href="#7-5、JVM的体系结构" class="headerlink" title="7.5、JVM的体系结构"></a>7.5、JVM的体系结构</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20201107194653461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img" class="lazyload"></p>
<ul>
<li>入口是编译好的字节码文件（编译器前端）–&gt;经过类加载子系统（将我们的字节码加载到内存当中，生成一个class对象，中间经过三步：加载—&gt;链接—&gt;初始化）</li>
<li>在内存中，多个对象共享内存的是方法区和堆区（多个线程共享区）。</li>
<li>Java虚拟机栈，本地方法栈，程序计数器每一个线程独有一份。</li>
<li>执行引擎：解释器（解释运行），jit及时编译器（编译器后端），垃圾回收器三部分。</li>
</ul>
<h3 id="7-6、Java代码的执行流程"><a href="#7-6、Java代码的执行流程" class="headerlink" title="7.6、Java代码的执行流程"></a>7.6、Java代码的执行流程</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20201107195054275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTYzMjQ0,size_16,color_FFFFFF,t_70" alt="img" class="lazyload"></p>
<ul>
<li>高级语言翻译为机器指令，主要是由执行引擎完成的。<ul>
<li>解释器（解释运行，把字节码翻译为机器指令，主要负责翻编译器性能）。</li>
<li>jit及时编译器（编译器后端，主要是把热点代码缓存起来，主要负责编译器性能）组成执行引擎。</li>
</ul>
</li>
</ul>
<h3 id="7-7、JVM的架构模型"><a href="#7-7、JVM的架构模型" class="headerlink" title="7.7、JVM的架构模型"></a>7.7、JVM的架构模型</h3><p>​        Java编译器输入的指令流基本上是基于栈的指令集架构，另一种指令集架构是基于寄存器的指令集架构，两种架构之间的区别如下：</p>
<p>基于栈实现的指令集特点如下：</p>
<ul>
<li>设计和实现更加简单，适用于资源受限的系统。</li>
<li>避开了寄存器额分配难题，使用零地址指令分配方式。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器更加容易实现。</li>
<li>不需要硬件支持，可移植性好，更好实现跨平台。</li>
<li>基于栈的指令集：跨平台性，指令集小，指令多执行性能比寄存器差。</li>
</ul>
<p>基于寄存器指令集的特点：</p>
<ul>
<li>典型的应用是x86二进制指令集，比如传统的pc以及android的davlik虚拟机。</li>
<li>指令集架构完全依赖于硬件，可移植性差。</li>
<li>性能优秀和执行更加高效。</li>
<li>花费更少的指令去完成一项任务。</li>
<li>在大部分情况下，<strong>基于寄存器的指令集往往都以一地址指令，二地址指令，三地址指令为主</strong>，而<strong>基于栈结构的指令集则以零地址为主</strong>。</li>
</ul>
<p>小结：</p>
<p>​        由于扩平台式的设计，Java的指令集都是根据栈来设计的，不同的平台cpu架构不同，所以不能设计为基于寄存器的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h3 id="7-8、JVM的生命周期"><a href="#7-8、JVM的生命周期" class="headerlink" title="7.8、JVM的生命周期"></a>7.8、JVM的生命周期</h3><ul>
<li>虚拟机的启动<ul>
<li>Java虚拟机的启动是通过引导类加载器bootstrap class loader创建一个初始类initail calss来完成的，这个类是由虚拟机的具体实现指定的。</li>
</ul>
</li>
<li>虚拟机的执行：<ul>
<li>一个运行着的java虚拟机有着清晰的任务，执行java程序。</li>
<li>程序开始执行虚拟机就运行，程序结束虚拟机就结束运行。</li>
<li>执行一个java程序的时候，真真正正的在执行的是一个java虚拟机进程。</li>
</ul>
</li>
<li>虚拟机的停止：以下几种情况会退出虚拟机：<ul>
<li>程序正常执行结束。</li>
<li>程序在运行过程中遇到错误或者异常而终止执行。</li>
<li>由于操作系统发故障而导致虚拟机进程终止运行。</li>
<li>某一个线程调用了Runtime类或者system类的exit方法，或者调用runtime类的halt方法，并且java安全管理器允许执行安全退出的方法。</li>
</ul>
</li>
</ul>
<h3 id="7-9、三大商业虚拟机"><a href="#7-9、三大商业虚拟机" class="headerlink" title="7.9、三大商业虚拟机"></a>7.9、三大商业虚拟机</h3><ul>
<li>Sun HotSpot<ul>
<li>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。</li>
<li>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码， 并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</li>
<li>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务， 使用HotSpot的JIT编译器与混合的运行时系统。</li>
<li>从服务器，桌面，到移动端，嵌入式都有应用。</li>
</ul>
</li>
<li>BEA JRocket<ul>
<li>专注于服务端应用(JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行)。</li>
<li>Jrockit JVM 是世界上最快的jvm3. 2008年被oracle收购。</li>
<li>专注于服务器端的应用。</li>
<li>它不太关注程序的启动速度，因此JRockit内部不包含解析器的实现，全部代码都靠及时编译器编译之后执行。</li>
</ul>
</li>
<li>iBM J9<ul>
<li>市场定位与hotspot接近，服务器端，桌面应用，嵌入式等。</li>
<li>目前，是影响力最大的三大商业虚拟机之一。</li>
<li>应用于IBM的各种Java产品。</li>
</ul>
</li>
</ul>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/03/17/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;JVM&#x2F;JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;JVM&#x2F;JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/">JAVA</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/JVM/" rel="tag">JVM</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">一、Java 内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1、程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%E3%80%81Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2、Java 虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3、本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4%E3%80%81Java-%E5%A0%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.4、Java 堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.1.5、方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.1.6、运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-7%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.1.7、直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="toc-number">1.2.</span> <span class="toc-text">1.2、HotSpot 虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1、对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2、对象的内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3、对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">1.3、实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.</span> <span class="toc-text">二、垃圾回收器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、对象已死吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1、引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E3%80%81%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2、可达性分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3、再谈引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4%E3%80%81%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4、生存还是死亡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5%E3%80%81%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.2.5、回收方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E3%80%81%E6%A0%87%E8%AE%B0-%E2%80%94%E2%80%94-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1、标记 —— 清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2、复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3、标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4%E3%80%81%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4、分代回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81HotSpot-%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、HotSpot 的算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">2.5、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%E3%80%81Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1、Serial 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2%E3%80%81ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2、ParNew 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3%E3%80%81Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">2.5.3、Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4%E3%80%81Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">2.5.4、Serial Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5%E3%80%81Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.5.</span> <span class="toc-text">2.5.5、Parallel Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6%E3%80%81CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.6.</span> <span class="toc-text">2.5.6、CMS 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-7%E3%80%81G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.7.</span> <span class="toc-text">2.5.7、G1 收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">2.6.</span> <span class="toc-text">2.6、内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%88%86%E9%85%8D"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1、对象优先在 Eden 分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%E3%80%81%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2、大对象直接进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%E3%80%81%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.6.3.</span> <span class="toc-text">2.6.3、长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4%E3%80%81%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-number">2.6.4.</span> <span class="toc-text">2.6.4、动态对象年龄判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-5%E3%80%81%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">2.6.5.</span> <span class="toc-text">2.6.5、空间分配担保</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Java 内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、Java 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1、主内存和工作内存之间的交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%E3%80%81%E5%AF%B9%E4%BA%8E-volatile-%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2、对于 volatile 型变量的特殊规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3%E3%80%81%E5%AF%B9%E4%BA%8E-long-%E5%92%8C-double-%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3、对于 long 和 double 型变量的特殊规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4、原子性、可见性与有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5%E3%80%81%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.1.5、先行发生原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81Java-%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、Java 与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1、线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%E3%80%81Java-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2、Java 线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3、状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">四、线程安全与锁优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">五、类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">六、虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、类加载时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1%E3%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1、加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2%E3%80%81%E9%AA%8C%E8%AF%81"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2、验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3%E3%80%81%E5%87%86%E5%A4%87"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3、准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4%E3%80%81%E8%A7%A3%E6%9E%90"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4、解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.5、初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">6.3、类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1、双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2、破坏双亲委派模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81JVM%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">七、JVM问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1、什么是JVM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81JVM%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">7.2、JVM跨平台及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81JVM%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">7.3、JVM的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%81JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.4.</span> <span class="toc-text">7.4、JVM的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E3%80%81JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">7.5.</span> <span class="toc-text">7.5、JVM的体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E3%80%81Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text">7.6、Java代码的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7%E3%80%81JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7.7、JVM的架构模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8%E3%80%81JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.8.</span> <span class="toc-text">7.8、JVM的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9%E3%80%81%E4%B8%89%E5%A4%A7%E5%95%86%E4%B8%9A%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.9.</span> <span class="toc-text">7.9、三大商业虚拟机</span></a></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1648456519239"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
