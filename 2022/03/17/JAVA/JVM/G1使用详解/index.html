<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>G1使用详解 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="​        Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8&#x2F;9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意">
<meta property="og:type" content="article">
<meta property="og:title" content="G1使用详解">
<meta property="og:url" content="http://example.com/2022/03/17/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="​        Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8&#x2F;9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png">
<meta property="og:image" content="https://c1.staticflickr.com/5/4603/28345836579_8dff90eb76_z.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/46f9b4f25c7783fd48a9a7df404e4f5e.png">
<meta property="og:image" content="https://c1.staticflickr.com/5/4740/40093687062_7383cd1b49_z.jpg">
<meta property="og:image" content="https://c1.staticflickr.com/5/4655/28345836209_7b70465317_b.jpg">
<meta property="og:image" content="https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg">
<meta property="og:image" content="https://c1.staticflickr.com/5/4621/28345836009_65a54854be_z.jpg">
<meta property="og:image" content="https://c1.staticflickr.com/5/4619/40093686872_ce639c1121_z.jpg">
<meta property="og:image" content="https://c1.staticflickr.com/5/4766/40126693251_d74183c2c6.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5a60b80279c1f7a7664f6b54d26e967c.png">
<meta property="og:image" content="https://c1.staticflickr.com/5/4658/40093686702_9d689b29e9_z.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ac554fcaf159d7a7c62511c5e7db19fc.png">
<meta property="article:published_time" content="2022-03-17T03:29:01.000Z">
<meta property="article:modified_time" content="2022-03-18T11:51:20.482Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1648185133649">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1648185133649">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1648185133649">
    <link rel="stylesheet" href="/css/style.css?v=1648185133649">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>25</div>
        <div><span>Tags</span>7</div>
        <div><span>Categories</span>11</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">20</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">17</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/Leetcode/" style="font-size: 12.5px;">Leetcode</a> <a href="/tags/Mybaits/" style="font-size: 20px;">Mybaits</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="/img/iTab-18057.jpg" data-sizes="auto" alt="G1使用详解" class="lazyload">
              <h1>G1使用详解</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年03月17日</a>
</div>

      

      <p>​        Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8/9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意的优化点。笔者希望通过本文，让有一定JVM基础的读者能尽快掌握G1的知识点。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​        G1(Garbage First)垃圾收集器是当今<strong>垃圾回收技术</strong>最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是<strong>关注最小时延</strong>的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是<strong>引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源</strong>，解决了其他收集器甚至CMS的众多缺陷。</p>
<h2 id="二、JVM-GC收集器的回顾与比较"><a href="#二、JVM-GC收集器的回顾与比较" class="headerlink" title="二、JVM GC收集器的回顾与比较"></a>二、JVM GC收集器的回顾与比较</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png" alt="JVM GC收集器成员" class="lazyload"></p>
<p>​        从JDK3(1.3)开始，HotSpot团队一直努力朝着**高效收集、减少停顿(STW: Stop The World)**的方向努力，也贡献了从串行到CMS乃至最新的G1在内的一系列优秀的垃圾收集器。上图展示了JDK的垃圾回收大家庭，以及相互之间的组合关系，下面就几种典型的组合应用进行简单的介绍。</p>
<h3 id="2-1、串行收集器"><a href="#2-1、串行收集器" class="headerlink" title="2.1、串行收集器"></a>2.1、串行收集器</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4603/28345836579_8dff90eb76_z.jpg" alt="img" class="lazyload"></p>
<p>​        串行收集器组合 Serial + Serial Old</p>
<blockquote>
<p> 开启选项：-XX:+SerialGC</p>
</blockquote>
<p>​        串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。</p>
<p>​        串行收集器采用<strong>单线程stop-the-world</strong>的方式进行收集。<strong>当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。</strong>单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</p>
<h3 id="2-2、并行收集器"><a href="#2-2、并行收集器" class="headerlink" title="2.2、并行收集器"></a>2.2、并行收集器</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/img_convert/46f9b4f25c7783fd48a9a7df404e4f5e.png" alt="并行收集器组合" class="lazyload"></p>
<p>​        并行收集器组合 Parallel Scavenge + Parallel Old</p>
<blockquote>
<p> 开启选项：-XX:+UseParallelGC或-XX:+UseParallelOldGC(可互相激活)</p>
</blockquote>
<p>​        并行收集器是以<strong>关注吞吐量</strong>为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。</p>
<p>​        并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。</p>
<p>​        关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数**-XX:MaxGCPauseMills和-XX:GCTimeRatio**，调整新生代空间大小，来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<h3 id="2-3、并发标记清除收集器"><a href="#2-3、并发标记清除收集器" class="headerlink" title="2.3、并发标记清除收集器"></a>2.3、并发标记清除收集器</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4740/40093687062_7383cd1b49_z.jpg" alt="img" class="lazyload"></p>
<p>​        并发标记清除收集器组合 ParNew + CMS + Serial Old</p>
<blockquote>
<p> 开启选项：-XX:+UseConcMarkSweepGC</p>
</blockquote>
<p>​        并发标记清除(CMS)是以<strong>关注延迟</strong>为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。</p>
<p>​        年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：<strong>初始标记、并发标记、重新标记、并发清除</strong>。其中，</p>
<ul>
<li>初始标记以STW的方式标记所有的根对象；</li>
<li>并发标记则同应用线程一起并行，标记出根对象的可达路径；</li>
<li>在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；</li>
<li>最后得到的不可达对象将在并发清除阶段进行回收。</li>
</ul>
<p>​        值得注意的是，初始标记和重新标记都已优化为多线程执行。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p>
<p>​        但是CMS并不完美，它有以下缺点：</p>
<p>​        由于并发进行，CMS在收集与应用线程会同时会<strong>增加对堆内存的占用</strong>，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。</p>
<p>​        CMS也提供了参数**-XX:CMSFullGCsBeForeCompaction**(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。</p>
<h3 id="2-4、Garbage-First"><a href="#2-4、Garbage-First" class="headerlink" title="2.4、Garbage First"></a>2.4、Garbage First</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4655/28345836209_7b70465317_b.jpg" alt="img" class="lazyload"></p>
<p>​        Garbage First (G1)</p>
<blockquote>
<p>开启选项：-XX:+UseG1GC</p>
</blockquote>
<p>​        之前介绍的几组垃圾收集器组合，都有几个共同点：</p>
<ul>
<li><p>年轻代、老年代是独立且连续的内存块；</p>
</li>
<li><p>年轻代收集使用单eden、双survivor进行复制算法；</p>
</li>
<li><p>老年代收集必须扫描整个老年代区域；</p>
</li>
<li><p>都是以尽可能少而块地执行GC为设计原则。</p>
</li>
</ul>
<p>​        G1垃圾收集器也是<strong>以关注延迟为目标</strong>、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：</p>
<p>​        G1的设计原则是”<strong>首先收集尽可能多的垃圾(Garbage First)</strong>“。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；<br>​        G1采用<strong>内存分区(Region)<strong>的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；<br>​        G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1</strong>只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换；<br>​        <strong>G1的收集都是STW的</strong>，但年轻代和老年代的收集界限比较模糊，采用了<strong>混合(mixed)收集</strong>的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p>
<h2 id="三、G1的内存模型"><a href="#三、G1的内存模型" class="headerlink" title="三、G1的内存模型"></a>三、G1的内存模型</h2><h3 id="3-1、分区概念"><a href="#3-1、分区概念" class="headerlink" title="3.1、分区概念"></a>3.1、分区概念</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg" alt="img" class="lazyload"></p>
<h4 id="3-1-1、分区-Region"><a href="#3-1-1、分区-Region" class="headerlink" title="3.1.1、分区 Region"></a>3.1.1、分区 Region</h4><p>​        G1采用了分区(Region)的思路，将整个<strong>堆空间</strong>分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>
<h4 id="3-1-2、卡片-Card"><a href="#3-1-2、卡片-Card" class="headerlink" title="3.1.2、卡片 Card"></a>3.1.2、卡片 Card</h4><p>​        在每个分区内部又被分成了若干个<strong>大小为512 Byte卡片</strong>(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<h4 id="3-1-3、堆-Heap"><a href="#3-1-3、堆-Heap" class="headerlink" title="3.1.3、堆 Heap"></a>3.1.3、堆 Heap</h4><p>​        G1同样可以<strong>通过-Xms/-Xmx来指定堆空间大小</strong>。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数**-XX:GCTimeRatio<strong>即为GC与应用的</strong>耗费时间比<strong>，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的</strong>Full GC**。Full GC后，堆尺寸计算结果也会调整堆空间。</p>
<h3 id="3-2、分代模型"><a href="#3-2、分代模型" class="headerlink" title="3.2、分代模型"></a>3.2、分代模型</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4621/28345836009_65a54854be_z.jpg" alt="img" class="lazyload"></p>
<h4 id="3-2-1、分代-Generation"><a href="#3-2-1、分代-Generation" class="headerlink" title="3.2.1、分代 Generation"></a>3.2.1、分代 Generation</h4><p>​        分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为<strong>年轻代和老年代</strong>，其中年轻代又划分为<strong>Eden空间和Survivor空间</strong>。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p>
<p>​        整个年轻代内存会在<strong>初始空间-XX:G1NewSizePercent</strong>(默认整堆5%)与<strong>最大空间-XX:G1MaxNewSizePercent</strong>(默认60%)之间动态变化，且<strong>由参数目标暂停时间-XX:MaxGCPauseMillis</strong>(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以**设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)**，但同时暂停目标将失去意义。</p>
<h4 id="3-2-2、本地分配缓冲-Lab"><a href="#3-2-2、本地分配缓冲-Lab" class="headerlink" title="3.2.2、本地分配缓冲  Lab"></a>3.2.2、本地分配缓冲  Lab</h4><p>​        值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Local allocation buffer)。</p>
<p>​        其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，<strong>因此TLAB的分区属于Eden空间</strong>；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为**晋升本地缓冲区(PLAB)**。</p>
<h3 id="3-3、分区模型"><a href="#3-3、分区模型" class="headerlink" title="3.3、分区模型"></a>3.3、分区模型</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4619/40093686872_ce639c1121_z.jpg" alt="img" class="lazyload"></p>
<p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p>
<h4 id="3-3-1、巨型对象-Humongous-Region"><a href="#3-3-1、巨型对象-Humongous-Region" class="headerlink" title="3.3.1、巨型对象 Humongous Region"></a>3.3.1、巨型对象 Humongous Region</h4><p>​        <strong>一个大小达到甚至超过分区大小一半的对象称为巨型对象</strong>(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为<strong>巨型分区</strong>(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p>
<p>​        巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为<u>开始巨型</u>(StartsHumongous)，相邻连续分区被标记为<u>连续巨型</u>(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<h4 id="3-3-2、已记忆集合-RSet"><a href="#3-3-2、已记忆集合-RSet" class="headerlink" title="3.3.2、已记忆集合  RSet"></a>3.3.2、已记忆集合  RSet</h4><p>​        在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(Remember Set)，*内部类似一个<u>反向指针</u>*，<strong>记录引用分区内对象的卡片索引</strong>。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>​        事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。</p>
<h4 id="3-3-3、Per-Region-Table"><a href="#3-3-3、Per-Region-Table" class="headerlink" title="3.3.3、Per Region Table"></a>3.3.3、Per Region Table</h4><p>​        RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p>
<ul>
<li><strong>稀少：</strong>直接记录引用对象的卡片索引；</li>
<li><strong>细粒度：</strong>记录引用对象的分区索引；</li>
<li><strong>粗粒度：</strong>只记录引用情况，每个分区对应一个比特位。</li>
</ul>
<p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
<h3 id="3-4、收集集合-CSet"><a href="#3-4、收集集合-CSet" class="headerlink" title="3.4、收集集合 (CSet)"></a>3.4、收集集合 (CSet)</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4766/40126693251_d74183c2c6.jpg" alt="img" class="lazyload"></p>
<h4 id="3-4-1、收集集合-CSet"><a href="#3-4-1、收集集合-CSet" class="headerlink" title="3.4.1、收集集合 CSet"></a>3.4.1、收集集合 CSet</h4><p>​        收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p>
<p>​        候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-<strong>XX:G1OldCSetRegionThresholdPercent</strong> (默认10%)<strong>设置数量上限</strong>。</p>
<p>​        由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h4 id="3-4-2、年轻代收集集合"><a href="#3-4-2、年轻代收集集合" class="headerlink" title="3.4.2、年轻代收集集合"></a>3.4.2、年轻代收集集合</h4><p>年轻代收集集合 CSet of Young Collection</p>
<p>​        应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>​        同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、S<strong>urvivor填充容量-XX:TargetSurvivorRatio</strong>(默认50%)、<strong>最大任期阈值-XX:MaxTenuringThreshold</strong>(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<h4 id="3-4-3、混合收集集合"><a href="#3-4-3、混合收集集合" class="headerlink" title="3.4.3、混合收集集合"></a>3.4.3、混合收集集合</h4><p>混合收集集合 CSet of Mixed Collection</p>
<p>​        年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过<strong>整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent</strong>(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>
<p>​        为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p>
<h1 id="四、G1的活动周期"><a href="#四、G1的活动周期" class="headerlink" title="四、G1的活动周期"></a>四、G1的活动周期</h1><h3 id="4-1、G1垃圾收集活动汇总"><a href="#4-1、G1垃圾收集活动汇总" class="headerlink" title="4.1、G1垃圾收集活动汇总"></a>4.1、G1垃圾收集活动汇总</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/img_convert/5a60b80279c1f7a7664f6b54d26e967c.png" alt="G1垃圾收集活动周期图" class="lazyload"></p>
<h3 id="4-2、RSet的维护"><a href="#4-2、RSet的维护" class="headerlink" title="4.2、RSet的维护"></a>4.2、RSet的维护</h3><p>​        由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。在G1中，RSet的维护主要来源两个方面：<strong>写栅栏</strong>(Write Barrier)和<strong>并发优化线程</strong>(Concurrence Refinement Threads)</p>
<h3 id="4-3、栅栏-Barrier"><a href="#4-3、栅栏-Barrier" class="headerlink" title="4.3、栅栏 Barrier"></a>4.3、栅栏 Barrier</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://c1.staticflickr.com/5/4658/40093686702_9d689b29e9_z.jpg" alt="img" class="lazyload">)</p>
<p>​        首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p>
<h4 id="4-3-1、写前栅栏-Pre-Write-Barrrier"><a href="#4-3-1、写前栅栏-Pre-Write-Barrrier" class="headerlink" title="4.3.1、写前栅栏 Pre-Write Barrrier"></a>4.3.1、写前栅栏 Pre-Write Barrrier</h4><p>​        <strong>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么JVM就需要在赋值语句生效之前，记录丧失引用的对象</strong>。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见SATB)。</p>
<h4 id="4-3-2、写后栅栏-Post-Write-Barrrier"><a href="#4-3-2、写后栅栏-Post-Write-Barrrier" class="headerlink" title="4.3.2、写后栅栏 Post-Write Barrrier"></a>4.3.2、写后栅栏 Post-Write Barrrier</h4><p>​        <strong>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新</strong>。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</p>
<h4 id="4-3-4、起始快照算法-SATB"><a href="#4-3-4、起始快照算法-SATB" class="headerlink" title="4.3.4、起始快照算法 SATB"></a>4.3.4、起始快照算法 SATB</h4><p>​        Taiichi Tuasa贡献的增量式完全并发标记算法起始快照算法(Snapshot at the beginning)，主要针对标记-清除垃圾收集器的<strong>并发标记阶段</strong>，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p>
<p>​        SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet。此过程又称为并发标记/SATB写前栅栏。</p>
<h3 id="4-4、并发优化线程"><a href="#4-4、并发优化线程" class="headerlink" title="4.4、并发优化线程"></a>4.4、并发优化线程</h3><h4 id="4-4-1、并发优化线程-Concurrence-Refinement-Threads"><a href="#4-4-1、并发优化线程-Concurrence-Refinement-Threads" class="headerlink" title="4.4.1、并发优化线程 Concurrence Refinement Threads"></a>4.4.1、并发优化线程 Concurrence Refinement Threads</h4><p>​        G1中使用基于Urs Hölzle的快速写栅栏，将栅栏开销缩减到2个额外的指令。栅栏将会更新一个<strong>card table type</strong>的结构来<strong>跟踪代间引用</strong>。</p>
<p>​        当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p>
<p>​        并发优化线程(Concurrence Refinement Threads)，<strong>只专注扫描日志缓冲区记录的卡片来维护更新RSet</strong>，线程最大数目可通过-XX:G1ConcRefinementThreads(默认等于-XX:ParellelGCThreads)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。</p>
<p>​        如果记录增长很快或者来不及处理，那么通过阈值-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p>
<h4 id="4-4-2、并发标记周期-Concurrent-Marking-Cycle"><a href="#4-4-2、并发标记周期-Concurrent-Marking-Cycle" class="headerlink" title="4.4.2、并发标记周期 Concurrent Marking Cycle"></a>4.4.2、并发标记周期 Concurrent Marking Cycle</h4><p>​        并发标记周期是G1中非常重要的阶段，这个阶段将会<strong>为混合收集周期识别垃圾最多的老年代分区</strong>。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p>
<p>​        <strong>当达到IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，便会触发并发标记周期</strong>。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，<strong>初始标记(随年轻代收集一起活动)、重新标记、清除是STW的</strong>，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p>
<h4 id="4-4-3、并发标记线程-Concurrent-Marking-Threads"><a href="#4-4-3、并发标记线程-Concurrent-Marking-Threads" class="headerlink" title="4.4.3、并发标记线程 Concurrent Marking Threads"></a>4.4.3、并发标记线程 Concurrent Marking Threads</h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/img_convert/ac554fcaf159d7a7c62511c5e7db19fc.png" alt="并发标记位图过程" class="lazyload"></p>
<p>​        要标记存活的对象，每个分区都需要<strong>创建位图(Bitmap)信息来存储标记数据</strong>，来确定标记周期内被分配的对象。G1采用了两个位图Previous Bitmap、Next Bitmap，来存储标记数据，Previous位图存储上次的标记数据，Next位图在标记周期内不断变化更新，同时Previous位图的标记数据也越来越过时，当标记周期结束后Next位图便替换Previous位图，成为上次标记的位图。同时，每个分区通过顶部开始标记(TAMS)，来记录已标记过的内存范围。同样的，G1使用了两个顶部开始标记Previous TAMS(PTAMS)、Next TAMS(NTAMS)，记录已标记的范围。</p>
<p>​        在并发标记阶段，G1会根据参数-XX:ConcGCThreads(默认GC线程数的1/4，即-XX:ParallelGCThreads/4)，分配并发标记线程(Concurrent Marking Threads)，进行标记活动。<u>每个并发线程一次只扫描一个分区</u>，并通过”手指”指针的方式优化获取分区。并发标记线程是爆发式的，在给定的时间段拼命干活，然后休息一段时间，再拼命干活。</p>
<p>​        每个并发标记周期，在初始标记STW的最后，G1会分配一个空的Next位图和一个指向分区顶部(Top)的NTAMS标记。Previous位图记录的上次标记数据，上次的标记位置，即PTAMS，在PTAMS与分区底部(Bottom)的范围内，所有的存活对象都已被标记。那么，在PTAMS与Top之间的对象都将是隐式存活(Implicitly Live)对象。在并发标记阶段，Next位图吸收了Previous位图的标记数据，同时每个分区都会有新的对象分配，则Top与NTAMS分离，前往更高的地址空间。在并发标记的一次标记中，并发标记线程将找出NTAMS与PTAMS之间的所有存活对象，将标记数据存储在Next位图中。同时，在NTAMS与Top之间的对象即成为已标记对象。如此不断地更新Next位图信息，并在清除阶段与Previous位图交换角色。</p>
<p><strong>初始标记 Initial Mark</strong></p>
<p>​        初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是<strong>需要一个STW的时间段</strong>。事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为<strong>借道</strong>(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p>
<p><strong>根分区扫描 Root Region Scanning</strong></p>
<p>​        在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为<strong>根分区</strong>(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p>
<p><strong>并发标记 Concurrent Marking</strong></p>
<p>​        和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数-XX:ConcGCThreads(默认GC线程数的1/4，即-XX:ParallelGCThreads/4) 控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。</p>
<p>​        参数-XX:+ClassUnloadingWithConcurrentMark会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p>
<p><strong>存活数据计算 Live Data Accounting</strong></p>
<p>​        存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p>
<p><strong>重新标记 Remark</strong></p>
<p>​        重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数-XX:ParallelGCThread可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p>
<p><strong>清除 Cleanup</strong></p>
<p>​        紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p>
<ul>
<li>RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节；</li>
<li>整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</li>
<li>识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</li>
</ul>
<h3 id="4-5、年轻代收集-混合收集周期"><a href="#4-5、年轻代收集-混合收集周期" class="headerlink" title="4.5、年轻代收集/混合收集周期"></a>4.5、年轻代收集/混合收集周期</h3><p>​        年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p>
<h4 id="4-5-1、GC工作线程数-XX-ParallelGCThreads"><a href="#4-5-1、GC工作线程数-XX-ParallelGCThreads" class="headerlink" title="4.5.1、GC工作线程数 -XX:ParallelGCThreads"></a>4.5.1、GC工作线程数 -XX:ParallelGCThreads</h4><p>​        JVM可以通过参数-XX:ParallelGCThreads进行指定GC工作的线程数量。参数-XX:ParallelGCThreads默认值并不是固定的，而是根据当前的CPU资源进行计算。如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；当然也可以人工指定与CPU核数相等。</p>
<h4 id="4-5-2、年轻代收集-Young-Collection"><a href="#4-5-2、年轻代收集-Young-Collection" class="headerlink" title="4.5.2、年轻代收集 Young Collection"></a>4.5.2、年轻代收集 Young Collection</h4><p>​        每次收集过程中，既有并行执行的活动，也有串行执行的活动，但都可以是多线程的。在并行执行的任务中，如果某个任务过重，会导致其他线程在等待某项任务的处理，需要对这些地方进行优化。</p>
<p><strong>并行活动</strong></p>
<p>​        <strong>外部根分区扫描 Ext Root Scanning：</strong>此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</p>
<p>​        <strong>更新已记忆集合 Update RS：</strong>并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比-XX:G1RSetUpdatingPauseTimePercent(默认10%，即-XX:MaxGCPauseMills/10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</p>
<p>​        <strong>RSet扫描 Scan RS：</strong>在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式-XX:UnlockDiagnosticVMOptions后，通过参数-XX:+G1SummarizeRSetStats可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数-XX：G1SummarizeRSetStatsPeriod=n可设置RSet的统计周期，即经历多少此GC后进行一次统计</p>
<p>​        <strong>代码根扫描 Code Root Scanning：</strong>对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</p>
<p>​        <strong>转移和回收 Object Copy：</strong>通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来负载均衡地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</p>
<p>​        <strong>终止 Termination：</strong>完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</p>
<p>​        <strong>GC外部的并行活动 GC Worker Other：</strong>该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</p>
<p><strong>串行活动</strong></p>
<p>​        <strong>代码根更新 Code Root Fixup：</strong>根据转移对象更新代码根。</p>
<p>​        <strong>代码根清理 Code Root Purge：</strong>清理代码根集合表。</p>
<p>​        <strong>清除全局卡片标记 Clear CT：</strong>在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</p>
<p>​        <strong>选择下次收集集合 Choose CSet：</strong>该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</p>
<p>​        <strong>引用处理 Ref Proc：</strong>主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数-XX:ParallelRefProcEnabled激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</p>
<p>​        <strong>引用排队 Ref Enq：</strong>此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</p>
<p>​        <strong>卡片重新脏化 Redirty Cards：</strong>重新脏化卡片。</p>
<p>​        <strong>回收空闲巨型分区 Humongous Reclaim：</strong>G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</p>
<p>​        <strong>释放分区 Free CSet：</strong>回收CSet分区的所有空间，并加入到空闲分区中。</p>
<p>​        <strong>其他活动 Other：</strong>GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等。</p>
<h4 id="4-5-3、并发标记周期后的年轻代收集"><a href="#4-5-3、并发标记周期后的年轻代收集" class="headerlink" title="4.5.3、并发标记周期后的年轻代收集"></a>4.5.3、并发标记周期后的年轻代收集</h4><p><strong>并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</strong></p>
<p>​        当G1发起并发标记周期之后，并不会马上开始混合收集。G1会先等待下一次年轻代收集，然后在该收集阶段中，确定下次混合收集的CSet(Choose CSet)。</p>
<p><strong>混合收集周期 Mixed Collection Cycle</strong></p>
<p>​        单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p>
<h3 id="4-6、转移失败的担保机制-Full-GC"><a href="#4-6、转移失败的担保机制-Full-GC" class="headerlink" title="4.6、转移失败的担保机制 Full GC"></a>4.6、转移失败的担保机制 Full GC</h3><p><strong>转移失败的担保机制 Full GC</strong></p>
<p>​        转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，<strong>执行一次STW式的、单线程的Full GC</strong>。Full GC会<strong>对整堆做标记清除和压缩，最后将只包含纯粹的存活对象</strong>。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p>
<p>​        G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p>
<ul>
<li>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区</li>
<li>从老年代分区转移存活对象时，无法找到可用的空闲分区</li>
<li>分配巨型对象时在老年代无法找到足够的连续分区</li>
</ul>
<p>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>​        G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过**首先收集尽可能多的垃圾(Garbage First)**的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/03/17/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;JVM&#x2F;G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;JAVA&#x2F;JVM&#x2F;G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/">JAVA</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/JAVA/%E2%80%9CJVM%E2%80%9D/">“JVM”</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/JVM/" rel="tag">JVM</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM-GC%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%AF%94%E8%BE%83"><span class="toc-number">2.</span> <span class="toc-text">二、JVM GC收集器的回顾与比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、串行收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、并行收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、并发标记清除收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81Garbage-First"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、Garbage First</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81G1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">三、G1的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E5%88%86%E5%8C%BA%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、分区概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E3%80%81%E5%88%86%E5%8C%BA-Region"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1、分区 Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%E3%80%81%E5%8D%A1%E7%89%87-Card"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2、卡片 Card</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3%E3%80%81%E5%A0%86-Heap"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3、堆 Heap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、分代模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E3%80%81%E5%88%86%E4%BB%A3-Generation"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1、分代 Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%E3%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E9%85%8D%E7%BC%93%E5%86%B2-Lab"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2、本地分配缓冲  Lab</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、分区模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E3%80%81%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1-Humongous-Region"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1、巨型对象 Humongous Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E3%80%81%E5%B7%B2%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88-RSet"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2、已记忆集合  RSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3%E3%80%81Per-Region-Table"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3、Per Region Table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88-CSet"><span class="toc-number">3.4.</span> <span class="toc-text">3.4、收集集合 (CSet)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1%E3%80%81%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88-CSet"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1、收集集合 CSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2、年轻代收集集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3%E3%80%81%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3、混合收集集合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81G1%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%91%A8%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">四、G1的活动周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%B4%BB%E5%8A%A8%E6%B1%87%E6%80%BB"><span class="toc-number">0.1.</span> <span class="toc-text">4.1、G1垃圾收集活动汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81RSet%E7%9A%84%E7%BB%B4%E6%8A%A4"><span class="toc-number">0.2.</span> <span class="toc-text">4.2、RSet的维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E6%A0%85%E6%A0%8F-Barrier"><span class="toc-number">0.3.</span> <span class="toc-text">4.3、栅栏 Barrier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%E3%80%81%E5%86%99%E5%89%8D%E6%A0%85%E6%A0%8F-Pre-Write-Barrrier"><span class="toc-number">0.3.1.</span> <span class="toc-text">4.3.1、写前栅栏 Pre-Write Barrrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2%E3%80%81%E5%86%99%E5%90%8E%E6%A0%85%E6%A0%8F-Post-Write-Barrrier"><span class="toc-number">0.3.2.</span> <span class="toc-text">4.3.2、写后栅栏 Post-Write Barrrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4%E3%80%81%E8%B5%B7%E5%A7%8B%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95-SATB"><span class="toc-number">0.3.3.</span> <span class="toc-text">4.3.4、起始快照算法 SATB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%BA%BF%E7%A8%8B"><span class="toc-number">0.4.</span> <span class="toc-text">4.4、并发优化线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E3%80%81%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%BA%BF%E7%A8%8B-Concurrence-Refinement-Threads"><span class="toc-number">0.4.1.</span> <span class="toc-text">4.4.1、并发优化线程 Concurrence Refinement Threads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E5%91%A8%E6%9C%9F-Concurrent-Marking-Cycle"><span class="toc-number">0.4.2.</span> <span class="toc-text">4.4.2、并发标记周期 Concurrent Marking Cycle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%BA%BF%E7%A8%8B-Concurrent-Marking-Threads"><span class="toc-number">0.4.3.</span> <span class="toc-text">4.4.3、并发标记线程 Concurrent Marking Threads</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86-%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86%E5%91%A8%E6%9C%9F"><span class="toc-number">0.5.</span> <span class="toc-text">4.5、年轻代收集&#x2F;混合收集周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1%E3%80%81GC%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%95%B0-XX-ParallelGCThreads"><span class="toc-number">0.5.1.</span> <span class="toc-text">4.5.1、GC工作线程数 -XX:ParallelGCThreads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86-Young-Collection"><span class="toc-number">0.5.2.</span> <span class="toc-text">4.5.2、年轻代收集 Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E5%91%A8%E6%9C%9F%E5%90%8E%E7%9A%84%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-number">0.5.3.</span> <span class="toc-text">4.5.3、并发标记周期后的年轻代收集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E3%80%81%E8%BD%AC%E7%A7%BB%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6-Full-GC"><span class="toc-number">0.6.</span> <span class="toc-text">4.6、转移失败的担保机制 Full GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">五、总结</span></a></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1648185133656"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
