<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>STL六大组件简介 | Shuyan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="STL 从广义上分为: **容器**(container) **算法**(algorithm) **迭代器**(iterator)。  ​        容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。 ​        STL(Standard Template Library)标准模板库">
<meta property="og:type" content="article">
<meta property="og:title" content="STL六大组件简介">
<meta property="og:url" content="http://example.com/2022/03/17/C%E8%AF%AD%E8%A8%80/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="STL 从广义上分为: **容器**(container) **算法**(algorithm) **迭代器**(iterator)。  ​        容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。 ​        STL(Standard Template Library)标准模板库">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190816214408796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817080710196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817080837663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817081120534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817081324852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817081547209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-03-17T03:16:04.419Z">
<meta property="article:modified_time" content="2022-03-17T03:19:42.801Z">
<meta property="article:author" content="Shuyan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190816214408796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="Shuyan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shuyan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C语言/STL六大组件简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/C%E8%AF%AD%E8%A8%80/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2022-03-17T03:16:04.419Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      STL六大组件简介
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>    STL 从广义上分为: **容器**(container) **算法**(algorithm) **迭代器**(iterator)。
</code></pre>
<p>​        容器和算法之间通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<p>​        STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。</p>
<h1 id="STL六大组件简介"><a href="#STL六大组件简介" class="headerlink" title="STL六大组件简介"></a>STL六大组件简介</h1><p>​        STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:<strong>容器</strong>、<strong>算法</strong>、<strong>迭代器</strong>、<strong>仿函数</strong>、<strong>适配器（配接器）</strong>、<strong>空间配置器</strong>。</p>
<ul>
<li><p><strong>容器</strong>：各种数据结构，如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p>
</li>
<li><p><strong>算法</strong>：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p>
</li>
<li><p><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>
</li>
<li><p><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p>
</li>
<li><p><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
</li>
<li><p><strong>空间配置器</strong>：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p>
</li>
</ul>
<p>​        STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<p><strong>STL的优点很明显了</strong>：</p>
<ul>
<li>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。<ul>
<li>高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li>
<li>高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</li>
<li>高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</li>
</ul>
</li>
</ul>
<h1 id="三大组件介绍"><a href="#三大组件介绍" class="headerlink" title="三大组件介绍"></a>三大组件介绍</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h2><p>​        几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。<br>​        常用的数据结构：<strong>数组</strong>(array) , <strong>链表</strong>(list), tree(<strong>树</strong>)，<strong>栈</strong>(stack), <strong>队列</strong>(queue), <strong>集合</strong>(set),<strong>映射表</strong>(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li>
<li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器</li>
</ul>
<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><p>​        算法，问题的解法，以有限的步骤，解决逻辑或数学上的问题。</p>
<p>​        我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p>
<p>​        算法分为:质变算法和非质变算法。</p>
<ul>
<li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
</ul>
<h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><p>​        迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 在&lt;<Design Patterns>&gt;一书中提供了23种设计模式的完整描述， 其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>​        迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。</p>
<p>​        从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p>
<p>迭代器的种类:</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>提供对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>演示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL 中的容器 算法 迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v; 			<span class="comment">// STL 中的标准容器之一 ：动态数组</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>); 		<span class="comment">// vector 容器提供的插入数据的方法</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator pStart = v.<span class="built_in">begin</span>(); 		<span class="comment">// vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>(); 			<span class="comment">// vector 容器提供了 end()方法 返回指向最后一个元素*下一个位置*的迭代器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过迭代器遍历</span></span><br><span class="line">    <span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">        cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pStart++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 算法 count 算法: 用于统计元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">count</span>(pStart, pEnd, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL 容器不单单可以存储基础数据类型，也可以存储类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Teacher</span>(<span class="keyword">int</span> age) :<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">    	~<span class="built_in">Teacher</span>()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Teacher&gt; v; 				<span class="comment">// 存储 Teacher 类型数据的容器</span></span><br><span class="line">    <span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">20</span>)</span>, <span class="title">t3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">    </span><br><span class="line">    vector&lt;Teacher&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;Teacher&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过迭代器遍历</span></span><br><span class="line">    <span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">        cout &lt;&lt; pStart-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pStart++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 Teacher 类型指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Teacher*&gt; v; 				<span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line">    Teacher* t1 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">10</span>);</span><br><span class="line">    Teacher* t2 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">20</span>);</span><br><span class="line">    Teacher* t3 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到容器迭代器</span></span><br><span class="line">    vector&lt;Teacher*&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;Teacher*&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过迭代器遍历</span></span><br><span class="line">    <span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">        cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pStart++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器嵌套容器 难点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator subIt = (*it).<span class="built_in">begin</span>(); subIt != (*it).<span class="built_in">end</span>(); subIt ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *subIt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="1-string容器"><a href="#1-string容器" class="headerlink" title="1. string容器"></a>1. string容器</h2><h3 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h3><p>​        C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。<br>String和c风格字符串对比：</p>
<ul>
<li>Char<em>是一个指针，String是一个类<br>string封装了char</em>，管理这个字符串，是一个char*型的容器。</li>
<li>String封装了很多实用的成员方法<br>查找find，拷贝copy，删除delete 替换replace，插入insert</li>
<li>不用考虑内存释放和越界<br>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li>
</ul>
<h3 id="string容器常用操作"><a href="#string容器常用操作" class="headerlink" title="string容器常用操作"></a>string容器常用操作</h3><p><strong>string 构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();														<span class="comment">// 创建一个空的字符串 例如: string str; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">int</span> n, <span class="keyword">char</span> c);											<span class="comment">// 使用n个字符c初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);										<span class="comment">// 使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span> &amp;str, size_type index, size_type length );		<span class="comment">// 以index为索引开始的子串，长度为length</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);											<span class="comment">// 使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s, size_type length );</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(input_iterator start, input_iterator end );				<span class="comment">// 以从start到end的元素为初值.</span></span><br></pre></td></tr></table></figure>

<p><strong>支持的操作符</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">== &gt; &lt; &gt;= &lt;= != + += []</span><br></pre></td></tr></table></figure>

<p><strong>string基本赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s);						<span class="comment">// char*类型字符串 赋值给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);					<span class="comment">// 把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span> = (<span class="keyword">char</span> c);							<span class="comment">// 字符赋值给当前的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;							<span class="comment">// 把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;					<span class="comment">// 把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;						<span class="comment">// 把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span>;		<span class="comment">// 将s从start开始n个字符赋值给字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;							<span class="comment">// 用n个字符c赋给当前字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>string存取字符操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n);							<span class="comment">// 通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">at</span><span class="params">(<span class="keyword">int</span> n)</span></span>;									<span class="comment">// 通过at方法获取字符</span></span><br></pre></td></tr></table></figure>

<p><strong>string拼接操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);						<span class="comment">// 重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str);						<span class="comment">// 重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c);							<span class="comment">// 重载+=操作符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;								<span class="comment">// 把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;						<span class="comment">// 把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;							<span class="comment">// 同operator+=()</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;			<span class="comment">// 把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(input_iterator start,input_iterator end)</span></span>; 	<span class="comment">// 在字符串的末尾添加以迭代器start和end表示的字符序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;								<span class="comment">// 在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>

<p><strong>string查找和替换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; 			<span class="comment">// 查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  				<span class="comment">// 查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  			<span class="comment">// 从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  				<span class="comment">// 查找字符c第一次出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;			<span class="comment">// 查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;				<span class="comment">// 查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;				<span class="comment">// 从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; 				<span class="comment">// 查找字符c最后一次出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; 		<span class="comment">// 替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; 			<span class="comment">// 替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 find_first_of:查找在字符串中第一个与str中的某个字符匹配的字符</span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> basic_string &amp;str, size_type index = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 find_first_not_of:在字符串中查找第一个与str中的字符都不匹配的字符</span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> basic_string &amp;str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 find_last_of:在字符串中查找最后一个与str中的某个字符匹配的字符</span></span><br><span class="line"><span class="function">size_type <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> basic_string &amp;str, size_type index = npos )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index = npos )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_of</span><span class="params">(<span class="keyword">char</span> ch, size_type index = npos )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数 find_last_not_of:在字符串中查找最后一个与str中的字符都不匹配的字符</span></span><br><span class="line"><span class="function">size_type <span class="title">find_last_not_of</span><span class="params">( <span class="keyword">const</span> basic_string &amp;str, size_type index = npos )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index = npos)</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">char</span> ch, size_type index = npos )</span></span>;    </span><br></pre></td></tr></table></figure>

<p><strong>string比较操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	compare函数在 &gt; 时返回 1，&lt; 时返回 -1，== 时返回 0。</span></span><br><span class="line"><span class="comment">	比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">	大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;							<span class="comment">// 与字符串s比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;							<span class="comment">// 与字符串s比较</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(size_type index, size_type length,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(size_type index, size_type length,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str,size_type index2,size_type length2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(size_type index,size_type length,<span class="keyword">const</span> <span class="keyword">char</span> *str,size_type length2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span></span><br></pre></td></tr></table></figure>

<p><strong>string子串</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;				<span class="comment">// 返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>string交换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(string&amp; str)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>string插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; 					<span class="comment">// 插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; 				<span class="comment">// 插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;						<span class="comment">// 在指定位置插入n个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span></span>;						<span class="comment">// 删除从Pos开始的n个字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>;								<span class="comment">// 删除it指向的字符，返回删除后迭代器的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;				<span class="comment">// 删除[first，last）之间的所有字符，返回删除后迭代器的位置</span></span><br></pre></td></tr></table></figure>

<p><strong>string和c-style字符串转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;								<span class="comment">//返回一个指向正规C字符串的指针, 内容与本字符串相同</span></span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span></span>;								<span class="comment">// 返回在重新申请更多的空间前字符串可以容纳的字符数. 这个数字至少与 size()一样大</span></span><br><span class="line"><span class="function">size_type <span class="title">copy</span><span class="params">( <span class="keyword">char</span> *str, size_type num, size_type index )</span></span>; <span class="comment">// 拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">data</span><span class="params">()</span></span>;									<span class="comment">// 返回指向自己的第一个字符的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span></span>;								<span class="comment">// 返回字符串能保存的最大字符数</span></span><br><span class="line"><span class="function">size_type <span class="title">length</span><span class="params">()</span></span>;									<span class="comment">// 返回字符串的长度. 这个数字应该和size()返回的数字相同</span></span><br><span class="line"><span class="built_in">size</span>();												<span class="comment">// 返回字符串中字符的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">reserve</span>( size_type num );							<span class="comment">// 保留一定容量以容纳字符串（设置capacity值）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( size_type num )</span></span>;						<span class="comment">// 改变本字符串的大小到num, 新空间的内容不确定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( size_type num, <span class="keyword">char</span> ch )</span></span>;				<span class="comment">// 也可以指定用ch填充</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 转 char*</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* 转 string </span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​        在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string.</p>
<p>​        通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.</p>
</blockquote>
<p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>&amp; a = s[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;pppppppppppppppppppppppp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = &#x27;1&#x27;;</span></span><br><span class="line"><span class="comment">// b = &#x27;2&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2. vector容器"></a>2. vector容器</h2><h3 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h3><p>​        vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。</p>
<p>​        <strong>Array是静态空间</strong>，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p>
<p>​        Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p>
<p>​        Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”<strong>配置新空间-数据移动-释放旧空间</strong>”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。</p>
<p><img src="https://img-blog.csdnimg.cn/20190816214408796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>​        Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*、 operator-&gt;、 operator++、operator–、 operator+、 operator-、 operator+=、 operator-=，普通指针天生具备。</p>
<p>​        <strong>Vector支持随机存取</strong>，而普通指针正有着这样的能力。所以vector提供的是<strong>随机访问迭代器</strong>(Random Access Iterators).</p>
<p>​        根据上述描述，如果我们写如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="keyword">int</span>&gt;::iterator it1;</span><br><span class="line">Vector&lt;Teacher&gt;::iterator it2;</span><br></pre></td></tr></table></figure>

<p>​        it1的型别其实就是Int，it2的型别其实就是Teacher。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;  				<span class="comment">// v.capacity()容器的容量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h3><p>​        Vector所采用的数据结构非常简单，<strong>线性连续空间</strong>，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器**_Myend指向整块连续内存空间的尾端**。</p>
<p>​        为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</p>
<blockquote>
<p>​        所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。</p>
</blockquote>
<h3 id="vector常用API操作"><a href="#vector常用API操作" class="headerlink" title="vector常用API操作"></a>vector常用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a>操作</h3><p><strong>vector构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; 								<span class="comment">// 采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());					<span class="comment">// 将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);							<span class="comment">// 构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> vector &amp;vec);					<span class="comment">// 拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>

<p><strong>vector常用赋值操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);							<span class="comment">// 将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);							<span class="comment">// 将n个elem拷贝赋值给本身。</span></span><br><span class="line"></span><br><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector  &amp;vec);		<span class="comment">// 重载等号操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(vec);									<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure>

<p><strong>vector定位操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>							<span class="comment">// 返回一个当前vector容器中起始元素的迭代器。</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>								<span class="comment">// 返回一个当前vector容器中末尾元素的迭代器。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> reverse_iterator <span class="title">rbegin</span><span class="params">()</span>				<span class="comment">// 返回一个逆序迭代器，指向容器的最后一个元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> reverse_iterator <span class="title">rend</span><span class="params">()</span>				<span class="comment">// 返回一个逆序迭代器，它指向容器的第一个元素前面的位置</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">front</span><span class="params">()</span>							<span class="comment">// 返回一个当前vector容器中末尾元素的迭代器。</span></span></span><br><span class="line"><span class="function">iterator <span class="title">back</span><span class="params">()</span>								<span class="comment">// 返回当前vector容器中末尾元素的引用。</span></span></span><br></pre></td></tr></table></figure>

<p><strong>vector大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();									<span class="comment">// 返回容器中元素的个数</span></span><br><span class="line">empty();								<span class="comment">// 判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">resize(<span class="keyword">int</span> num);						<span class="comment">// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。若容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(<span class="keyword">int</span> num, elem);					<span class="comment">// 重新指定容器的长度为num，若容器变长，则以elem值填充新位置。若容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line"></span><br><span class="line">capacity();								<span class="comment">// 容器的容量</span></span><br><span class="line">reserve(<span class="keyword">int</span> len);						<span class="comment">// 容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>

<p><strong>vector数据存取操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at(<span class="keyword">int</span> idx); 							<span class="comment">// 返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];								<span class="comment">// 返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"></span><br><span class="line">front();								<span class="comment">// 返回容器中第一个数据元素</span></span><br><span class="line">back();									<span class="comment">// 返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<p><strong>vector插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, <span class="keyword">int</span> count,ele);				<span class="comment">// 迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line">push_back(ele); 										<span class="comment">// 尾部插入元素ele</span></span><br><span class="line"></span><br><span class="line">pop_back();												<span class="comment">// 删除最后一个元素</span></span><br><span class="line"></span><br><span class="line">erase(const_iterator start, const_iterator end);		<span class="comment">// 删除迭代器从start到end之间的元素</span></span><br><span class="line">erase(const_iterator pos);								<span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line"></span><br><span class="line">clear();												<span class="comment">// 删除容器中所有元素</span></span><br></pre></td></tr></table></figure>

<p>vector 小demo:  巧用swap，收缩内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时 通过resize改变容器大小</span></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容量没有改变</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reserve预留空间</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预先开辟空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* pStart = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (pStart != &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">			pStart = &amp;v[<span class="number">0</span>];</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-deque容器"><a href="#3-deque容器" class="headerlink" title="3. deque容器"></a>3. deque容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h3><p>​        Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</p>
<p>​        所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p>
<p><img src="https://img-blog.csdnimg.cn/20190817080710196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p>
<p>​        虽然deque容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p>
<h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a>deque容器实现原理</h3><p>​        Deque容器是<strong>连续的空间</strong>，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector、array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上经历了“<strong>申请更大空间—&gt;原数据复制新空间—&gt;释放原空间</strong>”三个步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>​        Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>​        既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p>
<p>​        Deque采取一块所谓的<strong>map</strong>(注意，不是STL的map容器)作为主控，这里所谓的map是<strong>一小块连续的内存空间</strong>，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。<strong>缓冲区才是deque的存储空间的主体</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190817080837663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a>deque常用API</h3><p><strong>deque构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;T&gt; deqT;							<span class="comment">// 默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);						<span class="comment">// 构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);							<span class="comment">// 构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);				<span class="comment">// 拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>deque赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);						<span class="comment">// 将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);						<span class="comment">// 将n个elem拷贝赋值给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); 	<span class="comment">// 重载等号操作符 </span></span><br><span class="line"></span><br><span class="line">swap(deq);								<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>

<p><strong>deque大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();							<span class="comment">// 返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">deque</span>.empty();							<span class="comment">// 判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.resize(num);						<span class="comment">// 重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem);				<span class="comment">// 重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<p><strong>deque双端插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);						<span class="comment">// 在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);						<span class="comment">// 在容器头部插入一个数据</span></span><br><span class="line"></span><br><span class="line">pop_back();								<span class="comment">// 删除容器最后一个数据</span></span><br><span class="line">pop_front();							<span class="comment">// 删除容器第一个数据</span></span><br></pre></td></tr></table></figure>

<p><strong>deque数据存取</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at(idx);								<span class="comment">// 返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];								<span class="comment">// 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"></span><br><span class="line">front();								<span class="comment">// 返回第一个数据。</span></span><br><span class="line">back();									<span class="comment">// 返回最后一个数据</span></span><br></pre></td></tr></table></figure>

<p><strong>deque插入操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);						<span class="comment">// 在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);						<span class="comment">// 在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);					<span class="comment">// 在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>

<p><strong>deque删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();								<span class="comment">// 移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line">erase(beg,end);							<span class="comment">// 删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);								<span class="comment">// 删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-stack容器"><a href="#4-stack容器" class="headerlink" title="4. stack容器"></a>4. stack容器</h2><h3 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h3><p>​        stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，<strong>stack不允许有遍历行为</strong>。<br>​        有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.</p>
<p><img src="https://img-blog.csdnimg.cn/20190817081120534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="stack没有迭代器"><a href="#stack没有迭代器" class="headerlink" title="stack没有迭代器"></a>stack没有迭代器</h3><p>​        Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。<strong>Stack不提供遍历功能，也不提供迭代器</strong>。</p>
<h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a>stack常用API</h3><p><strong>stack构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;T&gt; stkT;								<span class="comment">// stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);					<span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>stack赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);			<span class="comment">// 重载等号操作符</span></span><br></pre></td></tr></table></figure>

<p><strong>stack数据存取操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);									<span class="comment">// 向栈顶添加元素</span></span><br><span class="line">pop();										<span class="comment">// 从栈顶移除第一个元素</span></span><br><span class="line">top();										<span class="comment">// 返回栈顶元素</span></span><br></pre></td></tr></table></figure>

<p><strong>stack大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();									<span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">size();										<span class="comment">// 返回堆栈的大小</span></span><br></pre></td></tr></table></figure>

<h2 id="5-queue容器"><a href="#5-queue容器" class="headerlink" title="5. queue容器"></a>5. queue容器</h2><h3 id="queue容器基本概念"><a href="#queue容器基本概念" class="headerlink" title="queue容器基本概念"></a>queue容器基本概念</h3><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<br><img src="https://img-blog.csdnimg.cn/20190817081324852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p>
<h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><p><strong>queue构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; queT;							<span class="comment">// queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);				<span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>queue存取、插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(elem);								<span class="comment">// 往队尾添加元素</span></span><br><span class="line">pop();									<span class="comment">// 从队头移除第一个元素</span></span><br><span class="line"></span><br><span class="line">front();								<span class="comment">// 返回第一个元素</span></span><br><span class="line">back();									<span class="comment">// 返回最后一个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>queue赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);		<span class="comment">// 重载等号操作符</span></span><br></pre></td></tr></table></figure>

<p><strong>queue大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();								<span class="comment">// 判断队列是否为空</span></span><br><span class="line">size();									<span class="comment">// 返回队列的大小</span></span><br></pre></td></tr></table></figure>

<h2 id="6-list容器"><a href="#6-list容器" class="headerlink" title="6. list容器"></a>6. list容器</h2><p><strong>list容器基本概念</strong><br>        链表是一种物理存储单元上<strong>非连续、非顺序</strong>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>​        链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>​        相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<p>​        List和vector是两个最常被使用的容器。</p>
<p>​        List容器是一个<strong>双向链表</strong>。<br><img src="https://img-blog.csdnimg.cn/20190817081547209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzIyMTAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大</li>
</ul>
<h3 id="list容器的迭代器"><a href="#list容器的迭代器" class="headerlink" title="list容器的迭代器"></a>list容器的迭代器</h3><p>​        List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。</p>
<p>​        List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p>
<p>​        由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是<strong>Bidirectional Iterators</strong>.</p>
<p>​        List有一个重要的性质，<strong>插入操作和删除操作都不会造成原有list迭代器的失效</strong>。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p>
<h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a>list容器的数据结构</h3><p>list容器不仅是一个双向链表，而且还是一个<strong>循环的双向链表</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; myList;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">		myList.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::_Nodeptr node =  myList._Myhead-&gt;_Next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList._Mysize * <span class="number">2</span>;i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Node:&quot;</span> &lt;&lt; node-&gt;_Myval &lt;&lt; endl;</span><br><span class="line">		node = node-&gt;_Next;</span><br><span class="line">		<span class="keyword">if</span> (node == myList._Myhead)&#123;</span><br><span class="line">			node = node-&gt;_Next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a>list常用API</h3><p><strong>list构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;T&gt; lstT;								<span class="comment">// list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);								<span class="comment">// 构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);								<span class="comment">// 构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);						<span class="comment">// 拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>list数据元素插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);							<span class="comment">// 在容器尾部加入一个元素</span></span><br><span class="line">pop_back();									<span class="comment">// 删除容器中最后一个元素</span></span><br><span class="line"></span><br><span class="line">push_front(elem);							<span class="comment">// 在容器开头插入一个元素</span></span><br><span class="line">pop_front();								<span class="comment">// 从容器开头移除第一个元素</span></span><br><span class="line"></span><br><span class="line">insert(pos,elem);							<span class="comment">// 在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);							<span class="comment">// 在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);						<span class="comment">// 在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"></span><br><span class="line">clear();									<span class="comment">// 移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line">erase(beg,end);								<span class="comment">// 删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);									<span class="comment">// 删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"></span><br><span class="line">remove(elem);								<span class="comment">// 删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>list大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size();									<span class="comment">// 返回容器中元素的个数</span></span><br><span class="line">empty();								<span class="comment">// 判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">resize(num);							<span class="comment">// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置;如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(num, elem);						<span class="comment">// 重新指定容器的长度为num，若容器变长，则以elem值填充新位置;如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<p><strong>list赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);						<span class="comment">// 将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);						<span class="comment">// 将n个elem拷贝赋值给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);		<span class="comment">// 重载等号操作符</span></span><br><span class="line"></span><br><span class="line">swap(lst);								<span class="comment">// 将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>

<p><strong>list数据的存取</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();								<span class="comment">// 返回第一个元素。</span></span><br><span class="line">back();									<span class="comment">// 返回最后一个元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>list反转排序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();								<span class="comment">// 反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line">sort(); 								<span class="comment">// list排序</span></span><br></pre></td></tr></table></figure>

<h2 id="7-set-multiset容器"><a href="#7-set-multiset容器" class="headerlink" title="7. set/multiset容器"></a>7. set/multiset容器</h2><h3 id="set容器基本概念"><a href="#set容器基本概念" class="headerlink" title="set容器基本概念"></a>set容器基本概念</h3><p>​        Set的特性是：<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p>
<p>​        我们不可以通过set的迭代器改变set元素的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种<strong>const</strong>_iterator.</p>
<p>​        set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p>
<h3 id="multiset容器基本概念"><a href="#multiset容器基本概念" class="headerlink" title="multiset容器基本概念"></a>multiset容器基本概念</h3><p>​        multiset特性及用法和set完全相同，唯一的差别在于它<strong>允许键值重复</strong>。set和multiset的底层实现是<strong>红黑树</strong>。</p>
<h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><p><strong>set构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;T&gt; st;								<span class="comment">// set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; 						<span class="comment">// multiset默认构造函数:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);						<span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>set赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);			<span class="comment">// 重载等号操作符</span></span><br><span class="line"></span><br><span class="line">swap(st);								<span class="comment">// 交换两个集合容器</span></span><br></pre></td></tr></table></figure>

<p><strong>set大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();									<span class="comment">// 返回容器中元素的数目</span></span><br><span class="line">empty();								<span class="comment">// 判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<p><strong>set插入和删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);							<span class="comment">// 在容器中插入元素。</span></span><br><span class="line"></span><br><span class="line">clear();								<span class="comment">// 清除所有元素</span></span><br><span class="line"></span><br><span class="line">erase(pos);								<span class="comment">// 删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg, end);						<span class="comment">// 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(elem);							<span class="comment">// 删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>set查找操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find(key);								<span class="comment">// 查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"></span><br><span class="line">count(key);								<span class="comment">// 查找键key的元素个数</span></span><br><span class="line"></span><br><span class="line">lower_bound(keyElem);					<span class="comment">// 返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);					<span class="comment">// 返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line">equal_range(keyElem);					<span class="comment">// 返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>

<p><strong>set的返回值 指定set排序规则举例:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = s.insert(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret.second)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare02</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">// set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">		s.insert(rand() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set容器中存放对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> mName;</span><br><span class="line">        <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare03</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.insert(p1);</span><br><span class="line">	s.insert(p2);</span><br><span class="line">	s.insert(p3);</span><br><span class="line">	s.insert(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; it-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; it-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。<br>类模板：<code>template &lt;class T1, class T2&gt; struct pair.</code><br>创建对组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法创建一个对组</span></span><br><span class="line"><span class="function"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="title">pair1</span><span class="params">(<span class="built_in">string</span>(<span class="string">&quot;name&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.first &lt;&lt; <span class="built_in">endl</span>; 						<span class="comment">// 访问pair第一个值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;						<span class="comment">// 访问pair第二个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = <span class="built_in">make_pair</span>(<span class="string">&quot;name&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pair=赋值</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3 = pair2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-map-multimap容器"><a href="#8-map-multimap容器" class="headerlink" title="8. map/multimap容器"></a>8. map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>​        Map的特性是，所有元素都会根据元素的键值自动排序。</p>
<p>​        Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p>
<p>​        我们不可以通过map的迭代器改变map的键值, 因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p>
<p>​        Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p>
<p>​        Multimap和map的操作类似，唯一区别multimap键值可重复。</p>
<p>​        Map和multimap都是以<strong>红黑树</strong>为底层实现机制。</p>
<h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><p><strong>map构造函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1, T2&gt; mapTT;							<span class="comment">// map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);							<span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>map赋值操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);				<span class="comment">// 重载等号操作符</span></span><br><span class="line">swap(mp);									<span class="comment">// 交换两个集合容器</span></span><br></pre></td></tr></table></figure>

<p><strong>map大小操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();										<span class="comment">// 返回容器中元素的数目</span></span><br><span class="line">empty();									<span class="comment">// 判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<p><strong>map插入数据元素操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(...); 							<span class="comment">// 往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.inset(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>map删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear();									<span class="comment">// 删除所有元素</span></span><br><span class="line"></span><br><span class="line">erase(pos);									<span class="comment">// 删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg,end);								<span class="comment">// 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(keyElem);								<span class="comment">// 删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>

<p><strong>map查找操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find(key);									<span class="comment">// 查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line"></span><br><span class="line">count(keyElem);								<span class="comment">// 返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line"></span><br><span class="line">lower_bound(keyElem);						<span class="comment">// 返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);						<span class="comment">// 返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line">equal_range(keyElem);						<span class="comment">// 返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>

<p><strong>multimap案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">// 人员信息有: 姓名 年龄 电话 工资等组成</span></span><br><span class="line"><span class="comment">// 通过Multimap进行信息的插入 保存 显示</span></span><br><span class="line"><span class="comment">// 分部门显示员工信息 显示全部员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap 案例</span></span><br><span class="line"><span class="comment">// 公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">// 人员信息有: 姓名 年龄 电话 工资等组成</span></span><br><span class="line"><span class="comment">// 通过 Multimap 进行信息的插入 保存 显示</span></span><br><span class="line"><span class="comment">// 分部门显示员工信息 显示全部员工信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALE_DEPATMENT 1 				<span class="comment">// 销售部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVELOP_DEPATMENT 2 			<span class="comment">// 研发部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINACIAL_DEPATMENT 3 			<span class="comment">// 财务部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL_DEPATMENT 4 				<span class="comment">// 所有部门</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name; 						<span class="comment">// 员工姓名</span></span><br><span class="line">	<span class="keyword">int</span> age; 							<span class="comment">// 员工年龄</span></span><br><span class="line">	<span class="keyword">double</span> salary; 						<span class="comment">// 员工工资</span></span><br><span class="line">	<span class="built_in">string</span> tele; 						<span class="comment">// 员工电话</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建5个员工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePerson</span><span class="params">(<span class="built_in">vector</span>&lt;person&gt;&amp; vlist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">		person p;</span><br><span class="line">		p.name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		p.name += seed[i];</span><br><span class="line">		p.age = rand() % <span class="number">30</span> + <span class="number">20</span>;</span><br><span class="line">		p.salary = rand() % <span class="number">20000</span> + <span class="number">10000</span>;</span><br><span class="line">		p.tele = <span class="string">&quot;010-8888888&quot;</span>;</span><br><span class="line">		vlist.push_back(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5名员工分配到不同的部门</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonByGroup</span><span class="params">(<span class="built_in">vector</span>&lt;person&gt;&amp; vlist, <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> operate = <span class="number">-1</span>; 					<span class="comment">// 用户的操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;person&gt;::iterator it = vlist.begin(); it != vlist.end(); it++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前员工信息:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operate);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (operate == SALE_DEPATMENT)&#123;  <span class="comment">// 将该员工加入到销售部门</span></span><br><span class="line">				plist.insert(<span class="built_in">make_pair</span>(SALE_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (operate == DEVELOP_DEPATMENT)&#123;</span><br><span class="line">				plist.insert(<span class="built_in">make_pair</span>(DEVELOP_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (operate == FINACIAL_DEPATMENT)&#123;</span><br><span class="line">				plist.insert(<span class="built_in">make_pair</span>(FINACIAL_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operate);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;员工部门分配完毕!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;***********************************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist, <span class="keyword">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (myoperate == ALL_DEPATMENT)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;second.tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;::iterator it = plist.find(myoperate);</span><br><span class="line">	<span class="keyword">int</span> depatCount = plist.count(myoperate);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (it != plist.end())&#123;</span><br><span class="line">		<span class="keyword">while</span> (it != plist.end() &amp;&amp; num &lt; depatCount)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;second.tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			it++;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户操作显示不同部门的人员列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPersonList</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist, <span class="keyword">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (myoperate)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">		printList(plist, SALE_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">		printList(plist, DEVELOP_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">		printList(plist, FINACIAL_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">		printList(plist, ALL_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户操作菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonMenue</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> isexit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">			ShowPersonList(plist, SALE_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">			ShowPersonList(plist, DEVELOP_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">			ShowPersonList(plist, FINACIAL_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">			ShowPersonList(plist, ALL_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			isexit = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isexit == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;person&gt;  vlist; 				<span class="comment">// 创建的5个员工 未分组</span></span><br><span class="line">	<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt; plist;		<span class="comment">// 保存分组后员工信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建5个员工</span></span><br><span class="line">	CreatePerson(vlist);</span><br><span class="line">	<span class="comment">// 5名员工分配到不同的部门</span></span><br><span class="line">	PersonByGroup(vlist, plist);</span><br><span class="line">	<span class="comment">// 根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表</span></span><br><span class="line">	PersonMenue(plist);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table>
<thead>
<tr>
<th>.</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：不是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>​        vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>
<p>​        deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>​        <strong>vector与deque的比较：</strong></p>
<ul>
<li><p>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</p>
</li>
<li><p>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p>
</li>
<li><p>deque支持头部的快速插入与快速移除，这是deque的优点。</p>
<p><strong>使用场景：</strong></p>
</li>
</ul>
<p>​        list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>​        set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>​        map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="1-函数对象"><a href="#1-函数对象" class="headerlink" title="1. 函数对象"></a>1. 函数对象</h2><p>​        <strong>重载函数调用操作符的类</strong>，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<p>注意:</p>
<ol>
<li><strong>函数对象(仿函数)是一个类</strong>，不是一个函数。</li>
<li>函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</li>
</ol>
<p>分类:</p>
<p>​        假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；</p>
<p>​        相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
<p>函数对象的作用:<br>        STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数对象是重载了函数调用符号的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyPrint()</span><br><span class="line">        &#123;</span><br><span class="line">            m_Num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m_Num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            m_Num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="comment">// 重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	myPrint(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	myPrint(<span class="number">20</span>);</span><br><span class="line">	myPrint(<span class="number">20</span>);</span><br><span class="line">	myPrint(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; myPrint.m_Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">(MyPrint print,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	print(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 参数1：匿名函数对象</span></span><br><span class="line">	doBusiness(MyPrint(),<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。<br>2、函数对象超出普通函数的概念，函数对象可以有自己的状态<br>3、函数对象可内联编译，性能好。用函数指针几乎不可能<br>4、模版函数对象使函数对象具有通用性，这也是它的优势之一</p>
<h2 id="2-谓词"><a href="#2-谓词" class="headerlink" title="2. 谓词"></a>2. 谓词</h2><p>​        **谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)**。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterThenFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元谓词</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());</span><br><span class="line">	 <span class="keyword">if</span> (it == v.end())</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.push_back(<span class="number">10</span>);</span><br><span class="line">	v.push_back(<span class="number">40</span>);</span><br><span class="line">	v.push_back(<span class="number">20</span>);</span><br><span class="line">	v.push_back(<span class="number">90</span>);</span><br><span class="line">	v.push_back(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认从小到大</span></span><br><span class="line">	sort(v.begin(), v.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	sort(v.begin(), v.end(),MyCompare());</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-内建函数对象"><a href="#3-内建函数对象" class="headerlink" title="3.内建函数对象"></a>3.内建函数对象</h2><p>​        STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T plus&lt;T&gt;							<span class="comment">// 加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T minus&lt;T&gt;						<span class="comment">// 减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T multiplies&lt;T&gt;					<span class="comment">// 乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T divides&lt;T&gt;						<span class="comment">// 除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T modulus&lt;T&gt;						<span class="comment">// 取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T negate&lt;T&gt;						<span class="comment">// 取反仿函数</span></span><br></pre></td></tr></table></figure>

<p>6个关系运算类函数对象,每一种都是二元运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> equal_to&lt;T&gt;					<span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> not_equal_to&lt;T&gt;				<span class="comment">// 不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> greater&lt;T&gt;					<span class="comment">// 大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> greater_equal&lt;T&gt;				<span class="comment">// 大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> less&lt;T&gt;						<span class="comment">// 小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> less_equal&lt;T&gt;				<span class="comment">// 小于等于</span></span><br></pre></td></tr></table></figure>

<p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> logical_and&lt;T&gt;				<span class="comment">// 逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> logical_or&lt;T&gt;				<span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">bool</span> logical_not&lt;T&gt;				<span class="comment">// 逻辑非</span></span><br></pre></td></tr></table></figure>

<p>内建函数对象举例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取反仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		v.push_back(rand() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-函数对象适配器"><a href="#4-函数对象适配器" class="headerlink" title="4. 函数对象适配器"></a>4. 函数对象适配器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数适配器bind1st bind2nd</span></span><br><span class="line"><span class="comment">// 现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span></span><br><span class="line"><span class="comment">// 我们直接给函数对象绑定参数 编译阶段就会报错</span></span><br><span class="line"><span class="comment">// for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span></span><br><span class="line"><span class="comment">// 如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span></span><br><span class="line"><span class="comment">// 根据我们函数对象是一元函数对象 还是二元函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> :</span><span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1 = : &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; v2 = :&quot;</span> &lt;&lt;v2  &lt;&lt; <span class="string">&quot; v1+v2 = :&quot;</span> &lt;&lt; (v1 + v2) &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数适配器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入起始值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), bind1st(MyPrint(), x));</span><br><span class="line">	<span class="comment">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总结：  bind1st和bind2nd区别?</span></span><br><span class="line"><span class="comment">// bind1st ： 将参数绑定为函数对象的第一个参数</span></span><br><span class="line"><span class="comment">// bind2nd ： 将参数绑定为函数对象的第二个参数</span></span><br><span class="line"><span class="comment">// bind1st bind2nd将二元函数对象转为一元函数对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterThenFive</span>:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、取反适配器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 	vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span></span><br><span class="line"><span class="comment">//	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span></span><br><span class="line">	<span class="comment">//自定义输入</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;<span class="keyword">int</span>&gt;(),<span class="number">5</span>)));</span><br><span class="line">	<span class="keyword">if</span> (it == v.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序  二元函数对象</span></span><br><span class="line">	sort(v.begin(), v.end(), not2(less&lt;<span class="keyword">int</span>&gt;()));</span><br><span class="line">	for_each(v.begin(), v.end(), [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// not1 对一元函数对象取反</span></span><br><span class="line"><span class="comment">// not2 对二元函数对象取反</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v + v2&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数指针适配器   ptr_fun</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ptr_fun( )把一个普通的函数指针适配成函数对象</span></span><br><span class="line">	for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), <span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、成员函数适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Name = name;</span><br><span class="line">            m_Age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成员函数:&quot;</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Plus100</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            m_Age += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">string</span> m_Name;</span><br><span class="line">        <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint04</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt;  p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span> &lt;Person&gt;v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for_each(v.begin(), v.end(), MyPrint04);</span></span><br><span class="line">	<span class="comment">// 利用 mem_fun_ref 将Person内部成员函数适配</span></span><br><span class="line">	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span></span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;Person*&gt; v1;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v1.push_back(&amp;p1);</span><br><span class="line">	v1.push_back(&amp;p2);</span><br><span class="line">	v1.push_back(&amp;p3);</span><br><span class="line">	v1.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">	for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果容器存放的是对象指针，那么用 mem_fun</span></span><br><span class="line"><span class="comment">// 如果容器中存放的是对象实体，那么用 mem_fun_ref</span></span><br></pre></td></tr></table></figure>

<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件**<algorithm><functional> <numeric>**组成。<br><algorithm>是所有STL头文件中最大的一个，其中常用的功能涉及到比较、交换、查找、遍历、复制、修改、反转、排序、合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数；<br><functional> 定义了一些模板类，用以声明函数对象。</p>
<h3 id="1-常用遍历算法"><a href="#1-常用遍历算法" class="headerlink" title="1. 常用遍历算法"></a>1. 常用遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">	@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback  函数回调或者函数对象</span></span><br><span class="line"><span class="comment">	@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">	注意 : transform 不会给目标容器分配内存，所以需要 *提前分配好内存*</span></span><br><span class="line"><span class="comment">	@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param _cakkback 回调函数或者函数对象</span></span><br><span class="line"><span class="comment">	@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for_each:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    template&lt;class _InIt,class _Fn1&gt; inline</span></span><br><span class="line"><span class="comment">    void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for (; _First != _Last; ++_First)</span></span><br><span class="line"><span class="comment">            _Func(*_First);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print001</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历算法</span></span><br><span class="line">	for_each(v.begin(), v.end(), print01);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), print001());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print02</span>&#123;</span></span><br><span class="line">	print02()&#123;</span><br><span class="line">		mCount = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		mCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.mCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print03</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> bindParam)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val + bindParam &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each绑定参数输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), bind2nd(print03(),<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transform:</span><br><span class="line"><span class="comment">//transform 将一个容器中的值搬运到另一个容器中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span></span><br><span class="line"><span class="comment">	_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">	&#123;	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		for (; _First != _Last; ++_First, ++_Dest)</span></span><br><span class="line"><span class="comment">			*_Dest = _Func(*_First);</span></span><br><span class="line"><span class="comment">		return (_Dest);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span></span><br><span class="line"><span class="comment">	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span></span><br><span class="line"><span class="comment">	&#123;	</span></span><br><span class="line"><span class="comment">		for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span></span><br><span class="line"><span class="comment">			*_Dest = _Func(*_First1, *_First2);</span></span><br><span class="line"><span class="comment">		return (_Dest);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transformTest01</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print01</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">		vSource.push_back(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标容器</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">// 给vTarget开辟空间</span></span><br><span class="line">	vTarget.resize(vSource.size());</span><br><span class="line">	<span class="comment">// 将vSource中的元素搬运到vTarget</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line">	<span class="comment">// 打印</span></span><br><span class="line">	for_each(vTarget.begin(), vTarget.end(), print01()); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将容器1和容器2中的元素相加放入到第三个容器中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transformTest02</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		vSource1.push_back(i + <span class="number">1</span>);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标容器</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">// 给vTarget开辟空间</span></span><br><span class="line">	vTarget.resize(vSource1.size());</span><br><span class="line">	transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line">	<span class="comment">// 打印</span></span><br><span class="line">	for_each(vTarget.begin(), vTarget.end(), print01()); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-常用查找算法"><a href="#2-常用查找算法" class="headerlink" title="2. 常用查找算法"></a>2. 常用查找算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	find算法 查找元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value 查找的元素</span></span><br><span class="line"><span class="comment">	@return 返回查找元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find</span>(iterator beg, iterator end, value)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	find_if算法 条件查找</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_if</span><span class="params">(iterator beg, iterator end, _callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	adjacent_find算法 查找相邻重复元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return 返回相邻元素的第一个位置的迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">adjacent_find</span>(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	binary_search算法 二分查找法</span></span><br><span class="line"><span class="comment">	注意: 在无序序列中不可用</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value 查找的元素</span></span><br><span class="line"><span class="comment">	@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  value回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_if</span><span class="params">(iterator beg, iterator end, _callback)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-常用排序算法"><a href="#3-常用排序算法" class="headerlink" title="3. 常用排序算法"></a>3. 常用排序算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	merge算法 容器元素合并，并存储到另一容器中</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sort算法 容器元素排序</span></span><br><span class="line"><span class="comment">	注意:两个容器必须是有序的</span></span><br><span class="line"><span class="comment">	@param beg 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sort算法 对指定范围内的元素随机调整次序</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	reverse算法 反转指定范围的元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure>

<h3 id="4-常用拷贝和替换算法"><a href="#4-常用拷贝和替换算法" class="headerlink" title="4. 常用拷贝和替换算法"></a>4. 常用拷贝和替换算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	copy算法 将容器内指定范围的元素拷贝到另一容器中</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest 目标起始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace算法 将容器内指定范围的旧元素修改为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param oldvalue 旧元素</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param callback函数回调或者谓词(返回Bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	swap算法 互换两个容器的元素</span></span><br><span class="line"><span class="comment">	@param c1容器1</span></span><br><span class="line"><span class="comment">	@param c2容器2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure>

<h3 id="5-常用算数生成算法"><a href="#5-常用算数生成算法" class="headerlink" title="5. 常用算数生成算法"></a>5. 常用算数生成算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	accumulate算法 计算容器元素累计总和</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value累加值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fill算法 向容器中添加元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value t填充元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure>

<h3 id="6-常用集合算法"><a href="#6-常用集合算法" class="headerlink" title="6. 常用集合算法"></a>6. 常用集合算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_intersection算法 求两个set集合的交集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_union算法 求两个set集合的并集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_difference算法 求两个set集合的差集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是 *有序序列*</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/C%E8%AF%AD%E8%A8%80/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/" data-id="cl0ufc4yd00015wvsamq70sfl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/01/19/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JVM Garbage First（G1）使用详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/17/C%E8%AF%AD%E8%A8%80/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/">STL六大组件简介</a>
          </li>
        
          <li>
            <a href="/2022/01/19/JAVA/JVM/G1%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">JVM Garbage First（G1）使用详解</a>
          </li>
        
          <li>
            <a href="/2022/01/19/JAVA/JVM/JVM%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">JVM使用详解</a>
          </li>
        
          <li>
            <a href="/2022/01/19/JAVA/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a>
          </li>
        
          <li>
            <a href="/2022/01/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Shuyan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>