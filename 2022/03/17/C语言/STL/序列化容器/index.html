<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>序列化容器 - Shuyan</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="一、序列化容器​        所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。      需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：   array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类">
<meta property="og:type" content="article">
<meta property="og:title" content="序列化容器">
<meta property="og:url" content="http://example.com/2022/03/17/C%E8%AF%AD%E8%A8%80/STL/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="Shuyan">
<meta property="og:description" content="一、序列化容器​        所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。      需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：   array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328115526806.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328115654022.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328115932947.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328120823093.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328154803390.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328155255585.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328155524075.png">
<meta property="og:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328160031705.png">
<meta property="article:published_time" content="2022-03-17T03:11:05.000Z">
<meta property="article:modified_time" content="2022-04-11T03:15:31.110Z">
<meta property="article:author" content="Shuyan">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/24371/AppData/Roaming/Typora/typora-user-images/image-20220328115526806.png">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1695524864432">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1695524864432">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1695524864432">
    <link rel="stylesheet" href="/css/style.css?v=1695524864432">
     
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(http://mms0.baidu.com/it/u=2467909075,3604847220&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=801&amp;h=500)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Shuyan" class="mdui-btn mdui-btn-icon"><img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Shuyan">
            <img src="http://mms2.baidu.com/it/u=1730774443,2723245118&amp;fm=253&amp;app=120&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" alt="Shuyan" alt="Shuyan">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>102</div>
        <div><span>Tags</span>20</div>
        <div><span>Categories</span>34</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/categories" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about" title="梦华录">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                梦华录
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=rd1wdMWxpIZJe5AIruJkY7xD8d68h031&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/400417888" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/">C语言</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Docker/">Docker</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/">JAVA</a>
          <span class="category-list-count">43</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/JavaWeb/">JavaWeb</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/LaTex/">LaTex</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/">Leetcode</a>
          <span class="category-list-count">21</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Linux/">Linux</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Mybaits/">Mybaits</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SSM/">SSM</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/C语言/STL/">STL</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/Spring/">Spring</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringBoot/">SpringBoot</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/SpringMVC/">SpringMVC</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/Spring框架/">Spring框架</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/sort/">sort</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Docker”/">“Docker”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JAVA基础知识”/">“JAVA基础知识”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“JVM”/">“JVM”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Nginx”/">“Nginx”</a>
          <span class="category-list-count">8</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Redis”/">“Redis”</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/Spring框架/“Security”/">“Security”</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/“Spring框架”/">“Spring框架”</a>
          <span class="category-list-count">22</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/二叉树/">二叉树</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/剑指offer/">剑指offer</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/动态规划/">动态规划</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/单链表/">单链表</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/字符串/">字符串</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/数组/">数组</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/栈和队列/">栈和队列</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/算法/">算法</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/线性表/">线性表</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JAVA/网络编程/">网络编程</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/联邦学习/">联邦学习</a>
          <span class="category-list-count">12</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Leetcode/贪心算法/">贪心算法</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Tag Cloud</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 12.5px;">Docker</a> <a href="/tags/JAVA/" style="font-size: 12.5px;">JAVA</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 12.5px;">JavaWeb</a> <a href="/tags/LaTex/" style="font-size: 10px;">LaTex</a> <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 11.25px;">Linux</a> <a href="/tags/Mybaits/" style="font-size: 15px;">Mybaits</a> <a href="/tags/Nginx/" style="font-size: 17.5px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 12.5px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10px;">SSM</a> <a href="/tags/STL/" style="font-size: 12.5px;">STL</a> <a href="/tags/Security/" style="font-size: 11.25px;">Security</a> <a href="/tags/Spring/" style="font-size: 16.25px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12.5px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 11.25px;">SpringMVC</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.75px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 11.25px;">动态规划</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 11.25px;">搜索</a> <a href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 18.75px;">联邦学习</a>
    </div>
    
  </div>
  <style>
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: rgba(255,78,106,0.8);
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta {
    margin: 25px 0px;
    font-size: 0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a {
    border-radius: 20px;
    padding: 10px 18px;
    color: #fff;
    font-size: 14px;
    display: inline-block;
    margin-bottom: 5px;
    margin-right: 10px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont {
    font-size: 14px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before,
    #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before {
    margin-right: 5px;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) {
    background-color: rgba(255,78,106,0.15);
    color: #ff4e6a;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) {
    background-color: rgba(255,170,115,0.15);
    color: #ffaa73;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) {
    background-color: rgba(254,212,102,0.15);
    color: #fed466;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) {
    background-color: rgba(60,220,130,0.15);
    color: #3cdc82;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) {
    background-color: rgba(100,220,240,0.15);
    color: #64dcf0;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) {
    background-color: rgba(100,185,255,0.15);
    color: #64b9ff;
    }
    #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) {
    background-color: rgba(180,180,255,0.15);
    color: #b4b4ff;
    }
  </style>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2023 Shuyan
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href=" "><img src="http://mms0.baidu.com/it/u=991445098,3809803602&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=500" width="100px" ></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="/img/序列化容器.jpg" data-sizes="auto" alt="序列化容器" class="lazyload">
              <h1>序列化容器</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年03月17日</a>
</div>

      

      <h1 id="一、序列化容器"><a href="#一、序列化容器" class="headerlink" title="一、序列化容器"></a>一、序列化容器</h1><p>​        所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p>
<pre><code>     需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：
</code></pre>
<ul>
<li><strong>array&lt;T,N&gt;（数组容器）</strong>：表示可以存储 N 个 T 类型的元素，是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li>
<li><strong>vector<T>（向量容器）</strong>：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为  O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li>
<li><strong>deque<T>（双端队列容器）</strong>：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li>
<li><strong>list<T>（链表容器）</strong>：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶  O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T>  必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li>
<li><strong>forward_list<T>（正向链表容器）</strong>：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li>
</ul>
<blockquote>
<p>​        注意，其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328115526806.png" alt="image-20220328115526806" class="lazyload"></p>
<p>图 1 中每种类型容器的操作都可以高效执行，但进行除此之外的其他操作，效率会稍差一些。在本章的剩余部分，会详细介绍每一类序列容器的具体用法。</p>
<h2 id="1-1-容器中常见的函数成员"><a href="#1-1-容器中常见的函数成员" class="headerlink" title="1.1 容器中常见的函数成员"></a>1.1 容器中常见的函数成员</h2><p>​        序列容器包含一些相同的成员函数，它们的功能也相同，本教程会在某个容器的上下文中详细介绍下面的每个函数，但对于每种类型的容器不会重复介绍它们的细节。</p>
<p>下表展示了 array、vector 和 deque 容器的函数成员，它们中至少有两个容器实现了同样的函数成员。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>array&lt;T,N&gt;</th>
<th>vector<T></th>
<th>deque<T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator=()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
<td>-</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator<a href=""></a></td>
<td>使用索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检査的索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>。</td>
<td>是</td>
<td>是</td>
<td>-</td>
</tr>
</tbody></table>
<blockquote>
<p>列表中 - 表明对应的容器并没有定义这个函数。</p>
</blockquote>
<p>​        list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>list<T></th>
<th>forward_list<T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>before_begin()</td>
<td>返回指向第一个元素前一个位置的迭代器。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator=()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的引用。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的引用。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的起始位置添加一个元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定位置直接生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置的后面直接生成一个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cmplacc_front()</td>
<td>在序列的起始位生成一个元索。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置的后面插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除序列尾部的元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除序列头部的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中某一段的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移除指定位置的一个元素或一段元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>erase_after()</td>
<td>移除指定位置后面的一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>remove()</td>
<td>移除所有和参数匹配的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>remove_if()</td>
<td>移除满足一元函数条件的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>unique()</td>
<td>移除所有连续重复的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的元素，容器大小变为 0。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>sort()</td>
<td>对元素进行排序。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个有序容器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>splice()</td>
<td>移动指定位置前面的所有元素到另一个同类型的 list 中。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>splice_after()</td>
<td>移动指定位置后面的所有元素到另一个同类型的 list 中。</td>
<td>-</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="二、array容器"><a href="#二、array容器" class="headerlink" title="二、array容器"></a>二、array容器</h1><h2 id="2-1-array容器简介"><a href="#2-1-array容器简介" class="headerlink" title="2.1 array容器简介"></a>2.1 array容器简介</h2><p>​        array 容器是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p>
<p>​        和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> 还提供有可动态扩展或收缩存储空间的 vector 容器，后续章节会对其做详细介绍。</p>
</blockquote>
<p>​        array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">size_t</span> N&gt;    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">array</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        因此，在使用该容器之前，代码中需引入 <array> 头文件，并默认使用 std 命令空间，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p>​        在 array&lt;T,N&gt; 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</p>
<pre><code>     array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-keyword">double</span>, 10&gt; values;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>提示，如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>​        由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p>
<p>​        通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-keyword">double</span>, 10&gt; values &#123;&#125;;<br></code></pre></td></tr></table></figure>

<p>​        使用该语句，容器中所有的元素都会被初始化为 0.0。</p>
<p>​        当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-keyword">double</span>, 10&gt; values &#123;<span class="hljs-number">0.5</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.5</span>,,<span class="hljs-number">2.0</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>​        可以看到，这里只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328115654022.png" alt="image-20220328115654022" class="lazyload"></p>
<p>​        除此之外，array 容器还提供有很多功能实用的成员函数，如下表所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody></table>
<p>​        除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和  end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的  begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样  end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>​        另外，在 <array> 头文件中还重载了 <strong>get() 全局函数</strong>，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p>
<blockquote>
<p>正是由于 array 容器中包含了 at() 这样的成员函数，使得操作元素时比普通数组更安全。</p>
</blockquote>
<p>例如代码演示了表 2 中一部分成员函数的用法和功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>									<span class="hljs-comment">// 需要引入 array 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>    std::array&lt;<span class="hljs-keyword">int</span>, 4&gt; values&#123;&#125;;    				<span class="hljs-comment">// 初始化 values 容器为 &#123;0,1,2,3&#125;    </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">size</span>(); i++) &#123;        <br>        values.<span class="hljs-built_in">at</span>(i) = i;    <br>    &#125;    <br>    <br>    <span class="hljs-comment">// 使用 get() 重载函数输出指定位置元素    </span><br>    cout &lt;&lt; get&lt;<span class="hljs-number">3</span>&gt;(values) &lt;&lt; endl;    <br>    <br>    <span class="hljs-comment">// 如果容器不为空，则输出容器中所有的元素    </span><br>    <span class="hljs-keyword">if</span> (!values.<span class="hljs-built_in">empty</span>()) &#123;        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val = values.<span class="hljs-built_in">begin</span>(); val &lt; values.<span class="hljs-built_in">end</span>(); val++) &#123;      <br>            cout &lt;&lt; *val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，代码中的 auto 关键字，可以使编译器自动判定变量的类型。运行这段代码，输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



<h2 id="2-2-array随机访问迭代器"><a href="#2-2-array随机访问迭代器" class="headerlink" title="2.2 array随机访问迭代器"></a>2.2 array随机访问迭代器</h2><p>​        STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。本节将详细介绍 array 容器的迭代器的用法。</p>
<p>​        在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和表 1 中的 begin()、end() 成员函数相同。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328115932947.png" alt="image-20220328115932947" class="lazyload"></p>
<p>​        可以看到，根据它们的功能并结合实际场景的需要，这些成员函数通常是成对使用的，即  begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend()  各自成对搭配使用。不仅如此，这 4 对中 begin()/end() 和 cbegin()/cend()、rbegin()/rend()  和 crbegin()/crend() 的功能大致是相同的（如图 2 所示），唯一的区别就在于其返回的迭代器能否用来修改元素值。</p>
<blockquote>
<p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<h3 id="2-2-1-begin-end-和-cbegin-cend"><a href="#2-2-1-begin-end-和-cbegin-cend" class="headerlink" title="2.2.1 begin()/end() 和 cbegin()/cend()"></a>2.2.1 begin()/end() 和 cbegin()/cend()</h3><p>​        array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p>
<pre><code>     例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span>				<span class="hljs-comment">// 需要引入 array 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt;values;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> last = values.<span class="hljs-built_in">end</span>();<br>    <br>    <span class="hljs-comment">// 初始化 values 容器为&#123;1,2,3,4,5&#125;</span><br>    <span class="hljs-keyword">while</span> (first != last)<br>    &#123;<br>        *first = h;<br>        ++first;<br>        h++;<br>    &#125;<br>  <br>    first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span> (first != last)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>​        可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p>​        与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> first = std::<span class="hljs-built_in">begin</span>(values);<br><span class="hljs-keyword">auto</span> last = std::<span class="hljs-built_in">end</span> (values);<br></code></pre></td></tr></table></figure>

<p>​        这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p>
<blockquote>
<p>需要注意的是，STL 标准库，不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p>
</blockquote>
<p>​        除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end()  唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend()  成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span>					<span class="hljs-comment">// 需要引入 array 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">cbegin</span>();<br>    <span class="hljs-keyword">auto</span> last = values.<span class="hljs-built_in">cend</span>();<br>   <br>    <span class="hljs-comment">// 由于 *first 为 const 类型，不能用来修改元素</span><br>    <span class="hljs-comment">// *first = 10;</span><br>   <br>    <span class="hljs-comment">// 遍历容器并输出容器中所有元素</span><br>    <span class="hljs-keyword">while</span> (first != last)<br>    &#123;<br>        <span class="hljs-comment">// 可以使用 const 类型迭代器访问元素</span><br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        此程序的第 14 行代码中，我们尝试使用 first 迭代器修改 values  容器中的值，如果取消注释并运行此程序，编译器会提示你“不能给常量赋值”，即 *first 是 const 类型常量，所以这么做是不对的。但  17~22 行代码遍历并访问容器的行为，是允许的。</p>
<h3 id="2-2-2-rbegin-rend-和-crbegin-crend"><a href="#2-2-2-rbegin-rend-和-crbegin-crend" class="headerlink" title="2.2.2 rbegin()/rend() 和 crbegin()/crend()"></a>2.2.2 rbegin()/rend() 和 crbegin()/crend()</h3><p>​        array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器（如图 2 所示）。</p>
<blockquote>
<p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p>
</blockquote>
<p>反向迭代器用于以逆序的方式处理元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span>				<span class="hljs-comment">// 需要引入 array 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt;values;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">rbegin</span>();<br>    <span class="hljs-keyword">auto</span> last = values.<span class="hljs-built_in">rend</span>(); <br>    <br>    <span class="hljs-comment">// 初始化 values 容器为 &#123;5,4,3,2,1&#125;</span><br>    <span class="hljs-keyword">while</span> (first != last)<br>    &#123;<br>        *first = h;<br>        ++first;<br>        h++;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重新遍历容器，并输入各个元素</span><br>    first = values.<span class="hljs-built_in">rbegin</span>();<br>    <span class="hljs-keyword">while</span> (first != last)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>​        可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p>
<blockquote>
<p>在反向迭代器上使用 ++ 递增运算符，会让迭代器用一种和普通正向迭代器移动方向相反的方式移动。</p>
</blockquote>
<p>​        当然，在上面程序中，我们也可以使用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/172.html">for 循环</a>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">rbegin</span>(); first != values.<span class="hljs-built_in">rend</span>(); ++first) &#123;<br>    cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        crbegin()/crend() 组合和 rbegin()/crend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<h2 id="2-3-array访问元素"><a href="#2-3-array访问元素" class="headerlink" title="2.3 array访问元素"></a>2.3 array访问元素</h2><p>​        当 array 容器创建完成之后，最常做的操作就是获取其中的元素，甚至有时还会通过循环结构获取多个元素。本节就对获取容器中元素的方法做个汇总。</p>
<h3 id="2-3-1-访问array容器中单个元素"><a href="#2-3-1-访问array容器中单个元素" class="headerlink" title="2.3.1 访问array容器中单个元素"></a>2.3.1 访问array容器中单个元素</h3><p>​        首先，可以通过<code>容器名[]</code>的方式直接访问和使用容器中的元素，这和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 标准数组访问元素的方式相同，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">values[<span class="hljs-number">4</span>] = values[<span class="hljs-number">3</span>] + <span class="hljs-number">2.</span>O*values[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>

<p>​        此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p>
<p>​         为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">values.<span class="hljs-built_in">at</span> (<span class="hljs-number">4</span>) = values.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) + <span class="hljs-number">2.</span>O*values.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>​        这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p>
<blockquote>
<p>​        为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？</p>
<p>​        答案很简单，因为性能。</p>
<p>​        如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>​        除此之外，array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n  个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</p>
<p> 下面代码展示了如何使用 get<n> 模板函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;string, 5&gt; words&#123; <span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-string">&quot;five&quot;</span> &#125;;<br>    cout &lt;&lt; get&lt;<span class="hljs-number">3</span>&gt;(words) &lt;&lt; endl; <span class="hljs-comment">// Output words[3]</span><br>    <span class="hljs-comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; //越界，会发生编译错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">four</span><br></code></pre></td></tr></table></figure>

<p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>。通过该指针，我们可以获得容器中的各个元素，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt; words&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout &lt;&lt; *( words.<span class="hljs-built_in">data</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure>

<h3 id="2-3-2-访问array容器中多个元素"><a href="#2-3-2-访问array容器中多个元素" class="headerlink" title="2.3.2 访问array容器中多个元素"></a>2.3.2 访问array容器中多个元素</h3><p>​        我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span> ; i &lt; values.<span class="hljs-built_in">size</span>() ; ++i)<br>&#123;<br>    total += values[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p>
<p>​         并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(values.<span class="hljs-built_in">empty</span>())<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The container has no elements.\n&quot;</span>;<br><span class="hljs-keyword">else</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The container has &quot;</span>&lt;&lt; values.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;elements.\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>​        然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p>
<blockquote>
<p>​        array 容器之所以提供 empty() 成员函数的原因，对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p>
</blockquote>
<p>​        除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;&amp; value : values)<br>    total += value;<br></code></pre></td></tr></table></figure>


<p> 下面是一个示例，展示了本节关于如何获取 array 容器中元素所讲到的知识：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt; values1;<br>    array&lt;<span class="hljs-keyword">int</span>, 5&gt; values2;<br>    <br>    <span class="hljs-comment">// 初始化 values1 为 &#123;0,1,2,3,4&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; values1.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        values1.<span class="hljs-built_in">at</span>(i) = i;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values1[2] is : &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">2</span>&gt;(values1) &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 初始化 values2 为&#123;10，11，12，13，14&#125;</span><br>    <span class="hljs-keyword">int</span> initvalue = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; value : values2)<br>    &#123;<br>        value = initvalue;<br>        initvalue++;<br>    &#125;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;Values1 is : &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = values1.<span class="hljs-built_in">begin</span>(); i &lt; values1.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Values2 is : &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = values2.<span class="hljs-built_in">begin</span>(); i &lt; values2.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">values1</span>[<span class="hljs-number">0</span>] is : <span class="hljs-number">0</span><br><span class="hljs-attribute">values1</span>[<span class="hljs-number">1</span>] is : <span class="hljs-number">1</span><br><span class="hljs-attribute">values1</span>[<span class="hljs-number">2</span>] is : <span class="hljs-number">2</span><br><span class="hljs-attribute">Values1</span> is : <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Values2</span> is : <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure>

<h1 id="三、vector容器"><a href="#三、vector容器" class="headerlink" title="三、vector容器"></a>三、vector容器</h1><h2 id="3-1-vector容器简介"><a href="#3-1-vector容器简介" class="headerlink" title="3.1 vector容器简介"></a>3.1 vector容器简介</h2><p>​        vector 容器是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。</p>
<p>​         vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为<code>O(1)</code>；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶<code>O(n)</code>。</p>
<p>​        vector 容器以类模板 vector<T>（ T 表示存储元素的类型）的形式定义在 <vector> 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 vector 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="3-1-1-创建vector容器的几种方式"><a href="#3-1-1-创建vector容器的几种方式" class="headerlink" title="3.1.1 创建vector容器的几种方式"></a>3.1.1 创建vector容器的几种方式</h3><p>创建 vector 容器的方式有很多，大致可分为以下几种。</p>
<ol>
<li>如下代码展示了如何创建存储 double 类型元素的一个 vector 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-keyword">double</span>&gt; values;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>​        注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。</p>
<p>​        在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">values.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>

<p>​        这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20  个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values  容器内此时仍然没有任何元素。</p>
<blockquote>
<p>​        还需注意的是，如果调用 reserve()  来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector<T>  容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</p>
</blockquote>
<ol start="2">
<li>除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数，比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-keyword">int</span>&gt; primes &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>​        这样就创建了一个含有 8 个素数的 vector 容器。</p>
<ol start="3">
<li>在创建 vector 容器时，也可以指定元素个数：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>​        如此，values 容器开始时就有 20 个元素，它们的默认初始值都为 0。</p>
<blockquote>
<p>注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。</p>
</blockquote>
<p>​        如果不想用 0 作为默认值，也可以指定一个其它值，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">1.0</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>​        第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。</p>
<p>​        值得一提的是，圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> num=<span class="hljs-number">20</span>;<br><span class="hljs-keyword">double</span> value =<span class="hljs-number">1.0</span>;<br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(num, value)</span></span>;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-keyword">char</span>&gt;<span class="hljs-built_in">value1</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br>std::vector&lt;<span class="hljs-keyword">char</span>&gt;<span class="hljs-built_in">value2</span>(value1);<br></code></pre></td></tr></table></figure>

<p>​        由此，value2 容器中也具有 5 个字符 ‘c’。在此基础上，如果不想复制其它容器中所有的元素，可以用一对<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>或者迭代器来指定初始值的范围，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> array[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>std::vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">values</span>(array, array+<span class="hljs-number">2</span>);<span class="hljs-comment">//values 将保存&#123;1,2&#125;</span><br>std::vector&lt;<span class="hljs-keyword">int</span>&gt;value1&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>std::vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">value2</span>(std::<span class="hljs-built_in">begin</span>(value1),std::<span class="hljs-built_in">begin</span>(value1)+<span class="hljs-number">3</span>);<span class="hljs-comment">//value2保存&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>

<p>​        由此，value2 容器中就包含了 {1,2,3} 这 3 个元素。</p>
<h3 id="3-1-2-vector容器包含的成员函数"><a href="#3-1-2-vector容器包含的成员函数" class="headerlink" title="3.1.2 vector容器包含的成员函数"></a>3.1.2 vector容器包含的成员函数</h3><p>​        相比 array 容器，vector 提供了更多了成员函数供我们使用，它们各自的功能如下表所示。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>reserve()</td>
<td>增加容器的容量。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>operator[ ]</td>
<td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的指针。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
</tr>
</tbody></table>
<p>​        除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和  end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的  begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样  end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>​         vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的 vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<p>​         如下代码演示了表 1 中部分成员函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化一个空vector容量</span><br>    vector&lt;<span class="hljs-keyword">char</span>&gt;value;<br>    <br>    <span class="hljs-comment">// 向value容器中的尾部依次添加 S、T、L 字符</span><br>    value.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;S&#x27;</span>);<br>    value.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;T&#x27;</span>);<br>    value.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;L&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 调用 size() 成员函数容器中的元素个数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素个数为：%d\n&quot;</span>, value.<span class="hljs-built_in">size</span>());<br>    <br>    <span class="hljs-comment">// 使用迭代器遍历容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = value.<span class="hljs-built_in">begin</span>(); i &lt; value.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 向容器开头插入字符</span><br>    value.<span class="hljs-built_in">insert</span>(value.<span class="hljs-built_in">begin</span>(), <span class="hljs-string">&#x27;C&#x27;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;首个元素为：&quot;</span> &lt;&lt; value.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">元素个数为：<span class="hljs-number">3</span><br>S <span class="hljs-built_in">T</span> L<br>首个元素为：C<br></code></pre></td></tr></table></figure>

<h2 id="3-2-vector迭代器"><a href="#3-2-vector迭代器" class="headerlink" title="3.2 vector迭代器"></a>3.2 vector迭代器</h2><p>​        vector 容器迭代器和前者有很多相同之处。比如，vector 容器的迭代器也是随机访问迭代器，并且 vector 模板类提供的操作迭代器的成员函数也和 array 容器一样（如表 1 所示）。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>​        除此之外，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新添加的 begin() 和 end() 全局函数也同样适用于 vector 容器。即当操作对象为 vector 容器时，其功能分别和表 1 中的 begin()、end() 成员函数相同。</p>
</blockquote>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328120823093.png" alt="image-20220328120823093" class="lazyload"></p>
<p>​        从图 2 可以看出，这些成员函数通常是成对使用的，即  begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend()  各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和  crbegin()/crend() 的功能是类似的。</p>
<blockquote>
<p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<h3 id="3-2-1-vector容器迭代器的基本用法"><a href="#3-2-1-vector容器迭代器的基本用法" class="headerlink" title="3.2.1 vector容器迭代器的基本用法"></a>3.2.1 vector容器迭代器的基本用法</h3><p>​        vector 容器迭代器最常用的功能就是遍历访问容器中存储的元素。</p>
<p>​        首先来看 begin() 和 end() 成员函数，它们分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 vector 容器并输出其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span> 				<span class="hljs-comment">// 需要引入 vector 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> end = values.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">while</span> (first != end)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>​        可以看到，迭代器对象是由 vector 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>那样上使用它们。比如代码中，在保存了元素值后，使用前缀<code>++</code>运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p> 与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，比如将上面代码中第 8、9 行代码用如下代码替换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> first = std::<span class="hljs-built_in">begin</span>(values);<br><span class="hljs-keyword">auto</span> end = std::<span class="hljs-built_in">end</span> (values);<br></code></pre></td></tr></table></figure>

<p>​         cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span>						<span class="hljs-comment">// 需要引入 vector 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">cbegin</span>();<br>    <span class="hljs-keyword">auto</span> end = values.<span class="hljs-built_in">cend</span>();<br>    <span class="hljs-keyword">while</span> (first != end)<br>    &#123;<br>        <span class="hljs-comment">// *first = 10;不能修改元素</span><br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        程序第 12 行，由于 first 是 const 类型的迭代器，因此不能用于修改容器中元素的值。</p>
<p>​         vector 模板类中还提供了 rbegin() 和 rend() 成员函数，分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器（如图 2 所示）。</p>
<blockquote>
<p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p>
</blockquote>
<p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span>						<span class="hljs-comment">// 需要引入 vector 头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">rbegin</span>();<br>    <span class="hljs-keyword">auto</span> end = values.<span class="hljs-built_in">rend</span>();<br>    <span class="hljs-keyword">while</span> (first != end)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>​        可以看到，从最后一个元素开始循环，遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p>
<p>​        当然，在上面程序中，我们也可以使用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/172.html">for 循环</a>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">rbegin</span>(); first != values.<span class="hljs-built_in">rend</span>(); ++first) &#123;<br>    cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​        crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<blockquote>
<p>有关 crbegin()/crend() 成员函数，这里不再给出具体实例，有兴趣的读者，可自行编写代码进行测试。</p>
</blockquote>
<h3 id="3-2-2-vector容器迭代器的独特之处"><a href="#3-2-2-vector容器迭代器的独特之处" class="headerlink" title="3.2.2 vector容器迭代器的独特之处"></a>3.2.2 vector容器迭代器的独特之处</h3><p>​        和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。</p>
<p>​        但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器。也就是说，如下初始化 vector 容器的方法是不行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values;<br>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>(); first &lt; values.<span class="hljs-built_in">end</span>(); ++first, val++) &#123;<br>        *first = val;<br>        <br>        <span class="hljs-comment">// 初始化的同时输出值</span><br>        cout &lt;&lt; *first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序可以看到，什么也没有输出。这是因为，对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。</p>
<blockquote>
<p>所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。</p>
</blockquote>
<p> 除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> end = values.<span class="hljs-built_in">end</span>();<br>    <br>    <span class="hljs-comment">// 增加 values 的容量</span><br>    values.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">20</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (first != end) &#123;<br>        cout &lt;&lt; *first;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，显示如下信息并崩溃：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">values</span> 容器首个元素的地址：<span class="hljs-number">0096</span>DFE<span class="hljs-number">8</span><br><span class="hljs-attribute">values</span> 容器首个元素的地址：<span class="hljs-number">00965560</span><br></code></pre></td></tr></table></figure>

<p>​        可以看到，values 容器在增加容量之后，首个元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> end = values.<span class="hljs-built_in">end</span>();<br>    <br>    <span class="hljs-comment">// 增加 values 的容量</span><br>    values.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">20</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>    first = values.<span class="hljs-built_in">begin</span>();<br>    end = values.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">while</span> (first != end) &#123;<br>        cout &lt;&lt; *first ;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">values</span> 容器首个元素的地址：<span class="hljs-number">0164</span>DBE<span class="hljs-number">8</span><br><span class="hljs-attribute">values</span> 容器首个元素的地址：<span class="hljs-number">01645560</span><br><span class="hljs-attribute">123</span><br></code></pre></td></tr></table></figure>

<h2 id="3-3-vector访问元素"><a href="#3-3-vector访问元素" class="headerlink" title="3.3 vector访问元素"></a>3.3 vector访问元素</h2><h3 id="3-3-1-访问vector容器中单个元素"><a href="#3-3-1-访问vector容器中单个元素" class="headerlink" title="3.3.1 访问vector容器中单个元素"></a>3.3.1 访问vector容器中单个元素</h3><p>首先，vector 容器可以向普通数组那样访问存储的元素，甚至对指定下标处的元素进行修改，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">// 获取容器中首个元素</span><br>    cout &lt;&lt; values[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 修改容器中下标为 0 的元素的值</span><br>    values[<span class="hljs-number">0</span>] = values[<span class="hljs-number">1</span>] + values[<span class="hljs-number">2</span>] + values[<span class="hljs-number">3</span>] + values[<span class="hljs-number">4</span>];<br>    cout &lt;&lt; values[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>14<br></code></pre></td></tr></table></figure>

<blockquote>
<p>显然，vector 的索引从 0 开始，这和普通数组一样。通过使用索引，总是可以访问到 vector 容器中现有的元素。</p>
</blockquote>
<p>​        值得一提的是，<code>容器名[n]</code>这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出<code>std::out_of_range</code>异常。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">// 获取容器中首个元素</span><br>    cout &lt;&lt; values.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 修改容器中下标为 0 的元素的值</span><br>    values.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = values.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) + values.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) + values.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) + values.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>);<br>    cout &lt;&lt; values.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 下面这条语句会发生 out_of_range 异常</span><br>    <span class="hljs-comment">// cout &lt;&lt; values.at(5) &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>14<br></code></pre></td></tr></table></figure>

<blockquote>
<p>​        读者可能有这样一个疑问，即为什么 vector 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>​        除此之外，vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 首元素为：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 尾元素为：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//修改首元素</span><br>    values.<span class="hljs-built_in">front</span>() = <span class="hljs-number">10</span>;<br>    cout &lt;&lt;<span class="hljs-string">&quot;values 新的首元素为：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//修改尾元素</span><br>    values.<span class="hljs-built_in">back</span>() = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;values 新的尾元素为：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">values</span> 首元素为：<span class="hljs-number">1</span><br><span class="hljs-attribute">values</span> 尾元素为：<span class="hljs-number">5</span><br><span class="hljs-attribute">values</span> 新的首元素为：<span class="hljs-number">10</span><br><span class="hljs-attribute">values</span> 新的尾元素为：<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p> 另外，vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>。通过该指针也可以访问甚至修改容器中的元素。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">//输出容器中第 3 个元素的值</span><br>    cout &lt;&lt; *(values.<span class="hljs-built_in">data</span>() + <span class="hljs-number">2</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//修改容器中第 2 个元素的值</span><br>    *(values.<span class="hljs-built_in">data</span>() + <span class="hljs-number">1</span>) = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; *(values.<span class="hljs-built_in">data</span>() + <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>10<br></code></pre></td></tr></table></figure>

<h3 id="3-3-2-访问vector容器中多个元素"><a href="#3-3-2-访问vector容器中多个元素" class="headerlink" title="3.3.2 访问vector容器中多个元素"></a>3.3.2 访问vector容器中多个元素</h3><p>​        如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">//从下标 0 一直遍历到 size()-1 处</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; values[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>注意，这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。</p>
<blockquote>
<p>关于 vector 容器 capacity() 和 size() 的差别，可以阅读 《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6770.html">STL vector容量（capacity）和大小（size）的区别</a>》一文。</p>
</blockquote>
<p>或者也可以使用基于范围的循环，此方式将会逐个遍历容器中的元素。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; value : values)<br>        cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p> 另外还可以使用 vector 迭代器遍历 vector 容器，这里以 begin()/end() 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>(); first &lt; values.<span class="hljs-built_in">end</span>(); ++first) &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>当然，这里也可以使用 rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 以及全局函数 begin()/end() ，它们都可以实现对容器中元素的访问。</p>
</blockquote>
<h2 id="3-4-添加元素"><a href="#3-4-添加元素" class="headerlink" title="3.4 添加元素"></a>3.4 添加元素</h2><p>在这些成员函数中，可以用来给容器中添加元素的函数有 2 个，分别是 push_back() 和 emplace_back() 函数。</p>
<blockquote>
<p>有读者可能认为还有 insert() 和 emplace() 成员函数，严格意义上讲，这 2 个成员函数的功能是向容器中的指定位置插入元素，后续章节会对它们做详细的介绍。</p>
</blockquote>
<h3 id="3-4-1-push-back"><a href="#3-4-1-push-back" class="headerlink" title="3.4.1 push_back()"></a>3.4.1 push_back()</h3><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;&#125;;<br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; values[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序中，第 7 行代码表示向 values 容器尾部添加一个元素，但由于当前 values 容器是空的，因此新添加的元素 1 无疑成为了容器中首个元素；第 8 行代码实现的功能是在现有元素 1 的后面，添加元素 2。</p>
<p> 运行程序，输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h3 id="3-4-2-emplace-back"><a href="#3-4-2-emplace-back" class="headerlink" title="3.4.2 emplace_back()"></a>3.4.2 emplace_back()</h3><p>该函数是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p>
<p> emplace_back() 成员函数的用法也很简单，这里直接举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; values&#123;&#125;;<br>    values.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>    values.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; values[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>读者可能会发现，以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？</p>
<h3 id="3-4-3-emplace-back-和push-back-的区别"><a href="#3-4-3-emplace-back-和push-back-的区别" class="headerlink" title="3.4.3 emplace_back()和push_back()的区别"></a>3.4.3 emplace_back()和push_back()的区别</h3><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back()  向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而  emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<p> 为了让大家清楚的了解它们之间的区别，我们创建一个包含类对象的 vector 容器，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testDemo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">int</span> num):<span class="hljs-built_in">num</span>(num)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">const</span> testDemo&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;<br>    std::vector&lt;testDemo&gt; demo1;<br>    demo1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>);  <br><br>    cout &lt;&lt; <span class="hljs-string">&quot;push_back:&quot;</span> &lt;&lt; endl;<br>    std::vector&lt;testDemo&gt; demo2;<br>    demo2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">emplace_back:</span><br>调用构造函数<br><span class="hljs-symbol">push_back:</span><br>调用构造函数<br>调用移动构造函数<br></code></pre></td></tr></table></figure>

<p>在此基础上，读者可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">emplace_back:</span><br>调用构造函数<br><span class="hljs-symbol">push_back:</span><br>调用构造函数<br>调用拷贝构造函数<br></code></pre></td></tr></table></figure>

<p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p>
<p>​        显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。</p>
<blockquote>
<p>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p>
</blockquote>
<h2 id="3-5-插入元素"><a href="#3-5-插入元素" class="headerlink" title="3.5 插入元素"></a>3.5 插入元素</h2><h3 id="3-5-1-insert"><a href="#3-5-1-insert" class="headerlink" title="3.5.1 insert()"></a>3.5.1 insert()</h3><p>​        insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<p> 下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-keyword">int</span>&gt; demo&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-comment">//第一种格式用法</span><br>    demo.<span class="hljs-built_in">insert</span>(demo.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//&#123;1,3,2&#125;</span><br><br>    <span class="hljs-comment">//第二种格式用法</span><br>    demo.<span class="hljs-built_in">insert</span>(demo.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//&#123;1,3,2,5,5&#125;</span><br><br>    <span class="hljs-comment">//第三种格式用法</span><br>    std::array&lt;<span class="hljs-keyword">int</span>,3&gt;test&#123; <span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span> &#125;;<br>    demo.<span class="hljs-built_in">insert</span>(demo.<span class="hljs-built_in">end</span>(), test.<span class="hljs-built_in">begin</span>(), test.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//&#123;1,3,2,5,5,7,8,9&#125;</span><br><br>    <span class="hljs-comment">//第四种格式用法</span><br>    demo.<span class="hljs-built_in">insert</span>(demo.<span class="hljs-built_in">end</span>(), &#123; <span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;);<span class="hljs-comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<h3 id="3-5-2-emplace"><a href="#3-5-2-emplace" class="headerlink" title="3.5.2 emplace()"></a>3.5.2 emplace()</h3><p>​        emplace() 是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p>
<blockquote>
<p>再次强调，emplace() 每次只能插入一个元素，而不是多个。</p>
</blockquote>
<p>​        该函数的语法格式如下：</p>
<p>​        iterator emplace (const_iterator pos, args…);</p>
<p>​        其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p>
<blockquote>
<p>简单的理解 args…，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-keyword">int</span>&gt; demo1&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <br>    <span class="hljs-comment">// emplace() 每次只能插入一个 int 类型元素</span><br>    demo1.<span class="hljs-built_in">emplace</span>(demo1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>​        既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testDemo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">int</span> num) :<span class="hljs-built_in">num</span>(num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">const</span> testDemo&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    testDemo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> testDemo&amp; other);<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> num;<br>&#125;;<br><br>testDemo&amp; testDemo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> testDemo&amp; other) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = other.num;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;insert:&quot;</span> &lt;&lt; endl;<br>    std::vector&lt;testDemo&gt; demo2&#123;&#125;;<br>    demo2.<span class="hljs-built_in">insert</span>(demo2.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">testDemo</span>(<span class="hljs-number">1</span>));<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace:&quot;</span> &lt;&lt; endl;<br>    std::vector&lt;testDemo&gt; demo1&#123;&#125;;<br>    demo1.<span class="hljs-built_in">emplace</span>(demo1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">insert:</span><br>调用构造函数<br>调用移动构造函数<br><span class="hljs-symbol">emplace:</span><br>调用构造函数<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</p>
</blockquote>
<p>​        可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</p>
<p>​        简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。</p>
<h2 id="3-6-删除元素"><a href="#3-6-删除元素" class="headerlink" title="3.6 删除元素"></a>3.6 删除元素</h2><p>​        基于不同场景的需要，删除 vecotr 容器的元素，可以使用表 1 中所示的函数（或者函数组合）。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>pop_back()</td>
<td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>erase(pos)</td>
<td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>swap(beg)、pop_back()</td>
<td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td>
</tr>
<tr>
<td>erase(beg,end)</td>
<td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>remove()</td>
<td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td>
</tr>
</tbody></table>
<p>​        下面就表 1 中罗列的这些函数，一一讲解它们的具体用法。</p>
<p>​        pop_back() 成员函数的用法非常简单，它不需要传入任何的参数，也没有返回值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    demo.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-comment">// 输出 dmeo 容器新的size</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 输出 demo 容器新的容量</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size</span> is :<span class="hljs-number">4</span><br><span class="hljs-attribute">capacity</span> is :<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>可以发现，相比原 demo 容器，新的 demo 容器删除了最后一个元素 5，容器的大小减了 1，但容量没变。</p>
<p>如果想删除 vector 容器中指定位置处的元素，可以使用 erase() 成员函数，该函数的语法格式为：</p>
<p>iterator erase (pos);</p>
<p>其中，pos 为指定被删除元素位置的迭代器，同时该函数会返回一个指向删除元素所在位置下一个位置的迭代器。</p>
<p> 下面的例子演示了 erase() 函数的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">auto</span> iter = demo.<span class="hljs-built_in">erase</span>(demo.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>);			<span class="hljs-comment">// 删除元素 2</span><br>    <br>    <span class="hljs-comment">// 输出 dmeo 容器新的size</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 输出 demo 容器新的容量</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// iter迭代器指向元素 3</span><br>    cout &lt;&lt; endl &lt;&lt; *iter &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size</span> is :<span class="hljs-number">4</span><br><span class="hljs-attribute">capacity</span> is :<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">3</span><br></code></pre></td></tr></table></figure>

<p>通过结果不能看出，erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。</p>
<p>另外，如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。</p>
<blockquote>
<p>注意，swap() 函数在头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;utility&gt;</code> 中都有定义，使用时引入其中一个即可。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 交换要删除元素和最后一个元素的位置</span><br>    <span class="hljs-built_in">swap</span>(*(std::<span class="hljs-built_in">begin</span>(demo)+<span class="hljs-number">1</span>),*(std::<span class="hljs-built_in">end</span>(demo)<span class="hljs-number">-1</span>));<span class="hljs-comment">//等同于 swap(demo[1],demo[4])</span><br>   <br>    <span class="hljs-comment">// 交换位置后的demo容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    demo.<span class="hljs-built_in">pop_back</span>();<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出demo 容器中剩余的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">size</span> is :<span class="hljs-number">4</span><br><span class="hljs-attribute">capacity</span> is :<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>​        当然，除了删除容器中单个元素，还可以删除容器中某个指定区域内的所有元素，同样可以使用 erase() 成员函数实现。该函数有 2 种基本格式，前面介绍了一种，这里使用另一种：</p>
<p>iterator erase (iterator first, iterator last);</p>
<p>其中 first 和 last 是指定被删除元素区域的迭代器，同时该函数会返回指向此区域之后一个位置的迭代器。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-keyword">int</span>&gt; demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 删除 2、3</span><br>    <span class="hljs-keyword">auto</span> iter = demo.<span class="hljs-built_in">erase</span>(demo.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, demo.<span class="hljs-built_in">end</span>() - <span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size</span> is :<span class="hljs-number">3</span><br><span class="hljs-attribute">capacity</span> is :<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>可以看到，和删除单个元素一样，删除指定区域内的元素时，也会将该区域后续的元素前移，并缩小容器的大小。</p>
<p> 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 <code>&lt;algorithm&gt;</code> 头文件中。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 交换要删除元素和最后一个元素的位置</span><br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">remove</span>(demo.<span class="hljs-built_in">begin</span>(), demo.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出剩余的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = demo.<span class="hljs-built_in">begin</span>(); first &lt; iter;++first) &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">size is :<span class="hljs-number">6</span><br>capacity is :<span class="hljs-number">6</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>​        注意，在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。</p>
<blockquote>
<p>​        remove()  的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 <code>1 4 5 4 3 5</code>。</p>
</blockquote>
<p>​        另外还可以看到，既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 “无用” 的元素。</p>
<p> 比如，修改上面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 交换要删除元素和最后一个元素的位置</span><br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">remove</span>(demo.<span class="hljs-built_in">begin</span>(), demo.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br>    demo.<span class="hljs-built_in">erase</span>(iter, demo.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出剩余的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; demo.<span class="hljs-built_in">size</span>();i++) &#123;<br>        cout &lt;&lt; demo[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size</span> is :<span class="hljs-number">3</span><br><span class="hljs-attribute">capacity</span> is :<span class="hljs-number">6</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。</p>
</blockquote>
<p> 如果想删除容器中所有的元素，则可以使用 clear() 成员函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;demo&#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 交换要删除元素和最后一个元素的位置</span><br>    demo.<span class="hljs-built_in">clear</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">size <span class="hljs-keyword">is</span> :<span class="hljs-number">0</span><br>capacity <span class="hljs-keyword">is</span> :<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<h1 id="四、deque容器"><a href="#四、deque容器" class="headerlink" title="四、deque容器"></a>四、deque容器</h1><h2 id="4-1-deque容器简介"><a href="#4-1-deque容器简介" class="headerlink" title="4.1 deque容器简介"></a>4.1 deque容器简介</h2><p>​        deque 是 double-ended queue 的缩写，又称双端队列容器。</p>
<p>​         前面章节中，我们已经系统学习了 vector 容器，值得一提的是，deque 容器和 vecotr 容器有很多相似之处，比如：</p>
<ul>
<li><p>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</p>
</li>
<li><p>deque 容器也可以根据需要修改自身的容量和大小。</p>
</li>
</ul>
<p>  和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<p>​        deque 容器以模板类 deque<T>（T 为存储元素的类型）的形式在 <deque> 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="4-1-1-创建deque容器的几种方式"><a href="#4-1-1-创建deque容器的几种方式" class="headerlink" title="4.1.1 创建deque容器的几种方式"></a>4.1.1 创建deque容器的几种方式</h3><p>创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。</p>
<ol>
<li>创建一个没有任何元素的空 deque 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::deque&lt;<span class="hljs-keyword">int</span>&gt; d;<br></code></pre></td></tr></table></figure>

<p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p>
<ol start="2">
<li>创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p>
<ol start="3">
<li>创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p>
<ol start="4">
<li>在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">std::deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1)</span></span>;<br></code></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝普通数组，创建deque容器</span><br><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>std::deque&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">d</span>(a, a + <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 适用于所有类型的容器</span><br>std::array&lt;<span class="hljs-keyword">int</span>, 5&gt;arr&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span> &#125;;<br>std::deque&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">d</span>(arr.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, arr.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//拷贝arr容器中的&#123;13,14,15&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-1-2-deque容器可利用的成员函数"><a href="#4-1-2-deque容器可利用的成员函数" class="headerlink" title="4.1.2 deque容器可利用的成员函数"></a>4.1.2 deque容器可利用的成员函数</h3><p>基于 deque 双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数。</p>
<p>下表中罗列了 deque 容器提供的所有成员函数。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的头部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td>
</tr>
</tbody></table>
<blockquote>
<p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
</blockquote>
<p>​        和 array、vector 相同，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2  个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end()  成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>​        deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<p> 如下代码演示了表 1 中部分成员函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化一个空deque容量</span><br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d;<br>    <br>    <span class="hljs-comment">// 向d容器中的尾部依次添加 1，2,3</span><br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//&#123;1&#125;</span><br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//&#123;1,2&#125;</span><br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//&#123;1,2,3&#125;</span><br>    <br>    <span class="hljs-comment">// 向d容器的头部添加 0 </span><br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//&#123;0,1,2,3&#125;</span><br><br>    <span class="hljs-comment">// 调用 size() 成员函数输出该容器存储的字符个数。</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素个数为：%d\n&quot;</span>, d.<span class="hljs-built_in">size</span>());<br>   <br>    <span class="hljs-comment">// 使用迭代器遍历容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = d.<span class="hljs-built_in">begin</span>(); i &lt; d.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">元素个数为：<span class="hljs-number">4</span><br><span class="hljs-number">0 1 2 3</span><br></code></pre></td></tr></table></figure>



<h2 id="4-2-deque容器迭代器"><a href="#4-2-deque容器迭代器" class="headerlink" title="4.2 deque容器迭代器"></a>4.2 deque容器迭代器</h2><p>deque 容器迭代器的类型为随机访问迭代器，deque 模板类提供了表 1 所示这些成员函数，通过调用这些函数，可以获得表示不同含义的随机访问迭代器。</p>
<blockquote>
<p>有关迭代器及其类型的介绍，可以阅读《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6675.html">C++ STL迭代器（iterator）</a>》一节，本节不再做具体介绍。</p>
</blockquote>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新添加的 begin() 和 end() 全局函数也同样适用于 deque 容器。即当操作对象为 deque 容器时，其功能分别和表 1 中的 begin()、end() 成员函数相同，具体用法本节后续会做详细介绍。</p>
</blockquote>
<p> 表 1 中这些成员函数的具体功能如图 2 所示。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328154803390.png" alt="image-20220328154803390" class="lazyload"></p>
<p>从图 2 可以看出，这些成员函数通常是成对使用的，即  begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend()  各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和  crbegin()/crend() 的功能是类似的。</p>
<blockquote>
<p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<h3 id="4-2-1-deque容器迭代器的基本用法"><a href="#4-2-1-deque容器迭代器的基本用法" class="headerlink" title="4.2.1 deque容器迭代器的基本用法"></a>4.2.1 deque容器迭代器的基本用法</h3><p>deque 容器迭代器常用来遍历容器中存储的各个元素。</p>
<p> begin() 和 end() 分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 deque 容器并输出其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 从容器首元素，遍历至最后一个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = d.<span class="hljs-built_in">begin</span>(); i &lt; d.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p>1 2 3 4 5</p>
<p> 前面提到，<a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> 还提供有全局的 begin() 和 end() 函数，当操作对象为容器时，它们的功能是上面的 begin()/end() 成员函数一样。例如，将上面程序中的第 8~10 行代码可以用如下代码替换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">begin</span>(d); i &lt; <span class="hljs-built_in">end</span>(d); i++) &#123;<br>    cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重新编译运行程序，会发现输出结果和上面一致。</p>
<p> cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> first = d.<span class="hljs-built_in">cbegin</span>();<br>    <span class="hljs-keyword">auto</span> end = d.<span class="hljs-built_in">cend</span>();<br>    <br>    <span class="hljs-comment">// 常量迭代器不能用来修改容器中的元素值</span><br>    <span class="hljs-comment">// *(first + 1) = 6;//尝试修改容器中元素 2 的值</span><br>    <span class="hljs-comment">// *(end - 1) = 10;//尝试修改容器中元素 5 的值</span><br>    <span class="hljs-comment">// 常量迭代器可以用来遍历容器、访问容器中的元素</span><br>    <span class="hljs-keyword">while</span>(first&lt;end)&#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>程序中，由于 first 和 end 都是常量迭代器，因此第 10、11 行修改容器内元素值的操作都是非法的。</p>
<p> deque 模板类中还提供了 rbegin() 和 rend() 成员函数，它们分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又常称为反向迭代器（如图 2 所示）。</p>
<blockquote>
<p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p>
</blockquote>
<p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = d.<span class="hljs-built_in">rbegin</span>(); i &lt; d.<span class="hljs-built_in">rend</span>(); i++) &#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>


<p>​        crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型迭代器，不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<h3 id="4-2-2-deque容器迭代器的使用注意事项"><a href="#4-2-2-deque容器迭代器的使用注意事项" class="headerlink" title="4.2.2 deque容器迭代器的使用注意事项"></a>4.2.2 deque容器迭代器的使用注意事项</h3><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p>
<p> 例如，如下代码中注释部分是错误的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;values;<br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">//*first = 1;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>对于空的 deque 容器来说，可以通过 push_back()、push_front() 或者 resize() 成员函数实现向（空）deque 容器中添加元素。</p>
</blockquote>
<p> 除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d;<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> first = d.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; *first &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 添加元素，会导致 first 失效</span><br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    cout &lt;&lt; *first &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序中第 12 行代码，会导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。</p>
<h2 id="4-3-deque容器访问元素"><a href="#4-3-deque容器访问元素" class="headerlink" title="4.3 deque容器访问元素"></a>4.3 deque容器访问元素</h2><p>通过《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6860.html">STL deque容器</a>》一节，详细介绍了如何创建一个 deque 容器，本节继续讲解如何访问（甚至修改）deque 容器存储的元素。</p>
<p> 和 array、vector 容器一样，可以采用普通数组访问存储元素的方式，访问 deque 容器中的元素，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>    cout &lt;&lt; d[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 修改指定下标位置处的元素</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; d[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>5<br></code></pre></td></tr></table></figure>

<p>​        可以看到，<code>容器名[n]</code>的这种方式，不仅可以访问容器中的元素，还可以对其进行修改。但需要注意的是，使用此方法需确保下标 n 的值不会超过容器中存储元素的个数，否则会发生越界访问的错误。</p>
<p>​        如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数，由于该函数会返回容器中指定位置处元素的引用形式，因此利用该函数的返回值，既可以访问指定位置处的元素，如果需要还可以对其进行修改。</p>
<p>​        不仅如此，at() 成员函数会自行判定访问位置是否越界，如果越界则抛出<code>std::out_of_range</code>异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>    cout &lt;&lt; d.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    d.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; d.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">// 下面这条语句会抛出 out_of_range 异常</span><br>    <span class="hljs-comment">// cout &lt;&lt; d.at(10) &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>5<br></code></pre></td></tr></table></figure>



<blockquote>
<p>读者可能有这样一个疑问，即为什么 deque 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>​        除此之外，deque 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用它们的返回值，可以访问（甚至修改）容器中的首尾元素。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; d&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deque 首元素为：&quot;</span> &lt;&lt; d.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deque 尾元素为：&quot;</span> &lt;&lt; d.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 修改首元素</span><br>    d.<span class="hljs-built_in">front</span>() = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deque 新的首元素为：&quot;</span> &lt;&lt; d.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 修改尾元素</span><br>    d.<span class="hljs-built_in">back</span>() = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deque 新的尾元素为：&quot;</span> &lt;&lt; d.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">deque</span> 首元素为：<span class="hljs-number">1</span><br><span class="hljs-attribute">deque</span> 尾元素为：<span class="hljs-number">5</span><br><span class="hljs-attribute">deque</span> 新的首元素为：<span class="hljs-number">10</span><br><span class="hljs-attribute">deque</span> 新的尾元素为：<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>


<p>​        注意，和 vector 容器不同，deque 容器没有提供 data() 成员函数，同时 deque 容器在存储元素时，也无法保证其会将元素存储在连续的内存空间中，因此尝试使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>去访问 deque 容器中指定位置处的元素，是非常危险的。</p>
<p> 另外，结合 deque 模板类中和迭代器相关的成员函数，可以实现遍历 deque 容器中指定区域元素的方法。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; d&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">// 从元素 2 开始遍历</span><br>    <span class="hljs-keyword">auto</span> first = d.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 遍历至 5 结束（不包括 5）</span><br>    <span class="hljs-keyword">auto</span> end = d.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (first &lt; end) &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<h2 id="4-4-添加和删除元素"><a href="#4-4-添加和删除元素" class="headerlink" title="4.4 添加和删除元素"></a>4.4 添加和删除元素</h2><p>​        deque 容器中，无论是添加元素还是删除元素，都只能借助 deque 模板类提供的成员函数。表 1 中罗列的是所有和添加或删除容器内元素相关的 deque 模板类中的成员函数。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>push_back()</td>
<td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td><a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置。</td>
</tr>
<tr>
<td>emplace()</td>
<td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或某一区域内的多个元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器中所有的元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>在实际应用中，常用 emplace()、emplace_front() 和 emplace_back() 分别代替 insert()、push_front() 和 push_back()，具体原因本节后续会讲。</p>
</blockquote>
<p>以上这些成员函数中，除了 insert() 函数的语法格式比较多，其他函数都只有一种用法（erase() 有 2 种语法格式），下面这段程序演示了它们的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt;d;<br>    <span class="hljs-comment">// 调用push_back()向容器尾部添加数据。</span><br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//&#123;2&#125;</span><br>    <span class="hljs-comment">// 调用pop_back()移除容器尾部的一个数据。</span><br>    d.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//&#123;&#125;</span><br><br>    <span class="hljs-comment">// 调用push_front()向容器头部添加数据。</span><br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//&#123;2&#125;</span><br>    <span class="hljs-comment">// 调用pop_front()移除容器头部的一个数据。</span><br>    d.<span class="hljs-built_in">pop_front</span>();<span class="hljs-comment">//&#123;&#125;</span><br><br>    <span class="hljs-comment">// 调用 emplace 系列函数，向容器中直接生成数据。</span><br>    d.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//&#123;2&#125;</span><br>    d.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//&#123;3,2&#125;</span><br>    <span class="hljs-comment">// emplace() 需要 2 个参数，第一个为指定插入位置的迭代器，第二个是插入的值。</span><br>    d.<span class="hljs-built_in">emplace</span>(d.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">//&#123;3,4,2&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : d) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// erase()可以接受一个迭代器表示要删除元素所在位置</span><br>    <span class="hljs-comment">// 也可以接受 2 个迭代器，表示要删除元素所在的区域。</span><br>    d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//&#123;4,2&#125;</span><br>    d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//&#123;&#125;，等同于 d.clear()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>


<p> 这里重点讲一下 insert() 函数的用法。insert() 函数的功能是在 deque 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如表 2 所示。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<p> 下面的程序演示了 insert() 函数的这几种用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::deque&lt;<span class="hljs-keyword">int</span>&gt; d&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-comment">// 第一种格式用法</span><br>    d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);						<span class="hljs-comment">// &#123;1,3,2&#125;</span><br><br>    <span class="hljs-comment">// 第二种格式用法</span><br>    d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);						<span class="hljs-comment">// &#123;1,3,2,5,5&#125;</span><br><br>    <span class="hljs-comment">// 第三种格式用法</span><br>    std::array&lt;<span class="hljs-keyword">int</span>, 3&gt;test&#123; <span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span> &#125;;<br>    d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">end</span>(), test.<span class="hljs-built_in">begin</span>(), test.<span class="hljs-built_in">end</span>());	<span class="hljs-comment">// &#123;1,3,2,5,5,7,8,9&#125;</span><br><br>    <span class="hljs-comment">// 第四种格式用法</span><br>    d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">end</span>(), &#123; <span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;);					<span class="hljs-comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; d[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p>1,3,2,5,5,7,8,9,10,11</p>
<h3 id="4-4-1-emplace系列函数的优势"><a href="#4-4-1-emplace系列函数的优势" class="headerlink" title="4.4.1 emplace系列函数的优势"></a>4.4.1 emplace系列函数的优势</h3><p>有关 emplace()、emplace_front() 和 emplace_back() 分别和 insert()、push_front() 和 push_back() 在运行效率上的对比，可以通过下面的程序体现出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testDemo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">int</span> num) :<span class="hljs-built_in">num</span>(num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(<span class="hljs-keyword">const</span> testDemo&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="hljs-built_in">num</span>(other.num) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    testDemo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> testDemo&amp; other);<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> num;<br>&#125;;<br><br>testDemo&amp; testDemo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> testDemo&amp; other) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = other.num;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// emplace和insert</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo1;<br>    demo1.<span class="hljs-built_in">emplace</span>(demo1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;insert:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo2;<br>    demo2.<span class="hljs-built_in">insert</span>(demo2.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// emplace_front和push_front</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace_front:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo3;<br>    demo3.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;push_front:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo4;<br>    demo4.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// emplace_back()和push_back()</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo5;<br>    demo5.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;push_back:&quot;</span> &lt;&lt; endl;<br>    std::deque&lt;testDemo&gt; demo6;<br>    demo6.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">emplace:</span><br>调用构造函数<br><span class="hljs-symbol">insert:</span><br>调用构造函数<br>调用移动构造函数<br><span class="hljs-symbol">emplace_front:</span><br>调用构造函数<br><span class="hljs-symbol">push_front:</span><br>调用构造函数<br>调用移动构造函数<br><span class="hljs-symbol">emplace_back:</span><br>调用构造函数<br><span class="hljs-symbol">push_back:</span><br>调用构造函数<br>调用移动构造函数<br></code></pre></td></tr></table></figure>



<p>可以看到，相比和它同功能的函数，emplace 系列函数都只调用了构造函数，而没有调用移动构造函数，这无疑提高了代码的运行效率。</p>
<h1 id="五、List容器"><a href="#五、List容器" class="headerlink" title="五、List容器"></a>五、List容器</h1><h2 id="5-1-list容器简介"><a href="#5-1-list容器简介" class="headerlink" title="5.1 list容器简介"></a>5.1 list容器简介</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<p> 图 1 展示了 list 双向链表容器是如何存储元素的。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328155255585.png" alt="image-20220328155255585" class="lazyload"></p>
<p>可以看到，list 容器中各个元素的前后顺序是靠<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p>
<p> 基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p> 使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p>
<blockquote>
<p>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</p>
</blockquote>
<p>list 容器以模板类 list<T>（T 为存储元素的类型）的形式在<code>&lt;list&gt;</code>头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="5-1-1-list容器的创建"><a href="#5-1-1-list容器的创建" class="headerlink" title="5.1.1 list容器的创建"></a>5.1.1 list容器的创建</h3><p>根据不同的使用场景，有以下 5 种创建 list 容器的方式供选择。</p>
<ol>
<li>创建一个没有任何元素的空 list 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::list&lt;<span class="hljs-keyword">int</span>&gt; values;<br></code></pre></td></tr></table></figure>

<p>和空 array 容器不同，空的 list 容器在创建之后仍可以添加元素，因此创建 list 容器的方式很常用。</p>
<ol start="2">
<li>创建一个包含 n 个元素的 list 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</p>
<ol start="3">
<li>创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素并且值都为 5 个 values 容器。</p>
<ol start="4">
<li>在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">std::list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value2</span><span class="hljs-params">(value1)</span></span>;<br></code></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝普通数组，创建list容器</span><br><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">std::list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 拷贝其它类型的容器，创建 list 容器</span><br>std::array&lt;<span class="hljs-keyword">int</span>, 5&gt;arr&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span> &#125;;<br>std::list&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">values</span>(arr.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, arr.<span class="hljs-built_in">end</span>());			<span class="hljs-comment">// 拷贝arr容器中的&#123;13,14,15&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="5-1-2-list容器可用的成员函数"><a href="#5-1-2-list容器可用的成员函数" class="headerlink" title="5.1.2 list容器可用的成员函数"></a>5.1.2 list容器可用的成员函数</h3><p>下表中罗列出了 list 模板类提供的所有成员函数以及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器实际包含的元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert()</td>
<td>在容器中的指定位置插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<p>​        除此之外，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11  标准库还新增加了 begin() 和 end() 这 2 个函数，和 list 容器包含的 begin() 和 end()  成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和  end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end()  返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>​        list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<p> 如下代码演示了表 2 中部分成员函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建空的 list 容器</span><br>    std::list&lt;<span class="hljs-keyword">double</span>&gt; values;<br>    <br>    <span class="hljs-comment">// 向容器中添加元素</span><br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3.1</span>);<br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2.2</span>);<br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2.9</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;values size：&quot;</span> &lt;&lt; values.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 对容器中的元素进行排序</span><br>    values.<span class="hljs-built_in">sort</span>();<br>    <br>    <span class="hljs-comment">// 使用迭代器输出list容器中的元素</span><br>    <span class="hljs-keyword">for</span> (std::list&lt;<span class="hljs-keyword">double</span>&gt;::iterator it = values.<span class="hljs-built_in">begin</span>(); it != values.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">values</span> size：<span class="hljs-number">3</span><br><span class="hljs-attribute">2</span>.<span class="hljs-number">2</span> <span class="hljs-number">2</span>.<span class="hljs-number">9</span> <span class="hljs-number">3</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<h2 id="5-2-List迭代器"><a href="#5-2-List迭代器" class="headerlink" title="5.2 List迭代器"></a>5.2 List迭代器</h2><p>只有运用迭代器，才能访问 list 容器中存储的各个元素。list 模板类提供了如表 1 所示的这些迭代器函数。</p>
<table>
<thead>
<tr>
<th>迭代器函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器（正向迭代器）。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。（正向迭代器）。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新添加的 begin() 和 end() 全局函数也同样适用于 list 容器。即当操作对象为 list 容器时，其功能分别和表 1 中的 begin()、end() 成员函数相同。</p>
</blockquote>
<p>表 1 中各个成员函数的功能如图 2 所示。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328155524075.png" alt="image-20220328155524075" class="lazyload"></p>
<blockquote>
<p>注意，list 容器的底层实现结构为双向链表，图 2 这种表示仅是为了方便理解各个迭代器函数的功能。</p>
</blockquote>
<p>从图 2 可以看出，这些成员函数通常是成对使用的，即  begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend()  各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和  crbegin()/crend() 的功能是类似的。</p>
<p> 前面章节已经详细介绍了 array、vector、deque 容器的迭代器，和它们相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。</p>
<p> 这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1–、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：</p>
<ul>
<li>p1[i]：不能通过下标访问 list 容器中指定位置处的元素。</li>
<li>p1-=i、 p1+=i、 p1+i 、p1-i：双向迭代器 p1 不支持使用 -=、+=、+、- 运算符。</li>
<li>p1&lt;p2、 p1&gt;p2、 p1&lt;=p2、 p1&gt;=p2：双向迭代器 p1、p2 不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符。</li>
</ul>
<blockquote>
<p>有关迭代器类别和功能的具体介绍，可阅读 《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6675.html">C++ STL迭代器</a>》一节。</p>
</blockquote>
<p>下面这个程序演示了如何使用表 1 中的迭代器遍历 list 容器中的各个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建 list 容器</span><br>    std::list&lt;<span class="hljs-keyword">char</span>&gt; values&#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br>    <br>    <span class="hljs-comment">// 使用begin()/end()迭代器函数对输出list容器中的元素</span><br>    <span class="hljs-keyword">for</span> (std::list&lt;<span class="hljs-keyword">char</span>&gt;::iterator it = values.<span class="hljs-built_in">begin</span>(); it != values.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span><br>    <span class="hljs-keyword">for</span> (std::list&lt;<span class="hljs-keyword">char</span>&gt;::reverse_iterator it = values.<span class="hljs-built_in">rbegin</span>(); it != values.<span class="hljs-built_in">rend</span>();++it) &#123;<br>        std::cout &lt;&lt; *it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>c.biancheng.net<br>ten.gnehcnaib.c<span class="hljs-regexp">//</span>:ptth<br></code></pre></td></tr></table></figure>



<blockquote>
<p>​        注意，程序中比较迭代器之间的关系，用的是 != 运算符，因为它不支持 &lt; 等运算符。另外在实际场景中，所有迭代器函数的返回值都可以传给使用 auto 关键字定义的变量，因为编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<p>​        值得一提的是，list 容器在进行插入（insert()）、接合（splice()）等操作时，都不会造成原有的 list 迭代器失效，甚至进行删除操作，而只有指向被删除元素的迭代器失效，其他迭代器不受任何影响。</p>
<p> 举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建 list 容器</span><br>    std::list&lt;<span class="hljs-keyword">char</span>&gt; values&#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br>    <br>    <span class="hljs-comment">// 创建 begin 和 end 迭代器</span><br>    std::list&lt;<span class="hljs-keyword">char</span>&gt;::iterator begin = values.<span class="hljs-built_in">begin</span>();<br>    std::list&lt;<span class="hljs-keyword">char</span>&gt;::iterator end = values.<span class="hljs-built_in">end</span>();<br>    <br>    <span class="hljs-comment">// 头部和尾部插入字符 &#x27;1&#x27;</span><br>    values.<span class="hljs-built_in">insert</span>(begin, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    values.<span class="hljs-built_in">insert</span>(end, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-keyword">while</span> (begin != end)<br>    &#123;<br>        std::cout &lt;&lt; *begin;<br>        ++begin;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>c.biancheng.net1<br></code></pre></td></tr></table></figure>

<p>​        可以看到，在进行插入操作之后，仍使用先前创建的迭代器遍历容器，虽然程序不会出错，但由于插入位置的不同，可能会遗漏新插入的元素。</p>
<h2 id="5-3-List访问元素"><a href="#5-3-List访问元素" class="headerlink" title="5.3 List访问元素"></a>5.3 List访问元素</h2><p>不同于之前学过的 <a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> 容器，访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。</p>
<blockquote>
<p>list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。</p>
</blockquote>
<p>通过 front() 和 back() 成员函数，可以分别获得 list 容器中第一个元素和最后一个元素的引用形式。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::list&lt;<span class="hljs-keyword">int</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>    <span class="hljs-keyword">int</span> &amp;first = mylist.<span class="hljs-built_in">front</span>();<br>    <span class="hljs-keyword">int</span> &amp;last = mylist.<span class="hljs-built_in">back</span>();<br>    cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; last &lt;&lt; endl;<br>    first = <span class="hljs-number">10</span>;<br>    last = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; mylist.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mylist.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>​        可以看到，通过 front() 和 back() 的返回值，我们不仅能分别获取当前 list 容器中的首尾元素，必要时还能修改它们的值。</p>
<p>​         除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> std::list&lt;<span class="hljs-keyword">int</span>&gt; mylist&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = mylist.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    ++it;<br>    <span class="hljs-keyword">while</span> (it!=mylist.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++it;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>值得一提的是，对于非 const 类型的 list 容器，迭代器不仅可以访问容器中的元素，也可以对指定元素的值进行修改。</p>
<blockquote>
<p>当然，对于修改容器指定元素的值，list 模板类提供有专门的成员函数 assign()，感兴趣的读者可自行查找该成员函数的用法。</p>
</blockquote>
<h2 id="5-4-添加插入"><a href="#5-4-添加插入" class="headerlink" title="5.4 添加插入"></a>5.4 添加插入</h2><p>list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：</p>
<ul>
<li>push_front()：向 list 容器首个元素前添加新元素；</li>
<li>push_back()：向 list 容器最后一个元素后添加新元素；</li>
<li>emplace_front()：在容器首个元素前直接生成新的元素；</li>
<li>emplace_back()：在容器最后一个元素后直接生成新的元素；</li>
<li>emplace()：在容器的指定位置直接生成新的元素；</li>
<li>insert()：在指定位置插入新元素；</li>
<li>splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。</li>
</ul>
<p> 以上这些成员方法中，除了 insert() 和 splice() 方法有多种语法格式外，其它成员方法都仅有 1 种语法格式，下面程序演示了它们的具体用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::list&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    values.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);						<span class="hljs-comment">// &#123;0,1,2,3&#125;</span><br>    values.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); 						<span class="hljs-comment">// &#123;0,1,2,3,4&#125;</span><br><br>    values.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">-1</span>);					<span class="hljs-comment">// &#123;-1,0,1,2,3,4&#125;</span><br>    values.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">5</span>);  					<span class="hljs-comment">// &#123;-1,0,1,2,3,4,5&#125;</span><br>   <br>    <span class="hljs-comment">// emplace(pos,value),其中 pos 表示指明位置的迭代器，value为要插入的元素值</span><br>    values.<span class="hljs-built_in">emplace</span>(values.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>);<span class="hljs-comment">//&#123;-1,0,1,2,3,4,5,6&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = values.<span class="hljs-built_in">begin</span>(); p != values.<span class="hljs-built_in">end</span>(); ++p) &#123;<br>        cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">-<span class="hljs-number">1,0,1,2</span>,<span class="hljs-number">3,4,5,6</span><br></code></pre></td></tr></table></figure>



<h3 id="5-4-1-list-insert-成员方法"><a href="#5-4-1-list-insert-成员方法" class="headerlink" title="5.4.1 list insert()成员方法"></a>5.4.1 list insert()成员方法</h3><p>insert() 成员方法的语法格式有 4 种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<p> 下面的程序演示了如何使用 insert() 方法向 list 容器中插入元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::list&lt;<span class="hljs-keyword">int</span>&gt; values&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-comment">// 第一种格式用法</span><br>    values.<span class="hljs-built_in">insert</span>(values.<span class="hljs-built_in">begin</span>() , <span class="hljs-number">3</span>);<span class="hljs-comment">//&#123;3,1,2&#125;</span><br><br>    <span class="hljs-comment">// 第二种格式用法</span><br>    values.<span class="hljs-built_in">insert</span>(values.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//&#123;3,1,2,5,5&#125;</span><br><br>    <span class="hljs-comment">// 第三种格式用法</span><br>    std::array&lt;<span class="hljs-keyword">int</span>, 3&gt;test&#123; <span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span> &#125;;<br>    values.<span class="hljs-built_in">insert</span>(values.<span class="hljs-built_in">end</span>(), test.<span class="hljs-built_in">begin</span>(), test.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//&#123;3,1,2,5,5,7,8,9&#125;</span><br><br>    <span class="hljs-comment">// 第四种格式用法</span><br>    values.<span class="hljs-built_in">insert</span>(values.<span class="hljs-built_in">end</span>(), &#123; <span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;);<span class="hljs-comment">//&#123;3,1,2,5,5,7,8,9,10,11&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = values.<span class="hljs-built_in">begin</span>(); p != values.<span class="hljs-built_in">end</span>(); ++p)<br>    &#123;<br>        cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<p>​        学到这里，读者有没有发现，同样是实现插入元素的功能，无论是 push_front()、push_back() 还是 insert()，都有以 emplace 为名且功能和前者相同的成员函数。这是因为，后者是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 标准新添加的，在大多数场景中，都可以完全替代前者实现同样的功能。更重要的是，实现同样的功能，emplace 系列方法的执行效率更高。</p>
<h3 id="5-4-2-list-splice-成员方法"><a href="#5-4-2-list-splice-成员方法" class="headerlink" title="5.4.2 list splice()成员方法"></a>5.4.2 list splice()成员方法</h3><p>​        和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。</p>
<pre><code>     splice() 成员方法的语法格式有 3 种，如表 2 所示。
</code></pre>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。  此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。  此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。  此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td>
</tr>
</tbody></table>
<p>​        我们知道，list 容器底层使用的是链表存储结构，splice() 成员方法移动元素的方式是，将存储该元素的节点从 list  容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中。这意味着，当使用 splice() 成员方法将 x  容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除。</p>
<p> 下面程序演示了 splice() 成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建并初始化 2 个 list 容器</span><br>    list&lt;<span class="hljs-keyword">int</span>&gt; mylist1&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;, mylist2&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br>    list&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = ++mylist1.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 指向 mylist1 容器中的元素 2</span><br>   <br>    <span class="hljs-comment">// 调用第一种语法格式</span><br>    mylist1.<span class="hljs-built_in">splice</span>(it, mylist2); <span class="hljs-comment">// mylist1: 1 10 20 30 2 3 4</span><br>                                 <span class="hljs-comment">// mylist2:</span><br>                                 <span class="hljs-comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span><br><br>    <span class="hljs-comment">// 调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span><br>    mylist2.<span class="hljs-built_in">splice</span>(mylist2.<span class="hljs-built_in">begin</span>(), mylist1, it);   <span class="hljs-comment">// mylist1: 1 10 20 30 3 4</span><br>                                                    <span class="hljs-comment">// mylist2: 2</span><br>                                                    <span class="hljs-comment">// it 仍然指向元素 2</span><br>   <br>    <span class="hljs-comment">// 调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span><br>    mylist2.<span class="hljs-built_in">splice</span>(mylist2.<span class="hljs-built_in">begin</span>(), mylist1, mylist1.<span class="hljs-built_in">begin</span>(), mylist1.<span class="hljs-built_in">end</span>());	<span class="hljs-comment">// mylist1:</span><br>                                                                             	<span class="hljs-comment">// mylist2:1 10 20 30 3 4 2</span><br>   <br>    cout &lt;&lt; <span class="hljs-string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个元素&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个元素&quot;</span> &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 输出 mylist2 容器中存储的数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;mylist2:&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mylist2.<span class="hljs-built_in">begin</span>(); iter != mylist2.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mylist1</span> 包含 <span class="hljs-number">0</span>个元素<br><span class="hljs-attribute">mylist2</span> 包含 <span class="hljs-number">7</span>个元素<br><span class="hljs-attribute">mylist2</span>:<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>



<h2 id="5-4-删除"><a href="#5-4-删除" class="headerlink" title="5.4 删除"></a>5.4 删除</h2><p>对 list 容器存储的元素执行删除操作，需要借助该容器模板类提供的成员函数。幸运的是，相比其它 <a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a> 容器模板类，list 模板类提供了更多用来实现此操作的成员函数（如表 1 所示）。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>pop_front()</td>
<td>删除位于 list 容器头部的一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除位于 list 容器尾部的一个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除 list 容器存储的所有元素。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一份。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
</tbody></table>
<p> 其中，pop_front()、pop_back() 和 clear() 的用法非常简单，这里仅给出一个样例，不再过多解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-keyword">int</span>&gt;values&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>   <br>    <span class="hljs-comment">// 删除当前容器中首个元素</span><br>    values.<span class="hljs-built_in">pop_front</span>();<span class="hljs-comment">//&#123;2,3,4&#125;</span><br>   <br>    <span class="hljs-comment">// 删除当前容器最后一个元素</span><br>    values.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&#123;2,3&#125;</span><br>   <br>    <span class="hljs-comment">// 清空容器，删除容器中所有的元素</span><br>    values.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//&#123;&#125;</span><br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begin = values.<span class="hljs-built_in">begin</span>(); begin != values.<span class="hljs-built_in">end</span>(); ++begin)<br>    &#123;<br>        cout &lt;&lt; *begin &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序，可以看到输出结果为“空”。</p>
<p> erase() 成员函数有以下 2 种语法格式：</p>
<ul>
<li>iterator erase (iterator position);</li>
<li>iterator erase (iterator first, iterator last);</li>
</ul>
<p>利用第一种语法格式，可实现删除 list 容器中 position 迭代器所指位置处的元素，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-keyword">int</span>&gt;values&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">//指向元素 1 的迭代器</span><br>    <span class="hljs-keyword">auto</span> del = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">//迭代器右移，改为指向元素 2</span><br>    ++del;<br>    values.<span class="hljs-built_in">erase</span>(del); <span class="hljs-comment">//&#123;1,3,4,5&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begin = values.<span class="hljs-built_in">begin</span>(); begin != values.<span class="hljs-built_in">end</span>(); ++begin)<br>    &#123;<br>        cout &lt;&lt; *begin &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>


<p> 利用第二种语法格式，可实现删除 list 容器中 first 迭代器和 last 迭代器限定区域内的所有元素（包括 first 指向的元素，但不包括 last 指向的元素）。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-keyword">int</span>&gt;values&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">//指定删除区域的左边界</span><br>    <span class="hljs-keyword">auto</span> first = values.<span class="hljs-built_in">begin</span>();<br>    ++first;<span class="hljs-comment">//指向元素 2</span><br><br>    <span class="hljs-comment">//指向删除区域的右边界</span><br>    <span class="hljs-keyword">auto</span> last = values.<span class="hljs-built_in">end</span>();<br>    --last;<span class="hljs-comment">//指向元素 5</span><br><br>    <span class="hljs-comment">//删除 2、3 和 4</span><br>    values.<span class="hljs-built_in">erase</span>(first, last);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begin = values.<span class="hljs-built_in">begin</span>(); begin != values.<span class="hljs-built_in">end</span>(); ++begin)<br>    &#123;<br>        cout &lt;&lt; *begin &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>


<p> erase() 成员函数是按照被删除元素所在的位置来执行删除操作，如果想根据元素的值来执行删除操作，可以使用 remove() 成员函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-keyword">char</span>&gt;values&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br>    values.<span class="hljs-built_in">remove</span>(<span class="hljs-string">&#x27;c&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begin = values.<span class="hljs-built_in">begin</span>(); begin != values.<span class="hljs-built_in">end</span>(); ++begin)<br>    &#123;<br>        cout &lt;&lt; *begin &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d<br></code></pre></td></tr></table></figure>


<p> unique() 函数也有以下 2 种语法格式：</p>
<ul>
<li>void unique()</li>
<li>void unique（BinaryPredicate）//传入一个二元谓词函数</li>
</ul>
<p> 以上 2 种格式都能实现去除 list 容器中相邻重复的元素，仅保留一份。但第 2 种格式的优势在于，我们能自定义去重的规则，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 二元谓词函数</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">demo</span><span class="hljs-params">(<span class="hljs-keyword">double</span> first, <span class="hljs-keyword">double</span> second)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(first) == <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(second));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-keyword">double</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4.5</span>,<span class="hljs-number">4.6</span> &#125;;<br>    <span class="hljs-comment">// 删除相邻重复的元素，仅保留一份</span><br>    mylist.<span class="hljs-built_in">unique</span>();<span class="hljs-comment">//&#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mylist.<span class="hljs-built_in">begin</span>(); it != mylist.<span class="hljs-built_in">end</span>(); ++it)<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-comment">// demo 为二元谓词函数，是我们自定义的去重规则</span><br>    mylist.<span class="hljs-built_in">unique</span>(demo);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mylist.<span class="hljs-built_in">begin</span>(); it != mylist.<span class="hljs-built_in">end</span>(); ++it)<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1.2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4.5</span> <span class="hljs-number">4.6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>注意，除了以上一定谓词函数的方式，还可以使用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/433.html">lamba表达式</a>以及<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/354.html">函数对象</a>的方式定义。</p>
</blockquote>
<p>可以看到，通过调用无参的 unique()，仅能删除相邻重复（也就是相等）的元素，而通过我们自定义去重的规则，可以更好的满足在不同场景下去重的需求。</p>
<p> 除此之外，通过将自定义的谓词函数（不限定参数个数）传给 remove_if() 成员函数，list 容器中能使谓词函数成立的元素都会被删除。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::list&lt;<span class="hljs-keyword">int</span>&gt; mylist&#123; <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">7</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">39</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-comment">//删除 mylist 容器中能够使 lamba 表达式成立的所有元素。</span><br>    mylist.<span class="hljs-built_in">remove_if</span>([](<span class="hljs-keyword">int</span> value) &#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (value &lt; <span class="hljs-number">10</span>); &#125;); <span class="hljs-comment">//&#123;15 36 17 20 39&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mylist.<span class="hljs-built_in">begin</span>(); it != mylist.<span class="hljs-built_in">end</span>(); ++it)<br>        std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *it;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span><span class="hljs-number">36</span> <span class="hljs-number">17</span> <span class="hljs-number">20</span> <span class="hljs-number">39</span><br></code></pre></td></tr></table></figure>



<h1 id="六、forward-list容器"><a href="#六、forward-list容器" class="headerlink" title="六、forward_list容器"></a>六、forward_list容器</h1><h2 id="6-1-forward-list容器简介"><a href="#6-1-forward-list容器简介" class="headerlink" title="6.1 forward_list容器简介"></a>6.1 forward_list容器简介</h2><p>forward_list 是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表（如图 1 所示）。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="C:\Users\24371\AppData\Roaming\Typora\typora-user-images\image-20220328160031705.png" alt="image-20220328160031705" class="lazyload"></p>
<blockquote>
<p>图 1 中，H 表示链表的表头。</p>
</blockquote>
<p>​        通过图 1 不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>来维持。</p>
<p>​        因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p>
<p>​        另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list  容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list  容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p>
<blockquote>
<p>有关迭代器的具体分类以及各种迭代器的具体功能，可以阅读《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6675.html">C++ STL迭代器</a>》一节。</p>
</blockquote>
<p>​        那么，既然 forward_list 容器具有和 list 容器相同的特性，list 容器还可以提供更多的功能函数，forward_list 容器有什么存在的必要呢？</p>
<p>​        当然有，forward_list 容器底层使用单链表，也不是一无是处。比如，存储相同个数的同类型元素，单链表耗用的内存空间更少，空间利用率更高，并且对于实现某些操作单链表的执行效率也更高。</p>
<blockquote>
<p>效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p>
</blockquote>
<h3 id="6-1-1-forward-list容器的创建"><a href="#6-1-1-forward-list容器的创建" class="headerlink" title="6.1.1 forward_list容器的创建"></a>6.1.1 forward_list容器的创建</h3><p>​        由于 forward_list 容器以模板类 forward_list<T>（T 为存储元素的类型）的形式被包含在<forward_list>头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>std 命名空间也可以在使用 forward_list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<p>​        创建 forward_list 容器的方式，大致分为以下 5 种。</p>
<ol>
<li>创建一个没有任何元素的空 forward_list 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values;<br></code></pre></td></tr></table></figure>

<p>由于 forward_list 容器在创建后也可以添加元素，因此这种创建方式很常见。</p>
<ol start="2">
<li>创建一个包含 n 个元素的 forward_list 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</p>
<ol start="3">
<li>创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素并且值都为 5 个 values 容器。</p>
<ol start="4">
<li>在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value2</span><span class="hljs-params">(value1)</span></span>;<br></code></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 forward_list 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝普通数组，创建forward_list容器</span><br><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 拷贝其它类型的容器，创建forward_list容器</span><br>std::array&lt;<span class="hljs-keyword">int</span>, 5&gt;arr&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span> &#125;;<br>std::forward_list&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">values</span>(arr.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, arr.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//拷贝arr容器中的&#123;13,14,15&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="6-1-2-forward-list容器支持的成员函数"><a href="#6-1-2-forward-list容器支持的成员函数" class="headerlink" title="6.1.2 forward_list容器支持的成员函数"></a>6.1.2 forward_list容器支持的成员函数</h3><p>下表中罗列出了 forward_list 模板类提供的所有成员函数以及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>before_begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td>
</tr>
<tr>
<td>begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td>
</tr>
<tr>
<td>end()</td>
<td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td>
</tr>
<tr>
<td>erase_after()</td>
<td>删除容器中某个指定位置或区域内的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice_after()</td>
<td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<p> 除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的  begin() 和 end() 成员函数不同，标准库提供的这 2  个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end()  成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end()  返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p> forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<p> 下面的样例演示了表 2 中部分成员函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    values.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//&#123;4,1,2,3&#125;</span><br>    values.<span class="hljs-built_in">emplace_after</span>(values.<span class="hljs-built_in">before_begin</span>(), <span class="hljs-number">5</span>); <span class="hljs-comment">//&#123;5,4,1,2,3&#125;</span><br>    values.<span class="hljs-built_in">reverse</span>();<span class="hljs-comment">//&#123;3,2,1,4,5&#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = values.<span class="hljs-built_in">begin</span>(); it != values.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>表中这些成员函数的具体用法，后续学习用到时会具体讲解，感兴趣的读者，也可以通过查阅<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/stl/"> STL手册</a>做详细了解。</p>
</blockquote>
<h3 id="6-1-3-和使用forward-list容器相关的函数"><a href="#6-1-3-和使用forward-list容器相关的函数" class="headerlink" title="6.1.3 和使用forward_list容器相关的函数"></a>6.1.3 和使用forward_list容器相关的函数</h3><p>通过表 2 我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 dis<a target="_blank" rel="noopener" href="http://c.biancheng.net/ref/tan.html">tan</a>ce() 函数。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; my_words&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">int</span> count = std::<span class="hljs-built_in">distance</span>(std::<span class="hljs-built_in">begin</span>(my_words), std::<span class="hljs-built_in">end</span>(my_words));<br>    cout &lt;&lt; count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure>


<p> 并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = values.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-built_in">advance</span>(it, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span> (it!=values.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>


































  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>Shuyan<br>
        <strong>Link：</strong><a href="http://example.com/2022/03/17/C%E8%AF%AD%E8%A8%80/STL/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%B9%E5%99%A8/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;C%E8%AF%AD%E8%A8%80&#x2F;STL&#x2F;%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%B9%E5%99%A8&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;03&#x2F;17&#x2F;C%E8%AF%AD%E8%A8%80&#x2F;STL&#x2F;%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%B9%E5%99%A8&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/C%E8%AF%AD%E8%A8%80/STL/">STL</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/STL/" rel="tag">STL</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">一、序列化容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 容器中常见的函数成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81array%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二、array容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-array%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 array容器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-array%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 array随机访问迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-begin-end-%E5%92%8C-cbegin-cend"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 begin()&#x2F;end() 和 cbegin()&#x2F;cend()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-rbegin-rend-%E5%92%8C-crbegin-crend"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 rbegin()&#x2F;rend() 和 crbegin()&#x2F;crend()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-array%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 array访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 访问array容器中单个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 访问array容器中多个元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81vector%E5%AE%B9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">三、vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-vector%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 vector容器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%88%9B%E5%BB%BAvector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 创建vector容器的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-vector%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 vector容器包含的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-vector%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 vector迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-vector%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 vector容器迭代器的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-vector%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%8B%AC%E7%89%B9%E4%B9%8B%E5%A4%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 vector容器迭代器的独特之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-vector%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 vector访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%AE%BF%E9%97%AEvector%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 访问vector容器中单个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E8%AE%BF%E9%97%AEvector%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 访问vector容器中多个元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-push-back"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 push_back()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-emplace-back"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 emplace_back()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-emplace-back-%E5%92%8Cpush-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 emplace_back()和push_back()的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 插入元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-insert"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 insert()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-emplace"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 emplace()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 删除元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81deque%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">四、deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-deque%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 deque容器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%88%9B%E5%BB%BAdeque%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 创建deque容器的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-deque%E5%AE%B9%E5%99%A8%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 deque容器可利用的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-deque%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 deque容器迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-deque%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 deque容器迭代器的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-deque%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 deque容器迭代器的使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-deque%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 deque容器访问元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 添加和删除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-emplace%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 emplace系列函数的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81List%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">五、List容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-list%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 list容器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-list%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 list容器的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-list%E5%AE%B9%E5%99%A8%E5%8F%AF%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 list容器可用的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-List%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 List迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-List%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 List访问元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%B7%BB%E5%8A%A0%E6%8F%92%E5%85%A5"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 添加插入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-list-insert-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 list insert()成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-list-splice-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 list splice()成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.</span> <span class="toc-text">5.4 删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81forward-list%E5%AE%B9%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">六、forward_list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-forward-list%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 forward_list容器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-forward-list%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 forward_list容器的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-forward-list%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 forward_list容器支持的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%92%8C%E4%BD%BF%E7%94%A8forward-list%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3 和使用forward_list容器相关的函数</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1695524864449"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?0a7e154da92f76d05c83b48cbab331da#&lt;ID&gt;';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
